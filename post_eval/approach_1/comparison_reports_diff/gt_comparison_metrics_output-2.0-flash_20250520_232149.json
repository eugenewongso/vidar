[
    {
        "cve_id": "ASB-A-296915500",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
        "ground_truth_codebase": "/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be used for outbound\n * share.\n */\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}",
        "metrics": {
            "relative_line_count_similarity": 0.9683,
            "normalized_edit_similarity": 0.9664,
            "token_level_edit_distance": 46,
            "codebert_score": {
                "precision": 0.9469,
                "recall": 0.956,
                "f1": 0.9515,
                "f3": 0.9551
            },
            "token_count_ground_truth": 1149,
            "token_count_llm_output": 1165,
            "token_count_total": 2314,
            "cosine_similarity_openai": 0.9875
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364027949",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {
            "relative_line_count_similarity": 0.4935,
            "normalized_edit_similarity": 0.6959,
            "token_level_edit_distance": 1297,
            "codebert_score": {
                "precision": 0.9996,
                "recall": 0.9508,
                "f1": 0.9746,
                "f3": 0.9555
            },
            "token_count_ground_truth": 4704,
            "token_count_llm_output": 2257,
            "token_count_total": 6961,
            "cosine_similarity_openai": "skipped"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364025411",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {
            "relative_line_count_similarity": 0.4935,
            "normalized_edit_similarity": 0.6959,
            "token_level_edit_distance": 1297,
            "codebert_score": {
                "precision": 0.9996,
                "recall": 0.9508,
                "f1": 0.9746,
                "f3": 0.9555
            },
            "token_count_ground_truth": 4704,
            "token_count_llm_output": 2257,
            "token_count_total": 6961,
            "cosine_similarity_openai": "skipped"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-340480881",
        "downstream_version": "14",
        "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}",
        "metrics": {
            "relative_line_count_similarity": 1.0,
            "normalized_edit_similarity": 0.9997,
            "token_level_edit_distance": 1,
            "codebert_score": {
                "precision": 1.0,
                "recall": 1.0,
                "f1": 1.0,
                "f3": 1.0
            },
            "token_count_ground_truth": 1385,
            "token_count_llm_output": 1385,
            "token_count_total": 2770,
            "cosine_similarity_openai": 1.0
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-369103643",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                // operations so we don't end up splitting effects between the WM\n                // pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                        & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter it. Instead, send a signal to request PIP\n                // mode to the app if they wish to support it below in #applyTaskChanges.\n                return effects;\n            }\n\n            final int prevMode = container.getRequestedOverrideWindowingMode();\n            container.setWindowingMode(windowingMode);\n            if (prevMode != container.getWindowingMode()) {\n                // The activity in the container may become focusable or non-focusable due to\n                // windowing modes changes (such as entering or leaving pinned windowing mode),\n                // so also apply the lifecycle effects to this transaction.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        return effects;\n    }\n\n    private int applyTaskChanges(Task tr, WindowContainerTransaction.Change c) {\n        int effects = applyChanges(tr, c);\n        final SurfaceControl.Transaction t = c.getBoundsChangeTransaction();\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n            if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                effects = TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_FORCE_TRANSLUCENT) != 0) {\n            tr.setForceTranslucent(c.getForceTranslucent());\n            effects = TRANSACT_EFFECTS_LIFECYCLE;\n        }\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_DRAG_RESIZING) != 0) {\n            tr.setDragResizing(c.getDragResizing());\n        }\n\n        final int childWindowingMode = c.getActivityWindowingMode();\n        if (childWindowingMode > -1) {\n            tr.forAllActivities(a -> { a.setWindowingMode(childWindowingMode); });\n        }\n\n        if (t != null) {\n            tr.setMainWindowSizeChangeTransaction(t);\n        }\n\n        Rect enterPipBounds = c.getEnterPipBounds();\n        if (enterPipBounds != null) {\n            tr.mDisplayContent.mPinnedTaskController.setEnterPipBounds(enterPipBounds);\n        }\n\n        if (c.getWindowingMode() == WindowConfiguration.WINDOWING_MODE_PINNED\n                && !tr.inPinnedWindowingMode()) {\n            final ActivityRecord activity = tr.getTopNonFinishingActivity();\n            if (activity != null) {\n                final boolean lastSupportsEnterPipOnTaskSwitch =\n                        activity.supportsEnterPipOnTaskSwitch;\n                // Temporarily force enable enter PIP on task switch so that PIP is requested\n                // regardless of whether the activity is resumed or paused.\n                activity.supportsEnterPipOnTaskSwitch = true;\n                boolean canEnterPip = activity.checkEnterPictureInPictureState(\n                        \"applyTaskChanges\", true /* beforeStopping */);\n                if (canEnterPip) {\n                    canEnterPip = mService.mActivityClientController\n                            .requestPictureInPictureMode(activity);\n                }\n                if (!canEnterPip) {\n                    // Restore the flag to its previous state when the activity cannot enter PIP.\n                    activity.supportsEnterPipOnTaskSwitch = lastSupportsEnterPipOnTaskSwitch;\n                }\n            }\n        }\n\n        return effects;\n    }\n\n    private int applyDisplayAreaChanges(DisplayArea displayArea,\n            WindowContainerTransaction.Change c) {\n        final int[] effects = new int[1];\n        effects[0] = applyChanges(displayArea, c);\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_IGNORE_ORIENTATION_REQUEST) != 0) {\n            if (displayArea.setIgnoreOrientationRequest(c.getIgnoreOrientationRequest())) {\n                effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        displayArea.forAllTasks(task -> {\n            Task tr = (Task) task;\n            if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n                if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                    effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n        });\n\n        return effects[0];\n    }\n\n    private int applyTaskFragmentChanges(@NonNull TaskFragment taskFragment,\n            @NonNull WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        if (taskFragment.isEmbeddedTaskFragmentInPip()) {\n            // No override from organizer for embedded TaskFragment in a PIP Task.\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        // When the TaskFragment is resized, we may want to create a change transition for it, for\n        // which we want to defer the surface update until we determine whether or not to start\n        // change transition.\n        mTmpBounds0.set(taskFragment.getBounds());\n        mTmpBounds1.set(taskFragment.getRelativeEmbeddedBounds());\n        taskFragment.deferOrganizedTaskFragmentSurfaceUpdate();\n        final Rect relBounds = c.getRelativeBounds();\n        if (relBounds != null) {\n            // Make sure the requested bounds satisfied the min dimensions requirement.\n            adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(taskFragment, relBounds,\n                    errorCallbackToken);\n\n            // For embedded TaskFragment, the organizer set the bounds in parent coordinate to\n            // prevent flicker in case there is a racing condition between the parent bounds changed\n            // and the organizer request.\n            final Rect parentBounds = taskFragment.getParent().getBounds();\n            // Convert relative bounds to screen space.\n            final Rect absBounds = taskFragment.translateRelativeBoundsToAbsoluteBounds(relBounds,\n                    parentBounds);\n            c.getConfiguration().windowConfiguration.setBounds(absBounds);\n            taskFragment.setRelativeEmbeddedBounds(relBounds);\n        }\n        final int effects = applyChanges(taskFragment, c);\n        if (taskFragment.shouldStartChangeTransition(mTmpBounds0, mTmpBounds1)) {\n            taskFragment.initializeChangeTransition(mTmpBounds0);\n        }\n        taskFragment.continueOrganizedTaskFragmentSurfaceUpdate();\n        return effects;\n    }\n\n    /**\n     * Adjusts the requested relative bounds on {@link TaskFragment} to make sure it satisfies the\n     * activity min dimensions.\n     */\n    private void adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(\n            @NonNull TaskFragment taskFragment, @NonNull Rect inOutRelativeBounds,\n            @Nullable IBinder errorCallbackToken) {\n        if (inOutRelativeBounds.isEmpty()) {\n            return;\n        }\n        final Point minDimensions = taskFragment.calculateMinDimension();\n        if (inOutRelativeBounds.width() < minDimensions.x\n                || inOutRelativeBounds.height() < minDimensions.y) {\n            // Notify organizer about the request failure.\n            final Throwable exception = new SecurityException(\"The requested relative bounds:\"\n                    + inOutRelativeBounds + \" does not satisfy minimum dimensions:\"\n                    + minDimensions);\n            sendTaskFragmentOperationFailure(taskFragment.getTaskFragmentOrganizer(),\n                    errorCallbackToken, taskFragment, OP_TYPE_SET_RELATIVE_BOUNDS, exception);\n\n            // Reset to match parent bounds.\n            inOutRelativeBounds.setEmpty();\n        }\n    }\n\n    private int applyHierarchyOp(WindowContainerTransaction.HierarchyOp hop, int effects,\n            int syncId, @Nullable Transition transition, boolean isInLockTaskMode,\n            @NonNull CallerInfo caller, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable Transition finishTransition) {\n        final int type = hop.getType();\n        switch (type) {\n            case HIERARCHY_OP_TYPE_REMOVE_TASK: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || wc.asTask() == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to remove invalid task: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                task.remove(true, \"Applying remove task Hierarchy Op\");\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch root to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (task.getTaskDisplayArea() == null) {\n                    throw new IllegalArgumentException(\"Cannot set a task without display area as \"\n                            + \"launch root: \" + wc);\n                } else {\n                    task.getDisplayArea().setLaunchRootTask(task,\n                            hop.getWindowingModes(), hop.getActivityTypes());\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch adjacent to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                final boolean clearRoot = hop.getToTop();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-organized task as adjacent flag root: \" + wc);\n                } else if (task.getAdjacentTaskFragment() == null && !clearRoot) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-adjacent task as adjacent flag root: \" + wc);\n                }\n\n                task.getDisplayArea().setLaunchAdjacentFlagRootTask(clearRoot ? null : task);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS: {\n                effects |= setAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS: {\n                effects |= clearAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT: {\n                effects |= reparentChildrenTasksHierarchyOp(hop, transition, syncId,\n                        isInLockTaskMode);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_FINISH_ACTIVITY: {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(hop.getContainer());\n                if (activity == null || activity.finishing) {\n                    break;\n                }\n                if (activity.isVisible() || activity.isVisibleRequested()) {\n                    // Prevent the transition from being executed too early if the activity is\n                    // visible.\n                    activity.finishIfPossible(\"finish-activity-op\", false /* oomAdj */);\n                } else {\n                    activity.destroyIfPossible(\"finish-activity-op\");\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_LAUNCH_TASK: {\n                mService.mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                        \"launchTask HierarchyOp\");\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final int taskId = launchOpts.getInt(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                launchOpts.remove(WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(launchOpts, caller.mPid, caller.mUid);\n                waitAsyncStart(() -> mService.mTaskSupervisor.startActivityFromRecents(\n                        caller.mPid, caller.mUid, taskId, safeOptions));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REORDER:\n            case HIERARCHY_OP_TYPE_REPARENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    break;\n                }\n                // There is no use case to ask the reparent operation in lock-task mode now, so keep\n                // skipping this operation as usual.\n                if (isInLockTaskMode && type == HIERARCHY_OP_TYPE_REPARENT) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    break;\n                }\n                if (isLockTaskModeViolation(wc.getParent(), wc.asTask(), isInLockTaskMode)) {\n                    break;\n                }\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) {\n                    transition.collect(wc);\n                    if (hop.isReparent()) {\n                        if (wc.getParent() != null) {\n                            // Collect the current parent. It's visibility may change as\n                            // a result of this reparenting.\n                            transition.collect(wc.getParent());\n                        }\n                        if (hop.getNewParent() != null) {\n                            final WindowContainer parentWc =\n                                    WindowContainer.fromBinder(hop.getNewParent());\n                            if (parentWc == null) {\n                                Slog.e(TAG, \"Can't resolve parent window from token\");\n                                break;\n                            }\n                            transition.collect(parentWc);\n                        }\n                    }\n                }\n                effects |= sanitizeAndApplyHierarchyOp(wc, hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION: {\n                effects |= applyTaskFragmentOperation(hop, transition, isInLockTaskMode, caller,\n                        errorCallbackToken, organizer);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_PENDING_INTENT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                ActivityOptions activityOptions = launchOpts != null\n                        ? new ActivityOptions(launchOpts) : null;\n                if (activityOptions != null && activityOptions.getTransientLaunch()\n                        && mService.isCallerRecents(hop.getPendingIntent().getCreatorUid())) {\n                    if (mService.getActivityStartController().startExistingRecentsIfPossible(\n                            hop.getActivityIntent(), activityOptions)) {\n                        // Start recents successfully.\n                        break;\n                    }\n                }\n\n                String resolvedType = hop.getActivityIntent() != null\n                        ? hop.getActivityIntent().resolveTypeIfNeeded(\n                        mService.mContext.getContentResolver())\n                        : null;\n\n                if (hop.getPendingIntent().isActivity()) {\n                    // Set the context display id as preferred for this activity launches, so that\n                    // it can land on caller's display. Or just brought the task to front at the\n                    // display where it was on since it has higher preference.\n                    if (activityOptions == null) {\n                        activityOptions = ActivityOptions.makeBasic();\n                    }\n                    activityOptions.setCallerDisplayId(DEFAULT_DISPLAY);\n                }\n                final Bundle options = activityOptions != null ? activityOptions.toBundle() : null;\n                int res = waitAsyncStart(() -> mService.mAmInternal.sendIntentSender(\n                        hop.getPendingIntent().getTarget(),\n                        hop.getPendingIntent().getWhitelistToken(), 0 /* code */,\n                        hop.getActivityIntent(), resolvedType, null /* finishReceiver */,\n                        null /* requiredPermission */, options));\n                if (ActivityManager.isStartResultSuccessful(res)) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            default: {\n                // The other operations may change task order so they are skipped while in lock\n                // task mode. The above operations are still allowed because they don't move\n                // tasks. And it may be necessary such as clearing launch root after entering\n                // lock task mode.\n                if (isInLockTaskMode) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    return effects;\n                }\n            }\n        }\n\n        switch (type) {\n            case HIERARCHY_OP_TYPE_START_SHORTCUT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final String callingPackage = launchOpts.getString(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n                launchOpts.remove(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n\n                final LauncherAppsServiceInternal launcherApps = LocalServices.getService(\n                        LauncherAppsServiceInternal.class);\n\n                final boolean success = launcherApps.startShortcut(caller.mUid, caller.mPid,\n                        callingPackage, hop.getShortcutInfo().getPackage(), null /* featureId */,\n                        hop.getShortcutInfo().getId(), null /* sourceBounds */, launchOpts,\n                        hop.getShortcutInfo().getUserId());\n                if (success) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER: {\n                if (finishTransition == null) break;\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) break;\n                final Task thisTask = container.asActivityRecord() != null\n                        ? container.asActivityRecord().getTask() : container.asTask();\n                if (thisTask == null) break;\n                final Task restoreAt = finishTransition.getTransientLaunchRestoreTarget(container);\n                if (restoreAt == null) break;\n                final TaskDisplayArea taskDisplayArea = thisTask.getTaskDisplayArea();\n                taskDisplayArea.moveRootTaskBehindRootTask(thisTask.getRootTask(), restoreAt);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to add local insets source provider on unknown: \"\n                            + container);\n                    break;\n                }\n                container.addLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to remove local insets source provider from unknown: \"\n                                    + container);\n                    break;\n                }\n                container.removeLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null || container.asDisplayArea() == null\n                        || !container.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached display area: \"\n                            + container);\n                    break;\n                }\n                container.setAlwaysOnTop(hop.isAlwaysOnTop());\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = container != null ? container.asTask() : null;\n                if (task == null || !task.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \"\n                            + container);\n                    break;\n                }\n                if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-organized task : \" + task);\n                }\n                if (!task.isRootTask()) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-root task : \" + task);\n                }\n                task.setReparentLeafTaskIfRelaunch(hop.isReparentLeafTaskIfRelaunch());\n                break;\n            }\n        }\n        return effects;\n    }\n\n    /**\n     * Applies change set through {@link WindowContainerTransaction#addTaskFragmentOperation}.\n     * @return an int to represent the transaction effects, such as {@link #TRANSACT_EFFECTS_NONE},\n     *         {@link #TRANSACT_EFFECTS_LIFECYCLE} or {@link #TRANSACT_EFFECTS_CLIENT_CONFIG}.\n     */\n    private int applyTaskFragmentOperation(@NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, boolean isInLockTaskMode, @NonNull CallerInfo caller,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        if (!validateTaskFragmentOperation(hop, errorCallbackToken, organizer)) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final int opType = operation.getOpType();\n\n        int effects = TRANSACT_EFFECTS_NONE;\n        switch (opType) {\n            case OP_TYPE_CREATE_TASK_FRAGMENT: {\n                final TaskFragmentCreationParams taskFragmentCreationParams =\n                        operation.getTaskFragmentCreationParams();\n                if (taskFragmentCreationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentCreationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                createTaskFragment(taskFragmentCreationParams, errorCallbackToken, caller,\n                        transition);\n                break;\n            }\n            case OP_TYPE_DELETE_TASK_FRAGMENT: {\n                if (isInLockTaskMode) {\n                    final ActivityRecord bottomActivity = taskFragment.getActivity(\n                            a -> !a.finishing, false /* traverseTopToBottom */);\n                    if (bottomActivity != null\n                            && mService.getLockTaskController().activityBlockedFromFinish(\n                            bottomActivity)) {\n                        Slog.w(TAG, \"Skip removing TaskFragment due in lock task mode.\");\n                        sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                                taskFragment, opType, new IllegalStateException(\n                                        \"Not allow to delete task fragment in lock task mode.\"));\n                        break;\n                    }\n                }\n                effects |= deleteTaskFragment(taskFragment, transition);\n                break;\n            }\n            case OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT: {\n                final IBinder callerActivityToken = operation.getActivityToken();\n                final Intent activityIntent = operation.getActivityIntent();\n                final Bundle activityOptions = operation.getBundle();\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                final int result = mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                callerActivityToken, caller.mUid, caller.mPid,\n                                errorCallbackToken);\n                if (!isStartResultSuccessful(result)) {\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, convertStartFailureToThrowable(result, activityIntent));\n                } else {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT: {\n                final IBinder activityToken = operation.getActivityToken();\n                ActivityRecord activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    // The token may be a temporary token if the activity doesn't belong to\n                    // the organizer process.\n                    activity = mTaskFragmentOrganizerController\n                            .getReparentActivityFromTemporaryToken(organizer, activityToken);\n                }\n                if (activity == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED) {\n                    final Throwable exception = new SecurityException(\n                            \"The task fragment is not allowed to embed the given activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getTask() != activity.getTask()) {\n                    final Throwable exception = new SecurityException(\"The reparented activity is\"\n                            + \" not in the same Task as the target TaskFragment.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (transition != null) {\n                    transition.collect(activity);\n                    if (activity.getParent() != null) {\n                        // Collect the current parent. Its visibility may change as a result of\n                        // this reparenting.\n                        transition.collect(activity.getParent());\n                    }\n                    transition.collect(taskFragment);\n                }\n                activity.reparent(taskFragment, POSITION_TOP);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS: {\n                final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment secondaryTaskFragment =\n                        mLaunchTaskFragments.get(secondaryFragmentToken);\n                if (secondaryTaskFragment == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"SecondaryFragmentToken must be set for setAdjacentTaskFragments.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getAdjacentTaskFragment() != secondaryTaskFragment) {\n                    // Only have lifecycle effect if the adjacent changed.\n                    taskFragment.setAdjacentTaskFragment(secondaryTaskFragment);\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n\n                final Bundle bundle = hop.getLaunchOptions();\n                final WindowContainerTransaction.TaskFragmentAdjacentParams adjacentParams =\n                        bundle != null\n                                ? new WindowContainerTransaction.TaskFragmentAdjacentParams(bundle)\n                                : null;\n                taskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelayPrimaryLastActivityRemoval());\n                secondaryTaskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelaySecondaryLastActivityRemoval());\n                break;\n            }\n            case OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS: {\n                final TaskFragment adjacentTaskFragment = taskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFragment == null) {\n                    break;\n                }\n                taskFragment.resetAdjacentTaskFragment();\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n\n                // Clear the focused app if the focused app is no longer visible after reset the\n                // adjacent TaskFragments.\n                final ActivityRecord focusedApp = taskFragment.getDisplayContent().mFocusedApp;\n                final TaskFragment focusedTaskFragment = focusedApp != null\n                        ? focusedApp.getTaskFragment()\n                        : null;\n                if ((focusedTaskFragment == taskFragment\n                        || focusedTaskFragment == adjacentTaskFragment)\n                        && !focusedTaskFragment.shouldBeVisible(null /* starting */)) {\n                    focusedTaskFragment.getDisplayContent().setFocusedApp(null /* newFocus */);\n                }\n                break;\n            }\n            case OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT: {\n                final ActivityRecord curFocus = taskFragment.getDisplayContent().mFocusedApp;\n                if (curFocus != null && curFocus.getTaskFragment() == taskFragment) {\n                    Slog.d(TAG, \"The requested TaskFragment already has the focus.\");\n                    break;\n                }\n                if (curFocus != null && curFocus.getTask() != taskFragment.getTask()) {\n                    Slog.d(TAG, \"The Task of the requested TaskFragment doesn't have focus.\");\n                    break;\n                }\n                final ActivityRecord targetFocus = taskFragment.getTopResumedActivity();\n                if (targetFocus == null) {\n                    Slog.d(TAG, \"There is no resumed activity in the requested TaskFragment.\");\n                    break;\n                }\n                taskFragment.getDisplayContent().setFocusedApp(targetFocus);\n                break;\n            }\n            case OP_TYPE_SET_COMPANION_TASK_FRAGMENT: {\n                final IBinder companionFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment companionTaskFragment = companionFragmentToken != null\n                        ? mLaunchTaskFragments.get(companionFragmentToken)\n                        : null;\n                taskFragment.setCompanionTaskFragment(companionTaskFragment);\n                break;\n            }\n            case OP_TYPE_SET_ANIMATION_PARAMS: {\n                final TaskFragmentAnimationParams animationParams = operation.getAnimationParams();\n                if (animationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentAnimationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                taskFragment.setAnimationParams(animationParams);\n                break;\n            }\n        }\n        return effects;\n    }\n\n    private boolean validateTaskFragmentOperation(\n            @NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        if (operation == null) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"TaskFragmentOperation must be non-null\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    OP_TYPE_UNKNOWN, exception);\n            return false;\n        }\n        final int opType = operation.getOpType();\n        if (opType == OP_TYPE_CREATE_TASK_FRAGMENT) {\n            // No need to check TaskFragment.\n            return true;\n        }\n\n        if (!validateTaskFragment(taskFragment, opType, errorCallbackToken, organizer)) {\n            return false;\n        }\n\n        final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n        return secondaryFragmentToken == null\n                || validateTaskFragment(mLaunchTaskFragments.get(secondaryFragmentToken), opType,\n                errorCallbackToken, organizer);\n    }\n\n    private boolean validateTaskFragment(@Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer) {\n        if (taskFragment == null || !taskFragment.isAttached()) {\n            // TaskFragment doesn't exist.\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on invalid fragment tokens opType=\" + opType);\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        if (taskFragment.isEmbeddedTaskFragmentInPip()\n                && (opType != OP_TYPE_DELETE_TASK_FRAGMENT\n                // When the Task enters PiP before the organizer removes the empty TaskFragment, we\n                // should allow it to delete the TaskFragment for cleanup.\n                || taskFragment.getTopNonFinishingActivity() != null)) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on PIP TaskFragment\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Post and wait for the result of the activity start to prevent potential deadlock against\n     * {@link WindowManagerGlobalLock}.\n     */\n    private int waitAsyncStart(IntSupplier startActivity) {\n        final Integer[] starterResult = {null};\n        final Handler handler = (Looper.myLooper() == mService.mH.getLooper())\n                // uncommon case where a queued transaction is trying to start an activity. We can't\n                // post to our own thread and wait (otherwise we deadlock), so use anim thread\n                // instead (which is 1 higher priority).\n                ? mService.mWindowManager.mAnimationHandler\n                // Otherwise just put it on main handler\n                : mService.mH;\n        handler.post(() -> {\n            try {\n                starterResult[0] = startActivity.getAsInt();\n            } catch (Throwable t) {\n                starterResult[0] = ActivityManager.START_CANCELED;\n                Slog.w(TAG, t);\n            }\n            synchronized (mGlobalLock) {\n                mGlobalLock.notifyAll();\n            }\n        });\n        while (starterResult[0] == null) {\n            try {\n                mGlobalLock.wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        return starterResult[0];\n    }\n\n    private int sanitizeAndApplyHierarchyOp(WindowContainer container,\n            WindowContainerTransaction.HierarchyOp hop) {\n        final Task task = container.asTask();\n        if (task == null) {\n            throw new IllegalArgumentException(\"Invalid container in hierarchy op\");\n        }\n        final DisplayContent dc = task.getDisplayContent();\n        if (dc == null) {\n            Slog.w(TAG, \"Container is no longer attached: \" + task);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final Task as = task;\n\n        if (hop.isReparent()) {\n            final boolean isNonOrganizedRootableTask =\n                    task.isRootTask() || task.getParent().asTask().mCreatedByOrganizer;\n            if (isNonOrganizedRootableTask) {\n                WindowContainer newParent = hop.getNewParent() == null\n                        ? dc.getDefaultTaskDisplayArea()\n                        : WindowContainer.fromBinder(hop.getNewParent());\n                if (newParent == null) {\n                    Slog.e(TAG, \"Can't resolve parent window from token\");\n                    return TRANSACT_EFFECTS_NONE;\n                }\n                if (task.getParent() != newParent) {\n                    if (newParent.asTaskDisplayArea() != null) {\n                        // For now, reparenting to displayarea is different from other reparents...\n                        as.reparent(newParent.asTaskDisplayArea(), hop.getToTop());\n                    } else if (newParent.asTask() != null) {\n                        if (newParent.inMultiWindowMode() && task.isLeafTask()) {\n                            if (newParent.inPinnedWindowingMode()) {\n                                Slog.w(TAG, \"Can't support moving a task to another PIP window...\"\n                                        + \" newParent=\" + newParent + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                            if (!task.supportsMultiWindowInDisplayArea(\n                                    newParent.asTask().getDisplayArea())) {\n                                Slog.w(TAG, \"Can't support task that doesn't support multi-window\"\n                                        + \" mode in multi-window mode... newParent=\" + newParent\n                                        + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                        }\n                        task.reparent((Task) newParent,\n                                hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                                false /*moveParents*/, \"sanitizeAndApplyHierarchyOp\");\n                    } else {\n                        throw new RuntimeException(\"Can only reparent task to another task or\"\n                                + \" taskDisplayArea, but not \" + newParent);\n                    }\n                } else {\n                    final Task rootTask = (Task) (\n                            (newParent != null && !(newParent instanceof TaskDisplayArea))\n                                    ? newParent : task.getRootTask());\n                    as.getDisplayArea().positionChildAt(\n                            hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM, rootTask,\n                            false /* includingParents */);\n                }\n            } else {\n                throw new RuntimeException(\"Reparenting leaf Tasks is not supported now. \" + task);\n            }\n        } else {\n            task.getParent().positionChildAt(\n                    hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                    task, false /* includingParents */);\n        }\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private boolean isLockTaskModeViolation(WindowContainer parent, Task task,\n            boolean isInLockTaskMode) {\n        if (!isInLockTaskMode || parent == null || task == null) {\n            return false;\n        }\n        final LockTaskController lockTaskController = mService.getLockTaskController();\n        boolean taskViolation = lockTaskController.isLockTaskModeViolation(task);\n        if (!taskViolation && parent.asTask() != null) {\n            taskViolation = lockTaskController.isLockTaskModeViolation(parent.asTask());\n        }\n        if (taskViolation) {\n            Slog.w(TAG, \"Can't support the operation since in lock task mode violation. \"\n                    + \" Task: \" + task + \" Parent : \" + parent);\n        }\n        return taskViolation;\n    }\n\n    private int reparentChildrenTasksHierarchyOp(WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, int syncId, boolean isInLockTaskMode) {\n        WindowContainer<?> currentParent = hop.getContainer() != null\n                ? WindowContainer.fromBinder(hop.getContainer()) : null;\n        WindowContainer newParent = hop.getNewParent() != null\n                ? WindowContainer.fromBinder(hop.getNewParent()) : null;\n        if (currentParent == null && newParent == null) {\n            throw new IllegalArgumentException(\"reparentChildrenTasksHierarchyOp: \" + hop);\n        } else if (currentParent == null) {\n            currentParent = newParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        } else if (newParent == null) {\n            newParent = currentParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        }\n\n        if (currentParent == newParent) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp parent not changing: \" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!currentParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp currentParent detached=\"\n                    + currentParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!newParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent detached=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (newParent.inPinnedWindowingMode()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent in PIP=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        final boolean newParentInMultiWindow = newParent.inMultiWindowMode();\n        final TaskDisplayArea newParentTda = newParent.asTask() != null\n                ? newParent.asTask().getDisplayArea()\n                : newParent.asTaskDisplayArea();\n        final WindowContainer finalCurrentParent = currentParent;\n        final WindowContainer finalNewParent = newParent;\n        Slog.i(TAG, \"reparentChildrenTasksHierarchyOp\"\n                + \" currentParent=\" + currentParent + \" newParent=\" + newParent + \" hop=\" + hop);\n\n        // We want to collect the tasks first before re-parenting to avoid array shifting on us.\n        final ArrayList<Task> tasksToReparent = new ArrayList<>();\n\n        currentParent.forAllTasks(task -> {\n            Slog.i(TAG, \" Processing task=\" + task);\n            final boolean reparent;\n            if (task.mCreatedByOrganizer || task.getParent() != finalCurrentParent) {\n                // We only care about non-organized task that are direct children of the thing we\n                // are reparenting from.\n                return false;\n            }\n            if (newParentInMultiWindow && !task.supportsMultiWindowInDisplayArea(newParentTda)) {\n                Slog.e(TAG, \"reparentChildrenTasksHierarchyOp non-resizeable task to multi window,\"\n                        + \" task=\" + task);\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getActivityTypes())\n                    && !ArrayUtils.contains(hop.getActivityTypes(), task.getActivityType())) {\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getWindowingModes())\n                    && !ArrayUtils.contains(hop.getWindowingModes(), task.getWindowingMode())) {\n                return false;\n            }\n            if (isLockTaskModeViolation(finalNewParent, task, isInLockTaskMode)) {\n                return false;\n            }\n\n            if (hop.getToTop()) {\n                tasksToReparent.add(0, task);\n            } else {\n                tasksToReparent.add(task);\n            }\n            return hop.getReparentTopOnly() && tasksToReparent.size() == 1;\n        });\n\n        final int count = tasksToReparent.size();\n        for (int i = 0; i < count; ++i) {\n            final Task task = tasksToReparent.get(i);\n            if (syncId >= 0) {\n                addToSyncSet(syncId, task);\n            }\n            if (transition != null) transition.collect(task);\n\n            if (newParent instanceof TaskDisplayArea) {\n                // For now, reparenting to display area is different from other reparents...\n                task.reparent((TaskDisplayArea) newParent, hop.getToTop());\n            } else {\n                task.reparent((Task) newParent,\n                        hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                        false /*moveParents*/, \"processChildrenTaskReparentHierarchyOp\");\n            }\n        }\n\n        if (transition != null) transition.collect(newParent);\n\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int setAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root1 = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        final TaskFragment root2 =\n                WindowContainer.fromBinder(hop.getAdjacentRoot()).asTaskFragment();\n        if (!root1.mCreatedByOrganizer || !root2.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"setAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root1=\" + root1 + \" root2=\" + root2);\n        }\n        if (root1.getAdjacentTaskFragment() == root2) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root1.setAdjacentTaskFragment(root2);\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int clearAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        if (!root.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"clearAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root=\" + root);\n        }\n        if (root.getAdjacentTaskFragment() == null) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root.resetAdjacentTaskFragment();\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private void sanitizeWindowContainer(WindowContainer wc) {\n        if (!(wc instanceof TaskFragment) && !(wc instanceof DisplayArea)) {\n            throw new RuntimeException(\"Invalid token in task fragment or displayArea transaction\");\n        }\n    }\n\n    private int applyWindowContainerChange(WindowContainer wc,\n            WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        sanitizeWindowContainer(wc);\n        if (wc.asDisplayArea() != null) {\n            return applyDisplayAreaChanges(wc.asDisplayArea(), c);\n        } else if (wc.asTask() != null) {\n            return applyTaskChanges(wc.asTask(), c);\n        } else if (wc.asTaskFragment() != null && wc.asTaskFragment().isEmbedded()) {\n            return applyTaskFragmentChanges(wc.asTaskFragment(), c, errorCallbackToken);\n        } else {\n            return applyChanges(wc, c);\n        }\n    }\n\n    @Override\n    public ITaskOrganizerController getTaskOrganizerController() {\n        enforceTaskPermission(\"getTaskOrganizerController()\");\n        return mTaskOrganizerController;\n    }\n\n    @Override\n    public IDisplayAreaOrganizerController getDisplayAreaOrganizerController() {\n        enforceTaskPermission(\"getDisplayAreaOrganizerController()\");\n        return mDisplayAreaOrganizerController;\n    }\n\n    @Override\n    public ITaskFragmentOrganizerController getTaskFragmentOrganizerController() {\n        return mTaskFragmentOrganizerController;\n    }\n\n    /**\n     * This will prepare a {@link BLASTSyncEngine.SyncGroup} for the organizer to track, but the\n     * {@link BLASTSyncEngine.SyncGroup} may not be active until the {@link BLASTSyncEngine} is\n     * free.\n     */\n    private BLASTSyncEngine.SyncGroup prepareSyncWithOrganizer(\n            IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = mService.mWindowManager.mSyncEngine\n                .prepareSyncSet(this, \"Organizer\");\n        mTransactionCallbacksByPendingSyncId.put(s.mSyncId, callback);\n        return s;\n    }\n\n    @VisibleForTesting\n    int startSyncWithOrganizer(IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = prepareSyncWithOrganizer(callback);\n        mService.mWindowManager.mSyncEngine.startSyncSet(s);\n        return s.mSyncId;\n    }\n\n    @VisibleForTesting\n    void setSyncReady(int id) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Set sync ready, syncId=%d\", id);\n        mService.mWindowManager.mSyncEngine.setReady(id);\n    }\n\n    @VisibleForTesting\n    void addToSyncSet(int syncId, WindowContainer wc) {\n        mService.mWindowManager.mSyncEngine.addToSyncSet(syncId, wc);\n    }\n\n    @Override\n    public void onTransactionReady(int syncId, SurfaceControl.Transaction t) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Transaction ready, syncId=%d\", syncId);\n        final IWindowContainerTransactionCallback callback =\n                mTransactionCallbacksByPendingSyncId.get(syncId);\n\n        try {\n            callback.onTransactionReady(syncId, t);\n        } catch (RemoteException e) {\n            // If there's an exception when trying to send the mergedTransaction to the client, we\n            // should immediately apply it here so the transactions aren't lost.\n            t.apply();\n        }\n\n        mTransactionCallbacksByPendingSyncId.remove(syncId);\n    }\n\n    @Override\n    public void registerTransitionPlayer(ITransitionPlayer player) {\n        enforceTaskPermission(\"registerTransitionPlayer()\");\n        final int callerPid = Binder.getCallingPid();\n        final int callerUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final WindowProcessController wpc =\n                        mService.getProcessController(callerPid, callerUid);\n                mTransitionController.registerTransitionPlayer(player, wpc);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ITransitionMetricsReporter getTransitionMetricsReporter() {\n        return mTransitionController.mTransitionMetricsReporter;\n    }\n\n    @Override\n    public IBinder getApplyToken() {\n        enforceTaskPermission(\"getApplyToken()\");\n        return SurfaceControl.Transaction.getDefaultApplyToken();\n    }\n\n    /** Whether the configuration changes are important to report back to an organizer. */\n    static boolean configurationsAreEqualForOrganizer(\n            Configuration newConfig, @Nullable Configuration oldConfig) {\n        if (oldConfig == null) {\n            return false;\n        }\n        int cfgChanges = newConfig.diff(oldConfig);\n        final int winCfgChanges = (cfgChanges & ActivityInfo.CONFIG_WINDOW_CONFIGURATION) != 0\n                ? (int) newConfig.windowConfiguration.diff(oldConfig.windowConfiguration,\n                true /* compareUndefined */) : 0;\n        if ((winCfgChanges & CONTROLLABLE_WINDOW_CONFIGS) == 0) {\n            cfgChanges &= ~ActivityInfo.CONFIG_WINDOW_CONFIGURATION;\n        }\n        return (cfgChanges & CONTROLLABLE_CONFIGS) == 0;\n    }\n\n    /**\n     * Makes sure that the transaction only contains operations that are allowed for the\n     * {@link WindowContainerTransaction#getTaskFragmentOrganizer()}.\n     */\n    private void enforceTaskFragmentOrganizerPermission(@NonNull String func,\n            @NonNull ITaskFragmentOrganizer organizer, @NonNull WindowContainerTransaction t) {\n        // Configuration changes\n        final Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                t.getChanges().entrySet().iterator();\n        while (entries.hasNext()) {\n            final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n            final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n            enforceTaskFragmentConfigChangeAllowed(func, wc, entry.getValue(), organizer);\n        }\n\n        // Hierarchy changes\n        final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n        for (int i = hops.size() - 1; i >= 0; i--) {\n            final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n            final int type = hop.getType();\n            // Check for each type of the operations that are allowed for TaskFragmentOrganizer.\n            switch (type) {\n                case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION:\n                    enforceTaskFragmentOrganized(func, hop.getContainer(), organizer);\n                    if (hop.getTaskFragmentOperation() != null\n                            && hop.getTaskFragmentOperation().getSecondaryFragmentToken() != null) {\n                        enforceTaskFragmentOrganized(func,\n                                hop.getTaskFragmentOperation().getSecondaryFragmentToken(),\n                                organizer);\n                    }\n                    break;\n                case HIERARCHY_OP_TYPE_FINISH_ACTIVITY:\n                    // Allow finish activity if it has the activity token.\n                    break;\n                default:\n                    // Other types of hierarchy changes are not allowed.\n                    String msg = \"Permission Denial: \" + func + \" from pid=\"\n                            + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                            + \" trying to apply a hierarchy change that is not allowed for\"\n                            + \" TaskFragmentOrganizer=\" + organizer;\n                    Slog.w(TAG, msg);\n                    throw new SecurityException(msg);\n            }\n        }\n    }\n\n    /**\n     * Makes sure that the {@link TaskFragment} of the given fragment token is created and organized\n     * by the given {@link ITaskFragmentOrganizer}.\n     */\n    private void enforceTaskFragmentOrganized(@NonNull String func,\n            @NonNull IBinder fragmentToken, @NonNull ITaskFragmentOrganizer organizer) {\n        Objects.requireNonNull(fragmentToken);\n        final TaskFragment tf = mLaunchTaskFragments.get(fragmentToken);\n        // When the TaskFragment is {@code null}, it means that the TaskFragment will be created\n        // later in the same transaction, in which case it will always be organized by the given\n        // organizer.\n        if (tf != null && !tf.hasTaskFragmentOrganizer(organizer)) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify TaskFragment not\"\n                    + \" belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    /**\n     * For config change on {@link TaskFragment}, we only support the following operations:\n     * {@link WindowContainerTransaction#setRelativeBounds(WindowContainerToken, Rect)},\n     * {@link WindowContainerTransaction#setWindowingMode(WindowContainerToken, int)}.\n     */\n    private void enforceTaskFragmentConfigChangeAllowed(@NonNull String func,\n            @Nullable WindowContainer wc, @NonNull WindowContainerTransaction.Change change,\n            @NonNull ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on task fragment that no longer exists\");\n            return;\n        }\n        final TaskFragment tf = wc.asTaskFragment();\n        if (tf == null || !tf.hasTaskFragmentOrganizer(organizer)) {\n            // Only allow to apply changes to TaskFragment that is organized by this organizer.\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify window container\"\n                    + \" not belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n\n        final int changeMask = change.getChangeMask();\n        final int configSetMask = change.getConfigSetMask();\n        final int windowSetMask = change.getWindowSetMask();\n        if (changeMask == 0 && configSetMask == 0 && windowSetMask == 0\n                && change.getWindowingMode() >= 0) {\n            // The change contains only setWindowingMode, which is allowed.\n            return;\n        }\n        if (changeMask != CHANGE_RELATIVE_BOUNDS\n                || configSetMask != ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n                || windowSetMask != WindowConfiguration.WINDOW_CONFIG_BOUNDS) {\n            // None of the change should be requested from a TaskFragment organizer except\n            // setRelativeBounds and setWindowingMode.\n            // For setRelativeBounds, we don't need to check whether it is outside of the Task\n            // bounds, because it is possible that the Task is also resizing, for which we don't\n            // want to throw an exception. The bounds will be adjusted in\n            // TaskFragment#translateRelativeBoundsToAbsoluteBounds.\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply changes of changeMask=\" + changeMask\n                    + \" configSetMask=\" + configSetMask + \" windowSetMask=\" + windowSetMask\n                    + \" to TaskFragment=\" + tf + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private void createTaskFragment(@NonNull TaskFragmentCreationParams creationParams,\n            @Nullable IBinder errorCallbackToken, @NonNull CallerInfo caller,\n            @Nullable Transition transition) {\n        final ActivityRecord ownerActivity =\n                ActivityRecord.forTokenLocked(creationParams.getOwnerToken());\n        final ITaskFragmentOrganizer organizer = ITaskFragmentOrganizer.Stub.asInterface(\n                creationParams.getOrganizer().asBinder());\n\n        if (mLaunchTaskFragments.containsKey(creationParams.getFragmentToken())) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"TaskFragment token must be unique\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerActivity == null || ownerActivity.getTask() == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid ownerToken\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (!ownerActivity.isResizeable()) {\n            final IllegalArgumentException exception = new IllegalArgumentException(\"Not allowed\"\n                    + \" to operate with non-resizable owner Activity\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        // The ownerActivity has to belong to the same app as the target Task.\n        final Task ownerTask = ownerActivity.getTask();\n        if (ownerTask.effectiveUid != ownerActivity.getUid()\n                || ownerTask.effectiveUid != caller.mUid) {\n            final Throwable exception =\n                    new SecurityException(\"Not allowed to operate with the ownerToken while \"\n                            + \"the root activity of the target task belong to the different app\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerTask.inPinnedWindowingMode()) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to create TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        final TaskFragment taskFragment = new TaskFragment(mService,\n                creationParams.getFragmentToken(), true /* createdByOrganizer */);\n        // Set task fragment organizer immediately, since it might have to be notified about further\n        // actions.\n        taskFragment.setTaskFragmentOrganizer(creationParams.getOrganizer(),\n                ownerActivity.getUid(), ownerActivity.info.processName);\n        final int position;\n        if (creationParams.getPairedPrimaryFragmentToken() != null) {\n            // When there is a paired primary TaskFragment, we want to place the new TaskFragment\n            // right above the paired one to make sure there is no other window in between.\n            final TaskFragment pairedPrimaryTaskFragment = getTaskFragment(\n                    creationParams.getPairedPrimaryFragmentToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedPrimaryTaskFragment);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else if (creationParams.getPairedActivityToken() != null) {\n            // When there is a paired Activity, we want to place the new TaskFragment right above\n            // the paired Activity to make sure the Activity position is not changed after reparent.\n            final ActivityRecord pairedActivity = ActivityRecord.forTokenLocked(\n                    creationParams.getPairedActivityToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedActivity);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else {\n            position = POSITION_TOP;\n        }\n        ownerTask.addChild(taskFragment, position);\n        taskFragment.setWindowingMode(creationParams.getWindowingMode());\n        if (!creationParams.getInitialRelativeBounds().isEmpty()) {\n            // Set relative bounds instead of using setBounds. This will avoid unnecessary update in\n            // case the parent has resized since the last time parent info is sent to the organizer.\n            taskFragment.setRelativeEmbeddedBounds(creationParams.getInitialRelativeBounds());\n            // Recompute configuration as the bounds will be calculated based on relative bounds in\n            // TaskFragment#resolveOverrideConfiguration.\n            taskFragment.recomputeConfiguration();\n        }\n        mLaunchTaskFragments.put(creationParams.getFragmentToken(), taskFragment);\n\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n    }\n\n    private int deleteTaskFragment(@NonNull TaskFragment taskFragment,\n            @Nullable Transition transition) {\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n        taskFragment.remove(true /* withTransition */, \"deleteTaskFragment\");\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    @Nullable\n    TaskFragment getTaskFragment(IBinder tfToken) {\n        return mLaunchTaskFragments.get(tfToken);\n    }\n\n    void cleanUpEmbeddedTaskFragment(TaskFragment taskFragment) {\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n    }\n\n    static class CallerInfo {\n        final int mPid;\n        final int mUid;\n\n        CallerInfo() {\n            mPid = Binder.getCallingPid();\n            mUid = Binder.getCallingUid();\n        }\n    }\n\n    void sendTaskFragmentOperationFailure(@NonNull ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken, @Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @NonNull Throwable exception) {\n        if (organizer == null) {\n            throw new IllegalArgumentException(\"Not allowed to operate with invalid organizer\");\n        }\n        mService.mTaskFragmentOrganizerController\n                .onTaskFragmentError(organizer, errorCallbackToken, taskFragment, opType,\n                        exception);\n    }\n\n    private Throwable convertStartFailureToThrowable(int result, Intent intent) {\n        switch (result) {\n            case ActivityManager.START_INTENT_NOT_RESOLVED:\n            case ActivityManager.START_CLASS_NOT_FOUND:\n                return new ActivityNotFoundException(\"No Activity found to handle \" + intent);\n            case ActivityManager.START_PERMISSION_DENIED:\n                return new SecurityException(\"Permission denied and not allowed to start activity \"\n                        + intent);\n            case ActivityManager.START_CANCELED:\n                return new AndroidRuntimeException(\"Activity could not be started for \" + intent\n                        + \" with error code : \" + result);\n            default:\n                return new AndroidRuntimeException(\"Start activity failed with error code : \"\n                        + result + \" when starting \" + intent);\n        }\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                 //operations so we don't end up splitting effects between the WM\n                 //pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                         & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter",
        "metrics": {
            "relative_line_count_similarity": 0.3438,
            "normalized_edit_similarity": 0.6583,
            "token_level_edit_distance": 225,
            "codebert_score": {
                "precision": 0.9952,
                "recall": 0.8958,
                "f1": 0.9429,
                "f3": 0.9049
            },
            "token_count_ground_truth": 7916,
            "token_count_llm_output": 2834,
            "token_count_total": 10750,
            "cosine_similarity_openai": "skipped_max_tokens"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364026473",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_tcid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {
            "relative_line_count_similarity": 0.4935,
            "normalized_edit_similarity": 0.6953,
            "token_level_edit_distance": 1298,
            "codebert_score": {
                "precision": 0.9982,
                "recall": 0.9502,
                "f1": 0.9736,
                "f3": 0.9548
            },
            "token_count_ground_truth": 4704,
            "token_count_llm_output": 2256,
            "token_count_total": 6960,
            "cosine_similarity_openai": "skipped"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-364027038",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND",
        "metrics": {
            "relative_line_count_similarity": 0.4935,
            "normalized_edit_similarity": 0.6959,
            "token_level_edit_distance": 1297,
            "codebert_score": {
                "precision": 0.9996,
                "recall": 0.9508,
                "f1": 0.9746,
                "f3": 0.9555
            },
            "token_count_ground_truth": 4704,
            "token_count_llm_output": 2257,
            "token_count_total": 6961,
            "cosine_similarity_openai": "skipped"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-352542820",
        "downstream_version": "14",
        "file_name": "src/com/android/settings/users/UserSettings.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n                && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    UserManager.isMultipleAdminEnabled(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(UserHandle.USER_SYSTEM);\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to system user\");\n                switchToUserId(UserHandle.USER_SYSTEM);\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (mUserCaps.mUserSwitcherEnabled) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            // Only current user will be displayed in case of multi-user switch is disabled\n            users = List.of(mUserManager.getUserInfo(context.getUserId()));\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n                if (user.isAdmin()) {\n                    pref.setSummary(R.string.user_admin);\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (mUserCaps.mUserSwitcherEnabled) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser && !mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.clear();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel",
        "metrics": {
            "relative_line_count_similarity": 0.4621,
            "normalized_edit_similarity": 0.3971,
            "token_level_edit_distance": 3188,
            "codebert_score": {
                "precision": 0.995,
                "recall": 0.9217,
                "f1": 0.9569,
                "f3": 0.9285
            },
            "token_count_ground_truth": 4699,
            "token_count_llm_output": 2101,
            "token_count_total": 6800,
            "cosine_similarity_openai": "skipped"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-289375038",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_",
        "metrics": {
            "relative_line_count_similarity": 0.1412,
            "normalized_edit_similarity": 0.5693,
            "token_level_edit_distance": 29,
            "codebert_score": {
                "precision": 0.9671,
                "recall": 0.8374,
                "f1": 0.8976,
                "f3": 0.8488
            },
            "token_count_ground_truth": 15700,
            "token_count_llm_output": 2366,
            "token_count_total": 18066,
            "cosine_similarity_openai": "skipped_max_tokens"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-289811388",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    System",
        "metrics": {
            "relative_line_count_similarity": 0.1412,
            "normalized_edit_similarity": 0.5626,
            "token_level_edit_distance": 2485,
            "codebert_score": {
                "precision": 0.9457,
                "recall": 0.834,
                "f1": 0.8864,
                "f3": 0.844
            },
            "token_count_ground_truth": 15700,
            "token_count_llm_output": 2372,
            "token_count_total": 18072,
            "cosine_similarity_openai": "skipped_max_tokens"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-375623125",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    @VisibleForTesting\n    public AppOpsService(File recentAccessesFile, File storageFile, Handler handler,\n            Context context) {\n        mContext = context;\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n        mAppOpsCheckingService = new AppOpsCheckingServiceTracingDecorator(\n                new AppOpsCheckingServiceImpl(\n                        storageFile, this, handler, context,  mSwitchedOps));\n        //mAppOpsCheckingService = new AppOpsCheckingServiceLoggingDecorator(\n        //        LocalServices.getService(AppOpsCheckingServiceInterface.class));\n        mAppOpsRestrictions = new AppOpsRestrictionsImpl(context, handler, mAppOpsCheckingService);\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mStorageFile = new AtomicFile(storageFile, \"appops_legacy\");\n        mRecentAccessesFile = new AtomicFile(recentAccessesFile, \"appops_accesses\");\n\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        // To migrate storageFile to recentAccessesFile, these reads must be called in this order.\n        readRecentAccesses();\n        mAppOpsCheckingService.readState();\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n        LocalManagerRegistry.addManager(AppOpsManagerLocal.class, new AppOpsManagerLocalImpl());\n    }\n\n    /** Handler for work when packages are updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mAppOpsCheckingService.systemReady();\n        initializeUidStates();\n\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        getUserManagerInternal().addUserLifecycleListener(\n                new UserManagerInternal.UserLifecycleListener() {\n                    @Override\n                    public void onUserCreated(UserInfo user, Object token) {\n                        initializeUserUidStates(user.id);\n                    }\n\n                    // onUserRemoved handled by #removeUser\n                });\n\n        getPackageManagerInternal().getPackageList(\n                new PackageManagerInternal.PackageListObserver() {\n                    @Override\n                    public void onPackageAdded(String packageName, int appId) {\n                        PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                                PackageManager.GET_PERMISSIONS, Process.myUid(),\n                                mContext.getUserId());\n                        boolean isSamplingTarget = isSamplingTarget(pi);\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            if (isSamplingTarget) {\n                                mRarelyUsedPackages.add(packageName);\n                            }\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                UidState uidState = getUidStateLocked(uid, true);\n                                if (!uidState.pkgOps.containsKey(packageName)) {\n                                    uidState.pkgOps.put(packageName,\n                                            new Ops(packageName, uidState));\n                                }\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onPackageRemoved(String packageName, int appId) {\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                packageRemovedLocked(uid, packageName);\n                            }\n                        }\n                    }\n                });\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<OnOpModeChangedListener> onModeChangedListeners;\n                    synchronized (AppOpsService.this) {\n                        onModeChangedListeners =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (onModeChangedListeners == null) {\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(onModeChangedListeners, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Initialize uid state objects for state contained in the checking service.\n     */\n    @VisibleForTesting\n    void initializeUidStates() {\n        UserManagerInternal umi = getUserManagerInternal();\n        synchronized (this) {\n            int[] userIds = umi.getUserIds();\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                         getPackageManagerLocal().withUnfilteredSnapshot()) {\n                Map<String, PackageState> packageStates = snapshot.getPackageStates();\n                for (int i = 0; i < userIds.length; i++) {\n                    int userId = userIds[i];\n                    initializeUserUidStatesLocked(userId, packageStates);\n                }\n            }\n        }\n    }\n\n    private void initializeUserUidStates(int userId) {\n        synchronized (this) {\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                    getPackageManagerLocal().withUnfilteredSnapshot()) {\n                initializeUserUidStatesLocked(userId, snapshot.getPackageStates());\n            }\n        }\n    }\n\n    private void initializeUserUidStatesLocked(int userId, Map<String,\n            PackageState> packageStates) {\n        for (Map.Entry<String, PackageState> entry : packageStates.entrySet()) {\n            int appId = entry.getValue().getAppId();\n            String packageName = entry.getKey();\n\n            initializePackageUidStateLocked(userId, appId, packageName);\n        }\n    }\n\n    /*\n      Be careful not to clear any existing data; only want to add objects that don't already exist.\n     */\n    private void initializePackageUidStateLocked(int userId, int appId, String packageName) {\n        int uid = UserHandle.getUid(userId, appId);\n        UidState uidState = getUidStateLocked(uid, true);\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        SparseIntArray packageModes =\n                mAppOpsCheckingService.getNonDefaultPackageModes(packageName, userId);\n        for (int k = 0; k < packageModes.size(); k++) {\n            int code = packageModes.keyAt(k);\n\n            if (ops.indexOfKey(code) < 0) {\n                ops.put(code, new Op(uidState, packageName, code, uid));\n            }\n        }\n\n        uidState.evalForegroundOps();\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    @VisibleForTesting\n    void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            packageRemovedLocked(uid, packageName);\n        }\n    }\n\n    @GuardedBy(\"this\")\n    private void packageRemovedLocked(int uid, String packageName) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        Ops removedOps = null;\n\n        // Remove any package state if such.\n        removedOps = uidState.pkgOps.remove(packageName);\n        mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n\n        if (removedOps != null) {\n            scheduleFastWriteLocked();\n\n            final int numOps = removedOps.size();\n            for (int opNum = 0; opNum < numOps; opNum++) {\n                final Op op = removedOps.valueAt(opNum);\n\n                final int numAttributions = op.mAttributions.size();\n                for (int attributionNum = 0; attributionNum < numAttributions;\n                        attributionNum++) {\n                    AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                    while (attributedOp.isRunning()) {\n                        attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                    }\n                    while (attributedOp.isPaused()) {\n                        attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.get(uid).clear();\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    // The callback method from AppOpsUidStateTracker\n    private void onUidStateChanged(int uid, int state, boolean foregroundModeMayChange) {\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, true);\n\n            if (uidState != null && foregroundModeMayChange && uidState.hasForegroundWatchers) {\n                for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                    if (!uidState.foregroundOps.valueAt(fgi)) {\n                        continue;\n                    }\n                    final int code = uidState.foregroundOps.keyAt(fgi);\n\n                    if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)\n                            && uidState.getUidMode(code) == AppOpsManager.MODE_FOREGROUND) {\n                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                AppOpsService::notifyOpChangedForAllPkgsInUid,\n                                this, code, uidState.uid, true, null));\n                    } else if (!uidState.pkgOps.isEmpty()) {\n                        final ArraySet<OnOpModeChangedListener> listenerSet =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (listenerSet != null) {\n                            for (int cbi = listenerSet.size() - 1; cbi >= 0; cbi--) {\n                                final OnOpModeChangedListener listener = listenerSet.valueAt(cbi);\n                                if ((listener.getFlags()\n                                        & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                        || !listener.isWatchingUid(uidState.uid)) {\n                                    continue;\n                                }\n                                for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                    final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                    if (op == null) {\n                                        continue;\n                                    }\n                                    if (op.getMode() == AppOpsManager.MODE_FOREGROUND) {\n                                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                                AppOpsService::notifyOpChanged,\n                                                this, listenerSet.valueAt(cbi), code, uidState.uid,\n                                                uidState.pkgOps.keyAt(pkgi)));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (uidState != null) {\n                int numPkgs = uidState.pkgOps.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = 0; attributionNum < numAttributions;\n                                attributionNum++) {\n                            AttributedOp attributedOp = op.mAttributions.valueAt(\n                                    attributionNum);\n\n                            attributedOp.onUidStateChanged(state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify the proc state or capability has changed for a certain UID.\n     */\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            getUidStateTracker().updateUidProcState(uid, procState, capability);\n            if (!mUidStates.contains(uid)) {\n                UidState uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n                onUidStateChanged(uid,\n                        AppOpsUidStateTracker.processStateToUidState(procState), false);\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeRecentAccesses();\n        }\n        mAppOpsCheckingService.shutdown();\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid())\n                == PackageManager.PERMISSION_GRANTED;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j = 0; j < pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                    continue;\n                }\n                resOps.add(getOpEntryForResult(curOp));\n            }\n        } else {\n            for (int j = 0; j < ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                        continue;\n                    }\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n        if (opModes == null) {\n            return null;\n        }\n\n        int opModeCount = opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = opModes.keyAt(i);\n                resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        // We get to access everything\n        final int callingPid = Binder.getCallingPid();\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        final int callingUid = Binder.getCallingUid();\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, callingPid,\n                callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        mAppOpsCheckingService.writeState();\n        mAppOpsCheckingService.readState();\n    }\n\n    @VisibleForTesting\n    void readState() {\n        mAppOpsCheckingService.readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                op.setMode(AppOpsManager.opToDefaultMode(op.op));\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        mAppOpsCheckingService.removePackage(ops.packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n            }\n            if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                previousMode = uidState.getUidMode(code);\n            } else {\n                // doesn't look right but is legacy behavior.\n                previousMode = MODE_DEFAULT;\n            }\n\n            if (!uidState.setUidMode(code, mode)) {\n                return;\n            }\n            uidState.evalForegroundOps();\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        ModeCallback listenerToIgnore = callbackToIgnore != null\n                ? mModeWatchers.get(callbackToIgnore.asBinder()) : null;\n        mAppOpsCheckingService.notifyOpChangedForAllPkgsInUid(code, uid, onlyForeground,\n                listenerToIgnore);\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        ArraySet<OnOpModeChangedListener> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot setMode: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot setMode\", e);\n            }\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.getMode() != mode) {\n                    previousMode = op.getMode();\n                    op.setMode(mode);\n\n                    if (uidState != null) {\n                        uidState.evalForegroundOps();\n                    }\n                    ArraySet<OnOpModeChangedListener> cbs =\n                            mAppOpsCheckingService.getOpModeChangedListeners(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mAppOpsCheckingService.getPackageModeChangedListeners(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<OnOpModeChangedListener> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final OnOpModeChangedListener callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(OnOpModeChangedListener callback, int code,\n            int uid, String packageName) {\n        mAppOpsCheckingService.notifyOpChanged(callback, code, uid, packageName);\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode,\n            ArraySet<OnOpModeChangedListener> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            OnOpModeChangedListener cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            int newMode = isUidOpGrantedByRole(uidState.uid, code) ? MODE_ALLOWED :\n                                    AppOpsManager.opToDefaultMode(code);\n                            uidState.setUidMode(code, newMode);\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode,\n                                        mAppOpsCheckingService.getOpModeChangedListeners(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mAppOpsCheckingService\n                                                .getPackageModeChangedListeners(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)) {\n                            int previousMode = curOp.getMode();\n                            int newMode = isPackageOpGrantedByRole(packageName, uidState.uid,\n                                    curOp.op) ? MODE_ALLOWED : AppOpsManager.opToDefaultMode(\n                                    curOp.op);\n                            if (previousMode == newMode) {\n                                continue;\n                            }\n                            curOp.setMode(newMode);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode,\n                                    mAppOpsCheckingService.getOpModeChangedListeners(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mAppOpsCheckingService\n                                            .getPackageModeChangedListeners(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                        mAppOpsCheckingService.removePackage(packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps();\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<OnOpModeChangedListener, ArrayList<ChangeRec>> ent\n                    : callbacks.entrySet()) {\n                OnOpModeChangedListener cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean isUidOpGrantedByRole(int uid, int code) {\n        if (!AppOpsManager.opIsUidAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            // Permissions are managed by UIDs, but unfortunately a package name is required in API.\n            String packageName = ArrayUtils.firstOrNull(packageManager.getPackagesForUid(uid));\n            if (packageName == null) {\n                return false;\n            }\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean isPackageOpGrantedByRole(@NonNull String packageName, int uid, int code) {\n        if (!AppOpsManager.opIsPackageAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName = packageName != null\n                && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(callingUid));\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                mAppOpsCheckingService.startWatchingOpModeChanged(cb, switchOp);\n            }\n            if (mayWatchPackageName) {\n                mAppOpsCheckingService.startWatchingPackageModeChanged(cb, packageName);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                mAppOpsCheckingService.removeListener(cb);\n            }\n\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot checkOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot checkOperation\", e);\n            }\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null\n                    && uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                final int rawMode = uidState.getUidMode(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.getMode() : op.uidState.evalMode(op.op, op.getMode());\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveNonAppUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return getPackageManagerInternal().getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, userId);\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))\n                || !isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot noteOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot noteOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.getState(), flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState.getState(),\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, OP_RECEIVE_AMBIENT_TRIGGER_AUDIO and\n        // OP_RECORD_AUDIO_SANDBOXED which we use only for attribution purposes and not as a check,\n        // also make sure that the caller is allowed to access the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        int result = MODE_DEFAULT;\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO\n                || code == OP_RECORD_AUDIO_SANDBOXED) {\n            result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        // As a special case for OP_CAMERA_SANDBOXED.\n        if (code == OP_CAMERA_SANDBOXED) {\n            result = checkOperation(OP_CAMERA, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot startOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot startOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return null;\n        }\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot finishOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot finishOperation\", e);\n            }\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        if (AppOpsManager.shouldForceCollectNoteForOp(opCode)) {\n            return true;\n        }\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private boolean isIncomingPackageValid(@Nullable String packageName, @UserIdInt int userId) {\n        final int callingUid = Binder.getCallingUid();\n        // Handle the special UIDs that don't have actual packages (audioserver, cameraserver, etc).\n        if (packageName == null || isSpecialPackage(callingUid, packageName)) {\n            return true;\n        }\n\n        // If the package doesn't exist, #verifyAndGetBypass would throw a SecurityException in\n        // the end. Although that exception would be caught and return, we could make it return\n        // early.\n        if (!isPackageExisted(packageName)) {\n            return false;\n        }\n\n        if (getPackageManagerInternal().filterAppAccess(packageName, callingUid, userId)) {\n            Slog.w(TAG, packageName + \" not found from \" + callingUid);\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            // if there is a next attribution source, it must be trusted, as well.\n            if (attributionSource.getNext() == null\n                    || attributionSource.getNext().isTrusted(mContext)) {\n                return true;\n            }\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        }\n\n        return uidState;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            getUidStateTracker().updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        if (mPackageManagerInternal == null) {\n            throw new IllegalStateException(\"PackageManagerInternal not loaded\");\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * @return {@link PackageManagerLocal}\n     */\n    private @NonNull PackageManagerLocal getPackageManagerLocal() {\n        if (mPackageManagerLocal == null) {\n            mPackageManagerLocal = LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n        if (mPackageManagerLocal == null) {\n            throw new IllegalStateException(\"PackageManagerLocal not loaded\");\n        }\n\n        return mPackageManagerLocal;\n    }\n\n    /**\n     * @return {@link UserManagerInternal}\n     */\n    private @NonNull UserManagerInternal getUserManagerInternal() {\n        if (mUserManagerInternal == null) {\n            mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);\n        }\n        if (mUserManagerInternal == null) {\n            throw new IllegalStateException(\"UserManagerInternal not loaded\");\n        }\n\n        return mUserManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull PackageState packageState) {\n        return new RestrictionBypass(packageState.getAppId() == Process.SYSTEM_UID,\n                packageState.isPrivileged(), mContext.checkPermission(\n                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1,\n                packageState.getAppId()) == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n                false);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    uid = pm.getPackageUidAsUser(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0), UserHandle.getUserId(uid));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && !uidState.pkgOps.isEmpty()) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable, non-app uids\n        int nonAppUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            nonAppUid = Process.SHELL_UID;\n        } else {\n            nonAppUid = resolveNonAppUid(packageName);\n        }\n        if (nonAppUid != Process.INVALID_UID) {\n            if (nonAppUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                                + \".\");\n                }\n                String otherUidMessage =\n                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName\n                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            // We only allow bypassing the attribution tag verification if the proxy is a\n            // system app (or is null), in order to prevent abusive apps clogging the appops\n            // system with unlimited attribution tags via proxy calls.\n            boolean proxyIsSystemAppOrNull = true;\n            if (proxyPackageName != null) {\n                int proxyAppId = UserHandle.getAppId(proxyUid);\n                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n                    proxyIsSystemAppOrNull =\n                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                }\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        int pkgUid = nonAppUid;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            var pkgState = pmInt.getPackageStateInternal(packageName);\n            var pkg = pkgState == null ? null : pkgState.getAndroidPackage();\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, pkgState.getAppId());\n                bypass = getBypassforPackage(pkgState);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            if (!suppressErrorLogs) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            }\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Read recent accesses from persistence (mRecentAccessesFile).\n     * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n     * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n     * If neither file exists, there's nothing to migrate.\n     */\n    private void readRecentAccesses() {\n        if (!mRecentAccessesFile.exists()) {\n            readRecentAccesses(mStorageFile);\n        } else {\n            readRecentAccesses(mRecentAccessesFile);\n        }\n    }\n\n    private void readRecentAccesses(AtomicFile file) {\n        synchronized (file) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = file.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + file.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                mAppOpsCheckingService.clearAllModes();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        // Parse next until we reach the start or end\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            // uid tag may be present during migration, don't print warning.\n                            XmlUtils.skipCurrentTag(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                        mAppOpsCheckingService.clearAllModes();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    @VisibleForTesting\n    void writeRecentAccesses() {\n        synchronized (mRecentAccessesFile) {\n            FileOutputStream stream;\n            try {\n                stream = mRecentAccessesFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mRecentAccessesFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mRecentAccessesFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveNonAppUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n        pw.println(\"  --uid-state-changes\");\n        pw.println(\"    Include logs about uid state changes.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                AttributedOp.InProgressStartOpEvent event =\n                        attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.mNumUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        boolean dumpUidStateChangeLogs = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n        boolean dumpAll = false;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                    dumpAll = true;\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else if (\"--uid-state-changes\".equals(arg)) {\n                    dumpUidStateChangeLogs = true;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n\n            if (!dumpHistory) {\n                needSep |= mAppOpsCheckingService.dumpListeners(dumpOp, dumpUid, dumpPackage, pw);\n            }\n\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i = 0; i < mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.getWatchingUid())) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (opModes != null\n                            && opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).getMode() == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                uidState.dump(pw, nowElapsed);\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.getMode()) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.getMode()));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj == null\n                                    ? AppOpsManager.opToDefaultMode(switchOp) : switchObj.getMode();\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            boolean showUserRestrictions = !(dumpMode < 0 && !dumpWatchers && !dumpHistory);\n            mAppOpsRestrictions.dumpRestrictions(pw, dumpOp, dumpPackage, showUserRestrictions);\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n\n            if (dumpAll || dumpUidStateChangeLogs) {\n                pw.println();\n                pw.println(\"Uid State Changes Event Log:\");\n                getUidStateTracker().dumpEvents(pw);\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.getMode() != MODE_ALLOWED && op.getMode() != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n                            .bypass;\n                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n                            bypass, false)) {\n                        // Only resume if there are no other restrictions remaining on this op\n                        attrOp.resume();\n                    }\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<OnOpModeChangedListener> modeChangedListenerSet;\n        synchronized (this) {\n            modeChangedListenerSet = mAppOpsCheckingService.getOpModeChangedListeners(code);\n            if (modeChangedListenerSet == null) {\n                return;\n            }\n        }\n\n        notifyOpChanged(modeChangedListenerSet,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return false;\n        }\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"this\")\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.valueAt(i).clear();\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveNonAppUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return Process.INVALID_UID;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n                    restricted, excludedPackageTags);\n        }\n\n        public boolean hasRestriction(int code, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n                    attributionTag, isCheckOp);\n        }\n\n        public void removeUser(int userId) {\n            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n        }\n\n        public boolean isDefault() {\n            return !mAppOpsRestrictions.hasUserRestrictions(token);\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mAppOpsRestrictions.clearUserRestrictions(token);\n                mOpUserRestrictions.remove(token);\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n        }\n\n        boolean hasRestriction(int code) {\n            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n        }\n\n        boolean isDefault() {\n            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n        }\n\n        @Override\n        public void binderDied() {\n            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n            mOpGlobalRestrictions.remove(mToken);\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n        @Override\n        public boolean isUidInForeground(int uid) {\n            synchronized (AppOpsService.this) {\n                return mUidStateTracker.isUidInForeground(uid);\n            }\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final",
        "metrics": {
            "relative_line_count_similarity": 0.1212,
            "normalized_edit_similarity": "skipped",
            "token_level_edit_distance": 18705,
            "codebert_score": {
                "precision": 0.9991,
                "recall": 0.8431,
                "f1": 0.9145,
                "f3": 0.8564
            },
            "token_count_ground_truth": 21712,
            "token_count_llm_output": 2411,
            "token_count_total": 24123,
            "cosine_similarity_openai": "skipped_max_tokens"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-353240784",
        "downstream_version": "14",
        "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        ensureWidgetCountBeforeAddLocked(widget);\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Ensures that the widget count for the widget's host is not greater than the maximum\n     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n     * from the host until the count is less than or equal to the maximum.\n     */\n    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n        if (widget.host == null || widget.host.id == null) {\n            return;\n        }\n        final List<Widget> widgetsInSameHost = new ArrayList<>();\n        for (Widget w : mWidgets) {\n            if (w.host != null && widget.host.id.equals(w.host.id)) {\n                widgetsInSameHost.add(w);\n            }\n        }\n        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n            removeWidgetLocked(widgetsInSameHost.remove(0));\n        }\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport androidx.annotation.NonNull;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    // See {@link Provider#pendingDeletedWidgetIds}.\n    private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {",
        "metrics": {
            "relative_line_count_similarity": 0.1673,
            "normalized_edit_similarity": 0.2865,
            "token_level_edit_distance": 11534,
            "codebert_score": {
                "precision": 0.9484,
                "recall": 0.866,
                "f1": 0.9054,
                "f3": 0.8736
            },
            "token_count_ground_truth": 16871,
            "token_count_llm_output": 2570,
            "token_count_total": 19441,
            "cosine_similarity_openai": "skipped_max_tokens"
        },
        "metrics_status": "computed"
    },
    {
        "cve_id": "ASB-A-382064697",
        "downstream_version": "14",
        "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
        "ground_truth_codebase": "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.devicepolicy;\n\nimport static android.Manifest.permission.BIND_DEVICE_ADMIN;\nimport static android.Manifest.permission.LOCK_DEVICE;\nimport static android.Manifest.permission.MANAGE_CA_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;\nimport static android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS;\nimport static android.Manifest.permission.MASTER_CLEAR;\nimport static android.Manifest.permission.QUERY_ADMIN_POLICY;\nimport static android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY;\nimport static android.Manifest.permission.SET_TIME;\nimport static android.Manifest.permission.SET_TIME_ZONE;\nimport static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK;\nimport static android.accounts.AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_FORCE_LOCK;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_WIPE_DATA;\nimport static android.app.admin.DeviceAdminReceiver.ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED;\nimport static android.app.admin.DeviceAdminReceiver.EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE;\nimport static android.app.admin.DevicePolicyIdentifiers.AUTO_TIMEZONE_POLICY;\nimport static android.app.admin.DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_FINANCING_STATE_CHANGED;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_RESOURCE_UPDATED;\nimport static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_USER;\nimport static android.app.admin.DevicePolicyManager.ACTION_SYSTEM_UPDATE_POLICY_CHANGED;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_INSTALL_EXISTING_PACKAGE;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_KEEP_UNINSTALLED_PACKAGES;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_FINANCED;\nimport static android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_HIBERNATION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_IDS;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_DRAWABLE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_STRING;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_BASE_INFO;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_IMEI;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_INDIVIDUAL_ATTESTATION;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_MEID;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_SERIAL;\nimport static android.app.admin.DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;\nimport static android.app.admin.DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_LOW;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_MANAGED;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_NOT_SUSPENDED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_EXPLICITLY;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OFF;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OPPORTUNISTIC;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_UNKNOWN;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR;\nimport static android.app.admin.DevicePolicyManager.PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_SETUP_FINALIZED;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_UNMANAGED;\nimport static android.app.admin.DevicePolicyManager.STATUS_ACCOUNTS_NOT_EMPTY;\nimport static android.app.admin.DevicePolicyManager.STATUS_CANNOT_ADD_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_DEVICE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_PAIRED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_MANAGED_USERS_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_NONSYSTEM_USER_EXISTS;\nimport static android.app.admin.DevicePolicyManager.STATUS_NOT_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_OK;\nimport static android.app.admin.DevicePolicyManager.STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\nimport static android.app.admin.DevicePolicyManager.STATUS_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_HAS_PROFILE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_NOT_RUNNING;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_SETUP_COMPLETED;\nimport static android.app.admin.DevicePolicyManager.WIPE_EUICC;\nimport static android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE;\nimport static android.app.admin.DevicePolicyManager.WIPE_RESET_PROTECTION_DATA;\nimport static android.app.admin.DevicePolicyManager.WIPE_SILENTLY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PRINTING_DISABLED_NAMED_ADMIN;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_GENERIC_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_BODY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON;\nimport static android.app.admin.ProvisioningException.ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PRE_CONDITION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PROFILE_CREATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_REMOVE_NON_REQUIRED_APPS_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SETTING_PROFILE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SET_DEVICE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_STARTING_PROFILE_FAILED;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_AVAILABLE;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.PackageManager.GET_META_DATA;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\nimport static android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_DEFAULT;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK;\nimport static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;\nimport static android.provider.DeviceConfig.NAMESPACE_DEVICE_POLICY_MANAGER;\nimport static android.provider.Settings.Global.PRIVATE_DNS_SPECIFIER;\nimport static android.provider.Settings.Secure.MANAGED_PROVISIONING_DPC_DOWNLOADED;\nimport static android.provider.Settings.Secure.USER_SETUP_COMPLETE;\nimport static android.provider.Telephony.Carriers.DPC_URI;\nimport static android.provider.Telephony.Carriers.ENFORCE_KEY;\nimport static android.provider.Telephony.Carriers.ENFORCE_MANAGED_URI;\nimport static android.provider.Telephony.Carriers.INVALID_APN_ID;\nimport static android.security.keystore.AttestationUtils.USE_INDIVIDUAL_ATTESTATION;\nimport static com.android.internal.logging.nano.MetricsProto.MetricsEvent.PROVISIONING_ENTRY_POINT_ADB;\nimport static com.android.internal.widget.LockPatternUtils.CREDENTIAL_TYPE_NONE;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW;\nimport static com.android.server.SystemTimeZone.TIME_ZONE_CONFIDENCE_HIGH;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_DEVICE_OWNER;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_DEVICE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n\nimport android.Manifest;\nimport android.Manifest.permission;\nimport android.accessibilityservice.AccessibilityServiceInfo;\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.Mode;\nimport android.app.BroadcastOptions;\nimport android.app.IActivityManager;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.StatusBarManager;\nimport android.app.admin.AccountTypePolicyKey;\nimport android.app.admin.BooleanPolicyValue;\nimport android.app.admin.BundlePolicyValue;\nimport android.app.admin.ComponentNamePolicyValue;\nimport android.app.admin.DeviceAdminInfo;\nimport android.app.admin.DeviceAdminReceiver;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.admin.DevicePolicyDrawableResource;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManager.DeviceOwnerType;\nimport android.app.admin.DevicePolicyManager.DevicePolicyOperation;\nimport android.app.admin.DevicePolicyManager.OperationSafetyReason;\nimport android.app.admin.DevicePolicyManager.PasswordComplexity;\nimport android.app.admin.DevicePolicyManager.PersonalAppsSuspensionReason;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerLiteInternal;\nimport android.app.admin.DevicePolicySafetyChecker;\nimport android.app.admin.DevicePolicyState;\nimport android.app.admin.DevicePolicyStringResource;\nimport android.app.admin.DeviceStateCache;\nimport android.app.admin.FactoryResetProtectionPolicy;\nimport android.app.admin.FullyManagedDeviceProvisioningParams;\nimport android.app.admin.IDevicePolicyManager;\nimport android.app.admin.IntegerPolicyValue;\nimport android.app.admin.IntentFilterPolicyKey;\nimport android.app.admin.LockTaskPolicy;\nimport android.app.admin.LongPolicyValue;\nimport android.app.admin.ManagedProfileProvisioningParams;\nimport android.app.admin.ManagedSubscriptionsPolicy;\nimport android.app.admin.NetworkEvent;\nimport android.app.admin.PackagePolicy;\nimport android.app.admin.ParcelableGranteeMap;\nimport android.app.admin.ParcelableResource;\nimport android.app.admin.PasswordMetrics;\nimport android.app.admin.PasswordPolicy;\nimport android.app.admin.PolicyKey;\nimport android.app.admin.PolicyValue;\nimport android.app.admin.PreferentialNetworkServiceConfig;\nimport android.app.admin.SecurityLog;\nimport android.app.admin.SecurityLog.SecurityEvent;\nimport android.app.admin.StartInstallingUpdateCallback;\nimport android.app.admin.StringSetPolicyValue;\nimport android.app.admin.SystemUpdateInfo;\nimport android.app.admin.SystemUpdatePolicy;\nimport android.app.admin.UnsafeStateException;\nimport android.app.admin.UserRestrictionPolicyKey;\nimport android.app.admin.WifiSsidPolicy;\nimport android.app.backup.IBackupManager;\nimport android.app.compat.CompatChanges;\nimport android.app.role.OnRoleHoldersChangedListener;\nimport android.app.role.RoleManager;\nimport android.app.trust.TrustManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.PermissionChecker;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.CrossProfileApps;\nimport android.content.pm.CrossProfileAppsInternal;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.StringParceledListSlice;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.pm.parsing.FrameworkParsingPackageUtils;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.hardware.usb.UsbManager;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.media.AudioManager;\nimport android.media.IAudioService;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivitySettingsManager;\nimport android.net.IIpConnectivityMetrics;\nimport android.net.ProfileNetworkPreference;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport android.net.VpnManager;\nimport android.net.metrics.IpConnectivityLog;\nimport android.net.wifi.WifiManager;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ServiceSpecificException;\nimport android.os.ShellCallback;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.UserManager.EnforcingUser;\nimport android.os.UserManager.UserRestrictionSource;\nimport android.os.storage.StorageManager;\nimport android.permission.AdminPermissionControlParams;\nimport android.permission.IPermissionManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.CalendarContract;\nimport android.provider.ContactsContract.QuickContact;\nimport android.provider.ContactsInternal;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.provider.Settings.Global;\nimport android.provider.Telephony;\nimport android.security.AppUriAuthenticationPolicy;\nimport android.security.IKeyChainAliasCallback;\nimport android.security.IKeyChainService;\nimport android.security.KeyChain;\nimport android.security.KeyChain.KeyChainConnection;\nimport android.security.KeyStore;\nimport android.security.keymaster.KeymasterCertificateChain;\nimport android.security.keystore.AttestationUtils;\nimport android.security.keystore.KeyGenParameterSpec;\nimport android.security.keystore.ParcelableKeyGenParameterSpec;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.telecom.TelecomManager;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.DebugUtils;\nimport android.util.IndentingPrintWriter;\nimport android.util.IntArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.Xml;\nimport android.view.IWindowManager;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.accessibility.IAccessibilityManager;\nimport android.view.inputmethod.InputMethodInfo;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.LocalePicker;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.net.NetworkUtilsInternal;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.statusbar.IStatusBarService;\nimport com.android.internal.telephony.SmsApplication;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.FunctionalUtils.ThrowingRunnable;\nimport com.android.internal.util.FunctionalUtils.ThrowingSupplier;\nimport com.android.internal.util.JournaledFile;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.StatLogger;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.internal.widget.LockSettingsInternal;\nimport com.android.internal.widget.LockscreenCredential;\nimport com.android.internal.widget.PasswordValidationError;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.net.module.util.ProxyUtils;\nimport com.android.server.AlarmManagerInternal;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.PersistentDataBlockManagerInternal;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.devicepolicy.ActiveAdmin.TrustAgentInfo;\nimport com.android.server.inputmethod.InputMethodManagerInternal;\nimport com.android.server.net.NetworkPolicyManagerInternal;\nimport com.android.server.pm.DefaultCrossProfileIntentFilter;\nimport com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.RestrictionsSet;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.UserManagerInternal.UserRestrictionsListener;\nimport com.android.server.pm.UserRestrictionsUtils;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.storage.DeviceStorageMonitorInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.utils.Slogf;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.text.DateFormat;\nimport java.time.LocalDate;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\n/**\n * Implementation of the device policy APIs.\n */\npublic class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n\n    protected static final String LOG_TAG = \"DevicePolicyManager\";\n\n    private static final String ATTRIBUTION_TAG = \"DevicePolicyManagerService\";\n\n    static final boolean VERBOSE_LOG = false; // DO NOT SUBMIT WITH TRUE\n\n    static final String DEVICE_POLICIES_XML = \"device_policies.xml\";\n\n    static final String POLICIES_VERSION_XML = \"device_policies_version\";\n\n    private static final String TRANSFER_OWNERSHIP_PARAMETERS_XML =\n            \"transfer-ownership-parameters.xml\";\n\n    private static final String TAG_TRANSFER_OWNERSHIP_BUNDLE = \"transfer-ownership-bundle\";\n\n    private static final int REQUEST_EXPIRE_PASSWORD = 5571;\n\n    private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;\n\n    // Binary XML serializer doesn't support longer strings\n    private static final int MAX_POLICY_STRING_LENGTH = 65535;\n    // FrameworkParsingPackageUtils#MAX_FILE_NAME_SIZE, Android packages are used in dir names.\n    private static final int MAX_PACKAGE_NAME_LENGTH = 223;\n\n    private static final int MAX_PROFILE_NAME_LENGTH = 200;\n    private static final int MAX_LONG_SUPPORT_MESSAGE_LENGTH = 20000;\n    private static final int MAX_SHORT_SUPPORT_MESSAGE_LENGTH = 200;\n    private static final int MAX_ORG_NAME_LENGTH = 200;\n\n    private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n\n    private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms\n    private static final long MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD = 3 * MS_PER_DAY;\n    /** When to warn the user about the approaching work profile off deadline: 1 day before */\n    private static final long MANAGED_PROFILE_OFF_WARNING_PERIOD = 1 * MS_PER_DAY;\n\n    private static final String ACTION_EXPIRED_PASSWORD_NOTIFICATION =\n            \"com.android.server.ACTION_EXPIRED_PASSWORD_NOTIFICATION\";\n\n    /** Broadcast action invoked when the user taps a notification to turn the profile on. */\n    @VisibleForTesting\n    static final String ACTION_TURN_PROFILE_ON_NOTIFICATION =\n            \"com.android.server.ACTION_TURN_PROFILE_ON_NOTIFICATION\";\n\n    /** Broadcast action for tracking managed profile maximum time off. */\n    @VisibleForTesting\n    static final String ACTION_PROFILE_OFF_DEADLINE =\n            \"com.android.server.ACTION_PROFILE_OFF_DEADLINE\";\n\n    private static final String CALLED_FROM_PARENT = \"calledFromParent\";\n    private static final String NOT_CALLED_FROM_PARENT = \"notCalledFromParent\";\n\n    private static final String CREDENTIAL_MANAGEMENT_APP = \"credentialManagementApp\";\n    private static final String NOT_CREDENTIAL_MANAGEMENT_APP = \"notCredentialManagementApp\";\n\n    private static final String NULL_STRING_ARRAY = \"nullStringArray\";\n\n    private static final String ALLOW_USER_PROVISIONING_KEY = \"ro.config.allowuserprovisioning\";\n\n    // Comprehensive list of delegations.\n    private static final String DELEGATIONS[] = {\n        DELEGATION_CERT_INSTALL,\n        DELEGATION_APP_RESTRICTIONS,\n        DELEGATION_BLOCK_UNINSTALL,\n        DELEGATION_ENABLE_SYSTEM_APP,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_PACKAGE_ACCESS,\n        DELEGATION_PERMISSION_GRANT,\n        DELEGATION_INSTALL_EXISTING_PACKAGE,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_NETWORK_LOGGING,\n        DELEGATION_SECURITY_LOGGING,\n        DELEGATION_CERT_SELECTION,\n    };\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of a\n    // managed profile.\n    private static final List<String> DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_NETWORK_LOGGING,\n            });\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of an\n    // organization-owned and managed profile.\n    private static final List<String>\n            DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_SECURITY_LOGGING,\n            });\n\n    // Subset of delegations that only one single package within a given user can hold\n    private static final List<String> EXCLUSIVE_DELEGATIONS = Arrays.asList(new String[] {\n            DELEGATION_NETWORK_LOGGING,\n            DELEGATION_SECURITY_LOGGING,\n            DELEGATION_CERT_SELECTION,\n    });\n\n    /**\n     * System property whose value indicates whether the device is fully owned by an organization:\n     * it can be either a device owner device, or a device with an organization-owned managed\n     * profile.\n     *\n     * <p>The state is stored as a Boolean string.\n     */\n    private static final String PROPERTY_ORGANIZATION_OWNED = \"ro.organization_owned\";\n\n    private static final int STATUS_BAR_DISABLE_MASK =\n            StatusBarManager.DISABLE_EXPAND |\n            StatusBarManager.DISABLE_NOTIFICATION_ICONS |\n            StatusBarManager.DISABLE_NOTIFICATION_ALERTS |\n            StatusBarManager.DISABLE_SEARCH;\n\n    private static final int STATUS_BAR_DISABLE2_MASK =\n            StatusBarManager.DISABLE2_QUICK_SETTINGS;\n\n    private static final Set<String> SECURE_SETTINGS_ALLOWLIST;\n    private static final Set<String> SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_DEPRECATED;\n    private static final Set<String> SYSTEM_SETTINGS_ALLOWLIST;\n    private static final Set<Integer> DA_DISALLOWED_POLICIES;\n    private static final String AB_DEVICE_KEY = \"ro.build.ab_update\";\n    // The version of the current DevicePolicyManagerService data. This version is used\n    // to decide whether an existing policy in the {@link #DEVICE_POLICIES_XML} needs to\n    // be upgraded. See {@link PolicyVersionUpgrader} on instructions how to add an upgrade\n    // step.\n    static final int DPMS_VERSION = 5;\n\n    static {\n        SECURE_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.DEFAULT_INPUT_METHOD);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.SKIP_FIRST_USE_HINTS);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.INSTALL_NON_MARKET_APPS);\n\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.addAll(SECURE_SETTINGS_ALLOWLIST);\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.add(Settings.Secure.LOCATION_MODE);\n\n        GLOBAL_SETTINGS_ALLOWLIST = new ArraySet<>();\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.ADB_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.ADB_WIFI_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.AUTO_TIME);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.AUTO_TIME_ZONE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.DATA_ROAMING);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.USB_MASS_STORAGE_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.WIFI_SLEEP_POLICY);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.STAY_ON_WHILE_PLUGGED_IN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.PRIVATE_DNS_MODE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.PRIVATE_DNS_SPECIFIER);\n\n        GLOBAL_SETTINGS_DEPRECATED = new ArraySet<>();\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.BLUETOOTH_ON);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.DEVELOPMENT_SETTINGS_ENABLED);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.MODE_RINGER);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.NETWORK_PREFERENCE);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.WIFI_ON);\n\n        SYSTEM_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_FLOAT);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_MODE);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_OFF_TIMEOUT);\n\n        DA_DISALLOWED_POLICIES = new ArraySet<>();\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    /**\n     * Keyguard features that when set on a profile affect the profile content or challenge only.\n     * These cannot be set on the managed profile's parent DPM instance\n     */\n    private static final int PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY =\n            DevicePolicyManager.KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS;\n\n    /** Keyguard features that are allowed to be set on a managed profile */\n    private static final int PROFILE_KEYGUARD_FEATURES =\n            NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER\n                    | PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY;\n\n    private static final int DEVICE_ADMIN_DEACTIVATE_TIMEOUT = 10000;\n\n    /**\n     * Minimum timeout in milliseconds after which unlocking with weak auth times out,\n     * i.e. the user has to use a strong authentication method like password, PIN or pattern.\n     */\n    private static final long MINIMUM_STRONG_AUTH_TIMEOUT_MS = TimeUnit.HOURS.toMillis(1);\n\n    /**\n     * The amount of ms that a managed kiosk must go without user interaction to be considered\n     * unattended.\n     */\n    private static final int UNATTENDED_MANAGED_KIOSK_MS = 30000;\n\n    /**\n     * Strings logged with {@link\n     * com.android.internal.logging.nano.MetricsProto.MetricsEvent#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#SET_NETWORK_LOGGING_ENABLED} and\n     * {@link DevicePolicyEnums#RETRIEVE_NETWORK_LOGS}.\n     */\n    private static final String LOG_TAG_PROFILE_OWNER = \"profile-owner\";\n    private static final String LOG_TAG_DEVICE_OWNER = \"device-owner\";\n\n    /**\n     * For admin apps targeting R+, throw when the app sets password requirement\n     * that is not taken into account at given quality. For example when quality is set\n     * to {@link android.app.admin.DevicePolicyManager#PASSWORD_QUALITY_UNSPECIFIED}, it doesn't\n     * make sense to require certain password length. If the intent is to require a password of\n     * certain length having at least NUMERIC quality, the admin should first call\n     * {@link android.app.admin.DevicePolicyManager#setPasswordQuality} and only then call\n     * {@link android.app.admin.DevicePolicyManager#setPasswordMinimumLength}.\n     *\n     * <p>Conversely when an admin app targeting R+ lowers password quality, those\n     * requirements that stop making sense are reset to default values.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long ADMIN_APP_PASSWORD_COMPLEXITY = 123562444L;\n\n    /**\n     * Admin apps targeting Android R+ may not use\n     * {@link android.app.admin.DevicePolicyManager#setSecureSetting} to change the deprecated\n     * {@link android.provider.Settings.Secure#LOCATION_MODE} setting. Instead they should use\n     * {@link android.app.admin.DevicePolicyManager#setLocationEnabled}.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long USE_SET_LOCATION_ENABLED = 117835097L;\n\n    /**\n     * Forces wipeDataNoLock to attempt removing the user or throw an error as\n     * opposed to trying to factory reset the device first and only then falling back to user\n     * removal.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long EXPLICIT_WIPE_BEHAVIOUR = 242193913L;\n\n    /**\n     * Apps targetting U+ should now expect that attempts to grant sensor permissions without\n     * authorisation will result in a security exception.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS = 277035314L;\n\n    // Only add to the end of the list. Do not change or rearrange these values, that will break\n    // historical data. Do not use negative numbers or zero, logger only handles positive\n    // integers.\n    private static final int COPY_ACCOUNT_SUCCEEDED = 1;\n    private static final int COPY_ACCOUNT_FAILED = 2;\n    private static final int COPY_ACCOUNT_TIMED_OUT = 3;\n    private static final int COPY_ACCOUNT_EXCEPTION = 4;\n\n    @IntDef({\n            COPY_ACCOUNT_SUCCEEDED,\n            COPY_ACCOUNT_FAILED,\n            COPY_ACCOUNT_TIMED_OUT,\n            COPY_ACCOUNT_EXCEPTION})\n    private @interface CopyAccountStatus {}\n\n    /**\n     * Mapping of {@link android.app.admin.DevicePolicyManager.ApplicationExemptionConstants} to\n     * corresponding app-ops.\n     */\n    private static final Map<Integer, String> APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS =\n            new ArrayMap<>();\n    static {\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_SUSPENSION, OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS,\n                OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION,\n                OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_HIBERNATION, OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_POWER_RESTRICTIONS, OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS);\n    }\n\n    /**\n     * Admin apps targeting Android S+ may not use\n     * {@link android.app.admin.DevicePolicyManager#setPasswordQuality} to set password quality\n     * on the {@code DevicePolicyManager} instance obtained by calling\n     * {@link android.app.admin.DevicePolicyManager#getParentProfileInstance}.\n     * Instead, they should use\n     * {@link android.app.admin.DevicePolicyManager#setRequiredPasswordComplexity} to set\n     * coarse-grained password requirements device-wide.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.S)\n    private static final long PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT = 165573442L;\n\n    /**\n     * For Admin Apps targeting U+\n     * If {@link android.security.IKeyChainService#setGrant} is called with an alias with no\n     * existing key, throw IllegalArgumentException.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    private static final long THROW_EXCEPTION_WHEN_KEY_MISSING = 175101461L;\n\n    private static final String CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG =\n            \"The alias provided must be contained in the aliases specified in the credential \"\n                    + \"management app's authentication policy\";\n    private static final String NOT_SYSTEM_CALLER_MSG = \"Only the system can %s\";\n\n    private static final String PERMISSION_BASED_ACCESS_EXPERIMENT_FLAG =\n            \"enable_permission_based_access\";\n    private static final boolean DEFAULT_VALUE_PERMISSION_BASED_ACCESS_FLAG = false;\n\n    private static final String ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG =\n            \"enable_device_policy_engine\";\n    private static final boolean DEFAULT_ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG = true;\n\n    // TODO(b/265683382) remove the flag after rollout.\n    private static final String KEEP_PROFILES_RUNNING_FLAG = \"enable_keep_profiles_running\";\n    public static final boolean DEFAULT_KEEP_PROFILES_RUNNING_FLAG = true;\n\n    // TODO(b/261999445) remove the flag after rollout.\n    private static final String HEADLESS_FLAG = \"headless\";\n    private static final boolean DEFAULT_HEADLESS_FLAG = true;\n\n    // TODO(b/266831522) remove the flag after rollout.\n    private static final String APPLICATION_EXEMPTIONS_FLAG = \"application_exemptions\";\n    private static final boolean DEFAULT_APPLICATION_EXEMPTIONS_FLAG = true;\n\n    /**\n     * For apps targeting U+\n     * Enable multiple admins to coexist on the same device.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    static final long ENABLE_COEXISTENCE_CHANGE = 260560985L;\n\n    final Context mContext;\n    final Injector mInjector;\n    final PolicyPathProvider mPathProvider;\n    final IPackageManager mIPackageManager;\n    final IPermissionManager mIPermissionManager;\n    final UserManager mUserManager;\n    final UserManagerInternal mUserManagerInternal;\n    final UsageStatsManagerInternal mUsageStatsManagerInternal;\n    final TelephonyManager mTelephonyManager;\n    final RoleManager mRoleManager;\n    private final LockPatternUtils mLockPatternUtils;\n    private final LockSettingsInternal mLockSettingsInternal;\n    private final DeviceAdminServiceController mDeviceAdminServiceController;\n    private final OverlayPackagesProvider mOverlayPackagesProvider;\n\n    private final DevicePolicyCacheImpl mPolicyCache = new DevicePolicyCacheImpl();\n    private final DeviceStateCacheImpl mStateCache = new DeviceStateCacheImpl();\n    private final Object mESIDInitilizationLock = new Object();\n    private EnterpriseSpecificIdCalculator mEsidCalculator;\n    private final Object mSubscriptionsChangedListenerLock = new Object();\n    @GuardedBy(\"mSubscriptionsChangedListenerLock\")\n    private SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedListener;\n\n    /**\n     * Contains the list of OEM Default Role Holders for Contact-related roles\n     * (DIALER, SMS, SYSTEM_CONTACTS)\n     */\n    private final Set<String> mContactSystemRoleHolders;\n\n    /**\n     * Contains (package-user) pairs to remove. An entry (p, u) implies that removal of package p\n     * is requested for user u.\n     */\n    private final Set<UserPackage> mPackagesToRemove = new ArraySet<>();\n\n    final LocalService mLocalService;\n\n    // Stores and loads state on device and profile owners.\n    @VisibleForTesting\n    final Owners mOwners;\n\n    private final Binder mToken = new Binder();\n\n    /**\n     * Whether or not device admin feature is supported. If it isn't return defaults for all\n     * public methods, unless the caller has the appropriate permission for a particular method.\n     */\n    final boolean mHasFeature;\n\n    /**\n     * Whether or not this device is a watch.\n     */\n    final boolean mIsWatch;\n\n    /**\n     * Whether or not this device is an automotive.\n     */\n    private final boolean mIsAutomotive;\n\n    /**\n     * Whether this device has the telephony feature.\n     */\n    final boolean mHasTelephonyFeature;\n\n    private final CertificateMonitor mCertificateMonitor;\n    private final SecurityLogMonitor mSecurityLogMonitor;\n    private final RemoteBugreportManager mBugreportCollectionManager;\n\n    @GuardedBy(\"getLockObject()\")\n    private NetworkLogger mNetworkLogger;\n\n    private final SetupContentObserver mSetupContentObserver;\n    private final DevicePolicyConstantsObserver mConstantsObserver;\n\n    private DevicePolicyConstants mConstants;\n\n    /**\n     * User to be switched to on {@code logoutUser()}.\n     *\n     * <p>Only used on devices with headless system user mode\n     */\n    @GuardedBy(\"getLockObject()\")\n    private @UserIdInt int mLogoutUserId = UserHandle.USER_NULL;\n\n    /**\n     * User the network logging notification was sent to.\n     */\n    // Guarded by mHandler\n    private @UserIdInt int mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n\n    private final DeviceManagementResourcesProvider mDeviceManagementResourcesProvider;\n    private final DevicePolicyManagementRoleObserver mDevicePolicyManagementRoleObserver;\n\n    private final DevicePolicyEngine mDevicePolicyEngine;\n\n    private static final boolean ENABLE_LOCK_GUARD = true;\n\n    /**\n     * Profile off deadline is not set or more than MANAGED_PROFILE_OFF_WARNING_PERIOD away, or the\n     * user is running unlocked, no need for notification.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_NONE = 0;\n    /**\n     * Profile off deadline is closer than MANAGED_PROFILE_OFF_WARNING_PERIOD.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_WARNING = 1;\n    /**\n     * Profile off deadline reached, notify the user that personal apps blocked.\n     */\n    private static final int PROFILE_OFF_NOTIFICATION_SUSPENDED = 2;\n\n    interface Stats {\n        int LOCK_GUARD_GUARD = 0;\n\n        int COUNT = LOCK_GUARD_GUARD + 1;\n    }\n\n    private final StatLogger mStatLogger = new StatLogger(new String[] {\n            \"LockGuard.guard()\",\n    });\n\n    private final Object mLockDoNoUseDirectly = LockGuard.installNewLock(\n            LockGuard.INDEX_DPMS, /* doWtf=*/ true);\n\n    final Object getLockObject() {\n        if (ENABLE_LOCK_GUARD) {\n            final long start = mStatLogger.getTime();\n            LockGuard.guard(LockGuard.INDEX_DPMS);\n            mStatLogger.logDurationStat(Stats.LOCK_GUARD_GUARD, start);\n        }\n        return mLockDoNoUseDirectly;\n    }\n\n    /**\n     * Check if the current thread holds the DPMS lock, and if not, do a WTF.\n     *\n     * (Doing this check too much may be costly, so don't call it in a hot path.)\n     */\n    final void ensureLocked() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            return;\n        }\n        Slogf.wtfStack(LOG_TAG, \"Not holding DPMS lock.\");\n    }\n\n    /**\n     * Calls wtfStack() if called with the DPMS lock held.\n     */\n    private void wtfIfInLock() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            Slogf.wtfStack(LOG_TAG, \"Shouldn't be called with DPMS lock held\");\n        }\n    }\n\n    @VisibleForTesting\n    final TransferOwnershipMetadataManager mTransferOwnershipMetadataManager;\n\n    @Nullable\n    private DevicePolicySafetyChecker mSafetyChecker;\n\n    @GuardedBy(\"getLockObject()\")\n    private final ArrayList<Object> mPendingUserCreatedCallbackTokens = new ArrayList<>();\n\n    public static final class Lifecycle extends SystemService {\n        private DevicePolicyManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            String dpmsClassName = context.getResources()\n                    .getString(R.string.config_deviceSpecificDevicePolicyManagerService);\n            if (TextUtils.isEmpty(dpmsClassName)) {\n                mService = new DevicePolicyManagerService(context);\n            } else {\n                try {\n                    Class<?> serviceClass = Class.forName(dpmsClassName);\n                    Constructor<?> constructor = serviceClass.getConstructor(Context.class);\n                    mService = (DevicePolicyManagerService) constructor.newInstance(context);\n                } catch (Exception e) {\n                    throw new IllegalStateException(\n                        \"Failed to instantiate DevicePolicyManagerService with class name: \"\n                        + dpmsClassName, e);\n                }\n            }\n        }\n\n        /** Sets the {@link DevicePolicySafetyChecker}. */\n        public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mService.setDevicePolicySafetyChecker(safetyChecker);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.DEVICE_POLICY_SERVICE, mService);\n        }\n\n        @Override\n        public void onBootPhase(int phase) {\n            mService.systemReady(phase);\n        }\n\n        @Override\n        public void onUserStarting(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStartUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStopUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocked(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleOnUserUnlocked(user.getUserIdentifier());\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    final SparseArray<DevicePolicyData> mUserData;\n\n    final Handler mHandler;\n    final Handler mBackgroundHandler;\n\n    /** Listens only if mHasFeature == true. */\n    final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE,\n                    getSendingUserId());\n\n            /*\n             * Network logging would ideally be started in setDeviceOwnerSystemPropertyLocked(),\n             * however it's too early in the boot process to register with IIpConnectivityMetrics\n             * to listen for events.\n             */\n            if (Intent.ACTION_USER_STARTED.equals(action) && userHandle == UserHandle.USER_SYSTEM) {\n                synchronized (getLockObject()) {\n                    if (isNetworkLoggingEnabledInternalLocked()) {\n                        setNetworkLoggingActiveInternal(true);\n                    }\n                }\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    && userHandle == mOwners.getDeviceOwnerUserId()) {\n                mBugreportCollectionManager.checkForPendingBugreportAfterBoot();\n\n            }\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    || ACTION_EXPIRED_PASSWORD_NOTIFICATION.equals(action)) {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"Sending password expiration notifications for action \"\n                            + action + \" for user \" + userHandle);\n                }\n                mHandler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        handlePasswordExpirationNotification(userHandle);\n                    }\n                });\n            }\n\n            if (Intent.ACTION_USER_ADDED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_ADDED, userHandle);\n                synchronized (getLockObject()) {\n                    // It might take a while for the user to become affiliated. Make security\n                    // and network logging unavailable in the meantime.\n                    maybePauseDeviceWideLoggingLocked();\n                }\n            } else if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_REMOVED, userHandle);\n                synchronized (getLockObject()) {\n                    // Check whether the user is affiliated, *before* removing its data.\n                    boolean isRemovedUserAffiliated = isUserAffiliatedWithDeviceLocked(userHandle);\n                    removeUserData(userHandle);\n                    if (!isRemovedUserAffiliated) {\n                        // We discard the logs when unaffiliated users are deleted (so that the\n                        // device owner cannot retrieve data about that user after it's gone).\n                        discardDeviceWideLogsLocked();\n                        // Resume logging if all remaining users are affiliated.\n                        maybeResumeDeviceWideLoggingLocked();\n                    }\n                }\n                if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                    mDevicePolicyEngine.handleUserRemoved(userHandle);\n                }\n            } else if (Intent.ACTION_USER_STARTED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STARTED, userHandle);\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                    // Reset the policy data\n                    mUserData.remove(userHandle);\n                }\n                handlePackagesChanged(null /* check all admins */, userHandle);\n                updatePersonalAppsSuspensionOnUserStart(userHandle);\n            } else if (Intent.ACTION_USER_STOPPED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STOPPED, userHandle);\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile was stopped\");\n                    updatePersonalAppsSuspension(userHandle);\n                }\n            } else if (Intent.ACTION_USER_SWITCHED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_SWITCHED, userHandle);\n            } else if (Intent.ACTION_USER_UNLOCKED.equals(action)) {\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                }\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile became unlocked\");\n                    final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                    triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n                }\n            } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {\n                handlePackagesChanged(null /* check all admins */, userHandle);\n            } else if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n            } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {\n                if (intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                } else {\n                    handleNewPackageInstalled(intent.getData().getSchemeSpecificPart(), userHandle);\n                }\n            } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)\n                    && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                removeCredentialManagementApp(intent.getData().getSchemeSpecificPart());\n            } else if (Intent.ACTION_MANAGED_PROFILE_ADDED.equals(action)) {\n                clearWipeProfileNotification();\n            } else if (Intent.ACTION_DATE_CHANGED.equals(action)\n                    || Intent.ACTION_TIME_CHANGED.equals(action)) {\n                // Update freeze period record when clock naturally progresses to the next day\n                // (ACTION_DATE_CHANGED), or when manual clock adjustment is made\n                // (ACTION_TIME_CHANGED)\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                }\n            } else if (ACTION_PROFILE_OFF_DEADLINE.equals(action)) {\n                Slogf.i(LOG_TAG, \"Profile off deadline alarm was triggered\");\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                } else {\n                    Slogf.wtf(LOG_TAG, \"Got deadline alarm for nonexistent profile\");\n                }\n            } else if (ACTION_TURN_PROFILE_ON_NOTIFICATION.equals(action)) {\n                Slogf.i(LOG_TAG, \"requesting to turn on the profile: \" + userHandle);\n                mUserManager.requestQuietModeEnabled(false, UserHandle.of(userHandle));\n            } else if (ACTION_MANAGED_PROFILE_UNAVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ false);\n                updatePersonalAppsSuspension(userHandle);\n            } else if (ACTION_MANAGED_PROFILE_AVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ true);\n                final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n            } else if (LOGIN_ACCOUNTS_CHANGED_ACTION.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n        }\n\n        private void sendDeviceOwnerUserCommand(String action, int userHandle) {\n            synchronized (getLockObject()) {\n                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null) {\n                    Bundle extras = new Bundle();\n                    extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n                    sendAdminCommandLocked(deviceOwner, action, extras, /* result */ null,\n                            /* inForeground */ true);\n                }\n            }\n        }\n    };\n\n    protected static class RestrictionsListener implements UserRestrictionsListener {\n        private final Context mContext;\n        private final UserManagerInternal mUserManagerInternal;\n        private final DevicePolicyManagerService mDpms;\n\n        public RestrictionsListener(\n                Context context,\n                UserManagerInternal userManagerInternal,\n                DevicePolicyManagerService dpms) {\n            mContext = context;\n            mUserManagerInternal = userManagerInternal;\n            mDpms = dpms;\n        }\n\n        @Override\n        public void onUserRestrictionsChanged(int userId, Bundle newRestrictions,\n                Bundle prevRestrictions) {\n            resetCrossProfileIntentFiltersIfNeeded(userId, newRestrictions, prevRestrictions);\n            resetUserVpnIfNeeded(userId, newRestrictions, prevRestrictions);\n        }\n\n        private void resetUserVpnIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            final boolean newlyEnforced =\n                    !prevRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN)\n                    && newRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN);\n            if (newlyEnforced) {\n                mDpms.clearUserConfiguredVpns(userId);\n            }\n        }\n\n        private void resetCrossProfileIntentFiltersIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            if (UserRestrictionsUtils.restrictionsChanged(prevRestrictions, newRestrictions,\n                    UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE)) {\n                final int parentId = mUserManagerInternal.getProfileParentId(userId);\n                if (parentId == userId) {\n                    return;\n                }\n\n                // Always reset filters on the parent user, which handles cross profile intent\n                // filters between the parent and its profiles.\n                Slogf.i(LOG_TAG, \"Resetting cross-profile intent filters on restriction \"\n                        + \"change\");\n                mDpms.resetDefaultCrossProfileIntentFilters(parentId);\n                mContext.sendBroadcastAsUser(\n                        new Intent(DevicePolicyManager.ACTION_DATA_SHARING_RESTRICTION_APPLIED),\n                        UserHandle.of(userId));\n            }\n        }\n    }\n\n    private void clearUserConfiguredVpns(int userId) {\n        final String adminConfiguredVpnPkg;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (owner == null) {\n                Slogf.wtf(LOG_TAG, \"Admin not found\");\n                return;\n            }\n            adminConfiguredVpnPkg = owner.mAlwaysOnVpnPackage;\n        }\n\n        // Clear always-on configuration if it wasn't set by the admin.\n        if (adminConfiguredVpnPkg == null) {\n            mInjector.getVpnManager().setAlwaysOnVpnPackageForUser(userId, null, false, null);\n        }\n\n        // Clear app authorizations to establish VPNs. When DISALLOW_CONFIG_VPN is enforced apps\n        // won't be able to get those authorizations unless it is configured by an admin.\n        final List<AppOpsManager.PackageOps> allVpnOps = mInjector.getAppOpsManager()\n                .getPackagesForOps(new int[] {AppOpsManager.OP_ACTIVATE_VPN});\n        if (allVpnOps == null) {\n            return;\n        }\n        for (AppOpsManager.PackageOps pkgOps : allVpnOps) {\n            if (UserHandle.getUserId(pkgOps.getUid()) != userId\n                    || pkgOps.getPackageName().equals(adminConfiguredVpnPkg)) {\n                continue;\n            }\n            if (pkgOps.getOps().size() != 1) {\n                Slogf.wtf(LOG_TAG, \"Unexpected number of ops returned\");\n                continue;\n            }\n            final @Mode int mode = pkgOps.getOps().get(0).getMode();\n            if (mode == MODE_ALLOWED) {\n                Slogf.i(LOG_TAG, String.format(\"Revoking VPN authorization for package %s uid %d\",\n                        pkgOps.getPackageName(), pkgOps.getUid()));\n                mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN, pkgOps.getUid(),\n                        pkgOps.getPackageName(), MODE_DEFAULT);\n            }\n        }\n    }\n\n    private final class UserLifecycleListener implements UserManagerInternal.UserLifecycleListener {\n\n        @Override\n        public void onUserCreated(UserInfo user, Object token) {\n            mHandler.post(() -> handleNewUserCreated(user, token));\n        }\n    }\n\n    private void handlePackagesChanged(@Nullable String packageName, int userHandle) {\n        boolean removedAdmin = false;\n        String removedAdminPackage = null;\n        if (VERBOSE_LOG) {\n            Slogf.d(LOG_TAG, \"Handling package changes package \" + packageName\n                    + \" for user \" + userHandle);\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        synchronized (getLockObject()) {\n            for (int i = policy.mAdminList.size() - 1; i >= 0; i--) {\n                ActiveAdmin aa = policy.mAdminList.get(i);\n                try {\n                    // If we're checking all packages or if the specific one we're checking matches,\n                    // then check if the package and receiver still exist.\n                    final String adminPackage = aa.info.getPackageName();\n                    if (packageName == null || packageName.equals(adminPackage)) {\n                        if (mIPackageManager.getPackageInfo(adminPackage, 0, userHandle) == null\n                                || mIPackageManager.getReceiverInfo(aa.info.getComponent(),\n                                PackageManager.MATCH_DIRECT_BOOT_AWARE\n                                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n                                userHandle) == null) {\n                            Slogf.e(LOG_TAG, String.format(\n                                    \"Admin package %s not found for user %d, removing active admin\",\n                                    packageName, userHandle));\n                            removedAdmin = true;\n                            removedAdminPackage = adminPackage;\n                            policy.mAdminList.remove(i);\n                            policy.mAdminMap.remove(aa.info.getComponent());\n                            pushActiveAdminPackagesLocked(userHandle);\n                            pushMeteredDisabledPackages(userHandle);\n                        }\n                    }\n                } catch (RemoteException re) {\n                    // Shouldn't happen.\n                    Slogf.wtf(LOG_TAG, \"Error handling package changes\", re);\n                }\n            }\n            if (removedAdmin) {\n                policy.validatePasswordOwner();\n            }\n\n            boolean removedDelegate = false;\n\n            // Check if a delegate was removed.\n            for (int i = policy.mDelegationMap.size() - 1; i >= 0; i--) {\n                final String delegatePackage = policy.mDelegationMap.keyAt(i);\n                if (isRemovedPackage(packageName, delegatePackage, userHandle)) {\n                    policy.mDelegationMap.removeAt(i);\n                    removedDelegate = true;\n                }\n            }\n\n            // If it's an owner package, we may need to refresh the bound connection.\n            final ComponentName owner = getOwnerComponent(userHandle);\n            if ((packageName != null) && (owner != null)\n                    && (owner.getPackageName().equals(packageName))) {\n                startOwnerService(userHandle, \"package-broadcast\");\n            }\n            if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                mDevicePolicyEngine.handlePackageChanged(\n                        packageName, userHandle, removedAdminPackage);\n            }\n            // Persist updates if the removed package was an admin or delegate.\n            if (removedAdmin || removedDelegate) {\n                saveSettingsLocked(policy.mUserId);\n            }\n        }\n        if (removedAdmin) {\n            // The removed admin might have disabled camera, so update user restrictions.\n            pushUserRestrictions(userHandle);\n        }\n    }\n\n    private void removeCredentialManagementApp(String packageName) {\n        mBackgroundHandler.post(() -> {\n            try (KeyChainConnection connection = mInjector.keyChainBind()) {\n                IKeyChainService service = connection.getService();\n                if (service.hasCredentialManagementApp()\n                        && packageName.equals(service.getCredentialManagementAppPackageName())) {\n                    service.removeCredentialManagementApp();\n                }\n            } catch (RemoteException | InterruptedException | IllegalStateException\n                    | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Unable to remove the credential management app\", e);\n            }\n        });\n    }\n\n    private boolean isRemovedPackage(String changedPackage, String targetPackage, int userHandle) {\n        try {\n            return targetPackage != null\n                    && (changedPackage == null || changedPackage.equals(targetPackage))\n                    && mIPackageManager.getPackageInfo(targetPackage, 0, userHandle) == null;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error checking isRemovedPackage\", e);\n        }\n\n        return false;\n    }\n\n    private void handleNewPackageInstalled(String packageName, int userHandle) {\n        // If personal apps were suspended by the admin, suspend the newly installed one.\n        if (!getUserData(userHandle).mAppsSuspended) {\n            return;\n        }\n        final String[] packagesToSuspend = { packageName };\n        // Check if package is considered not suspendable?\n        if (mInjector.getPackageManager(userHandle)\n                .getUnsuspendablePackages(packagesToSuspend).length != 0) {\n            Slogf.i(LOG_TAG, \"Newly installed package is unsuspendable: \" + packageName);\n            return;\n        }\n        mInjector.getPackageManagerInternal()\n                .setPackagesSuspendedByAdmin(userHandle, packagesToSuspend, true /*suspend*/);\n    }\n\n    public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(mIsAutomotive || isAdb(callerIdentity), \"can only set \"\n                + \"DevicePolicySafetyChecker on automotive builds or from ADB (but caller is %s)\",\n                callerIdentity);\n        setDevicePolicySafetyCheckerUnchecked(safetyChecker);\n    }\n\n    /**\n     * Used by {@code setDevicePolicySafetyChecker()} above and {@link OneTimeSafetyChecker}.\n     */\n    void setDevicePolicySafetyCheckerUnchecked(DevicePolicySafetyChecker safetyChecker) {\n        Slogf.i(LOG_TAG, \"Setting DevicePolicySafetyChecker as %s\", safetyChecker);\n        mSafetyChecker = safetyChecker;\n        mInjector.setDevicePolicySafetyChecker(safetyChecker);\n    }\n\n    /**\n     * Used by {@link OneTimeSafetyChecker} only.\n     */\n    DevicePolicySafetyChecker getDevicePolicySafetyChecker() {\n        return mSafetyChecker;\n    }\n\n    /**\n     * Checks if it's safe to execute the given {@code operation}.\n     *\n     * @throws UnsafeStateException if it's not safe to execute the operation.\n     */\n    private void checkCanExecuteOrThrowUnsafe(@DevicePolicyOperation int operation) {\n        int reason = getUnsafeOperationReason(operation);\n        if (reason == OPERATION_SAFETY_REASON_NONE) return;\n\n        if (mSafetyChecker == null) {\n            // Happens on CTS after it's set just once (by OneTimeSafetyChecker)\n            throw new UnsafeStateException(operation, reason);\n        }\n        // Let mSafetyChecker customize it (for example, by explaining how to retry)\n        throw mSafetyChecker.newUnsafeStateException(operation, reason);\n    }\n\n    /**\n     * Returns whether it's safe to execute the given {@code operation}, and why.\n     */\n    @OperationSafetyReason\n    int getUnsafeOperationReason(@DevicePolicyOperation int operation) {\n        return mSafetyChecker == null ? OPERATION_SAFETY_REASON_NONE\n                : mSafetyChecker.getUnsafeOperationReason(operation);\n    }\n\n    @Override\n    public void setNextOperationSafety(@DevicePolicyOperation int operation,\n            @OperationSafetyReason int reason) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Slogf.i(LOG_TAG, \"setNextOperationSafety(%s, %s)\",\n                DevicePolicyManager.operationToString(operation),\n                DevicePolicyManager.operationSafetyReasonToString(reason));\n        mSafetyChecker = new OneTimeSafetyChecker(this, operation, reason);\n    }\n\n    @Override\n    public boolean isSafeOperation(@OperationSafetyReason int reason) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"checking isSafeOperation(%s) using mSafetyChecker %s\",\n                    DevicePolicyManager.operationSafetyReasonToString(reason), mSafetyChecker);\n        }\n        return mSafetyChecker == null ? true : mSafetyChecker.isSafeOperation(reason);\n    }\n\n    // Used by DevicePolicyManagerServiceShellCommand\n    List<OwnerShellData> listAllOwners() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            SparseArray<DevicePolicyData> userData;\n\n            // Gets the owners of \"full users\" first (device owner and profile owners)\n            List<OwnerShellData> owners = mOwners.listAllOwners();\n            synchronized (getLockObject()) {\n                for (int i = 0; i < owners.size(); i++) {\n                    OwnerShellData owner = owners.get(i);\n                    owner.isAffiliated = isUserAffiliatedWithDeviceLocked(owner.userId);\n                }\n                userData = mUserData;\n            }\n\n            // Then the owners of profile users (managed profiles)\n            for (int i = 0; i < userData.size(); i++) {\n                DevicePolicyData policyData = mUserData.valueAt(i);\n                int userId = userData.keyAt(i);\n                int parentUserId = mUserManagerInternal.getProfileParentId(userId);\n                boolean isProfile = parentUserId != userId;\n                if (!isProfile) continue;\n                for (int j = 0; j < policyData.mAdminList.size(); j++) {\n                    ActiveAdmin admin = policyData.mAdminList.get(j);\n                    OwnerShellData owner = OwnerShellData.forManagedProfileOwner(userId,\n                            parentUserId, admin.info.getComponent());\n                    owners.add(owner);\n                }\n            }\n\n            return owners;\n        });\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n\n        public final Context mContext;\n\n        @Nullable private DevicePolicySafetyChecker mSafetyChecker;\n\n        Injector(Context context) {\n            mContext = context;\n        }\n\n        public boolean hasFeature() {\n            return getPackageManager().hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN);\n        }\n\n        Context createContextAsUser(UserHandle user) throws PackageManager.NameNotFoundException {\n            final String packageName = mContext.getPackageName();\n            return mContext.createPackageContextAsUser(packageName, 0, user);\n        }\n\n        Resources getResources() {\n            return mContext.getResources();\n        }\n\n        UserManager getUserManager() {\n            return UserManager.get(mContext);\n        }\n\n        UserManagerInternal getUserManagerInternal() {\n            return LocalServices.getService(UserManagerInternal.class);\n        }\n\n        PackageManagerInternal getPackageManagerInternal() {\n            return LocalServices.getService(PackageManagerInternal.class);\n        }\n\n        PackageManagerLocal getPackageManagerLocal() {\n            return LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n\n        ActivityTaskManagerInternal getActivityTaskManagerInternal() {\n            return LocalServices.getService(ActivityTaskManagerInternal.class);\n        }\n\n        @NonNull PermissionControllerManager getPermissionControllerManager(\n                @NonNull UserHandle user) {\n            if (user.equals(mContext.getUser())) {\n                return mContext.getSystemService(PermissionControllerManager.class);\n            } else {\n                try {\n                    return mContext.createPackageContextAsUser(mContext.getPackageName(), 0,\n                            user).getSystemService(PermissionControllerManager.class);\n                } catch (NameNotFoundException notPossible) {\n                    // not possible\n                    throw new IllegalStateException(notPossible);\n                }\n            }\n        }\n\n        UsageStatsManagerInternal getUsageStatsManagerInternal() {\n            return LocalServices.getService(UsageStatsManagerInternal.class);\n        }\n\n        NetworkPolicyManagerInternal getNetworkPolicyManagerInternal() {\n            return LocalServices.getService(NetworkPolicyManagerInternal.class);\n        }\n\n        NotificationManager getNotificationManager() {\n            return mContext.getSystemService(NotificationManager.class);\n        }\n\n        IIpConnectivityMetrics getIIpConnectivityMetrics() {\n            return (IIpConnectivityMetrics) IIpConnectivityMetrics.Stub.asInterface(\n                ServiceManager.getService(IpConnectivityLog.SERVICE_NAME));\n        }\n\n        PackageManager getPackageManager() {\n            return mContext.getPackageManager();\n        }\n\n        PackageManager getPackageManager(int userId) {\n            try {\n                return createContextAsUser(UserHandle.of(userId)).getPackageManager();\n            } catch (NameNotFoundException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        PowerManagerInternal getPowerManagerInternal() {\n            return LocalServices.getService(PowerManagerInternal.class);\n        }\n\n        TelephonyManager getTelephonyManager() {\n            return mContext.getSystemService(TelephonyManager.class);\n        }\n\n        RoleManager getRoleManager() {\n            return mContext.getSystemService(RoleManager.class);\n        }\n\n        TrustManager getTrustManager() {\n            return (TrustManager) mContext.getSystemService(Context.TRUST_SERVICE);\n        }\n\n        AlarmManager getAlarmManager() {\n            return mContext.getSystemService(AlarmManager.class);\n        }\n\n        AlarmManagerInternal getAlarmManagerInternal() {\n            return LocalServices.getService(AlarmManagerInternal.class);\n        }\n\n        ConnectivityManager getConnectivityManager() {\n            return mContext.getSystemService(ConnectivityManager.class);\n        }\n\n        VpnManager getVpnManager() {\n            return mContext.getSystemService(VpnManager.class);\n        }\n\n        LocationManager getLocationManager() {\n            return mContext.getSystemService(LocationManager.class);\n        }\n\n        IWindowManager getIWindowManager() {\n            return IWindowManager.Stub\n                    .asInterface(ServiceManager.getService(Context.WINDOW_SERVICE));\n        }\n\n        IActivityManager getIActivityManager() {\n            return ActivityManager.getService();\n        }\n\n        IActivityTaskManager getIActivityTaskManager() {\n            return ActivityTaskManager.getService();\n        }\n\n        ActivityManagerInternal getActivityManagerInternal() {\n            return LocalServices.getService(ActivityManagerInternal.class);\n        }\n\n        IPackageManager getIPackageManager() {\n            return AppGlobals.getPackageManager();\n        }\n\n        IPermissionManager getIPermissionManager() {\n            return AppGlobals.getPermissionManager();\n        }\n\n        IBackupManager getIBackupManager() {\n            return IBackupManager.Stub.asInterface(\n                    ServiceManager.getService(Context.BACKUP_SERVICE));\n        }\n\n        IAudioService getIAudioService() {\n            return IAudioService.Stub.asInterface(ServiceManager.getService(Context.AUDIO_SERVICE));\n        }\n\n        PersistentDataBlockManagerInternal getPersistentDataBlockManagerInternal() {\n            return LocalServices.getService(PersistentDataBlockManagerInternal.class);\n        }\n\n        AppOpsManager getAppOpsManager() {\n            return mContext.getSystemService(AppOpsManager.class);\n        }\n\n        LockSettingsInternal getLockSettingsInternal() {\n            return LocalServices.getService(LockSettingsInternal.class);\n        }\n\n        CrossProfileApps getCrossProfileApps(@UserIdInt int userId) {\n            return mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                    .getSystemService(CrossProfileApps.class);\n        }\n\n        boolean hasUserSetupCompleted(DevicePolicyData userData) {\n            return userData.mUserSetupComplete;\n        }\n\n        boolean isBuildDebuggable() {\n            return Build.IS_DEBUGGABLE;\n        }\n\n        LockPatternUtils newLockPatternUtils() {\n            return new LockPatternUtils(mContext);\n        }\n\n        EnterpriseSpecificIdCalculator newEnterpriseSpecificIdCalculator() {\n            return new EnterpriseSpecificIdCalculator(mContext);\n        }\n\n        boolean storageManagerIsFileBasedEncryptionEnabled() {\n            return StorageManager.isFileEncrypted();\n        }\n\n        Looper getMyLooper() {\n            return Looper.myLooper();\n        }\n\n        WifiManager getWifiManager() {\n            return mContext.getSystemService(WifiManager.class);\n        }\n\n        UsbManager getUsbManager() {\n            return mContext.getSystemService(UsbManager.class);\n        }\n\n        @SuppressWarnings(\"ResultOfClearIdentityCallNotStoredInVariable\")\n        long binderClearCallingIdentity() {\n            return Binder.clearCallingIdentity();\n        }\n\n        void binderRestoreCallingIdentity(long token) {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n\n        int binderGetCallingPid() {\n            return Binder.getCallingPid();\n        }\n\n        UserHandle binderGetCallingUserHandle() {\n            return Binder.getCallingUserHandle();\n        }\n\n        boolean binderIsCallingUidMyUid() {\n            return getCallingUid() == Process.myUid();\n        }\n\n        void binderWithCleanCallingIdentity(@NonNull ThrowingRunnable action) {\n             Binder.withCleanCallingIdentity(action);\n        }\n\n        final <T> T binderWithCleanCallingIdentity(@NonNull ThrowingSupplier<T> action) {\n            return Binder.withCleanCallingIdentity(action);\n        }\n\n        final int userHandleGetCallingUserId() {\n            return UserHandle.getUserId(binderGetCallingUid());\n        }\n\n        void powerManagerGoToSleep(long time, int reason, int flags) {\n            mContext.getSystemService(PowerManager.class).goToSleep(time, reason, flags);\n        }\n\n        void powerManagerReboot(String reason) {\n            mContext.getSystemService(PowerManager.class).reboot(reason);\n        }\n\n        boolean recoverySystemRebootWipeUserData(boolean shutdown, String reason, boolean force,\n                boolean wipeEuicc, boolean wipeExtRequested, boolean wipeResetProtectionData)\n                        throws IOException {\n            return FactoryResetter.newBuilder(mContext).setSafetyChecker(mSafetyChecker)\n                    .setReason(reason).setShutdown(shutdown).setForce(force).setWipeEuicc(wipeEuicc)\n                    .setWipeAdoptableStorage(wipeExtRequested)\n                    .setWipeFactoryResetProtection(wipeResetProtectionData)\n                    .build().factoryReset();\n        }\n\n        boolean systemPropertiesGetBoolean(String key, boolean def) {\n            return SystemProperties.getBoolean(key, def);\n        }\n\n        long systemPropertiesGetLong(String key, long def) {\n            return SystemProperties.getLong(key, def);\n        }\n\n        String systemPropertiesGet(String key, String def) {\n            return SystemProperties.get(key, def);\n        }\n\n        String systemPropertiesGet(String key) {\n            return SystemProperties.get(key);\n        }\n\n        void systemPropertiesSet(String key, String value) {\n            SystemProperties.set(key, value);\n        }\n\n        boolean userManagerIsHeadlessSystemUserMode() {\n            return UserManager.isHeadlessSystemUserMode();\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetActivityAsUser(Context context, int requestCode,\n                @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n            return PendingIntent.getActivityAsUser(\n                    context, requestCode, intent, flags, options, user);\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetBroadcast(\n                Context context, int requestCode, Intent intent, int flags) {\n            return PendingIntent.getBroadcast(context, requestCode, intent, flags);\n        }\n\n        void registerContentObserver(Uri uri, boolean notifyForDescendents,\n                ContentObserver observer, int userHandle) {\n            mContext.getContentResolver().registerContentObserver(uri, notifyForDescendents,\n                    observer, userHandle);\n        }\n\n        int settingsSecureGetIntForUser(String name, int def, int userHandle) {\n            return Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                    name, def, userHandle);\n        }\n\n        String settingsSecureGetStringForUser(String name, int userHandle) {\n            return Settings.Secure.getStringForUser(mContext.getContentResolver(), name,\n                    userHandle);\n        }\n\n        void settingsSecurePutIntForUser(String name, int value, int userHandle) {\n            Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutStringForUser(String name, String value, int userHandle) {\n            Settings.Secure.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsGlobalPutStringForUser(String name, String value, int userHandle) {\n            Settings.Global.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutInt(String name, int value) {\n            Settings.Secure.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        int settingsGlobalGetInt(String name, int def) {\n            return Settings.Global.getInt(mContext.getContentResolver(), name, def);\n        }\n\n        @Nullable\n        String settingsGlobalGetString(String name) {\n            return Settings.Global.getString(mContext.getContentResolver(), name);\n        }\n\n        void settingsGlobalPutInt(String name, int value) {\n            Settings.Global.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSecurePutString(String name, String value) {\n            Settings.Secure.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsGlobalPutString(String name, String value) {\n            Settings.Global.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSystemPutStringForUser(String name, String value, int userId) {\n          Settings.System.putStringForUser(\n              mContext.getContentResolver(), name, value, userId);\n        }\n\n        void securityLogSetLoggingEnabledProperty(boolean enabled) {\n            SecurityLog.setLoggingEnabledProperty(enabled);\n        }\n\n        boolean securityLogGetLoggingEnabledProperty() {\n            return SecurityLog.getLoggingEnabledProperty();\n        }\n\n        boolean securityLogIsLoggingEnabled() {\n            return SecurityLog.isLoggingEnabled();\n        }\n\n        KeyChainConnection keyChainBind() throws InterruptedException {\n            return KeyChain.bind(mContext);\n        }\n\n        KeyChainConnection keyChainBindAsUser(UserHandle user) throws InterruptedException {\n            return KeyChain.bindAsUser(mContext, user);\n        }\n\n        void postOnSystemServerInitThreadPool(Runnable runnable) {\n            SystemServerInitThreadPool.submit(runnable, LOG_TAG);\n        }\n\n        public TransferOwnershipMetadataManager newTransferOwnershipMetadataManager() {\n            return new TransferOwnershipMetadataManager();\n        }\n\n        public void runCryptoSelfTest() {\n            CryptoTestHelper.runAndLogSelfTest();\n        }\n\n        public String[] getPersonalAppsForSuspension(@UserIdInt int userId) {\n            return PersonalAppsSuspensionHelper.forUser(mContext, userId)\n                    .getPersonalAppsForSuspension();\n        }\n\n        public long systemCurrentTimeMillis() {\n            return System.currentTimeMillis();\n        }\n\n        public boolean isChangeEnabled(long changeId, String packageName, int userId) {\n            return CompatChanges.isChangeEnabled(changeId, packageName, UserHandle.of(userId));\n        }\n\n        void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mSafetyChecker = safetyChecker;\n        }\n\n        DeviceManagementResourcesProvider getDeviceManagementResourcesProvider() {\n            return new DeviceManagementResourcesProvider();\n        }\n    }\n\n    /**\n     * Instantiates the service.\n     */\n    public DevicePolicyManagerService(Context context) {\n        this(new Injector(\n                context.createAttributionContext(ATTRIBUTION_TAG)), new PolicyPathProvider() {});\n    }\n\n    @VisibleForTesting\n    DevicePolicyManagerService(Injector injector, PolicyPathProvider pathProvider) {\n        DevicePolicyManager.disableLocalCaches();\n\n        mInjector = injector;\n        mPathProvider = pathProvider;\n        mContext = Objects.requireNonNull(injector.mContext);\n        mHandler = new Handler(Objects.requireNonNull(injector.getMyLooper()));\n\n        mConstantsObserver = new DevicePolicyConstantsObserver(mHandler);\n        mConstantsObserver.register();\n        mConstants = loadConstants();\n\n        mUserManager = Objects.requireNonNull(injector.getUserManager());\n        mUserManagerInternal = Objects.requireNonNull(injector.getUserManagerInternal());\n        mUsageStatsManagerInternal = Objects.requireNonNull(\n                injector.getUsageStatsManagerInternal());\n        mIPackageManager = Objects.requireNonNull(injector.getIPackageManager());\n        mIPermissionManager = Objects.requireNonNull(injector.getIPermissionManager());\n        mTelephonyManager = Objects.requireNonNull(injector.getTelephonyManager());\n        mRoleManager = Objects.requireNonNull(injector.getRoleManager());\n\n        mLocalService = new LocalService();\n        mLockPatternUtils = injector.newLockPatternUtils();\n        mLockSettingsInternal = injector.getLockSettingsInternal();\n        // TODO: why does SecurityLogMonitor need to be created even when mHasFeature == false?\n        mSecurityLogMonitor = new SecurityLogMonitor(this);\n\n        mHasFeature = mInjector.hasFeature();\n        mIsWatch = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_WATCH);\n        mHasTelephonyFeature = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY);\n        mIsAutomotive = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n        mBackgroundHandler = BackgroundThread.getHandler();\n\n        // Needed when mHasFeature == false, because it controls the certificate warning text.\n        mCertificateMonitor = new CertificateMonitor(this, mInjector, mBackgroundHandler);\n\n        mDeviceAdminServiceController = new DeviceAdminServiceController(this, mConstants);\n        mOverlayPackagesProvider = new OverlayPackagesProvider(mContext);\n        mTransferOwnershipMetadataManager = mInjector.newTransferOwnershipMetadataManager();\n        mBugreportCollectionManager = new RemoteBugreportManager(this, mInjector);\n\n        mDeviceManagementResourcesProvider = mInjector.getDeviceManagementResourcesProvider();\n        mDevicePolicyManagementRoleObserver = new DevicePolicyManagementRoleObserver(mContext);\n        mDevicePolicyManagementRoleObserver.register();\n\n        // \"Lite\" interface is available even when the device doesn't have the feature\n        LocalServices.addService(DevicePolicyManagerLiteInternal.class, mLocalService);\n\n        // Policy version upgrade must not depend on either mOwners or mUserData, so they are\n        // initialized only after performing the upgrade.\n        if (mHasFeature) {\n            performPolicyVersionUpgrade();\n        }\n\n        mUserData = new SparseArray<>();\n        mOwners = makeOwners(injector, pathProvider);\n\n        mDevicePolicyEngine = new DevicePolicyEngine(\n                mContext, mDeviceAdminServiceController, getLockObject());\n\n        if (!mHasFeature) {\n            // Skip the rest of the initialization\n            mSetupContentObserver = null;\n            mContactSystemRoleHolders = Collections.emptySet();\n            return;\n        }\n\n        loadOwners();\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_BOOT_COMPLETED);\n        filter.addAction(ACTION_EXPIRED_PASSWORD_NOTIFICATION);\n        filter.addAction(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        filter.addAction(ACTION_PROFILE_OFF_DEADLINE);\n        filter.addAction(Intent.ACTION_USER_ADDED);\n        filter.addAction(Intent.ACTION_USER_REMOVED);\n        filter.addAction(Intent.ACTION_USER_STARTED);\n        filter.addAction(Intent.ACTION_USER_STOPPED);\n        filter.addAction(Intent.ACTION_USER_SWITCHED);\n        filter.addAction(Intent.ACTION_USER_UNLOCKED);\n        filter.addAction(LOGIN_ACCOUNTS_CHANGED_ACTION);\n        filter.addAction(ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        filter.addAction(ACTION_MANAGED_PROFILE_AVAILABLE);\n        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        filter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        filter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        filter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_MANAGED_PROFILE_ADDED);\n        filter.addAction(Intent.ACTION_TIME_CHANGED);\n        filter.addAction(Intent.ACTION_DATE_CHANGED);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n\n        LocalServices.addService(DevicePolicyManagerInternal.class, mLocalService);\n\n        mSetupContentObserver = new SetupContentObserver(mHandler);\n\n        mUserManagerInternal.addUserRestrictionsListener(\n                new RestrictionsListener(mContext, mUserManagerInternal, this));\n        mUserManagerInternal.addUserLifecycleListener(new UserLifecycleListener());\n\n        mDeviceManagementResourcesProvider.load();\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.load();\n        }\n\n        mContactSystemRoleHolders = fetchOemSystemHolders(/* roleResIds...= */\n                com.android.internal.R.string.config_defaultSms,\n                com.android.internal.R.string.config_defaultDialer,\n                com.android.internal.R.string.config_systemContacts\n        );\n\n        // The binder caches are not enabled until the first invalidation.\n        invalidateBinderCaches();\n    }\n\n    /**\n     * Fetch the OEM System Holders for the supplied roleNames\n     *\n     * @param roleResIds the list of resource ids whose role holders are needed\n     * @return the set of packageNames that handle the requested roles\n     */\n    private @NonNull Set<String> fetchOemSystemHolders(int... roleResIds) {\n        Set<String> packageNames = new ArraySet<>();\n\n        for (int roleResId : roleResIds) {\n            String packageName = getDefaultRoleHolderPackageName(roleResId);\n            if (packageName != null) {\n                packageNames.add(packageName);\n            }\n        }\n\n        return Collections.unmodifiableSet(packageNames);\n    }\n\n\n    private @Nullable String getDefaultRoleHolderPackageName(int resId) {\n        String packageNameAndSignature = mContext.getString(resId);\n\n        if (TextUtils.isEmpty(packageNameAndSignature)) {\n            return null;\n        }\n\n        if (packageNameAndSignature.contains(\":\")) {\n            return packageNameAndSignature.split(\":\")[0];\n        }\n\n        return packageNameAndSignature;\n    }\n\n    private void suspendAppsForQuietProfiles(boolean toSuspend) {\n        PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        List<UserInfo> users = mUserManagerInternal.getUsers(true /* excludeDying */);\n        for (UserInfo user : users) {\n            if (user.isManagedProfile() && user.isQuietModeEnabled()) {\n                pmi.setPackagesSuspendedForQuietMode(user.id, toSuspend);\n            }\n        }\n    }\n\n    private Owners makeOwners(Injector injector, PolicyPathProvider pathProvider) {\n        return new Owners(\n                injector.getUserManager(), injector.getUserManagerInternal(),\n                injector.getPackageManagerInternal(),\n                injector.getActivityTaskManagerInternal(),\n                injector.getActivityManagerInternal(), mStateCache, pathProvider);\n    }\n\n    /**\n     * Invalidate the binder API caches. The invalidation itself does not require any\n     * locking, but this specific call should be protected by getLockObject() to ensure\n     * that the invalidation is synchronous with cached queries, for those queries that\n     * are served under getLockObject().\n     */\n    static void invalidateBinderCaches() {\n        DevicePolicyManager.invalidateBinderCaches();\n    }\n\n    /**\n     * Creates and loads the policy data from xml.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    @NonNull\n    DevicePolicyData getUserData(int userHandle) {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy == null) {\n                policy = new DevicePolicyData(userHandle);\n                mUserData.append(userHandle, policy);\n                loadSettingsLocked(policy, userHandle);\n                if (userHandle == UserHandle.USER_SYSTEM) {\n                    mStateCache.setDeviceProvisioned(policy.mUserSetupComplete);\n                }\n            }\n            return policy;\n        }\n    }\n\n    /**\n     * Creates and loads the policy data from xml for data that is shared between\n     * various profiles of a user. In contrast to {@link #getUserData(int)}\n     * it allows access to data of users other than the calling user.\n     *\n     * This function should only be used for shared data, e.g. everything regarding\n     * passwords and should be removed once multiple screen locks are present.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    DevicePolicyData getUserDataUnchecked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> getUserData(userHandle));\n    }\n\n    void removeUserData(int userHandle) {\n        final boolean isOrgOwned;\n        synchronized (getLockObject()) {\n            if (userHandle == UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Tried to remove device policy file for user 0! Ignoring.\");\n                return;\n            }\n            updatePasswordQualityCacheForUserGroup(userHandle);\n            mPolicyCache.onUserRemoved(userHandle);\n\n            if (isManagedProfile(userHandle)) {\n                clearManagedProfileApnUnchecked();\n            }\n            isOrgOwned = mOwners.isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n\n            // Clear any restrictions set by the a profile owner and the parent admin.\n            final ActiveAdmin admin = getProfileOwnerLocked(userHandle);\n            if (admin != null) {\n                admin.userRestrictions = null;\n                final ActiveAdmin parentAdmin = admin.getParentActiveAdmin();\n                if (parentAdmin != null) {\n                    parentAdmin.userRestrictions = null;\n                }\n                pushUserRestrictions(userHandle);\n            }\n            mOwners.removeProfileOwner(userHandle);\n            mOwners.writeProfileOwner(userHandle);\n            pushScreenCapturePolicy(userHandle);\n\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy != null) {\n                mUserData.remove(userHandle);\n            }\n\n            File policyFile =\n                    new File(mPathProvider.getUserSystemDirectory(userHandle), DEVICE_POLICIES_XML);\n            policyFile.delete();\n            Slogf.i(LOG_TAG, \"Removed device policy file \" + policyFile.getAbsolutePath());\n        }\n        if (isOrgOwned) {\n            final UserInfo primaryUser = mUserManager.getPrimaryUser();\n            if (primaryUser != null) {\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(primaryUser.id);\n            } else {\n                Slogf.wtf(LOG_TAG, \"Was unable to get primary user.\");\n            }\n        }\n    }\n\n    /**\n     * Load information about device and profile owners of the device, populating mOwners and\n     * pushing owner info to other system services. This is called at a fairly early stage of\n     * system server initialiation (via DevicePolicyManagerService's ctor), so care should to\n     * be taken to not interact with system services that are initialiated after DPMS.\n     * onLockSettingsReady() is a safer place to do initialization work not critical during\n     * the first boot stage.\n     * Note this only loads the list of owners, and not their actual policy (DevicePolicyData).\n     * The policy is normally loaded lazily when it's first accessed. In several occasions\n     * the list of owners is necessary for providing callers with aggregated policies across\n     * multiple owners, hence the owner list is loaded as part of DPMS's construction here.\n     */\n    void loadOwners() {\n        synchronized (getLockObject()) {\n            mOwners.load();\n            setDeviceOwnershipSystemPropertyLocked();\n            if (mOwners.hasDeviceOwner()) {\n                setGlobalSettingDeviceOwnerType(\n                        mOwners.getDeviceOwnerType(mOwners.getDeviceOwnerPackageName()));\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity() {\n        return getCallerIdentity(null, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity(@Nullable String callerPackage) {\n        return getCallerIdentity(null, callerPackage);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * The component name should be an active admin for the calling user.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent) {\n        return getCallerIdentity(adminComponent, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * If {@code adminComponent} is provided, it's validated against the list of known\n     * active admins and caller uid. If {@code callerPackage} is provided, it's validated\n     * against the caller uid. If a valid {@code adminComponent} is provided but not\n     * {@code callerPackage}, the package name of the {@code adminComponent} is used instead.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent,\n            @Nullable String callerPackage) {\n        final int callerUid = mInjector.binderGetCallingUid();\n\n        if (callerPackage != null) {\n            if (!isCallingFromPackage(callerPackage, callerUid)) {\n                throw new SecurityException(\n                        String.format(\"Caller with uid %d is not %s\", callerUid, callerPackage));\n            }\n        }\n\n        if (adminComponent != null) {\n            final DevicePolicyData policy = getUserData(UserHandle.getUserId(callerUid));\n            ActiveAdmin admin = policy.mAdminMap.get(adminComponent);\n\n            // Throwing combined exception message for both the cases here, because from different\n            // security exceptions it could be deduced if particular package is admin package.\n            if (admin == null || admin.getUid() != callerUid) {\n                throw new SecurityException(String.format(\n                        \"Admin %s does not exist or is not owned by uid %d\", adminComponent,\n                        callerUid));\n            }\n            if (callerPackage != null) {\n                Preconditions.checkArgument(callerPackage.equals(adminComponent.getPackageName()));\n            } else {\n                callerPackage = adminComponent.getPackageName();\n            }\n        }\n\n        return new CallerIdentity(callerUid, callerPackage, adminComponent);\n    }\n\n    /**\n     * Checks if the device is in COMP mode, and if so migrates it to managed profile on a\n     * corporate owned device.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void migrateToProfileOnOrganizationOwnedDeviceIfCompLocked() {\n        if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Checking whether we need to migrate COMP \");\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping migration.\");\n            return;\n        }\n\n        final List<UserInfo> profiles = mUserManager.getProfiles(doUserId);\n        if (profiles.size() != 2) {\n            if (profiles.size() == 1) {\n                if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Profile not found, skipping migration.\");\n            } else {\n                Slogf.wtf(LOG_TAG, \"Found \" + profiles.size() + \" profiles, skipping migration\");\n            }\n            return;\n        }\n\n        final int poUserId = getManagedUserId(doUserId);\n        if (poUserId < 0) {\n            Slogf.wtf(LOG_TAG, \"Found DO and a profile, but it is not managed, skipping migration\");\n            return;\n        }\n\n        final ActiveAdmin doAdmin = getDeviceOwnerAdminLocked();\n        final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(poUserId);\n        if (doAdmin == null || poAdmin == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get either PO or DO admin, aborting migration.\");\n            return;\n        }\n\n        final ComponentName doAdminComponent = mOwners.getDeviceOwnerComponent();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(poUserId);\n        if (doAdminComponent == null || poAdminComponent == null) {\n            Slogf.wtf(LOG_TAG, \"Cannot find PO or DO component name, aborting migration.\");\n            return;\n        }\n        if (!doAdminComponent.getPackageName().equals(poAdminComponent.getPackageName())) {\n            Slogf.e(LOG_TAG, \"DO and PO are different packages, aborting migration.\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Migrating COMP to PO on a corp owned device; primary user: %d; \"\n                + \"profile: %d\", doUserId, poUserId);\n\n        Slogf.i(LOG_TAG, \"Giving the PO additional power...\");\n        setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(poAdminComponent, poUserId, true);\n        Slogf.i(LOG_TAG, \"Migrating DO policies to PO...\");\n        moveDoPoliciesToProfileParentAdminLocked(doAdmin, poAdmin.getParentActiveAdmin());\n        migratePersonalAppSuspensionLocked(doUserId, poUserId, poAdmin);\n        saveSettingsLocked(poUserId);\n        Slogf.i(LOG_TAG, \"Clearing the DO...\");\n        final ComponentName doAdminReceiver = doAdmin.info.getComponent();\n        clearDeviceOwnerLocked(doAdmin, doUserId);\n        Slogf.i(LOG_TAG, \"Removing admin artifacts...\");\n        removeAdminArtifacts(doAdminReceiver, doUserId);\n        Slogf.i(LOG_TAG, \"Uninstalling the DO...\");\n        uninstallOrDisablePackage(doAdminComponent.getPackageName(), doUserId);\n        Slogf.i(LOG_TAG, \"Migration complete.\");\n\n        // Note: KeyChain keys are not removed and will remain accessible for the apps that have\n        // been given grants to use them.\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.COMP_TO_ORG_OWNED_PO_MIGRATED)\n                .setAdmin(poAdminComponent)\n                .write();\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void migratePersonalAppSuspensionLocked(\n            int doUserId, int poUserId, ActiveAdmin poAdmin) {\n        final PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        if (!pmi.isSuspendingAnyPackages(PLATFORM_PACKAGE_NAME, doUserId)) {\n            Slogf.i(LOG_TAG, \"DO is not suspending any apps.\");\n            return;\n        }\n\n        if (getTargetSdk(poAdmin.info.getPackageName(), poUserId) >= Build.VERSION_CODES.R) {\n            Slogf.i(LOG_TAG, \"PO is targeting R+, keeping personal apps suspended.\");\n            getUserData(doUserId).mAppsSuspended = true;\n            poAdmin.mSuspendPersonalApps = true;\n        } else {\n            Slogf.i(LOG_TAG, \"PO isn't targeting R+, unsuspending personal apps.\");\n            pmi.unsuspendForSuspendingPackage(PLATFORM_PACKAGE_NAME, doUserId);\n        }\n    }\n\n    private void uninstallOrDisablePackage(String packageName, @UserIdInt int userId) {\n        final ApplicationInfo appInfo;\n        try {\n            appInfo = mIPackageManager.getApplicationInfo(\n                    packageName, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, userId);\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return;\n        }\n        if (appInfo == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get package info for \" + packageName);\n            return;\n        }\n        if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n            Slogf.i(LOG_TAG, \"Package %s is pre-installed, marking disabled until used\",\n                    packageName);\n            mContext.getPackageManager().setApplicationEnabledSetting(packageName,\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, /* flags= */ 0);\n            return;\n        }\n\n        final IIntentSender.Stub mLocalSender = new IIntentSender.Stub() {\n            @Override\n            public void send(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n                    IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {\n                final int status = intent.getIntExtra(\n                        PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);\n                if (status == PackageInstaller.STATUS_SUCCESS) {\n                    Slogf.i(LOG_TAG, \"Package %s uninstalled for user %d\", packageName, userId);\n                } else {\n                    Slogf.e(LOG_TAG, \"Failed to uninstall %s; status: %d\", packageName, status);\n                }\n            }\n        };\n\n        final PackageInstaller pi = mInjector.getPackageManager(userId).getPackageInstaller();\n        pi.uninstall(packageName, /* flags= */ 0, new IntentSender((IIntentSender) mLocalSender));\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void moveDoPoliciesToProfileParentAdminLocked(\n            ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        // The following policies can be already controlled via parent instance, skip if so.\n        if (parentAdmin.mPasswordPolicy.quality == PASSWORD_QUALITY_UNSPECIFIED) {\n            parentAdmin.mPasswordPolicy = doAdmin.mPasswordPolicy;\n        }\n        if (parentAdmin.passwordHistoryLength == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordHistoryLength = doAdmin.passwordHistoryLength;\n        }\n        if (parentAdmin.passwordExpirationTimeout == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordExpirationTimeout = doAdmin.passwordExpirationTimeout;\n        }\n        if (parentAdmin.maximumFailedPasswordsForWipe\n                == ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n            parentAdmin.maximumFailedPasswordsForWipe = doAdmin.maximumFailedPasswordsForWipe;\n        }\n        if (parentAdmin.maximumTimeToUnlock == ActiveAdmin.DEF_MAXIMUM_TIME_TO_UNLOCK) {\n            parentAdmin.maximumTimeToUnlock = doAdmin.maximumTimeToUnlock;\n        }\n        if (parentAdmin.strongAuthUnlockTimeout\n                == DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            parentAdmin.strongAuthUnlockTimeout = doAdmin.strongAuthUnlockTimeout;\n        }\n        parentAdmin.disabledKeyguardFeatures |=\n                doAdmin.disabledKeyguardFeatures & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n\n        parentAdmin.trustAgentInfos.putAll(doAdmin.trustAgentInfos);\n\n        // The following policies weren't available to PO, but will be available after migration.\n        parentAdmin.disableCamera = doAdmin.disableCamera;\n        parentAdmin.disableScreenCapture = doAdmin.disableScreenCapture;\n        parentAdmin.accountTypesWithManagementDisabled.addAll(\n                doAdmin.accountTypesWithManagementDisabled);\n\n        moveDoUserRestrictionsToCopeParent(doAdmin, parentAdmin);\n\n        // From Android 11, {@link setAutoTimeRequired} is no longer used. The user restriction\n        // {@link UserManager#DISALLOW_CONFIG_DATE_TIME} should be used to enforce auto time\n        // settings instead.\n        if (doAdmin.requireAutoTime) {\n            parentAdmin.ensureUserRestrictions().putBoolean(\n                    UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n        }\n    }\n\n    private void moveDoUserRestrictionsToCopeParent(ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        if (doAdmin.userRestrictions == null) {\n            return;\n        }\n        for (final String restriction : doAdmin.userRestrictions.keySet()) {\n            if (UserRestrictionsUtils.canProfileOwnerOfOrganizationOwnedDeviceChange(restriction)) {\n                parentAdmin.ensureUserRestrictions().putBoolean(\n                        restriction, doAdmin.userRestrictions.getBoolean(restriction));\n            }\n        }\n    }\n\n    /**\n     * If the device is in Device Owner mode, apply the restriction on adding\n     * a managed profile.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void applyProfileRestrictionsIfDeviceOwnerLocked() {\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping application of restriction.\");\n            return;\n        }\n\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            // Based on  CDD : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support,\n            // creation of clone profile is not allowed in case device owner is set.\n            // Enforcing this restriction on setting up of device owner.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_CLONE_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, true,\n                        userHandle);\n            }\n            // Creation of managed profile is restricted in case device owner is set, enforcing this\n            // restriction by setting user level restriction at time of device owner setup.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                        userHandle);\n            }\n        }\n    }\n\n    /** Apply default restrictions that haven't been applied to profile owners yet. */\n    private void maybeSetDefaultProfileOwnerUserRestrictions() {\n        synchronized (getLockObject()) {\n            for (final int userId : mOwners.getProfileOwnerKeys()) {\n                final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n                // The following restrictions used to be applied to managed profiles by different\n                // means (via Settings or by disabling components). Now they are proper user\n                // restrictions so we apply them to managed profile owners. Non-managed secondary\n                // users didn't have those restrictions so we skip them to keep existing behavior.\n                if (profileOwner == null || !mUserManager.isManagedProfile(userId)) {\n                    continue;\n                }\n                maybeSetDefaultRestrictionsForAdminLocked(userId, profileOwner);\n                ensureUnknownSourcesRestrictionForProfileOwnerLocked(\n                        userId, profileOwner, false /* newOwner */);\n            }\n        }\n    }\n\n    /**\n     * Checks whether {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES} should be added to the\n     * set of restrictions for this profile owner.\n     */\n    private void ensureUnknownSourcesRestrictionForProfileOwnerLocked(int userId,\n            ActiveAdmin profileOwner, boolean newOwner) {\n        if (newOwner || mInjector.settingsSecureGetIntForUser(\n                Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId) != 0) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES),\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                profileOwner.info.getComponent(),\n                                profileOwner.getUserHandle().getIdentifier()),\n                        new BooleanPolicyValue(true),\n                        userId);\n            } else {\n                profileOwner.ensureUserRestrictions().putBoolean(\n                        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, true);\n                saveUserRestrictionsLocked(userId);\n            }\n            mInjector.settingsSecurePutIntForUser(\n                    Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId);\n        }\n    }\n\n    /**\n     * Apply default restrictions that haven't been applied to a given admin yet.\n     */\n    private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n        final Set<String> restrictionsToSet =\n            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n        if (restrictionsToSet.isEmpty()) {\n            return; // The same set of default restrictions has been already applied.\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            for (String restriction : restrictionsToSet) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                admin.info.getComponent(),\n                                admin.getUserHandle().getIdentifier()),\n                        new BooleanPolicyValue(true),\n                        userId);\n            }\n            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n                    restrictionsToSet);\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"New user restrictions need to be set by default for user \" + userId);\n\n        if (VERBOSE_LOG) {\n            Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n                    + restrictionsToSet\n                    + \". Restrictions already enabled: \"\n                    + admin.defaultEnabledRestrictionsAlreadySet);\n        }\n        for (final String restriction : restrictionsToSet) {\n            admin.ensureUserRestrictions().putBoolean(restriction, true);\n        }\n        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n        saveUserRestrictionsLocked(userId);\n    }\n\n    private void setDeviceOwnershipSystemPropertyLocked() {\n        final boolean deviceProvisioned =\n                mInjector.settingsGlobalGetInt(Settings.Global.DEVICE_PROVISIONED, 0) != 0;\n        final boolean hasDeviceOwner = mOwners.hasDeviceOwner();\n        final boolean hasOrgOwnedProfile = isOrganizationOwnedDeviceWithManagedProfile();\n        // If the device is not provisioned and there is currently no management, do not set the\n        // read-only system property yet, since device owner / org-owned profile may still be\n        // provisioned.\n        if (!hasDeviceOwner && !hasOrgOwnedProfile && !deviceProvisioned) {\n            return;\n        }\n        final String value = Boolean.toString(hasDeviceOwner || hasOrgOwnedProfile);\n        final String currentVal = mInjector.systemPropertiesGet(PROPERTY_ORGANIZATION_OWNED, null);\n        if (TextUtils.isEmpty(currentVal)) {\n            Slogf.i(LOG_TAG, \"Set ro.organization_owned property to \" + value);\n            mInjector.systemPropertiesSet(PROPERTY_ORGANIZATION_OWNED, value);\n        } else if (!value.equals(currentVal)) {\n            Slogf.w(LOG_TAG, \"Cannot change existing ro.organization_owned to \" + value);\n        }\n    }\n\n    private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n        synchronized (getLockObject()) {\n            if (mInjector.securityLogIsLoggingEnabled()) {\n                mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());\n                mInjector.runCryptoSelfTest();\n                maybePauseDeviceWideLoggingLocked();\n            }\n        }\n    }\n\n    /**\n     * Fix left-over restrictions and auto-time policy during COMP -> COPE migration.\n     *\n     * When a COMP device with requireAutoTime policy set was migrated to an\n     * organization-owned profile, a DISALLOW_CONFIG_DATE_TIME restriction is set\n     * on user 0 from the DO user, which becomes unremovable by the organization-owned\n     * profile owner. Fix this by force removing that restriction. Also revert the\n     * parentAdmin.requireAutoTime bit (since the COPE PO cannot unset this bit)\n     * and replace it with DISALLOW_CONFIG_DATE_TIME on the correct\n     * admin, in line with the deprecation recommendation of setAutoTimeRequired().\n     */\n    private void fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration() {\n        for (UserInfo ui : mUserManager.getUsers()) {\n            final int userId = ui.id;\n            if (isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n                final ActiveAdmin parent = getProfileOwnerAdminLocked(userId).parentAdmin;\n                if (parent != null && parent.requireAutoTime) {\n                    // Remove deprecated requireAutoTime\n                    parent.requireAutoTime = false;\n                    saveSettingsLocked(userId);\n\n                    // Remove user restrictions set by the device owner before the upgrade to\n                    // Android 11.\n                    mUserManagerInternal.setDevicePolicyUserRestrictions(UserHandle.USER_SYSTEM,\n                            new Bundle(), new RestrictionsSet(), /* isDeviceOwner */ false);\n\n                    // Apply user restriction to parent active admin instead\n                    parent.ensureUserRestrictions().putBoolean(\n                            UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n                    pushUserRestrictions(userId);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set an alarm for an upcoming event - expiration warning, expiration, or post-expiration\n     * reminders.  Clears alarm if no expirations are configured.\n     */\n    private void setExpirationAlarmCheckLocked(Context context, int userHandle, boolean parent) {\n        final long expiration = getPasswordExpirationLocked(null, userHandle, parent);\n        final long now = System.currentTimeMillis();\n        final long timeToExpire = expiration - now;\n        final long alarmTime;\n        if (expiration == 0) {\n            // No expirations are currently configured:  Cancel alarm.\n            alarmTime = 0;\n        } else if (timeToExpire <= 0) {\n            // The password has already expired:  Repeat every 24 hours.\n            alarmTime = now + MS_PER_DAY;\n        } else {\n            // Selecting the next alarm time:  Roll forward to the next 24 hour multiple before\n            // the expiration time.\n            long alarmInterval = timeToExpire % MS_PER_DAY;\n            if (alarmInterval == 0) {\n                alarmInterval = MS_PER_DAY;\n            }\n            alarmTime = now + alarmInterval;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            int affectedUserHandle = parent ? getProfileParentId(userHandle) : userHandle;\n            AlarmManager am = mInjector.getAlarmManager();\n            // Broadcast alarms sent by system are immutable\n            PendingIntent pi = PendingIntent.getBroadcastAsUser(context, REQUEST_EXPIRE_PASSWORD,\n                    new Intent(ACTION_EXPIRED_PASSWORD_NOTIFICATION),\n                    PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                            | PendingIntent.FLAG_IMMUTABLE,\n                    UserHandle.of(affectedUserHandle));\n            am.cancel(pi);\n            if (alarmTime != 0) {\n                am.set(AlarmManager.RTC, alarmTime, pi);\n            }\n        });\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle) {\n        ensureLocked();\n        ActiveAdmin admin = getUserData(userHandle).mAdminMap.get(who);\n        if (admin != null\n                && who.getPackageName().equals(admin.info.getActivityInfo().packageName)\n                && who.getClassName().equals(admin.info.getActivityInfo().name)) {\n            return admin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle, boolean parent) {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                    \"You can not call APIs on the parent profile outside a managed profile, \"\n                            + \"userId = %d\", userHandle);\n        }\n        ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        if (admin != null && parent) {\n            admin = admin.getParentActiveAdmin();\n        }\n        return admin;\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(ComponentName who, int reqPolicy)\n            throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(who,\n                reqPolicy, /* permission= */ null);\n    }\n\n    ActiveAdmin getDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n        return doAdmin;\n    }\n\n    ActiveAdmin getDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        if (mOwners.getDeviceOwnerType(doComponent.getPackageName()) == DEFAULT_DEVICE_OWNER) {\n            ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n            return doAdmin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getProfileOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n        ActiveAdmin poAdmin = getUserData(userId).mAdminMap.get(poAdminComponent);\n        return poAdmin;\n    }\n\n    @NonNull ActiveAdmin getOrganizationOwnedProfileOwnerLocked(final CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(\n                mOwners.isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()),\n                \"Caller %s is not an admin of an org-owned device\",\n                caller.getComponentName());\n        final ActiveAdmin profileOwner = getProfileOwnerLocked(caller.getUserId());\n\n        return profileOwner;\n    }\n\n    ActiveAdmin getProfileOwnerOrDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDeviceOwnerLocked(userId);\n    }\n\n    ActiveAdmin getProfileOwnerOrDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDefaultDeviceOwnerLocked(userId);\n    }\n\n    @NonNull ActiveAdmin getParentOfAdminIfRequired(ActiveAdmin admin, boolean parent) {\n        Objects.requireNonNull(admin);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permissions} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * one of {@code permissions} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        final CallerIdentity caller = getCallerIdentity();\n\n        ActiveAdmin result = getActiveAdminWithPolicyForUidLocked(who, reqPolicy, caller.getUid());\n        if (result != null) {\n            return result;\n        } else {\n            for (String permission : permissions) {\n                if (hasCallingPermission(permission)) {\n                    return null;\n                }\n            }\n        }\n\n        // Code for handling failure from getActiveAdminWithPolicyForUidLocked to find an admin\n        // that satisfies the required policy.\n        // Throws a security exception with the right error message.\n        if (who != null) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            final boolean isDeviceOwner = isDeviceOwner(admin.info.getComponent(),\n                    caller.getUserId());\n            final boolean isProfileOwner = isProfileOwner(admin.info.getComponent(),\n                    caller.getUserId());\n\n            if (DA_DISALLOWED_POLICIES.contains(reqPolicy) && !isDeviceOwner && !isProfileOwner) {\n                throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                        + \" is not a device owner or profile owner, so may not use policy: \"\n                        + admin.info.getTagForPolicy(reqPolicy));\n            }\n            throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                    + \" did not specify uses-policy for: \"\n                    + admin.info.getTagForPolicy(reqPolicy));\n        } else {\n            throw new SecurityException(\"No active admin owned by uid \"\n                    + caller.getUid() + \" for policy #\" + reqPolicy + (permissions.isEmpty() ? \"\"\n                    : \", which doesn't have \" + permissions));\n        }\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(@Nullable ComponentName who, int reqPolicy,\n            boolean parent) throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(\n                who, reqPolicy, parent, /* permission= */ null);\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, parent, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallingUser(isManagedProfile(getCallerIdentity().getUserId()));\n        }\n        ActiveAdmin admin = getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permissions);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Find the admin for the component and userId bit of the uid, then check\n     * the admin's uid matches the uid.\n     */\n    private ActiveAdmin getActiveAdminForUidLocked(ComponentName who, int uid) {\n        ensureLocked();\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        ActiveAdmin admin = policy.mAdminMap.get(who);\n        if (admin == null) {\n            throw new SecurityException(\"No active admin \" + who + \" for UID \" + uid);\n        }\n        if (admin.getUid() != uid) {\n            throw new SecurityException(\"Admin \" + who + \" is not owned by uid \" + uid);\n        }\n        return admin;\n    }\n\n    /**\n     * Returns the active admin for the user of the caller as denoted by uid, which implements\n     * the {@code reqPolicy}.\n     *\n     * The {@code who} parameter is used as a hint:\n     * If provided, it must be the component name of the active admin for that user and the caller\n     * uid must match the uid of the admin.\n     * If not provided, iterate over all of the active admins in the DevicePolicyData for that user\n     * and return the one with the uid specified as parameter, and has the policy specified.\n     */\n    @Nullable\n    private ActiveAdmin getActiveAdminWithPolicyForUidLocked(ComponentName who, int reqPolicy,\n            int uid) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        if (who != null) {\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            if (admin == null || admin.getUid() != uid) {\n                throw new SecurityException(\n                        \"Admin \" + who + \" is not active or not owned by uid \" + uid);\n            }\n            if (isActiveAdminWithPolicyForUserLocked(admin, reqPolicy, userId)) {\n                return admin;\n            }\n        } else {\n            for (ActiveAdmin admin : policy.mAdminList) {\n                if (admin.getUid() == uid && isActiveAdminWithPolicyForUserLocked(admin, reqPolicy,\n                        userId)) {\n                    return admin;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    @VisibleForTesting\n    boolean isActiveAdminWithPolicyForUserLocked(ActiveAdmin admin, int reqPolicy,\n            int userId) {\n        ensureLocked();\n        final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userId);\n        final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userId);\n\n        boolean allowedToUsePolicy = ownsDevice || ownsProfile\n                || !DA_DISALLOWED_POLICIES.contains(reqPolicy)\n                || getTargetSdk(admin.info.getPackageName(), userId) < Build.VERSION_CODES.Q;\n        return allowedToUsePolicy && admin.info.usesPolicy(reqPolicy);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action) {\n        sendAdminCommandLocked(admin, action, null);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, null, result);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, adminExtras, result, false);\n    }\n\n    /**\n     * Send an update to one specific admin, get notified when that admin returns a result.\n     *\n     * @return whether the broadcast was successfully sent\n     */\n    boolean sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result, boolean inForeground) {\n        Intent intent = new Intent(action);\n        intent.setComponent(admin.info.getComponent());\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING)) {\n            intent.putExtra(\"expiration\", admin.passwordExpirationDate);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (adminExtras != null) {\n            intent.putExtras(adminExtras);\n        }\n        if (mInjector.getPackageManager().queryBroadcastReceiversAsUser(\n                intent,\n                PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                admin.getUserHandle()).isEmpty()) {\n            return false;\n        }\n\n        final BroadcastOptions options = BroadcastOptions.makeBasic();\n        options.setBackgroundActivityStartsAllowed(true);\n\n        if (result != null) {\n            mContext.sendOrderedBroadcastAsUser(intent, admin.getUserHandle(),\n                    null, AppOpsManager.OP_NONE, options.toBundle(),\n                    result, mHandler, Activity.RESULT_OK, null, null);\n        } else {\n            mContext.sendBroadcastAsUser(intent, admin.getUserHandle(), null, options.toBundle());\n        }\n\n        return true;\n    }\n\n    /**\n     * Send an update to all admins of a user that enforce a specified policy.\n     */\n    void sendAdminCommandLocked(String action, int reqPolicy, int userHandle, Bundle adminExtras) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        final int count = policy.mAdminList.size();\n        for (int i = 0; i < count; i++) {\n            final ActiveAdmin admin = policy.mAdminList.get(i);\n            if (admin.info.usesPolicy(reqPolicy)) {\n                sendAdminCommandLocked(admin, action, adminExtras, null);\n            }\n        }\n    }\n\n    /**\n     * Send an update intent to all admins of a user and its profiles. Only send to admins that\n     * enforce a specified policy.\n     */\n    private void sendAdminCommandToSelfAndProfilesLocked(String action, int reqPolicy,\n            int userHandle, Bundle adminExtras) {\n        int[] profileIds = mUserManager.getProfileIdsWithDisabled(userHandle);\n        for (int profileId : profileIds) {\n            sendAdminCommandLocked(action, reqPolicy, profileId, adminExtras);\n        }\n    }\n\n    /**\n     * Sends a broadcast to each profile that share the password unlock with the given user id.\n     */\n    private void sendAdminCommandForLockscreenPoliciesLocked(\n            String action, int reqPolicy, int userHandle) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n            sendAdminCommandLocked(action, reqPolicy, userHandle, extras);\n        } else {\n            sendAdminCommandToSelfAndProfilesLocked(action, reqPolicy, userHandle, extras);\n        }\n    }\n\n    void removeActiveAdminLocked(final ComponentName adminReceiver, final int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n        DevicePolicyData policy = getUserData(userHandle);\n        if (admin != null && !policy.mRemovingAdmins.contains(adminReceiver)) {\n            policy.mRemovingAdmins.add(adminReceiver);\n            sendAdminCommandLocked(admin,\n                    DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLED,\n                    new BroadcastReceiver() {\n                        @Override\n                        public void onReceive(Context context, Intent intent) {\n                            removeAdminArtifacts(adminReceiver, userHandle);\n                            removePackageIfRequired(adminReceiver.getPackageName(), userHandle);\n                        }\n                    });\n        }\n    }\n\n    private DeviceAdminInfo findAdmin(final ComponentName adminName, final int userHandle,\n            boolean throwForMissingPermission) {\n        final ActivityInfo ai = mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mIPackageManager.getReceiverInfo(adminName,\n                        GET_META_DATA\n                        | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS\n                        | PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, userHandle);\n            } catch (RemoteException e) {\n                // shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error getting receiver info\", e);\n                return null;\n            }\n        });\n        if (ai == null) {\n            throw new IllegalArgumentException(\"Unknown admin: \" + adminName);\n        }\n\n        if (!permission.BIND_DEVICE_ADMIN.equals(ai.permission)) {\n            final String message = \"DeviceAdminReceiver \" + adminName + \" must be protected with \"\n                    + permission.BIND_DEVICE_ADMIN;\n            Slogf.w(LOG_TAG, message);\n            if (throwForMissingPermission &&\n                    ai.applicationInfo.targetSdkVersion > Build.VERSION_CODES.M) {\n                throw new IllegalArgumentException(message);\n            }\n        }\n\n        try {\n            return new DeviceAdminInfo(mContext, ai);\n        } catch (XmlPullParserException | IOException e) {\n            Slogf.w(LOG_TAG, \"Bad device admin requested for user=\" + userHandle + \": \" + adminName,\n                    e);\n            return null;\n        }\n    }\n\n    private File getPolicyFileDirectory(@UserIdInt int userId) {\n        return userId == UserHandle.USER_SYSTEM\n                ? mPathProvider.getDataSystemDirectory()\n                : mPathProvider.getUserSystemDirectory(userId);\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId, String fileName) {\n        final String base = new File(getPolicyFileDirectory(userId), fileName)\n                .getAbsolutePath();\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Opening %s\", base);\n        return new JournaledFile(new File(base), new File(base + \".tmp\"));\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId) {\n        return makeJournaledFile(userId, DEVICE_POLICIES_XML);\n    }\n\n    /**\n     * Persist modified values to disk by calling {@link #saveSettingsLocked} for each\n     * affected user ID.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void saveSettingsForUsersLocked(Set<Integer> affectedUserIds) {\n        for (int userId : affectedUserIds) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void saveSettingsLocked(int userHandle) {\n        if (DevicePolicyData.store(getUserData(userHandle), makeJournaledFile(userHandle))) {\n            sendChangedNotification(userHandle);\n        }\n        invalidateBinderCaches();\n    }\n\n    private void sendChangedNotification(int userHandle) {\n        Intent intent = new Intent(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        Bundle options = new BroadcastOptions()\n                .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n                .setDeferralPolicy(BroadcastOptions.DEFERRAL_POLICY_UNTIL_ACTIVE)\n                .toBundle();\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.sendBroadcastAsUser(intent, new UserHandle(userHandle), null, options));\n    }\n\n    private void loadSettingsLocked(DevicePolicyData policy, int userHandle) {\n        DevicePolicyData.load(policy,\n                makeJournaledFile(userHandle),\n                component -> findAdmin(\n                        component, userHandle, /* throwForMissingPermission= */ false),\n                getOwnerComponent(userHandle));\n\n        policy.validatePasswordOwner();\n        updateMaximumTimeToLockLocked(userHandle);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            updateLockTaskPackagesLocked(mContext, policy.mLockTaskPackages, userHandle);\n            updateLockTaskFeaturesLocked(policy.mLockTaskFeatures, userHandle);\n        }\n        if (policy.mStatusBarDisabled) {\n            setStatusBarDisabledInternal(policy.mStatusBarDisabled, userHandle);\n        }\n    }\n\n    static void updateLockTaskPackagesLocked(Context context, List<String> packages, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n\n            String[] packagesArray = null;\n            if (!packages.isEmpty()) {\n                // When adding packages, we need to include the exempt apps so they can still be\n                // launched (ideally we should use a different AM API as these apps don't need to\n                // use lock-task mode).\n                // They're not added when the packages is empty though, as in that case we're\n                // disabling lock-task mode.\n                List<String> exemptApps = listPolicyExemptAppsUnchecked(context);\n                if (!exemptApps.isEmpty()) {\n                    // TODO(b/175377361): add unit test to verify it (cannot be CTS because the\n                    //  policy-exempt apps are provided by OEM and the test would have no control\n                    //  over it) once tests are migrated to the new infra-structure\n                    HashSet<String> updatedPackages = new HashSet<>(packages);\n                    updatedPackages.addAll(exemptApps);\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"added %d policy-exempt apps to %d lock task \"\n                                + \"packages. Final list: %s\",\n                                exemptApps.size(), packages.size(), updatedPackages);\n                    }\n                    packagesArray = updatedPackages.toArray(new String[updatedPackages.size()]);\n                }\n            }\n\n            if (packagesArray == null) {\n                packagesArray = packages.toArray(new String[packages.size()]);\n            }\n            try {\n                ActivityManager.getService().updateLockTaskPackages(userId, packagesArray);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void updateLockTaskFeaturesLocked(int flags, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                ActivityTaskManager.getService().updateLockTaskFeatures(userId, flags);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void validateQualityConstant(int quality) {\n        switch (quality) {\n            case PASSWORD_QUALITY_UNSPECIFIED:\n            case PASSWORD_QUALITY_BIOMETRIC_WEAK:\n            case PASSWORD_QUALITY_SOMETHING:\n            case PASSWORD_QUALITY_NUMERIC:\n            case PASSWORD_QUALITY_NUMERIC_COMPLEX:\n            case PASSWORD_QUALITY_ALPHABETIC:\n            case PASSWORD_QUALITY_ALPHANUMERIC:\n            case PASSWORD_QUALITY_COMPLEX:\n            case PASSWORD_QUALITY_MANAGED:\n                return;\n        }\n        throw new IllegalArgumentException(\"Invalid quality constant: 0x\"\n                + Integer.toHexString(quality));\n    }\n\n    @VisibleForTesting\n    void systemReady(int phase) {\n        if (!mHasFeature) {\n            return;\n        }\n        switch (phase) {\n            case SystemService.PHASE_LOCK_SETTINGS_READY:\n                onLockSettingsReady();\n                loadAdminDataAsync();\n                mOwners.systemReady();\n                applyManagedSubscriptionsPolicyIfRequired();\n                break;\n            case SystemService.PHASE_ACTIVITY_MANAGER_READY:\n                synchronized (getLockObject()) {\n                    migrateToProfileOnOrganizationOwnedDeviceIfCompLocked();\n                    applyProfileRestrictionsIfDeviceOwnerLocked();\n\n                    // TODO: Is this the right place to trigger the migration?\n                    if (shouldMigrateToDevicePolicyEngine()) {\n                        migratePoliciesToDevicePolicyEngine();\n                    }\n\n                    maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                }\n                maybeStartSecurityLogMonitorOnActivityManagerReady();\n                break;\n            case SystemService.PHASE_BOOT_COMPLETED:\n                // Ideally it should be done earlier, but currently it relies on RecoverySystem,\n                // which would hang on earlier phases\n                factoryResetIfDelayedEarlier();\n\n                ensureDeviceOwnerUserStarted(); // TODO Consider better place to do this.\n                break;\n        }\n    }\n\n    private void applyManagedSubscriptionsPolicyIfRequired() {\n        int copeProfileUserId = getOrganizationOwnedProfileUserId();\n        // This policy is relevant only for COPE devices.\n        if (copeProfileUserId != UserHandle.USER_NULL) {\n            unregisterOnSubscriptionsChangedListener();\n            int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                clearManagedSubscriptionsPolicy();\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                // Add listener to assign all current and future subs to managed profile.\n                registerListenerToAssignSubscriptionsToUser(copeProfileUserId);\n            }\n        }\n    }\n\n    private void updatePersonalAppsSuspensionOnUserStart(int userHandle) {\n        final int profileUserHandle = getManagedUserId(userHandle);\n        if (profileUserHandle >= 0) {\n            // Given that the parent user has just started, profile should be locked.\n            updatePersonalAppsSuspension(profileUserHandle);\n        } else {\n            suspendPersonalAppsInternal(userHandle, profileUserHandle, false);\n        }\n    }\n\n    private void onLockSettingsReady() {\n        synchronized (getLockObject()) {\n            fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration();\n        }\n        getUserData(UserHandle.USER_SYSTEM);\n        cleanUpOldUsers();\n        maybeSetDefaultProfileOwnerUserRestrictions();\n        handleStartUser(UserHandle.USER_SYSTEM);\n        maybeLogStart();\n\n        // Register an observer for watching for user setup complete and settings changes.\n        mSetupContentObserver.register();\n        // Initialize the user setup state, to handle the upgrade case.\n        updateUserSetupCompleteAndPaired();\n\n        List<String> packageList;\n        synchronized (getLockObject()) {\n            packageList = getKeepUninstalledPackagesLocked();\n        }\n        if (packageList != null) {\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                // Push the force-ephemeral-users policy to the user manager.\n                mUserManagerInternal.setForceEphemeralUsers(deviceOwner.forceEphemeralUsers);\n\n                // Update user switcher message to activity manager.\n                ActivityManagerInternal activityManagerInternal =\n                        mInjector.getActivityManagerInternal();\n                activityManagerInternal.setSwitchingFromSystemUserMessage(\n                        deviceOwner.startUserSessionMessage);\n                activityManagerInternal.setSwitchingToSystemUserMessage(\n                        deviceOwner.endUserSessionMessage);\n            }\n\n            revertTransferOwnershipIfNecessaryLocked();\n        }\n        updateUsbDataSignal();\n\n        // In case flag value has changed, we apply it during boot to avoid doing it concurrently\n        // with user toggling quiet mode.\n        setKeepProfileRunningEnabledUnchecked(isKeepProfilesRunningFlagEnabled());\n    }\n\n    // TODO(b/230841522) Make it static.\n    private class DpmsUpgradeDataProvider implements PolicyUpgraderDataProvider {\n        @Override\n        public JournaledFile makeDevicePoliciesJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, DEVICE_POLICIES_XML);\n        }\n\n        @Override\n        public JournaledFile makePoliciesVersionJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, POLICIES_VERSION_XML);\n        }\n\n        @Override\n        public Function<ComponentName, DeviceAdminInfo> getAdminInfoSupplier(int userId) {\n            return component ->\n                    findAdmin(component, userId, /* throwForMissingPermission= */ false);\n        }\n\n        @Override\n        public int[] getUsersForUpgrade() {\n            List<UserInfo> allUsers = mUserManager.getUsers();\n            return allUsers.stream().mapToInt(u -> u.id).toArray();\n        }\n\n        @Override\n        public List<String> getPlatformSuspendedPackages(int userId) {\n            PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n            return mInjector.getPackageManager(userId)\n                    .getInstalledPackages(PackageManager.PackageInfoFlags.of(\n                            MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE))\n                    .stream()\n                    .map(packageInfo -> packageInfo.packageName)\n                    .filter(pkg ->\n                            PLATFORM_PACKAGE_NAME.equals(pmi.getSuspendingPackage(pkg, userId))\n                    )\n                    .collect(Collectors.toList());\n        }\n    }\n\n    private void performPolicyVersionUpgrade() {\n        PolicyVersionUpgrader upgrader = new PolicyVersionUpgrader(\n                new DpmsUpgradeDataProvider(), mPathProvider);\n        upgrader.upgradePolicy(DPMS_VERSION);\n    }\n\n    private void revertTransferOwnershipIfNecessaryLocked() {\n        if (!mTransferOwnershipMetadataManager.metadataFileExists()) {\n            return;\n        }\n        Slogf.e(LOG_TAG, \"Owner transfer metadata file exists! Reverting transfer.\");\n        final TransferOwnershipMetadataManager.Metadata metadata =\n                mTransferOwnershipMetadataManager.loadMetadataFile();\n        // Revert transfer\n        if (metadata.adminType.equals(ADMIN_TYPE_PROFILE_OWNER)) {\n            transferProfileOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        } else if (metadata.adminType.equals(ADMIN_TYPE_DEVICE_OWNER)) {\n            transferDeviceOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        }\n        updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            pushUserControlDisabledPackagesLocked(metadata.userId);\n        }\n    }\n\n    private void maybeLogStart() {\n        if (!SecurityLog.isLoggingEnabled()) {\n            return;\n        }\n        final String verifiedBootState =\n                mInjector.systemPropertiesGet(\"ro.boot.verifiedbootstate\");\n        final String verityMode = mInjector.systemPropertiesGet(\"ro.boot.veritymode\");\n        SecurityLog.writeEvent(SecurityLog.TAG_OS_STARTUP, verifiedBootState, verityMode);\n    }\n\n    private void ensureDeviceOwnerUserStarted() {\n        final int userId;\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return;\n            }\n            userId = mOwners.getDeviceOwnerUserId();\n        }\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Starting non-system DO user: \" + userId);\n        }\n        if (userId != UserHandle.USER_SYSTEM) {\n            try {\n                mInjector.getIActivityManager().startUserInBackground(userId);\n\n                // STOPSHIP Prevent the DO user from being killed.\n\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Exception starting user\", e);\n            }\n        }\n    }\n\n    void handleStartUser(int userId) {\n        synchronized (getLockObject()) {\n            pushScreenCapturePolicy(userId);\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                pushUserControlDisabledPackagesLocked(userId);\n            }\n        }\n        pushUserRestrictions(userId);\n        // When system user is started (device boot), load cache for all users.\n        // This is to mitigate the potential race between loading the cache and keyguard\n        // reading the value during user switch, due to onStartUser() being asynchronous.\n        updatePasswordQualityCacheForUserGroup(\n                userId == UserHandle.USER_SYSTEM ? UserHandle.USER_ALL : userId);\n        updatePermissionPolicyCache(userId);\n        updateAdminCanGrantSensorsPermissionCache(userId);\n\n        final List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs;\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            preferentialNetworkServiceConfigs = owner != null\n                    ? owner.mPreferentialNetworkServiceConfigs\n                    : List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n        updateNetworkPreferenceForUser(userId, preferentialNetworkServiceConfigs);\n\n        if (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        }\n\n        startOwnerService(userId, \"start-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleStartUser(userId);\n        }\n    }\n\n    void pushUserControlDisabledPackagesLocked(int userId) {\n        final int targetUserId;\n        final ActiveAdmin owner;\n        if (getDeviceOwnerUserIdUncheckedLocked() == userId) {\n            owner = getDeviceOwnerAdminLocked();\n            targetUserId = UserHandle.USER_ALL;\n        } else {\n            owner = getProfileOwnerAdminLocked(userId);\n            targetUserId = userId;\n        }\n\n        List<String> protectedPackages = (owner == null || owner.protectedPackages == null)\n                ? null : owner.protectedPackages;\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getPackageManagerInternal().setOwnerProtectedPackages(\n                        targetUserId, protectedPackages));\n        mUsageStatsManagerInternal.setAdminProtectedPackages(new ArraySet(protectedPackages),\n                targetUserId);\n    }\n\n    void handleUnlockUser(int userId) {\n        startOwnerService(userId, \"unlock-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleUnlockUser(userId);\n        }\n    }\n\n    void handleOnUserUnlocked(int userId) {\n        showNewUserDisclaimerIfNecessary(userId);\n    }\n\n    void handleStopUser(int userId) {\n        updateNetworkPreferenceForUser(userId, List.of(PreferentialNetworkServiceConfig.DEFAULT));\n        mDeviceAdminServiceController.stopServicesForUser(userId, /* actionForLog= */ \"stop-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleStopUser(userId);\n        }\n    }\n\n    private void startOwnerService(int userId, String actionForLog) {\n        final ComponentName owner = getOwnerComponent(userId);\n        if (owner != null) {\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    owner.getPackageName(), userId, actionForLog);\n            invalidateBinderCaches();\n        }\n    }\n\n    private void cleanUpOldUsers() {\n        // This is needed in case the broadcast {@link Intent.ACTION_USER_REMOVED} was not handled\n        // before reboot\n        Set<Integer> usersWithProfileOwners;\n        Set<Integer> usersWithData;\n        synchronized (getLockObject()) {\n            usersWithProfileOwners = mOwners.getProfileOwnerKeys();\n            usersWithData = new ArraySet<>();\n            for (int i = 0; i < mUserData.size(); i++) {\n                usersWithData.add(mUserData.keyAt(i));\n            }\n        }\n        List<UserInfo> allUsers = mUserManager.getUsers();\n\n        Set<Integer> deletedUsers = new ArraySet<>();\n        deletedUsers.addAll(usersWithProfileOwners);\n        deletedUsers.addAll(usersWithData);\n        for (UserInfo userInfo : allUsers) {\n            deletedUsers.remove(userInfo.id);\n        }\n        for (Integer userId : deletedUsers) {\n            removeUserData(userId);\n            if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                mDevicePolicyEngine.handleUserRemoved(userId);\n            }\n        }\n    }\n\n    private void handlePasswordExpirationNotification(int userHandle) {\n        final Bundle adminExtras = new Bundle();\n        adminExtras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n\n        synchronized (getLockObject()) {\n            final long now = System.currentTimeMillis();\n\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if ((admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD))\n                        && admin.passwordExpirationTimeout > 0L\n                        && now >= admin.passwordExpirationDate - EXPIRATION_GRACE_PERIOD_MS\n                        && admin.passwordExpirationDate > 0L) {\n                    sendAdminCommandLocked(admin,\n                            DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING, adminExtras, null);\n                }\n            }\n            setExpirationAlarmCheckLocked(mContext, userHandle, /* parent */ false);\n        }\n    }\n\n    /**\n     * Clean up internal state when the set of installed trusted CA certificates changes.\n     *\n     * @param userHandle user to check for. This must be a real user and not, for example,\n     *        {@link UserHandle#ALL}.\n     * @param installedCertificates the full set of certificate authorities currently installed for\n     *        {@param userHandle}. After calling this function, {@code mAcceptedCaCertificates} will\n     *        correspond to some subset of this.\n     */\n    protected void onInstalledCertificatesChanged(final UserHandle userHandle,\n            final @NonNull Collection<String> installedCertificates) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n\n            boolean changed = false;\n            changed |= policy.mAcceptedCaCertificates.retainAll(installedCertificates);\n            changed |= policy.mOwnerInstalledCaCerts.retainAll(installedCertificates);\n            if (changed) {\n                saveSettingsLocked(userHandle.getIdentifier());\n            }\n        }\n    }\n\n    /**\n     * Internal method used by {@link CertificateMonitor}.\n     */\n    protected Set<String> getAcceptedCaCertificates(final UserHandle userHandle) {\n        if (!mHasFeature) {\n            return Collections.<String> emptySet();\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n            return policy.mAcceptedCaCertificates;\n        }\n    }\n\n    /**\n     * @param adminReceiver The admin to add\n     * @param refreshing true = update an active admin, no error\n     */\n    @Override\n    public void setActiveAdmin(\n            ComponentName adminReceiver, boolean refreshing, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        DevicePolicyData policy = getUserData(userHandle);\n        DeviceAdminInfo info = findAdmin(adminReceiver, userHandle,\n                /* throwForMissingPermission= */ true);\n        synchronized (getLockObject()) {\n            checkActiveAdminPrecondition(adminReceiver, info, policy);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final ActiveAdmin existingAdmin\n                        = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n                if (!refreshing && existingAdmin != null) {\n                    throw new IllegalArgumentException(\"Admin is already added\");\n                }\n                ActiveAdmin newAdmin = new ActiveAdmin(info, /* parent */ false);\n                newAdmin.testOnlyAdmin =\n                        (existingAdmin != null) ? existingAdmin.testOnlyAdmin\n                                : isPackageTestOnly(adminReceiver.getPackageName(), userHandle);\n                policy.mAdminMap.put(adminReceiver, newAdmin);\n                int replaceIndex = -1;\n                final int N = policy.mAdminList.size();\n                for (int i=0; i < N; i++) {\n                    ActiveAdmin oldAdmin = policy.mAdminList.get(i);\n                    if (oldAdmin.info.getComponent().equals(adminReceiver)) {\n                        replaceIndex = i;\n                        break;\n                    }\n                }\n                if (replaceIndex == -1) {\n                    policy.mAdminList.add(newAdmin);\n                    enableIfNecessary(info.getPackageName(), userHandle);\n                    mUsageStatsManagerInternal.onActiveAdminAdded(\n                            adminReceiver.getPackageName(), userHandle);\n                } else {\n                    policy.mAdminList.set(replaceIndex, newAdmin);\n                }\n                saveSettingsLocked(userHandle);\n                sendAdminCommandLocked(newAdmin, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        /* adminExtras= */ null, /* result= */ null);\n            });\n        }\n    }\n\n    private void loadAdminDataAsync() {\n        mInjector.postOnSystemServerInitThreadPool(() -> {\n            pushActiveAdminPackages();\n            mUsageStatsManagerInternal.onAdminDataAvailable();\n            pushAllMeteredRestrictedPackages();\n            mInjector.getNetworkPolicyManagerInternal().onAdminDataAvailable();\n        });\n    }\n\n    private void pushActiveAdminPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mUsageStatsManagerInternal.setActiveAdminApps(\n                        getActiveAdminPackagesLocked(userId), userId);\n            }\n        }\n    }\n\n    private void pushAllMeteredRestrictedPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackagesAsync(\n                        getMeteredDisabledPackages(userId), userId);\n            }\n        }\n    }\n\n    private void pushActiveAdminPackagesLocked(int userId) {\n        mUsageStatsManagerInternal.setActiveAdminApps(\n                getActiveAdminPackagesLocked(userId), userId);\n    }\n\n    private Set<String> getActiveAdminPackagesLocked(int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n        Set<String> adminPkgs = null;\n        for (int i = policy.mAdminList.size() - 1; i >= 0; --i) {\n            final String pkgName = policy.mAdminList.get(i).info.getPackageName();\n            if (adminPkgs == null) {\n                adminPkgs = new ArraySet<>();\n            }\n            adminPkgs.add(pkgName);\n        }\n        return adminPkgs;\n    }\n\n    private void transferActiveAdminUncheckedLocked(ComponentName incomingReceiver,\n            ComponentName outgoingReceiver, int userHandle) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        if (!policy.mAdminMap.containsKey(outgoingReceiver)\n                && policy.mAdminMap.containsKey(incomingReceiver)) {\n            // Nothing to transfer - the incoming receiver is already the active admin.\n            return;\n        }\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(incomingReceiver, userHandle,\n            /* throwForMissingPermission= */ true);\n        final ActiveAdmin adminToTransfer = policy.mAdminMap.get(outgoingReceiver);\n        final int oldAdminUid = adminToTransfer.getUid();\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin oldAdmin =\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            outgoingReceiver, userHandle, adminToTransfer);\n            EnforcingAdmin newAdmin =\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            incomingReceiver, userHandle, adminToTransfer);\n\n            mDevicePolicyEngine.transferPolicies(oldAdmin, newAdmin);\n        }\n\n        adminToTransfer.transfer(incomingDeviceInfo);\n        policy.mAdminMap.remove(outgoingReceiver);\n        policy.mAdminMap.put(incomingReceiver, adminToTransfer);\n        if (policy.mPasswordOwner == oldAdminUid) {\n            policy.mPasswordOwner = adminToTransfer.getUid();\n        }\n\n        saveSettingsLocked(userHandle);\n        sendAdminCommandLocked(adminToTransfer, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                null, null);\n    }\n\n    private void checkActiveAdminPrecondition(ComponentName adminReceiver, DeviceAdminInfo info,\n            DevicePolicyData policy) {\n        if (info == null) {\n            throw new IllegalArgumentException(\"Bad admin: \" + adminReceiver);\n        }\n        if (!info.getActivityInfo().applicationInfo.isInternal()) {\n            throw new IllegalArgumentException(\"Only apps in internal storage can be active admin: \"\n                    + adminReceiver);\n        }\n        if (info.getActivityInfo().applicationInfo.isInstantApp()) {\n            throw new IllegalArgumentException(\"Instant apps cannot be device admins: \"\n                    + adminReceiver);\n        }\n        if (policy.mRemovingAdmins.contains(adminReceiver)) {\n            throw new IllegalArgumentException(\n                    \"Trying to set an admin which is being removed\");\n        }\n    }\n\n    private void checkAllUsersAreAffiliatedWithDevice() {\n        Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(),\n                \"operation not allowed when device has unaffiliated users\");\n    }\n\n    @Override\n    public boolean isAdminActive(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getActiveAdminUncheckedLocked(adminReceiver, userHandle) != null;\n        }\n    }\n\n    @Override\n    public boolean isRemovingAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userHandle);\n            return policyData.mRemovingAdmins.contains(adminReceiver);\n        }\n    }\n\n    @Override\n    public boolean hasGrantedPolicy(ComponentName adminReceiver, int policyId, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                isCallingFromPackage(adminReceiver.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin administrator = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (administrator == null) {\n                throw new SecurityException(\"No active admin \" + adminReceiver);\n            }\n            return administrator.info.usesPolicy(policyId);\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<ComponentName> getActiveAdmins(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.EMPTY_LIST;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            if (N <= 0) {\n                return null;\n            }\n            ArrayList<ComponentName> res = new ArrayList<ComponentName>(N);\n            for (int i=0; i<N; i++) {\n                res.add(policy.mAdminList.get(i).info.getComponent());\n            }\n            return res;\n        }\n    }\n\n    @Override\n    public boolean packageHasActiveAdmins(String packageName, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i=0; i<N; i++) {\n                if (policy.mAdminList.get(i).info.getPackageName().equals(packageName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public void forceRemoveActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(adminReceiver, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS),\n                \"Caller must be shell or hold MANAGE_PROFILE_AND_DEVICE_OWNERS to call \"\n                        + \"forceRemoveActiveAdmin\");\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean isOrgOwnedProfile = false;\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(adminReceiver, userHandle)) {\n                    throw new SecurityException(\"Attempt to remove non-test admin \"\n                            + adminReceiver + \" \" + userHandle);\n                }\n\n                // If admin is a device or profile owner tidy that up first.\n                if (isDeviceOwner(adminReceiver, userHandle)) {\n                    clearDeviceOwnerLocked(getDeviceOwnerAdminLocked(), userHandle);\n                }\n                if (isProfileOwner(adminReceiver, userHandle)) {\n                    isOrgOwnedProfile = isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n                    final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver,\n                            userHandle, /* parent */ false);\n                    clearProfileOwnerLocked(admin, userHandle);\n                }\n            }\n            // Remove the admin skipping sending the broadcast.\n            removeAdminArtifacts(adminReceiver, userHandle);\n\n            // In case of PO on org owned device, clean device-wide policies and restrictions.\n            if (isOrgOwnedProfile) {\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userHandle));\n                clearOrgOwnedProfileOwnerUserRestrictions(parentUser);\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(parentUser.getIdentifier());\n            }\n\n            Slogf.i(LOG_TAG, \"Admin \" + adminReceiver + \" removed from user \" + userHandle);\n        });\n    }\n\n    private void clearOrgOwnedProfileOwnerUserRestrictions(UserHandle parentUserHandle) {\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_REMOVE_MANAGED_PROFILE, false, parentUserHandle);\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_ADD_USER, false, parentUserHandle);\n    }\n\n    private void clearDeviceOwnerUserRestriction(UserHandle userHandle) {\n        if (isHeadlessFlagEnabled()) {\n            for (int userId : mUserManagerInternal.getUserIds()) {\n                UserHandle user = UserHandle.of(userId);\n                // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the\n                // original state\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                            false, user);\n                }\n                // When a device owner is set, the system automatically restricts adding a\n                // managed profile.\n                // Remove this restriction when the device owner is cleared.\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                            false,\n                            user);\n                }\n                // When a device owner is set, the system automatically restricts adding a\n                // clone profile.\n                // Remove this restriction when the device owner is cleared.\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                            false, user);\n                }\n            }\n        } else {\n            // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the original state\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER, false,\n                        userHandle);\n            }\n            // When a device owner is set, the system automatically restricts adding a\n            // managed profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        false,\n                        userHandle);\n            }\n            // When a device owner is set, the system automatically restricts adding a clone\n            // profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                    userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                        false,\n                        userHandle);\n            }\n        }\n    }\n\n    /**\n     * Return if a given package has testOnly=\"true\", in which case we'll relax certain rules\n     * for CTS.\n     *\n     * DO NOT use this method except in {@link #setActiveAdmin}.  Use {@link #isAdminTestOnlyLocked}\n     * to check wehter an active admin is test-only or not.\n     *\n     * The system allows this flag to be changed when an app is updated, which is not good\n     * for us.  So we persist the flag in {@link ActiveAdmin} when an admin is first installed,\n     * and used the persisted version in actual checks. (See b/31382361 and b/28928996)\n     */\n    private boolean isPackageTestOnly(String packageName, int userHandle) {\n        final ApplicationInfo ai;\n        try {\n            ai = mInjector.getIPackageManager().getApplicationInfo(packageName,\n                    (PackageManager.MATCH_DIRECT_BOOT_AWARE\n                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE), userHandle);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n        if (ai == null) {\n            throw new IllegalStateException(\"Couldn't find package: \"\n                    + packageName + \" on user \" + userHandle);\n        }\n        return (ai.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0;\n    }\n\n    /**\n     * See {@link #isPackageTestOnly}.\n     */\n    private boolean isAdminTestOnlyLocked(ComponentName who, int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        return (admin != null) && admin.testOnlyAdmin;\n    }\n\n    @Override\n    public void removeActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                ? getCallerIdentity() : getCallerIdentity(adminReceiver);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_ACTIVE_ADMIN);\n        enforceUserUnlocked(userHandle);\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            // Active device/profile owners must remain active admins.\n            if (isDeviceOwner(adminReceiver, userHandle)\n                    || isProfileOwner(adminReceiver, userHandle)) {\n                Slogf.e(LOG_TAG, \"Device/profile owner cannot be removed: component=\"\n                        + adminReceiver);\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    removeActiveAdminLocked(adminReceiver, userHandle));\n        }\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            adminReceiver, userHandle, admin));\n        }\n    }\n\n    private boolean canSetPasswordQualityOnParent(String packageName, final CallerIdentity caller) {\n        return !mInjector.isChangeEnabled(\n                PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT, packageName, caller.getUserId())\n            || isProfileOwnerOfOrganizationOwnedDevice(caller);\n    }\n\n    private boolean isPasswordLimitingAdminTargetingP(CallerIdentity caller) {\n        if (!caller.hasAdminComponent()) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return getActiveAdminWithPolicyForUidLocked(\n                    caller.getComponentName(), DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD,\n                    caller.getUid()) != null;\n        }\n    }\n\n    private boolean notSupportedOnAutomotive(String method) {\n        if (mIsAutomotive) {\n            Slogf.i(LOG_TAG, \"%s is not supported on automotive builds\", method);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void setPasswordQuality(ComponentName who, int quality, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordQuality\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        validateQualityConstant(quality);\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || isSystemUid(caller) || isPasswordLimitingAdminTargetingP(caller));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    canSetPasswordQualityOnParent(who.getPackageName(), caller),\n                    \"Profile Owner may not apply password quality requirements device-wide\");\n        }\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n\n            // If setPasswordQuality is called on the parent, ensure that\n            // the primary admin does not have password complexity state (this is an\n            // unsupported state).\n            if (parent) {\n                final ActiveAdmin primaryAdmin = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, false);\n                final boolean hasComplexitySet =\n                        primaryAdmin.mPasswordComplexity != PASSWORD_COMPLEXITY_NONE;\n                Preconditions.checkState(!hasComplexitySet,\n                        \"Cannot set password quality when complexity is set on the primary admin.\"\n                        + \" Set the primary admin's complexity to NONE first.\");\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n                if (passwordPolicy.quality != quality) {\n                    passwordPolicy.quality = quality;\n                    ap.mPasswordComplexity = PASSWORD_COMPLEXITY_NONE;\n                    resetInactivePasswordRequirementsIfRPlus(userId, ap);\n                    updatePasswordValidityCheckpointLocked(userId, parent);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                    saveSettingsLocked(userId);\n                }\n                logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_QUALITY)\n                .setAdmin(who)\n                .setInt(quality)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    private boolean passwordQualityInvocationOrderCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(ADMIN_APP_PASSWORD_COMPLEXITY, packageName, userId);\n    }\n\n    /**\n     * For admins targeting R+ reset various password constraints to default values when quality is\n     * set to a value that makes those constraints that have no effect.\n     */\n    private void resetInactivePasswordRequirementsIfRPlus(int userId, ActiveAdmin admin) {\n        if (passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(), userId)) {\n            final PasswordPolicy policy = admin.mPasswordPolicy;\n            if (policy.quality < PASSWORD_QUALITY_NUMERIC) {\n                policy.length = PasswordPolicy.DEF_MINIMUM_LENGTH;\n            }\n            if (policy.quality < PASSWORD_QUALITY_COMPLEX) {\n                policy.letters = PasswordPolicy.DEF_MINIMUM_LETTERS;\n                policy.upperCase = PasswordPolicy.DEF_MINIMUM_UPPER_CASE;\n                policy.lowerCase = PasswordPolicy.DEF_MINIMUM_LOWER_CASE;\n                policy.numeric = PasswordPolicy.DEF_MINIMUM_NUMERIC;\n                policy.symbols = PasswordPolicy.DEF_MINIMUM_SYMBOLS;\n                policy.nonLetter = PasswordPolicy.DEF_MINIMUM_NON_LETTER;\n            }\n        }\n    }\n\n    /**\n     * Updates a flag that tells us whether the user's password currently satisfies the\n     * requirements set by all of the user's active admins.\n     * This should be called whenever the password or the admin policies have changed. The caller\n     * is responsible for calling {@link #saveSettingsLocked} to persist the change.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordValidityCheckpointLocked(int userHandle, boolean parent) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        final int credentialOwner = getCredentialOwner(userHandle, parent);\n        DevicePolicyData policy = getUserData(credentialOwner);\n        PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n        // Update the checkpoint only if the user's password metrics is known\n        if (metrics != null) {\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            final boolean newCheckpoint = isPasswordSufficientForUserWithoutCheckpointLocked(\n                    metrics, userToCheck);\n            if (newCheckpoint != policy.mPasswordValidAtLastCheckpoint) {\n                policy.mPasswordValidAtLastCheckpoint = newCheckpoint;\n                affectedUserIds.add(credentialOwner);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    /**\n     * Update password quality values in policy cache for all users in the same user group as\n     * the given user. The cached password quality for user X is the aggregated quality among all\n     * admins who have influence of user X's screenlock, i.e. it's equivalent to the return value of\n     * getPasswordQuality(null, user X, false).\n     *\n     * Caches for all users in the same user group often need to be updated alltogether because a\n     * user's admin policy can affect another's aggregated password quality in some situation.\n     * For example a managed profile's policy will affect the parent user if the profile has unified\n     * challenge. A profile can also explicitly set a parent password quality which will affect the\n     * aggregated password quality of the parent user.\n     */\n    private void updatePasswordQualityCacheForUserGroup(@UserIdInt int userId) {\n        final List<UserInfo> users;\n        if (userId == UserHandle.USER_ALL) {\n            users = mUserManager.getUsers();\n        } else {\n            users = mUserManager.getProfiles(userId);\n        }\n        for (UserInfo userInfo : users) {\n            final int currentUserId = userInfo.id;\n            mPolicyCache.setPasswordQuality(currentUserId,\n                    getPasswordQuality(null, currentUserId, false));\n        }\n    }\n\n    @Override\n    public int getPasswordQuality(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return PASSWORD_QUALITY_UNSPECIFIED;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            int mode = PASSWORD_QUALITY_UNSPECIFIED;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.mPasswordPolicy.quality : mode;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (mode < admin.mPasswordPolicy.quality) {\n                    mode = admin.mPasswordPolicy.quality;\n                }\n            }\n            return mode;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForLockscreenPoliciesLocked(int userHandle) {\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n\n            if (isPermissionCheckFlagEnabled()) {\n                return getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(userHandle);\n            }\n            // If this user has a separate challenge, only return its restrictions.\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        // If isSeparateProfileChallengeEnabled is false and userHandle points to a managed profile\n        // we need to query the parent user who owns the credential.\n        if (isPermissionCheckFlagEnabled()) {\n            return getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(getProfileParentId(userHandle),\n                    (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n        } else {\n            return getActiveAdminsForUserAndItsManagedProfilesLocked(getProfileParentId(userHandle),\n                    (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n        }\n\n    }\n\n    /**\n     * Get the list of active admins for an affected user:\n     * <ul>\n     * <li>The active admins associated with the userHandle itself</li>\n     * <li>The parent active admins for each managed profile associated with the userHandle</li>\n     * </ul>\n     *\n     * @param userHandle the affected user for whom to get the active admins\n     * @return the list of active admins for the affected user\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForAffectedUserLocked(int userHandle) {\n        if (isManagedProfile(userHandle)) {\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        return getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                /* shouldIncludeProfileAdmins */ (user) -> false);\n    }\n\n    /**\n     * Get the list of active admins for an affected user:\n     * <ul>\n     * <li>The active admins associated with the userHandle itself</li>\n     * <li>The parent active admins for each managed profile associated with the userHandle</li>\n     * <li>The permission based admin associated with the userHandle itself</li>\n     * </ul>\n     *\n     * @param userHandle the affected user for whom to get the active admins\n     * @return the list of active admins for the affected user\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(\n            int userHandle) {\n        List<ActiveAdmin> list;\n\n        if (isManagedProfile(userHandle)) {\n            list = getUserDataUnchecked(userHandle).mAdminList;\n        }\n        list = getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(userHandle,\n                /* shouldIncludeProfileAdmins */ (user) -> false);\n\n        if (getUserData(userHandle).mPermissionBasedAdmin != null) {\n            list.add(getUserData(userHandle).mPermissionBasedAdmin);\n        }\n        return list;\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                    if (policy.mPermissionBasedAdmin != null) {\n                        admins.add(policy.mPermissionBasedAdmin);\n                    }\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                    if (policy.mPermissionBasedAdmin != null\n                            && shouldIncludeProfileAdmins.test(userInfo)) {\n                        admins.add(policy.mPermissionBasedAdmin);\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    private boolean isSeparateProfileChallengeEnabled(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.isSeparateProfileChallengeEnabled(userHandle));\n    }\n\n    @Override\n    public void setPasswordMinimumLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLength\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_NUMERIC, \"setPasswordMinimumLength\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.length != length) {\n                passwordPolicy.length = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LENGTH)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    private void ensureMinimumQuality(\n            int userId, ActiveAdmin admin, int minimumQuality, String operation) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // This check will also take care of the case where the password requirements\n            // are specified as complexity rather than quality: When a password complexity\n            // is set, the quality is reset to \"unspecified\" which will be below any value\n            // of minimumQuality.\n            if (admin.mPasswordPolicy.quality < minimumQuality\n                    && passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(),\n                    userId)) {\n                throw new IllegalStateException(String.format(\n                        \"password quality should be at least %d for %s\",\n                        minimumQuality, operation));\n            }\n        });\n    }\n\n    @Override\n    public int getPasswordMinimumLength(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.length, PASSWORD_QUALITY_NUMERIC);\n    }\n\n    @Override\n    public void setPasswordHistoryLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            if (ap.passwordHistoryLength != length) {\n                ap.passwordHistoryLength = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_HISTORY_LENGTH_SET,\n                    who.getPackageName(), userId, affectedUserId, length);\n        }\n    }\n\n    @Override\n    public int getPasswordHistoryLength(ComponentName who, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.passwordHistoryLength, PASSWORD_QUALITY_UNSPECIFIED);\n    }\n\n    @Override\n    public void setPasswordExpirationTimeout(ComponentName who, String callerPackageName,\n            long timeout, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        Preconditions.checkArgumentNonnegative(timeout, \"Timeout must be >= 0 ms\");\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUserId)\n                        .getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD, parent);\n            }\n            // Calling this API automatically bumps the expiration date\n            final long expiration = timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            ap.passwordExpirationDate = expiration;\n            ap.passwordExpirationTimeout = timeout;\n            if (timeout > 0L) {\n                Slogf.w(LOG_TAG, \"setPasswordExpiration(): password will expire on \"\n                        + DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)\n                        .format(new Date(expiration)));\n            }\n            saveSettingsLocked(userHandle);\n\n            // in case this is the first one, set the alarm on the appropriate user.\n            setExpirationAlarmCheckLocked(mContext, userHandle, parent);\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_EXPIRATION_SET, callerPackageName,\n                    userHandle, affectedUserId, timeout);\n        }\n    }\n\n    /**\n     * Return a single admin's expiration cycle time, or the min of all cycle times.\n     * Returns 0 if not configured.\n     */\n    @Override\n    public long getPasswordExpirationTimeout(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            long timeout = 0L;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.passwordExpirationTimeout : timeout;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (timeout == 0L || (admin.passwordExpirationTimeout != 0L\n                        && timeout > admin.passwordExpirationTimeout)) {\n                    timeout = admin.passwordExpirationTimeout;\n                }\n            }\n            return timeout;\n        }\n    }\n\n    @Override\n    public boolean addCrossProfileWidgetProvider(ComponentName admin, String callerPackageName,\n            String packageName) {\n        CallerIdentity caller;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        ActiveAdmin activeAdmin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            activeAdmin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller));\n            synchronized (getLockObject()) {\n                activeAdmin = getProfileOwnerLocked(caller.getUserId());\n            }\n        }\n        List<String> changedProviders = null;\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null) {\n                activeAdmin.crossProfileWidgetProviders = new ArrayList<>();\n            }\n            List<String> providers = activeAdmin.crossProfileWidgetProviders;\n            if (!providers.contains(packageName)) {\n                providers.add(packageName);\n                changedProviders = new ArrayList<>(providers);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_CROSS_PROFILE_WIDGET_PROVIDER)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (changedProviders != null) {\n            mLocalService.notifyCrossProfileProvidersChanged(caller.getUserId(),\n                    changedProviders);\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean removeCrossProfileWidgetProvider(ComponentName admin, String callerPackageName,\n            String packageName) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        ActiveAdmin activeAdmin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            activeAdmin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller));\n            synchronized (getLockObject()) {\n                activeAdmin = getProfileOwnerLocked(caller.getUserId());\n            }\n        }\n        List<String> changedProviders = null;\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null\n                    || activeAdmin.crossProfileWidgetProviders.isEmpty()) {\n                return false;\n            }\n            List<String> providers = activeAdmin.crossProfileWidgetProviders;\n            if (providers.remove(packageName)) {\n                changedProviders = new ArrayList<>(providers);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.REMOVE_CROSS_PROFILE_WIDGET_PROVIDER)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (changedProviders != null) {\n            mLocalService.notifyCrossProfileProvidersChanged(caller.getUserId(),\n                    changedProviders);\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<String> getCrossProfileWidgetProviders(ComponentName admin,\n            String callerPackageName) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        ActiveAdmin activeAdmin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforceCanQueryAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            activeAdmin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller));\n            synchronized (getLockObject()) {\n                activeAdmin = getProfileOwnerLocked(caller.getUserId());\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (activeAdmin.crossProfileWidgetProviders == null\n                    || activeAdmin.crossProfileWidgetProviders.isEmpty()) {\n                return null;\n            }\n            if (mInjector.binderIsCallingUidMyUid()) {\n                return new ArrayList<>(activeAdmin.crossProfileWidgetProviders);\n            } else {\n                return activeAdmin.crossProfileWidgetProviders;\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's expiration date/time, or the min (soonest) for all admins.\n     * Returns 0 if not configured.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private long getPasswordExpirationLocked(ComponentName who, int userHandle, boolean parent) {\n        long timeout = 0L;\n\n        if (who != null) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n            return admin != null ? admin.passwordExpirationDate : timeout;\n        }\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (timeout == 0L || (admin.passwordExpirationDate != 0\n                    && timeout > admin.passwordExpirationDate)) {\n                timeout = admin.passwordExpirationDate;\n            }\n        }\n        return timeout;\n    }\n\n    @Override\n    public long getPasswordExpiration(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getPasswordExpirationLocked(who, userHandle, parent);\n        }\n    }\n\n    @Override\n    public void setPasswordMinimumUpperCase(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumUpperCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumUpperCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.upperCase != length) {\n                passwordPolicy.upperCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_UPPER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumUpperCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.upperCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLowerCase(ComponentName who, int length, boolean parent) {\n        if (notSupportedOnAutomotive(\"setPasswordMinimumLowerCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLowerCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.lowerCase != length) {\n                passwordPolicy.lowerCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LOWER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLowerCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.lowerCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLetters(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLetters\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLetters\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.letters != length) {\n                passwordPolicy.letters = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LETTERS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLetters(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.letters, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNumeric(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNumeric\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNumeric\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.numeric != length) {\n                passwordPolicy.numeric = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NUMERIC)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNumeric(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.numeric, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumSymbols(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumSymbols\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumSymbols\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.symbols != length) {\n                ap.mPasswordPolicy.symbols = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_SYMBOLS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumSymbols(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.symbols, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNonLetter(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNonLetter\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNonLetter\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.nonLetter != length) {\n                ap.mPasswordPolicy.nonLetter = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NON_LETTER)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNonLetter(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.nonLetter, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    private int getStrictestPasswordRequirement(ComponentName who, int userHandle,\n            boolean parent, Function<ActiveAdmin, Integer> getter, int minimumPasswordQuality) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? getter.apply(admin) : 0;\n            }\n\n            int maxValue = 0;\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin admin = admins.get(i);\n                if (!isLimitPasswordAllowed(admin, minimumPasswordQuality)) {\n                    continue;\n                }\n                final Integer adminValue = getter.apply(admin);\n                if (adminValue > maxValue) {\n                    maxValue = adminValue;\n                }\n            }\n            return maxValue;\n        }\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    @Override\n    public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle)\n                && (isSystemUid(caller) || hasCallingOrSelfPermission(\n                permission.SET_INITIAL_LOCK)));\n        return getPasswordMinimumMetricsUnchecked(userHandle, deviceWideOnly);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId) {\n        return getPasswordMinimumMetricsUnchecked(userId, false);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId,\n            boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            new PasswordMetrics(CREDENTIAL_TYPE_NONE);\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        if (deviceWideOnly) {\n            Preconditions.checkArgument(!isManagedProfile(userId));\n        }\n\n        ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>();\n        final List<ActiveAdmin> admins;\n        synchronized (getLockObject()) {\n            if (deviceWideOnly) {\n                admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userId,\n                        /* shouldIncludeProfileAdmins */ (user) -> false);\n            } else {\n                admins = getActiveAdminsForLockscreenPoliciesLocked(userId);\n            }\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n            }\n        }\n        return PasswordMetrics.merge(adminMetrics);\n    }\n\n    @Override\n    public boolean isActivePasswordSufficient(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        enforceUserUnlocked(userHandle, parent);\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                int affectedUser = parent ? getProfileParentId(userHandle) : userHandle;\n                enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        callerPackageName, affectedUser);\n            } else {\n                // This API can only be called by an active device admin,\n                // so try to retrieve it to check that the caller is one.\n                getActiveAdminForCallerLocked(\n                        null, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            }\n\n            int credentialOwner = getCredentialOwner(userHandle, parent);\n            DevicePolicyData policy = getUserDataUnchecked(credentialOwner);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            boolean activePasswordSufficientForUserLocked = isActivePasswordSufficientForUserLocked(\n                    policy.mPasswordValidAtLastCheckpoint, metrics, userToCheck);\n            return activePasswordSufficientForUserLocked;\n        }\n    }\n\n    @Override\n    public boolean isActivePasswordSufficientForDeviceRequirement() {\n        if (!mHasFeature) {\n            return true;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final int profileUserId = caller.getUserId();\n        Preconditions.checkCallingUser(isManagedProfile(profileUserId));\n\n        // This method is always called on the parent DPM instance to check if its password (i.e.\n        // the device password) is sufficient for all explicit password requirement set on it\n        // So retrieve the parent user Id to which the device password belongs.\n        final int parentUser = getProfileParentId(profileUserId);\n        enforceUserUnlocked(parentUser);\n\n        final boolean isSufficient;\n        synchronized (getLockObject()) {\n\n            int complexity = getAggregatedPasswordComplexityLocked(parentUser, true);\n            PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(parentUser, true);\n\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(parentUser);\n            final List<PasswordValidationError> passwordValidationErrors =\n                    PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n            isSufficient = passwordValidationErrors.isEmpty();\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.IS_ACTIVE_PASSWORD_SUFFICIENT_FOR_DEVICE)\n                .setStrings(mOwners.getProfileOwnerComponent(caller.getUserId()).getPackageName())\n                .write();\n        return isSufficient;\n    }\n\n    @Override\n    public boolean isUsingUnifiedPassword(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n\n        return !isSeparateProfileChallengeEnabled(caller.getUserId());\n    }\n\n    @Override\n    public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                \"You can not check password sufficiency for a managed profile, userId = %d\",\n                userHandle);\n        enforceUserUnlocked(userHandle);\n\n        synchronized (getLockObject()) {\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(userHandle);\n\n            // Combine password policies across the user and its profiles. Profile admins are\n            // included if the profile is to be unified or currently has unified challenge\n            List<ActiveAdmin> admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> user.id == profileUser\n                    || !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n            ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>(admins.size());\n            int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n                maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n            }\n            return PasswordMetrics.validatePasswordMetrics(PasswordMetrics.merge(adminMetrics),\n                    maxRequiredComplexity, metrics).isEmpty();\n        }\n    }\n\n    private boolean isActivePasswordSufficientForUserLocked(\n            boolean passwordValidAtLastCheckpoint, @Nullable PasswordMetrics metrics,\n            int userHandle) {\n        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled() && (metrics == null)) {\n            // Before user enters their password for the first time after a reboot, return the\n            // value of this flag, which tells us whether the password was valid the last time\n            // settings were saved.  If DPC changes password requirements on boot so that the\n            // current password no longer meets the requirements, this value will be stale until\n            // the next time the password is entered.\n            return passwordValidAtLastCheckpoint;\n        }\n\n        if (metrics == null) {\n            // Called on a FBE device when the user password exists but its metrics is unknown.\n            // This shouldn't happen since we enforce the user to be unlocked (which would result\n            // in the metrics known to the framework on a FBE device) at all call sites.\n            throw new IllegalStateException(\"isActivePasswordSufficient called on FBE-locked user\");\n        }\n\n        return isPasswordSufficientForUserWithoutCheckpointLocked(metrics, userHandle);\n    }\n\n    /**\n     * Returns {@code true} if the password represented by the {@code metrics} argument\n     * sufficiently fulfills the password requirements for the user corresponding to\n     * {@code userId}.\n     */\n    private boolean isPasswordSufficientForUserWithoutCheckpointLocked(\n            @NonNull PasswordMetrics metrics, @UserIdInt int userId) {\n        final int complexity = getAggregatedPasswordComplexityLocked(userId);\n        PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userId);\n        final List<PasswordValidationError> passwordValidationErrors =\n                PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n        return passwordValidationErrors.isEmpty();\n    }\n\n    @Override\n    @PasswordComplexity\n    public int getPasswordComplexity(boolean parent) {\n        final CallerIdentity caller = getCallerIdentity();\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_USER_PASSWORD_COMPLEXITY_LEVEL)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT,\n                        mInjector.getPackageManager().getPackagesForUid(caller.getUid()))\n                .write();\n\n        enforceUserUnlocked(caller.getUserId());\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller) || isSystemUid(caller),\n                    \"Only profile owner, device owner and system may call this method on parent.\");\n        } else {\n            if (isPermissionCheckFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                                || hasCallingOrSelfPermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS)\n                                || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                        \"Must have \" + REQUEST_PASSWORD_COMPLEXITY + \" or \" +\n                                MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS\n                                + \" permissions, or be a profile owner or device owner.\");\n            } else {\n                Preconditions.checkCallAuthorization(\n                        hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                                || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                        \"Must have \" + REQUEST_PASSWORD_COMPLEXITY\n                                + \" permission, or be a profile owner or device owner.\");\n            }\n        }\n\n        synchronized (getLockObject()) {\n            final int credentialOwner = getCredentialOwner(caller.getUserId(), parent);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            return metrics == null ? PASSWORD_COMPLEXITY_NONE : metrics.determineComplexity();\n        }\n    }\n\n    @Override\n    public void setRequiredPasswordComplexity(\n            String callerPackageName, int passwordComplexity, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return;\n        }\n        final Set<Integer> allowedModes = Set.of(PASSWORD_COMPLEXITY_NONE, PASSWORD_COMPLEXITY_LOW,\n                PASSWORD_COMPLEXITY_MEDIUM, PASSWORD_COMPLEXITY_HIGH);\n        Preconditions.checkArgument(allowedModes.contains(passwordComplexity),\n                \"Provided complexity is not one of the allowed values.\");\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                // TODO: Make sure this returns the parent of the fake admin\n                // TODO: Deal with null componentname\n                int affectedUser = calledOnParent\n                        ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        null, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUser).getActiveAdmin();\n            } else {\n                admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), calledOnParent);\n            }\n\n            if (admin.mPasswordComplexity != passwordComplexity) {\n                // We require the caller to explicitly clear any password quality requirements set\n                // on the parent DPM instance, to avoid the case where password requirements are\n                // specified in the form of quality on the parent but complexity on the profile\n                // itself.\n                if (!calledOnParent) {\n                    final boolean hasQualityRequirementsOnParent = admin.hasParentActiveAdmin()\n                            && admin.getParentActiveAdmin().mPasswordPolicy.quality\n                            != PASSWORD_QUALITY_UNSPECIFIED;\n                    Preconditions.checkState(!hasQualityRequirementsOnParent,\n                            \"Password quality is set on the parent when attempting to set password\"\n                            + \"complexity. Clear the quality by setting the password quality \"\n                            + \"on the parent to PASSWORD_QUALITY_UNSPECIFIED first\");\n                }\n\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    admin.mPasswordComplexity = passwordComplexity;\n                    // Reset the password policy.\n                    admin.mPasswordPolicy = new PasswordPolicy();\n                    updatePasswordValidityCheckpointLocked(caller.getUserId(), calledOnParent);\n                    updatePasswordQualityCacheForUserGroup(caller.getUserId());\n                    saveSettingsLocked(caller.getUserId());\n                });\n\n\n                //TODO(b/276855301): caller.getPackageName() will be null when the coexistence flags are\n                // turned off. Change back to caller.getPackageName once this API is unflagged.\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.SET_PASSWORD_COMPLEXITY)\n                        .setAdmin(admin.info.getPackageName())\n                        .setInt(passwordComplexity)\n                        .setBoolean(calledOnParent)\n                        .write();\n            }\n            logPasswordComplexityRequiredIfSecurityLogEnabled(caller.getPackageName(),\n                    caller.getUserId(), calledOnParent, passwordComplexity);\n        }\n    }\n\n    private void logPasswordComplexityRequiredIfSecurityLogEnabled(String adminPackageName,\n            int userId,\n            boolean parent, int complexity) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_REQUIRED,\n                    adminPackageName, userId, affectedUserId, complexity);\n        }\n    }\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle) {\n        return getAggregatedPasswordComplexityLocked(userHandle, false);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        ensureLocked();\n        final List<ActiveAdmin> admins;\n        if (deviceWideOnly) {\n            admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> false);\n        } else {\n            admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        }\n        int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n        for (ActiveAdmin admin : admins) {\n            maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n        }\n        return maxRequiredComplexity;\n    }\n\n    @Override\n    public int getRequiredPasswordComplexity(String callerPackageName, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n\n        if (isPermissionCheckFlagEnabled()) {\n            int affectedUser = calledOnParent ? getProfileParentId(caller.getUserId())\n                    : caller.getUserId();\n            enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    callerPackageName, affectedUser);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getParentOfAdminIfRequired(\n                    getDeviceOrProfileOwnerAdminLocked(caller.getUserId()), calledOnParent);\n            return requiredAdmin.mPasswordComplexity;\n        }\n    }\n\n    @Override\n    public int getAggregatedPasswordComplexityForUser(int userId, boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return getAggregatedPasswordComplexityLocked(userId, deviceWideOnly);\n        }\n    }\n\n\n    @Override\n    public int getCurrentFailedPasswordAttempts(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (!isSystemUid(caller)) {\n                // This API can be called by an active device admin or by keyguard code.\n                if (!hasCallingPermission(permission.ACCESS_KEYGUARD_SECURE_STORAGE)) {\n                    if (isPermissionCheckFlagEnabled()) {\n                        int affectedUser = parent ? getProfileParentId(userHandle) : userHandle;\n                        enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                                callerPackageName, affectedUser);\n                    } else {\n                        getActiveAdminForCallerLocked(\n                                null, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n                    }\n                }\n            }\n\n            DevicePolicyData policy = getUserDataUnchecked(getCredentialOwner(userHandle, parent));\n\n            return policy.mFailedPasswordAttempts;\n        }\n    }\n\n    @Override\n    public void setMaximumFailedPasswordsForWipe(\n            ComponentName who, String callerPackageName, int num, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n\n        int userId = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        /*permission=*/ MANAGE_DEVICE_POLICY_WIPE_DATA,\n                        /* adminPolicy=*/ DeviceAdminInfo.USES_POLICY_WIPE_DATA,\n                        caller.getPackageName(), affectedUserId).getActiveAdmin();\n            } else {\n                // This API can only be called by an active device admin,\n                // so try to retrieve it to check that the caller is one.\n                getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_WIPE_DATA, parent);\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n            }\n\n            if (ap.maximumFailedPasswordsForWipe != num) {\n                ap.maximumFailedPasswordsForWipe = num;\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_PASSWORD_ATTEMPTS_SET, callerPackageName,\n                    userId, affectedUserId, num);\n        }\n    }\n\n    @Override\n    public int getMaximumFailedPasswordsForWipe(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = (who != null)\n                    ? getActiveAdminUncheckedLocked(who, userHandle, parent)\n                    : getAdminWithMinimumFailedPasswordsForWipeLocked(userHandle, parent);\n            return admin != null ? admin.maximumFailedPasswordsForWipe : 0;\n        }\n    }\n\n    @Override\n    public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                    userHandle, parent);\n            return admin != null ? getUserIdToWipeForFailedPasswords(admin) : UserHandle.USER_NULL;\n        }\n    }\n\n    /**\n     * Returns the admin with the strictest policy on maximum failed passwords for:\n     * <ul>\n     *   <li>this user if it has a separate profile challenge, or\n     *   <li>this user and all profiles that don't have their own challenge otherwise.\n     * </ul>\n     * <p>If the policy for the primary and any other profile are equal, it returns the admin for\n     * the primary profile. Policy of a PO on an organization-owned device applies to the primary\n     * profile.\n     * Returns {@code null} if no participating admin has that policy set.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private ActiveAdmin getAdminWithMinimumFailedPasswordsForWipeLocked(\n            int userHandle, boolean parent) {\n        int count = 0;\n        ActiveAdmin strictestAdmin = null;\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.maximumFailedPasswordsForWipe ==\n                    ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n                continue;  // No max number of failed passwords policy set for this profile.\n            }\n\n            // We always favor the primary profile if several profiles have the same value set.\n            final int userId = getUserIdToWipeForFailedPasswords(admin);\n            if (count == 0 ||\n                    count > admin.maximumFailedPasswordsForWipe ||\n                    (count == admin.maximumFailedPasswordsForWipe &&\n                            getUserInfo(userId).isPrimary())) {\n                count = admin.maximumFailedPasswordsForWipe;\n                strictestAdmin = admin;\n            }\n        }\n        return strictestAdmin;\n    }\n\n    private UserInfo getUserInfo(@UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mUserManager.getUserInfo(userId));\n    }\n\n    private boolean setPasswordPrivileged(@NonNull String password, int flags,\n            CallerIdentity caller) {\n        // Only allow setting password on an unsecured user\n        if (isLockScreenSecureUnchecked(caller.getUserId())) {\n            throw new SecurityException(\"Cannot change current password\");\n        }\n        return resetPasswordInternal(password, 0, null, flags, caller);\n    }\n\n    @Override\n    public boolean resetPassword(@Nullable String password, int flags) throws RemoteException {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            Slogf.w(LOG_TAG, \"Cannot reset password when the device has no lock screen\");\n            return false;\n        }\n        if (password == null) password = \"\";\n        final CallerIdentity caller = getCallerIdentity();\n        final int userHandle = caller.getUserId();\n\n        // As of R, only privileged caller holding RESET_PASSWORD can call resetPassword() to\n        // set password to an unsecured user.\n        if (hasCallingPermission(permission.RESET_PASSWORD)) {\n            final boolean result = setPasswordPrivileged(password, flags, caller);\n            if (result) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD)\n                        .write();\n            }\n            return result;\n        }\n\n        // If caller has PO (or DO) throw or fail silently depending on its target SDK level.\n        if (isDefaultDeviceOwner(caller) || isProfileOwner(caller)) {\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                if (getTargetSdk(admin.info.getPackageName(), userHandle) < Build.VERSION_CODES.O) {\n                    Slogf.e(LOG_TAG, \"DPC can no longer call resetPassword()\");\n                    return false;\n                }\n                throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n            }\n        }\n\n        // Caller is not DO or PO, could either be unauthorized or Device Admin.\n        synchronized (getLockObject()) {\n            // Legacy device admin cannot call resetPassword either\n            ActiveAdmin admin = getActiveAdminForCallerLocked(\n                    null, DeviceAdminInfo.USES_POLICY_RESET_PASSWORD, false);\n            Preconditions.checkCallAuthorization(admin != null,\n                    \"Unauthorized caller cannot call resetPassword.\");\n            if (getTargetSdk(admin.info.getPackageName(),\n                    userHandle) <= android.os.Build.VERSION_CODES.M) {\n                Slogf.e(LOG_TAG, \"Device admin can no longer call resetPassword()\");\n                return false;\n            }\n            throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n        }\n    }\n\n    private boolean resetPasswordInternal(String password, long tokenHandle, byte[] token,\n            int flags, CallerIdentity caller) {\n        final int callingUid = caller.getUid();\n        final int userHandle = UserHandle.getUserId(callingUid);\n        final boolean isPin = PasswordMetrics.isNumericOnly(password);\n        synchronized (getLockObject()) {\n            final PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userHandle);\n            final List<PasswordValidationError> validationErrors;\n            final int complexity = getAggregatedPasswordComplexityLocked(userHandle);\n            // TODO: Consider changing validation API to take LockscreenCredential.\n            if (password.isEmpty()) {\n                validationErrors = PasswordMetrics.validatePasswordMetrics(\n                        minMetrics, complexity, new PasswordMetrics(CREDENTIAL_TYPE_NONE));\n            } else {\n                // TODO(b/120484642): remove getBytes() below\n                validationErrors = PasswordMetrics.validatePassword(\n                        minMetrics, complexity, isPin, password.getBytes());\n            }\n\n            if (!validationErrors.isEmpty()) {\n                Slogf.w(LOG_TAG, \"Failed to reset password due to constraint violation: %s\",\n                        validationErrors.get(0));\n                return false;\n            }\n        }\n\n        DevicePolicyData policy = getUserData(userHandle);\n        if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {\n            Slogf.w(LOG_TAG, \"resetPassword: already set by another uid and not entered by user\");\n            return false;\n        }\n\n        boolean callerIsDeviceOwnerAdmin = isDefaultDeviceOwner(caller);\n        boolean doNotAskCredentialsOnBoot =\n                (flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;\n        if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {\n            setDoNotAskCredentialsOnBoot();\n        }\n\n        // Don't do this with the lock held, because it is going to call\n        // back in to the service.\n        final long ident = mInjector.binderClearCallingIdentity();\n        final LockscreenCredential newCredential;\n        if (isPin) {\n            newCredential = LockscreenCredential.createPin(password);\n        } else {\n            newCredential = LockscreenCredential.createPasswordOrNone(password);\n        }\n        try {\n            if (tokenHandle == 0 || token == null) {\n                if (!mLockPatternUtils.setLockCredential(newCredential,\n                        LockscreenCredential.createNone(), userHandle)) {\n                    return false;\n                }\n            } else {\n                if (!mLockPatternUtils.setLockCredentialWithToken(newCredential, tokenHandle,\n                        token, userHandle)) {\n                    return false;\n                }\n            }\n            boolean requireEntry = (flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;\n            if (requireEntry) {\n                mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW,\n                        UserHandle.USER_ALL);\n            }\n            synchronized (getLockObject()) {\n                int newOwner = requireEntry ? callingUid : -1;\n                if (policy.mPasswordOwner != newOwner) {\n                    policy.mPasswordOwner = newOwner;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    private boolean isLockScreenSecureUnchecked(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.isSecure(userId));\n    }\n\n    private void setDoNotAskCredentialsOnBoot() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (!policyData.mDoNotAskCredentialsOnBoot) {\n                policyData.mDoNotAskCredentialsOnBoot = true;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public boolean getDoNotAskCredentialsOnBoot() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            return policyData.mDoNotAskCredentialsOnBoot;\n        }\n    }\n\n    @Override\n    public void setMaximumTimeToLock(ComponentName who, String callerPackageName,\n            long timeMs, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        /*permission=*/ MANAGE_DEVICE_POLICY_LOCK,\n                        /*AdminPolicy=*/DeviceAdminInfo.USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        affectedUserId).getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_FORCE_LOCK, parent);\n            }\n\n            if (ap.maximumTimeToUnlock != timeMs) {\n                ap.maximumTimeToUnlock = timeMs;\n                saveSettingsLocked(userHandle);\n                updateMaximumTimeToLockLocked(userHandle);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_SCREEN_LOCK_TIMEOUT_SET,\n                    callerPackageName, userHandle, affectedUserId, timeMs);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateMaximumTimeToLockLocked(@UserIdInt int userId) {\n        // Update the profile's timeout\n        if (isManagedProfile(userId)) {\n            updateProfileLockTimeoutLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Update the device timeout\n            final int parentId = getProfileParentId(userId);\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(parentId));\n\n            final DevicePolicyData policy = getUserDataUnchecked(parentId);\n            if (policy.mLastMaximumTimeToLock == timeMs) {\n                return;\n            }\n            policy.mLastMaximumTimeToLock = timeMs;\n\n            if (policy.mLastMaximumTimeToLock != Long.MAX_VALUE) {\n                // Make sure KEEP_SCREEN_ON is disabled, since that\n                // would allow bypassing of the maximum time to lock.\n                mInjector.settingsGlobalPutInt(Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0);\n            }\n            getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(parentId, timeMs);\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileLockTimeoutLocked(@UserIdInt int userId) {\n        final long timeMs;\n        if (isSeparateProfileChallengeEnabled(userId)) {\n            timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(userId));\n        } else {\n            timeMs = Long.MAX_VALUE;\n        }\n\n        final DevicePolicyData policy = getUserDataUnchecked(userId);\n        if (policy.mLastMaximumTimeToLock == timeMs) {\n            return;\n        }\n        policy.mLastMaximumTimeToLock = timeMs;\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(\n                        userId, policy.mLastMaximumTimeToLock));\n    }\n\n    @Override\n    public long getMaximumTimeToLock(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.maximumTimeToUnlock : 0;\n            }\n            // Return the strictest policy across all participating admins.\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(admins);\n            return timeMs == Long.MAX_VALUE ? 0 : timeMs;\n        }\n    }\n\n    private long getMaximumTimeToLockPolicyFromAdmins(List<ActiveAdmin> admins) {\n        long time = Long.MAX_VALUE;\n        for (final ActiveAdmin admin : admins) {\n            if (admin.maximumTimeToUnlock > 0 && admin.maximumTimeToUnlock < time) {\n                time = admin.maximumTimeToUnlock;\n            }\n        }\n        return time;\n    }\n\n    @Override\n    public void setRequiredStrongAuthTimeout(ComponentName who, String callerPackageName, long timeoutMs,\n            boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Preconditions.checkArgument(timeoutMs >= 0, \"Timeout must not be a negative number.\");\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n        // timeoutMs with value 0 means that the admin doesn't participate\n        // timeoutMs is clamped to the interval in case the internal constants change in the future\n        final long minimumStrongAuthTimeout = getMinimumStrongAuthTimeoutMs();\n        if (timeoutMs != 0 && timeoutMs < minimumStrongAuthTimeout) {\n            timeoutMs = minimumStrongAuthTimeout;\n        }\n        if (timeoutMs > DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            timeoutMs = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n\n        final int userHandle = caller.getUserId();\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                int affectedUser = parent\n                        ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUser).getActiveAdmin();\n            } else {\n                ap = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n            }\n            if (ap.strongAuthUnlockTimeout != timeoutMs) {\n                ap.strongAuthUnlockTimeout = timeoutMs;\n                saveSettingsLocked(userHandle);\n                changed = true;\n            }\n        }\n        if (changed) {\n            mLockSettingsInternal.refreshStrongAuthTimeout(userHandle);\n            // Refreshes the parent if profile has unified challenge, since the timeout would\n            // also affect the parent user in this case.\n            if (isManagedProfile(userHandle) && !isSeparateProfileChallengeEnabled(userHandle)) {\n                mLockSettingsInternal.refreshStrongAuthTimeout(getProfileParentId(userHandle));\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's strong auth unlock timeout or minimum value (strictest) of all\n     * admins if who is null.\n     * Returns 0 if not configured for the provided admin.\n     */\n    @Override\n    public long getRequiredStrongAuthTimeout(ComponentName who, int userId, boolean parent) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            // No strong auth timeout on devices not supporting the\n            // {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature\n            return 0;\n        }\n        synchronized (getLockObject()) {\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId, parent);\n                return admin != null ? admin.strongAuthUnlockTimeout : 0;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userId, parent));\n\n            long strongAuthUnlockTimeout = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n            for (int i = 0; i < admins.size(); i++) {\n                final long timeout = admins.get(i).strongAuthUnlockTimeout;\n                if (timeout != 0) { // take only participating admins into account\n                    strongAuthUnlockTimeout = Math.min(timeout, strongAuthUnlockTimeout);\n                }\n            }\n            return Math.max(strongAuthUnlockTimeout, getMinimumStrongAuthTimeoutMs());\n        }\n    }\n\n    private long getMinimumStrongAuthTimeoutMs() {\n        if (!mInjector.isBuildDebuggable()) {\n            return MINIMUM_STRONG_AUTH_TIMEOUT_MS;\n        }\n        // ideally the property was named persist.sys.min_strong_auth_timeout, but system property\n        // name cannot be longer than 31 characters\n        return Math.min(mInjector.systemPropertiesGetLong(\"persist.sys.min_str_auth_timeo\",\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS),\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS);\n    }\n\n    @Override\n    public void lockNow(int flags, String callerPackageName, boolean parent) {\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n        }\n\n        final int callingUserId = caller.getUserId();\n        ComponentName adminComponent = null;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            // Make sure the caller has any active admin with the right policy or\n            // the required permission.\n            if (isUnicornFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        /* admin= */ null,\n                        /* permission= */ MANAGE_DEVICE_POLICY_LOCK,\n                        USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        getAffectedUser(parent)\n                 ).getActiveAdmin();\n            } else {\n                admin = getActiveAdminOrCheckPermissionForCallerLocked(\n                        null,\n                        DeviceAdminInfo.USES_POLICY_FORCE_LOCK,\n                        parent,\n                        LOCK_DEVICE);\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOCK_NOW);\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                adminComponent = admin == null ? null : admin.info.getComponent();\n                if (adminComponent != null) {\n                    // For Profile Owners only, callers with only permission not allowed.\n                    if ((flags & DevicePolicyManager.FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY) != 0) {\n                        // Evict key\n                        Preconditions.checkCallingUser(isManagedProfile(callingUserId));\n                        Preconditions.checkArgument(!parent,\n                                \"Cannot set FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY for the parent\");\n                        if (!isProfileOwner(adminComponent, callingUserId)) {\n                            throw new SecurityException(\"Only profile owner admins can set \"\n                                    + \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY\");\n                        }\n                        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n                            throw new UnsupportedOperationException(\n                                    \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY only applies to FBE\"\n                                        + \" devices\");\n                        }\n                        mUserManager.evictCredentialEncryptionKey(callingUserId);\n                    }\n                }\n\n                // Lock all users unless this is a managed profile with a separate challenge\n                final int userToLock = (parent || !isSeparateProfileChallengeEnabled(callingUserId)\n                        ? UserHandle.USER_ALL : callingUserId);\n                mLockPatternUtils.requireStrongAuth(\n                        STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW, userToLock);\n\n                // Require authentication for the device or profile\n                if (userToLock == UserHandle.USER_ALL) {\n                    if (mIsAutomotive) {\n                        if (VERBOSE_LOG) {\n                            Slogf.v(LOG_TAG, \"lockNow(): not powering off display on automotive\"\n                                    + \" build\");\n                        }\n                    } else {\n                        // Power off the display\n                        mInjector.powerManagerGoToSleep(SystemClock.uptimeMillis(),\n                                PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN, 0);\n                    }\n                    mInjector.getIWindowManager().lockNow(null);\n                } else {\n                    mInjector.getTrustManager().setDeviceLockedForUser(userToLock, true);\n                }\n\n                if (SecurityLog.isLoggingEnabled() && adminComponent != null) {\n                    final int affectedUserId =\n                            parent ? getProfileParentId(callingUserId) : callingUserId;\n                    SecurityLog.writeEvent(SecurityLog.TAG_REMOTE_LOCK,\n                            adminComponent.getPackageName(), callingUserId, affectedUserId);\n                }\n            } catch (RemoteException e) {\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.LOCK_NOW)\n                .setAdmin(adminComponent)\n                .setInt(flags)\n                .write();\n    }\n\n    @Override\n    public void enforceCanManageCaCerts(ComponentName who, String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n    }\n\n    private boolean canManageCaCerts(CallerIdentity caller) {\n        return (caller.hasAdminComponent() && (isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_INSTALL))\n                || hasCallingOrSelfPermission(MANAGE_CA_CERTIFICATES);\n    }\n\n    @Override\n    public boolean approveCaCert(String alias, int userId, boolean approval) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            Set<String> certs = getUserData(userId).mAcceptedCaCertificates;\n            boolean changed = (approval ? certs.add(alias) : certs.remove(alias));\n            if (!changed) {\n                return false;\n            }\n            saveSettingsLocked(userId);\n        }\n        mCertificateMonitor.onCertificateApprovalsChanged(userId);\n        return true;\n    }\n\n    @Override\n    public boolean isCaCertApproved(String alias, int userId) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getUserData(userId).mAcceptedCaCertificates.contains(alias);\n        }\n    }\n\n    private Set<Integer> removeCaApprovalsIfNeeded(int userId) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        for (UserInfo userInfo : mUserManager.getProfiles(userId)) {\n            boolean isSecure = mLockPatternUtils.isSecure(userInfo.id);\n            if (userInfo.isManagedProfile()){\n                isSecure |= mLockPatternUtils.isSecure(getProfileParentId(userInfo.id));\n            }\n            if (!isSecure) {\n                synchronized (getLockObject()) {\n                    getUserData(userInfo.id).mAcceptedCaCertificates.clear();\n                    affectedUserIds.add(userInfo.id);\n                }\n                mCertificateMonitor.onCertificateApprovalsChanged(userId);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public boolean installCaCert(ComponentName admin, String callerPackage, byte[] certBuffer) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_CA_CERT);\n\n        final String alias = mInjector.binderWithCleanCallingIdentity(() -> {\n            String installedAlias = mCertificateMonitor.installCaCert(\n                    caller.getUserHandle(), certBuffer);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_CA_CERT)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .write();\n            return installedAlias;\n        });\n\n        if (alias == null) {\n            Slogf.w(LOG_TAG, \"Problem installing cert\");\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(caller.getUserId()).mOwnerInstalledCaCerts.add(alias);\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public void uninstallCaCerts(ComponentName admin, String callerPackage, String[] aliases) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_UNINSTALL_CA_CERT);\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mCertificateMonitor.uninstallCaCerts(caller.getUserHandle(), aliases);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.UNINSTALL_CA_CERTS)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .write();\n        });\n\n        synchronized (getLockObject()) {\n            if (getUserData(caller.getUserId()).mOwnerInstalledCaCerts.removeAll(\n                    Arrays.asList(aliases))) {\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean installKeyPair(ComponentName who, String callerPackage, byte[] privKey,\n            byte[] cert, byte[] chain, String alias, boolean requestAccess,\n            boolean isUserSelectable) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        }  else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(!isUserSelectable, \"The credential \"\n                    + \"management app is not allowed to install a user selectable key pair\");\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_KEY_PAIR);\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            final KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle());\n            try {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                if (!keyChain.installKeyPair(privKey, cert, chain, alias, KeyStore.UID_SELF)) {\n                    logInstallKeyPairFailure(caller, isCredentialManagementApp);\n                    return false;\n                }\n                if (requestAccess) {\n                    keyChain.setGrant(caller.getUid(), alias, true);\n                }\n                keyChain.setUserSelectable(alias, isUserSelectable);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.INSTALL_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return true;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Installing certificate\", e);\n            } finally {\n                keyChainConnection.close();\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while installing certificate\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        logInstallKeyPairFailure(caller, isCredentialManagementApp);\n        return false;\n    }\n\n    private void logInstallKeyPairFailure(CallerIdentity caller,\n            boolean isCredentialManagementApp) {\n        if (!isCredentialManagementApp) {\n            return;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.CREDENTIAL_MANAGEMENT_APP_INSTALL_KEY_PAIR_FAILED)\n                .setStrings(caller.getPackageName())\n                .write();\n    }\n\n    @Override\n    public boolean removeKeyPair(ComponentName who, String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        }  else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_KEY_PAIR);\n\n        final long id = Binder.clearCallingIdentity();\n        try {\n            final KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle());\n            try {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.REMOVE_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return keyChain.removeKeyPair(alias);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Removing keypair\", e);\n            } finally {\n                keyChainConnection.close();\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while removing keypair\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean hasKeyPair(String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        Preconditions.checkCallAuthorization(canInstallCertificates(caller)\n                || isCredentialManagementApp);\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                return keyChainConnection.getService().containsKeyPair(alias);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Querying keypair\", e);\n            } catch (InterruptedException e) {\n                Slogf.w(LOG_TAG, \"Interrupted while querying keypair\", e);\n                Thread.currentThread().interrupt();\n            }\n            return false;\n        });\n    }\n\n    private boolean canInstallCertificates(CallerIdentity caller) {\n        if (isPermissionCheckFlagEnabled()) {\n            return hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    caller.getPackageName(), caller.getUserId());\n        }  else {\n            return isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        }\n    }\n\n    private boolean canChooseCertificates(CallerIdentity caller) {\n        return isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                || isCallerDelegate(caller, DELEGATION_CERT_SELECTION);\n    }\n\n    @Override\n    public boolean setKeyGrantToWifiAuth(String callerPackage, String alias, boolean hasGrant) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to grant cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n        try {\n            return setKeyChainGrantInternal(\n                    alias, hasGrant, Process.WIFI_UID, caller.getUserHandle());\n        } catch (IllegalArgumentException e) {\n            if (mInjector.isChangeEnabled(THROW_EXCEPTION_WHEN_KEY_MISSING, caller.getPackageName(),\n                    caller.getUserId())) {\n                throw e;\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isKeyPairGrantedToWifiAuth(String callerPackage, String alias) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to check cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                final List<String> result = new ArrayList<>();\n                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);\n\n                for (final int uid : granteeUids) {\n                    if (uid == Process.WIFI_UID) {\n                        return true;\n                    }\n                }\n                return false;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Querying grant to wifi auth.\", e);\n                return false;\n            }\n        });\n    }\n\n    @Override\n    public boolean setKeyGrantForApp(ComponentName who, String callerPackage, String alias,\n            String packageName, boolean hasGrant) {\n        Preconditions.checkStringNotEmpty(alias, \"Alias to grant cannot be empty\");\n        Preconditions.checkStringNotEmpty(packageName, \"Package to grant to cannot be empty\");\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_SELECTION)));\n\n        final int granteeUid;\n        try {\n            ApplicationInfo ai = mInjector.getIPackageManager().getApplicationInfo(\n                    packageName, 0, caller.getUserId());\n            Preconditions.checkArgument(ai != null,\n                    \"Provided package %s is not installed\", packageName);\n            granteeUid = ai.uid;\n        } catch (RemoteException e) {\n            throw new IllegalStateException(\"Failure getting grantee uid\", e);\n        }\n        try {\n            return setKeyChainGrantInternal(alias, hasGrant, granteeUid, caller.getUserHandle());\n        } catch (IllegalArgumentException e) {\n            if (mInjector.isChangeEnabled(THROW_EXCEPTION_WHEN_KEY_MISSING, callerPackage,\n                    caller.getUserId())) {\n                throw e;\n            }\n            return false;\n        }\n    }\n\n    private boolean setKeyChainGrantInternal(String alias, boolean hasGrant, int granteeUid,\n            UserHandle userHandle) {\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, userHandle)) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n                return keyChain.setGrant(granteeUid, alias, hasGrant);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Setting grant for package.\", e);\n                return false;\n            }\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while setting key grant\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public ParcelableGranteeMap getKeyPairGrants(String callerPackage, String alias) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(canChooseCertificates(caller));\n\n        final ArrayMap<Integer, Set<String>> result = new ArrayMap<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection keyChainConnection =\n                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);\n                final PackageManager pm = mInjector.getPackageManager(caller.getUserId());\n\n                for (final int uid : granteeUids) {\n                    final String[] packages = pm.getPackagesForUid(uid);\n                    if (packages == null) {\n                        Slogf.wtf(LOG_TAG, \"No packages found for uid \" + uid);\n                        continue;\n                    }\n                    result.put(uid, new ArraySet<String>(packages));\n                }\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Querying keypair grants\", e);\n            } catch (InterruptedException e) {\n                Slogf.w(LOG_TAG, \"Interrupted while querying keypair grants\", e);\n                Thread.currentThread().interrupt();\n            }\n        });\n        return new ParcelableGranteeMap(result);\n    }\n\n    @VisibleForTesting\n    public static int[] translateIdAttestationFlags(\n            int idAttestationFlags) {\n        Map<Integer, Integer> idTypeToAttestationFlag = new HashMap();\n        idTypeToAttestationFlag.put(ID_TYPE_SERIAL, AttestationUtils.ID_TYPE_SERIAL);\n        idTypeToAttestationFlag.put(ID_TYPE_IMEI, AttestationUtils.ID_TYPE_IMEI);\n        idTypeToAttestationFlag.put(ID_TYPE_MEID, AttestationUtils.ID_TYPE_MEID);\n        idTypeToAttestationFlag.put(\n                ID_TYPE_INDIVIDUAL_ATTESTATION, USE_INDIVIDUAL_ATTESTATION);\n\n        int numFlagsSet = Integer.bitCount(idAttestationFlags);\n        // No flags are set - return null to indicate no device ID attestation information should\n        // be included in the attestation record.\n        if (numFlagsSet == 0) {\n            return null;\n        }\n\n        // If the ID_TYPE_BASE_INFO is set, make sure that a non-null array is returned, even if\n        // no other flag is set. That will lead to inclusion of general device make data in the\n        // attestation record, but no specific device identifiers.\n        if ((idAttestationFlags & ID_TYPE_BASE_INFO) != 0) {\n            numFlagsSet -= 1;\n            idAttestationFlags = idAttestationFlags & (~ID_TYPE_BASE_INFO);\n        }\n\n        int[] attestationUtilsFlags = new int[numFlagsSet];\n        int i = 0;\n        for (Integer idType: idTypeToAttestationFlag.keySet()) {\n            if ((idType & idAttestationFlags) != 0) {\n                attestationUtilsFlags[i++] = idTypeToAttestationFlag.get(idType);\n            }\n        }\n\n        return attestationUtilsFlags;\n    }\n\n    @Override\n    public boolean generateKeyPair(ComponentName who, String callerPackage, String algorithm,\n            ParcelableKeyGenParameterSpec parcelableKeySpec, int idAttestationFlags,\n            KeymasterCertificateChain attestationChain) {\n        // Get attestation flags, if any.\n        final int[] attestationUtilsFlags = translateIdAttestationFlags(idAttestationFlags);\n        final boolean deviceIdAttestationRequired = attestationUtilsFlags != null;\n        KeyGenParameterSpec keySpec = parcelableKeySpec.getSpec();\n        final String alias = keySpec.getKeystoreAlias();\n        Preconditions.checkStringNotEmpty(alias, \"Empty alias provided\");\n        Preconditions.checkArgument(\n                !deviceIdAttestationRequired || keySpec.getAttestationChallenge() != null,\n                \"Requested Device ID attestation but challenge is empty\");\n\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (deviceIdAttestationRequired && attestationUtilsFlags.length > 0) {\n            Preconditions.checkCallAuthorization(hasDeviceIdAccessUnchecked(\n                    caller.getPackageName(), caller.getUid()));\n            enforceIndividualAttestationSupportedIfRequested(attestationUtilsFlags);\n        } else {\n            if (isPermissionCheckFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                                caller.getPackageName(), caller.getUserId())\n                                || isCredentialManagementApp);\n            }  else {\n                Preconditions.checkCallAuthorization((caller.hasAdminComponent() && (isProfileOwner(\n                        caller) || isDefaultDeviceOwner(caller))) || (caller.hasPackage() && (\n                        isCallerDelegate || isCredentialManagementApp)));\n            }\n            if (isCredentialManagementApp) {\n                Preconditions.checkCallAuthorization(\n                        isAliasInCredentialManagementAppPolicy(caller, alias),\n                        CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n            }\n        }\n\n        if (TextUtils.isEmpty(alias)) {\n            throw new IllegalArgumentException(\"Empty alias provided.\");\n        }\n        // As the caller will be granted access to the key, ensure no UID was specified, as\n        // it will not have the desired effect.\n        if (keySpec.getUid() != KeyStore.UID_SELF) {\n            Slogf.e(LOG_TAG, \"Only the caller can be granted access to the generated keypair.\");\n            logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n            return false;\n        }\n\n        if (deviceIdAttestationRequired) {\n            if (keySpec.getAttestationChallenge() == null) {\n                throw new IllegalArgumentException(\n                        \"Requested Device ID attestation but challenge is empty.\");\n            }\n            KeyGenParameterSpec.Builder specBuilder = new KeyGenParameterSpec.Builder(keySpec);\n            specBuilder.setAttestationIds(attestationUtilsFlags);\n            specBuilder.setDevicePropertiesAttestationIncluded(true);\n            keySpec = specBuilder.build();\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            try (KeyChainConnection keyChainConnection =\n                    KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n                IKeyChainService keyChain = keyChainConnection.getService();\n\n                final int generationResult = keyChain.generateKeyPair(algorithm,\n                        new ParcelableKeyGenParameterSpec(keySpec));\n                if (generationResult != KeyChain.KEY_GEN_SUCCESS) {\n                    Slogf.e(LOG_TAG, \"KeyChain failed to generate a keypair, error %d.\",\n                            generationResult);\n                    logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n                    switch (generationResult) {\n                        case KeyChain.KEY_GEN_STRONGBOX_UNAVAILABLE:\n                            throw new ServiceSpecificException(\n                                    DevicePolicyManager.KEY_GEN_STRONGBOX_UNAVAILABLE,\n                                    String.format(\"KeyChain error: %d\", generationResult));\n                        case KeyChain.KEY_ATTESTATION_CANNOT_ATTEST_IDS:\n                            throw new UnsupportedOperationException(\n                                \"Device does not support Device ID attestation.\");\n                        default:\n                            return false;\n                    }\n                }\n\n                // Set a grant for the caller here so that when the client calls\n                // requestPrivateKey, it will be able to get the key from Keystore.\n                // Note the use of the calling  UID, since the request for the private\n                // key will come from the client's process, so the grant has to be for\n                // that UID.\n                keyChain.setGrant(caller.getUid(), alias, true);\n\n                try {\n                    final List<byte[]> encodedCerts = new ArrayList();\n                    final CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n                    final byte[] certChainBytes = keyChain.getCaCertificates(alias);\n                    encodedCerts.add(keyChain.getCertificate(alias));\n                    if (certChainBytes != null) {\n                        final Collection<X509Certificate> certs =\n                                (Collection<X509Certificate>) certFactory.generateCertificates(\n                                    new ByteArrayInputStream(certChainBytes));\n                        for (X509Certificate cert : certs) {\n                            encodedCerts.add(cert.getEncoded());\n                        }\n                    }\n\n                    attestationChain.shallowCopyFrom(new KeymasterCertificateChain(encodedCerts));\n                } catch (CertificateException e) {\n                    logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n                    Slogf.e(LOG_TAG, \"While retrieving certificate chain.\", e);\n                    return false;\n                }\n\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.GENERATE_KEY_PAIR)\n                        .setAdmin(caller.getPackageName())\n                        .setBoolean(/* isDelegate */ isCallerDelegate)\n                        .setInt(idAttestationFlags)\n                        .setStrings(algorithm, isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                        .write();\n                return true;\n            }\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"KeyChain error while generating a keypair\", e);\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while generating keypair\", e);\n            Thread.currentThread().interrupt();\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        logGenerateKeyPairFailure(caller, isCredentialManagementApp);\n        return false;\n    }\n\n    private void logGenerateKeyPairFailure(CallerIdentity caller,\n            boolean isCredentialManagementApp) {\n        if (!isCredentialManagementApp) {\n            return;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.CREDENTIAL_MANAGEMENT_APP_GENERATE_KEY_PAIR_FAILED)\n                .setStrings(caller.getPackageName())\n                .write();\n    }\n\n    private void enforceIndividualAttestationSupportedIfRequested(int[] attestationUtilsFlags) {\n        for (int attestationFlag : attestationUtilsFlags) {\n            if (attestationFlag == USE_INDIVIDUAL_ATTESTATION\n                    && !mInjector.getPackageManager().hasSystemFeature(\n                    PackageManager.FEATURE_DEVICE_UNIQUE_ATTESTATION)) {\n                throw new UnsupportedOperationException(\"Device Individual attestation is not \"\n                        + \"supported on this device.\");\n            }\n        }\n    }\n\n    @Override\n    public boolean setKeyPairCertificate(ComponentName who, String callerPackage, String alias,\n            byte[] cert, byte[] chain, boolean isUserSelectable) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try (final KeyChainConnection keyChainConnection =\n                KeyChain.bindAsUser(mContext, caller.getUserHandle())) {\n            IKeyChainService keyChain = keyChainConnection.getService();\n            if (!keyChain.setKeyPairCertificate(alias, cert, chain)) {\n                return false;\n            }\n            keyChain.setUserSelectable(alias, isUserSelectable);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_KEY_PAIR_CERTIFICATE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ isCallerDelegate)\n                    .setStrings(isCredentialManagementApp\n                            ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                    .write();\n            return true;\n        } catch (InterruptedException e) {\n            Slogf.w(LOG_TAG, \"Interrupted while setting keypair certificate\", e);\n            Thread.currentThread().interrupt();\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"Failed setting keypair certificate\", e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return false;\n    }\n\n    @Override\n    public void choosePrivateKeyAlias(final int uid, final Uri uri, final String alias,\n            final IBinder response) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"choose private key alias\"));\n\n        // If there is a profile owner, redirect to that; otherwise query the device owner.\n        ComponentName aliasChooser = getProfileOwnerAsUser(caller.getUserId());\n        if (aliasChooser == null && caller.getUserHandle().isSystem()) {\n            synchronized (getLockObject()) {\n                final ActiveAdmin deviceOwnerAdmin = getDeviceOwnerAdminLocked();\n                if (deviceOwnerAdmin != null) {\n                    aliasChooser = deviceOwnerAdmin.info.getComponent();\n                }\n            }\n        }\n        if (aliasChooser == null) {\n            sendPrivateKeyAliasResponse(null, response);\n            return;\n        }\n\n        Intent intent = new Intent(DeviceAdminReceiver.ACTION_CHOOSE_PRIVATE_KEY_ALIAS);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, uid);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_URI, uri);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_ALIAS, alias);\n        intent.putExtra(DeviceAdminReceiver.EXTRA_CHOOSE_PRIVATE_KEY_RESPONSE, response);\n        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n\n        final ComponentName delegateReceiver;\n        delegateReceiver = resolveDelegateReceiver(DELEGATION_CERT_SELECTION,\n                DeviceAdminReceiver.ACTION_CHOOSE_PRIVATE_KEY_ALIAS, caller.getUserId());\n\n        final boolean isDelegate;\n        if (delegateReceiver != null) {\n            intent.setComponent(delegateReceiver);\n            isDelegate = true;\n        } else {\n            intent.setComponent(aliasChooser);\n            isDelegate = false;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mContext.sendOrderedBroadcastAsUser(intent, caller.getUserHandle(), null,\n                    new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final String chosenAlias = getResultData();\n                    sendPrivateKeyAliasResponse(chosenAlias, response);\n                }\n            }, null, Activity.RESULT_OK, null, null);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.CHOOSE_PRIVATE_KEY_ALIAS)\n                    .setAdmin(intent.getComponent())\n                    .setBoolean(isDelegate)\n                    .write();\n        });\n    }\n\n    private void sendPrivateKeyAliasResponse(final String alias, final IBinder responseBinder) {\n        final IKeyChainAliasCallback keyChainAliasResponse =\n                IKeyChainAliasCallback.Stub.asInterface(responseBinder);\n        // Send the response. It's OK to do this from the main thread because IKeyChainAliasCallback\n        // is oneway, which means it won't block if the recipient lives in another process.\n        try {\n            keyChainAliasResponse.alias(alias);\n        } catch (Exception e) {\n            // Caller could throw RuntimeException or RemoteException back across processes. Catch\n            // everything just to be sure.\n            Slogf.e(LOG_TAG, \"error while responding to callback\", e);\n        }\n    }\n\n    /**\n     * Determine whether DPMS should check if a delegate package is already installed before\n     * granting it new delegations via {@link #setDelegatedScopes}.\n     */\n    private static boolean shouldCheckIfDelegatePackageIsInstalled(String delegatePackage,\n            int targetSdk, List<String> scopes) {\n        // 1) Never skip is installed check from N.\n        if (targetSdk >= Build.VERSION_CODES.N) {\n            return true;\n        }\n        // 2) Skip if DELEGATION_CERT_INSTALL is the only scope being given.\n        if (scopes.size() == 1 && scopes.get(0).equals(DELEGATION_CERT_INSTALL)) {\n            return false;\n        }\n        // 3) Skip if all previously granted scopes are being cleared.\n        if (scopes.isEmpty()) {\n            return false;\n        }\n        // Otherwise it should check that delegatePackage is installed.\n        return true;\n    }\n\n    /**\n     * Set the scopes of a device owner or profile owner delegate.\n     *\n     * @param who the device owner or profile owner.\n     * @param delegatePackage the name of the delegate package.\n     * @param scopeList the list of delegation scopes to be given to the delegate package.\n     */\n    @Override\n    public void setDelegatedScopes(ComponentName who, String delegatePackage,\n            List<String> scopeList) throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(delegatePackage, \"Delegate package is null or empty\");\n        Preconditions.checkCollectionElementsNotNull(scopeList, \"Scopes\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        // Remove possible duplicates.\n        final ArrayList<String> scopes = new ArrayList(new ArraySet(scopeList));\n        // Ensure given scopes are valid.\n        if (scopes.retainAll(Arrays.asList(DELEGATIONS))) {\n            throw new IllegalArgumentException(\"Unexpected delegation scopes\");\n        }\n        // Retrieve the user ID of the calling process.\n        final int userId = caller.getUserId();\n        // Ensure calling process is device/profile owner.\n        if (!Collections.disjoint(scopes, DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS)) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || (isProfileOwner(caller) && isManagedProfile(caller.getUserId())));\n        } else if (!Collections.disjoint(\n                scopes, DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS)) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            // Ensure the delegate is installed (skip this for DELEGATION_CERT_INSTALL in pre-N).\n            if (shouldCheckIfDelegatePackageIsInstalled(delegatePackage,\n                        getTargetSdk(who.getPackageName(), userId), scopes)) {\n                // Throw when the delegate package is not installed.\n                if (!isPackageInstalledForUser(delegatePackage, userId)) {\n                    throw new IllegalArgumentException(\"Package \" + delegatePackage\n                            + \" is not installed on the current user\");\n                }\n            }\n\n            // Set the new delegate in user policies.\n            final DevicePolicyData policy = getUserData(userId);\n            List<String> exclusiveScopes = null;\n            if (!scopes.isEmpty()) {\n                policy.mDelegationMap.put(delegatePackage, new ArrayList<>(scopes));\n                exclusiveScopes = new ArrayList<>(scopes);\n                exclusiveScopes.retainAll(EXCLUSIVE_DELEGATIONS);\n            } else {\n                // Remove any delegation info if the given scopes list is empty.\n                policy.mDelegationMap.remove(delegatePackage);\n            }\n            sendDelegationChangedBroadcast(delegatePackage, scopes, userId);\n\n            // If set, remove exclusive scopes from all other delegates\n            if (exclusiveScopes != null && !exclusiveScopes.isEmpty()) {\n                for (int i = policy.mDelegationMap.size() - 1; i >= 0; --i) {\n                    final String currentPackage = policy.mDelegationMap.keyAt(i);\n                    final List<String> currentScopes = policy.mDelegationMap.valueAt(i);\n\n                    if (!currentPackage.equals(delegatePackage)) {\n                        // Iterate through all other delegates\n                        if (currentScopes.removeAll(exclusiveScopes)) {\n                            // And if this delegate had some exclusive scopes which are now moved\n                            // to the new delegate, notify about its delegation changes.\n                            if (currentScopes.isEmpty()) {\n                                policy.mDelegationMap.removeAt(i);\n                            }\n                            sendDelegationChangedBroadcast(currentPackage,\n                                    new ArrayList<>(currentScopes), userId);\n                        }\n                    }\n                }\n            }\n            // Persist updates.\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void sendDelegationChangedBroadcast(String delegatePackage, ArrayList<String> scopes,\n            int userId) {\n        // Notify delegate package of updates.\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED);\n        // Only call receivers registered with Context#registerReceiver (don\u2019t wake delegate).\n        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        // Limit components this intent resolves to to the delegate package.\n        intent.setPackage(delegatePackage);\n        // Include the list of delegated scopes as an extra.\n        intent.putStringArrayListExtra(DevicePolicyManager.EXTRA_DELEGATION_SCOPES, scopes);\n        // Send the broadcast.\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    /**\n     * Get the delegation scopes given to a delegate package by a device owner or profile owner.\n     *\n     * A DO/PO can get the scopes of any package. A non DO/PO package can get its own scopes by\n     * passing in {@code null} as the {@code who} parameter and its own name as the\n     * {@code delegatepackage}.\n     *\n     * @param who the device owner or profile owner, or {@code null} if the caller is\n     *            {@code delegatePackage}.\n     * @param delegatePackage the name of the delegate package whose scopes are to be retrieved.\n     * @return a list of the delegation scopes currently given to {@code delegatePackage}.\n     */\n    @Override\n    @NonNull\n    public List<String> getDelegatedScopes(ComponentName who,\n            String delegatePackage) throws SecurityException {\n        Objects.requireNonNull(delegatePackage, \"Delegate package is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        // Ensure the caller may call this method:\n        // * Either it's a profile owner / device owner, if componentName is provided\n        // * Or it's an app querying its own delegation scopes\n        if (caller.hasAdminComponent()) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isPackage(caller, delegatePackage),\n                    String.format(\"Caller with uid %d is not %s\", caller.getUid(),\n                            delegatePackage));\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the scopes assigned to delegatePackage, or null if no scope was given.\n            final List<String> scopes = policy.mDelegationMap.get(delegatePackage);\n            return scopes == null ? Collections.EMPTY_LIST : scopes;\n        }\n    }\n\n    /**\n     * Get a list of  packages that were given a specific delegation scopes by a device owner or\n     * profile owner.\n     *\n     * @param who the device owner or profile owner.\n     * @param scope the scope whose delegates are to be retrieved.\n     * @return a list of the delegate packages currently given the {@code scope} delegation.\n     */\n    @NonNull\n    public List<String> getDelegatePackages(ComponentName who, String scope)\n            throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(scope, \"Scope is null\");\n        if (!Arrays.asList(DELEGATIONS).contains(scope)) {\n            throw new IllegalArgumentException(\"Unexpected delegation scope: \" + scope);\n        }\n\n        // Retrieve the user ID of the calling process.\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        synchronized (getLockObject()) {\n            return getDelegatePackagesInternalLocked(scope, caller.getUserId());\n        }\n    }\n\n    private List<String> getDelegatePackagesInternalLocked(String scope, int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n\n        // Create a list to hold the resulting delegate packages.\n        final List<String> delegatePackagesWithScope = new ArrayList<>();\n        // Add all delegations containing scope to the result list.\n        for (int i = 0; i < policy.mDelegationMap.size(); i++) {\n            if (policy.mDelegationMap.valueAt(i).contains(scope)) {\n                delegatePackagesWithScope.add(policy.mDelegationMap.keyAt(i));\n            }\n        }\n        return delegatePackagesWithScope;\n    }\n\n    /**\n     * Return the ComponentName of the receiver that handles the given broadcast action, from\n     * the app that holds the given delegation capability. If the app defines multiple receivers\n     * with the same intent action filter, will return any one of them nondeterministically.\n     *\n     * @return ComponentName of the receiver or {@null} if none exists.\n     */\n    private ComponentName resolveDelegateReceiver(String scope, String action, int userId) {\n\n        final List<String> delegates;\n        synchronized (getLockObject()) {\n            delegates = getDelegatePackagesInternalLocked(scope, userId);\n        }\n        if (delegates.size() == 0) {\n            return null;\n        } else if (delegates.size() > 1) {\n            Slogf.wtf(LOG_TAG, \"More than one delegate holds \" + scope);\n            return null;\n        }\n        final String pkg = delegates.get(0);\n        Intent intent = new Intent(action);\n        intent.setPackage(pkg);\n        final List<ResolveInfo> receivers;\n        try {\n            receivers = mIPackageManager.queryIntentReceivers(\n                    intent, null, 0, userId).getList();\n        } catch (RemoteException e) {\n            return null;\n        }\n        final int count = receivers.size();\n        if (count >= 1) {\n            if (count > 1) {\n                Slogf.w(LOG_TAG, pkg + \" defines more than one delegate receiver for \" + action);\n            }\n            return receivers.get(0).activityInfo.getComponentName();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated a given scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that {@code callerPackage} was granted {@code scope} delegation and\n     * then comparing the calling UID with the UID of {@code callerPackage} as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param callerPackage the name of the package that is trying to invoke a function in the DPMS.\n     * @param scope the delegation scope to be checked.\n     * @return {@code true} if the calling process is a delegate of {@code scope}.\n     */\n    private boolean isCallerDelegate(String callerPackage, int callerUid, String scope) {\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n        if (!Arrays.asList(DELEGATIONS).contains(scope)) {\n            throw new IllegalArgumentException(\"Unexpected delegation scope: \" + scope);\n        }\n\n        // Retrieve the UID and user ID of the calling process.\n        final int userId = UserHandle.getUserId(callerUid);\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(userId);\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(callerPackage);\n            // Check callingUid only if callerPackage has the required scope delegation.\n            if (scopes != null && scopes.contains(scope)) {\n                // Return true if the caller is actually callerPackage.\n                return isCallingFromPackage(callerPackage, callerUid);\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated a given scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that the calling package was granted {@code scope} delegation and\n     * then comparing the calling UID with the UID of the calling package as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param caller the calling identity\n     * @param scope the delegation scope to be checked.\n     * @return {@code true} if the calling process is a delegate of {@code scope}.\n     */\n    private boolean isCallerDelegate(CallerIdentity caller, String scope) {\n        if (caller.getPackageName() == null) {\n            return false;\n        }\n        Preconditions.checkArgument(Arrays.asList(DELEGATIONS).contains(scope),\n                \"Unexpected delegation scope: %s\", scope);\n\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(caller.getPackageName());\n            // Check callingUid only if callerPackage has the required scope delegation.\n            return scopes != null && scopes.contains(scope);\n        }\n    }\n\n    /**\n     * Check whether a caller application has been delegated any scope via\n     * {@link #setDelegatedScopes} to access privileged APIs on the behalf of a profile owner or\n     * device owner.\n     * <p>\n     * This is done by checking that the calling package was granted any scope delegations and\n     * then comparing the calling UID with the UID of the calling package as reported by\n     * {@link PackageManager#getPackageUidAsUser}.\n     *\n     * @param caller the calling identity\n     * @return {@code true} if the calling process is a delegate of any scope.\n     */\n    private boolean isCallerDelegate(CallerIdentity caller) {\n        Objects.requireNonNull(caller.getPackageName(), \"callerPackage is null\");\n\n        synchronized (getLockObject()) {\n            // Retrieve user policy data.\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            // Retrieve the list of delegation scopes granted to callerPackage.\n            final List<String> scopes = policy.mDelegationMap.get(caller.getPackageName());\n            // Check callingUid only if callerPackage has the required scope delegation.\n            return scopes != null;\n        }\n    }\n\n    /**\n     * Helper function to preserve delegation behavior pre-O when using the deprecated functions\n     * {@code #setCertInstallerPackage} and {@code #setApplicationRestrictionsManagingPackage}.\n     */\n    private void setDelegatedScopePreO(ComponentName who,\n            String delegatePackage, String scope) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // Ensure calling process is device/profile owner.\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n\n            if (delegatePackage != null) {\n                // Set package as a delegate for scope if it is not already one.\n                List<String> scopes = policy.mDelegationMap.get(delegatePackage);\n                if (scopes == null) {\n                    scopes = new ArrayList<>();\n                }\n                if (!scopes.contains(scope)) {\n                    scopes.add(scope);\n                    setDelegatedScopes(who, delegatePackage, scopes);\n                }\n            }\n\n            // Clear any existing scope delegates.\n            for (int i = 0; i < policy.mDelegationMap.size(); i++) {\n                final String currentPackage = policy.mDelegationMap.keyAt(i);\n                final List<String> currentScopes = policy.mDelegationMap.valueAt(i);\n\n                if (!currentPackage.equals(delegatePackage) && currentScopes.contains(scope)) {\n                    final List<String> newScopes = new ArrayList(currentScopes);\n                    newScopes.remove(scope);\n                    setDelegatedScopes(who, currentPackage, newScopes);\n                }\n            }\n        }\n    }\n\n    /**\n     * Check whether a caller application is the credential management app, which can access\n     * privileged APIs.\n     * <p>\n     * This is done by checking that the calling package is authorized to perform the app operation\n     * {@link android.app.AppOpsManager#OP_MANAGE_CREDENTIALS}.\n     *\n     * @param caller the calling identity\n     * @return {@code true} if the calling process is the credential management app.\n     */\n    private boolean isCredentialManagementApp(CallerIdentity caller) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            AppOpsManager appOpsManager = mInjector.getAppOpsManager();\n            if (appOpsManager == null) return false;\n            return appOpsManager.noteOpNoThrow(AppOpsManager.OP_MANAGE_CREDENTIALS, caller.getUid(),\n                    caller.getPackageName(), null, null) == AppOpsManager.MODE_ALLOWED;\n        });\n    }\n\n    /**\n     * If the caller is the credential management app, the alias provided must be contained\n     * in the aliases specified in the credential management app's authentication policy.\n     */\n    private boolean isAliasInCredentialManagementAppPolicy(CallerIdentity caller, String alias) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try (KeyChainConnection connection = KeyChain.bindAsUser(mContext,\n                    caller.getUserHandle())) {\n                // The policy will be null if there is no credential management app\n                AppUriAuthenticationPolicy policy =\n                        connection.getService().getCredentialManagementAppPolicy();\n                return policy != null && !policy.getAppAndUriMappings().isEmpty()\n                        && containsAlias(policy, alias);\n            } catch (RemoteException | InterruptedException e) {\n                return false;\n            }\n        });\n    }\n\n    private static boolean containsAlias(AppUriAuthenticationPolicy policy, String alias) {\n        for (Map.Entry<String, Map<Uri, String>> appsToUris :\n                policy.getAppAndUriMappings().entrySet()) {\n            for (Map.Entry<Uri, String> urisToAliases : appsToUris.getValue().entrySet()) {\n                if (urisToAliases.getValue().equals(alias)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setCertInstallerPackage(ComponentName who, String installerPackage)\n            throws SecurityException {\n        setDelegatedScopePreO(who, installerPackage, DELEGATION_CERT_INSTALL);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CERT_INSTALLER_PACKAGE)\n                .setAdmin(who)\n                .setStrings(installerPackage)\n                .write();\n    }\n\n    @Override\n    public String getCertInstallerPackage(ComponentName who) throws SecurityException {\n        final List<String> delegatePackages = getDelegatePackages(who, DELEGATION_CERT_INSTALL);\n        return delegatePackages.size() > 0 ? delegatePackages.get(0) : null;\n    }\n\n    /**\n     * @return {@code true} if the package is installed and set as always-on, {@code false} if it is\n     * not installed and therefore not available.\n     *\n     * @throws SecurityException if the caller is not a profile or device owner.\n     * @throws UnsupportedOperationException if the package does not support being set as always-on.\n     */\n    @Override\n    public boolean setAlwaysOnVpnPackage(ComponentName who, String vpnPackage, boolean lockdown,\n            List<String> lockdownAllowlist)\n            throws SecurityException {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_ALWAYS_ON_VPN_PACKAGE);\n\n        if (vpnPackage == null) {\n            final String prevVpnPackage;\n            synchronized (getLockObject()) {\n                prevVpnPackage = getProfileOwnerOrDeviceOwnerLocked(\n                        caller.getUserId()).mAlwaysOnVpnPackage;\n                // If the admin is clearing VPN package but hasn't configure any VPN previously,\n                // ignore it so that it doesn't interfere with user-configured VPNs.\n                if (TextUtils.isEmpty(prevVpnPackage)) {\n                    return true;\n                }\n            }\n            revokeVpnAuthorizationForPackage(prevVpnPackage, caller.getUserId());\n        }\n\n        final int userId = caller.getUserId();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (vpnPackage != null && !isPackageInstalledForUser(vpnPackage, userId)) {\n                Slogf.w(LOG_TAG, \"Non-existent VPN package specified: \" + vpnPackage);\n                throw new ServiceSpecificException(\n                        DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, vpnPackage);\n            }\n\n            if (vpnPackage != null && lockdown && lockdownAllowlist != null) {\n                for (String packageName : lockdownAllowlist) {\n                    if (!isPackageInstalledForUser(packageName, userId)) {\n                        Slogf.w(LOG_TAG, \"Non-existent package in VPN allowlist: \" + packageName);\n                        throw new ServiceSpecificException(\n                                DevicePolicyManager.ERROR_VPN_PACKAGE_NOT_FOUND, packageName);\n                    }\n                }\n            }\n            // If some package is uninstalled after the check above, it will be ignored by CM.\n            if (!mInjector.getVpnManager().setAlwaysOnVpnPackageForUser(\n                    userId, vpnPackage, lockdown, lockdownAllowlist)) {\n                throw new UnsupportedOperationException();\n            }\n        });\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ALWAYS_ON_VPN_PACKAGE)\n                .setAdmin(caller.getComponentName())\n                .setStrings(vpnPackage)\n                .setBoolean(lockdown)\n                .setInt(lockdownAllowlist != null ? lockdownAllowlist.size() : 0)\n                .write();\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (!TextUtils.equals(vpnPackage, admin.mAlwaysOnVpnPackage)\n                    || lockdown != admin.mAlwaysOnVpnLockdown) {\n                admin.mAlwaysOnVpnPackage = vpnPackage;\n                admin.mAlwaysOnVpnLockdown = lockdown;\n                saveSettingsLocked(userId);\n            }\n        }\n        return true;\n    }\n\n    private void revokeVpnAuthorizationForPackage(String vpnPackage, int userId) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                final ApplicationInfo ai = mIPackageManager.getApplicationInfo(\n                        vpnPackage, /* flags= */ 0, userId);\n                if (ai == null) {\n                    Slogf.w(LOG_TAG, \"Non-existent VPN package: \" + vpnPackage);\n                } else {\n                    mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN,\n                            ai.uid, vpnPackage, MODE_DEFAULT);\n                }\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Can't talk to package managed\", e);\n            }\n        });\n    }\n\n    @Override\n    public String getAlwaysOnVpnPackage(ComponentName admin) throws SecurityException {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getVpnManager().getAlwaysOnVpnPackageForUser(caller.getUserId()));\n    }\n\n    @Override\n    public String getAlwaysOnVpnPackageForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call getAlwaysOnVpnPackageForUser\"));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            return admin != null ? admin.mAlwaysOnVpnPackage : null;\n        }\n    }\n\n    @Override\n    public boolean isAlwaysOnVpnLockdownEnabled(ComponentName admin) throws SecurityException {\n        final CallerIdentity caller;\n        if (hasCallingPermission(PERMISSION_MAINLINE_NETWORK_STACK)) {\n            // TODO: CaptivePortalLoginActivity erroneously calls this method with a non-admin\n            // ComponentName, so we have to use a separate code path for it:\n            // getCallerIdentity(admin) will throw if the admin is not in the known admin list.\n            caller = getCallerIdentity();\n        } else {\n            caller = getCallerIdentity(admin);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getVpnManager().isVpnLockdownEnabled(caller.getUserId()));\n    }\n\n    @Override\n    public boolean isAlwaysOnVpnLockdownEnabledForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call isAlwaysOnVpnLockdownEnabledForUser\"));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            return admin != null && admin.mAlwaysOnVpnLockdown;\n        }\n    }\n\n    @Override\n    public List<String> getAlwaysOnVpnLockdownAllowlist(ComponentName admin)\n            throws SecurityException {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getVpnManager().getVpnLockdownAllowlist(caller.getUserId()));\n    }\n\n    private void forceWipeDeviceNoLock(boolean wipeExtRequested, String reason, boolean wipeEuicc,\n            boolean wipeResetProtectionData) {\n        wtfIfInLock();\n        boolean success = false;\n\n        try {\n            boolean delayed = !mInjector.recoverySystemRebootWipeUserData(\n                    /* shutdown= */ false, reason, /* force= */ true, /* wipeEuicc= */ wipeEuicc,\n                    wipeExtRequested, wipeResetProtectionData);\n            if (delayed) {\n                // Persist the request so the device is automatically factory-reset on next start if\n                // the system crashes or reboots before the {@code DevicePolicySafetyChecker} calls\n                // its callback.\n                Slogf.i(LOG_TAG, \"Persisting factory reset request as it could be delayed by %s\",\n                        mSafetyChecker);\n                synchronized (getLockObject()) {\n                    DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n                    policy.setDelayedFactoryReset(reason, wipeExtRequested, wipeEuicc,\n                            wipeResetProtectionData);\n                    saveSettingsLocked(UserHandle.USER_SYSTEM);\n                }\n            }\n            success = true;\n        } catch (IOException | SecurityException e) {\n            Slogf.w(LOG_TAG, \"Failed requesting data wipe\", e);\n        } finally {\n            if (!success) SecurityLog.writeEvent(SecurityLog.TAG_WIPE_FAILURE);\n        }\n    }\n\n    private void factoryResetIfDelayedEarlier() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n\n            if (policy.mFactoryResetFlags == 0) return;\n\n            if (policy.mFactoryResetReason == null) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"no persisted reason for factory resetting\");\n                policy.mFactoryResetReason = \"requested before boot\";\n            }\n            FactoryResetter factoryResetter = FactoryResetter.newBuilder(mContext)\n                    .setReason(policy.mFactoryResetReason).setForce(true)\n                    .setWipeEuicc((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_EUICC) != 0)\n                    .setWipeAdoptableStorage((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_EXTERNAL_STORAGE) != 0)\n                    .setWipeFactoryResetProtection((policy.mFactoryResetFlags & DevicePolicyData\n                            .FACTORY_RESET_FLAG_WIPE_FACTORY_RESET_PROTECTION) != 0)\n                    .build();\n            Slogf.i(LOG_TAG, \"Factory resetting on boot using \" + factoryResetter);\n            try {\n                if (!factoryResetter.factoryReset()) {\n                    // Shouldn't happen because FactoryResetter was created without a\n                    // DevicePolicySafetyChecker.\n                    Slogf.wtf(LOG_TAG, \"Factory reset using \" + factoryResetter + \" failed.\");\n                }\n            } catch (IOException e) {\n                // Shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Could not factory reset using \" + factoryResetter, e);\n            }\n        }\n    }\n\n    private void forceWipeUser(int userId, String wipeReasonForUser, boolean wipeSilently) {\n        boolean success = false;\n        try {\n            if (getCurrentForegroundUserId() == userId) {\n                // TODO: We need to special case headless here as we can't switch to the system user\n                mInjector.getIActivityManager().switchUser(UserHandle.USER_SYSTEM);\n            }\n\n            success = mUserManagerInternal.removeUserEvenWhenDisallowed(userId);\n            if (!success) {\n                Slogf.w(LOG_TAG, \"Couldn't remove user \" + userId);\n            } else if (isManagedProfile(userId) && !wipeSilently) {\n                sendWipeProfileNotification(wipeReasonForUser,\n                        UserHandle.of(getProfileParentId(userId)));\n            }\n        } catch (RemoteException re) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error forcing wipe user\", re);\n        } finally {\n            if (!success) SecurityLog.writeEvent(SecurityLog.TAG_WIPE_FAILURE);\n        }\n    }\n\n    @Override\n    public void wipeDataWithReason(String callerPackageName, int flags,\n            @NonNull String wipeReasonForUser, boolean calledOnParentInstance,\n            boolean factoryReset) {\n        if (!mHasFeature && !hasCallingOrSelfPermission(permission.MASTER_CLEAR)) {\n            return;\n        }\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        }  else {\n            caller = getCallerIdentity();\n        }\n        ActiveAdmin admin;\n\n        boolean calledByProfileOwnerOnOrgOwnedDevice =\n                isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId());\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                    /*admin=*/ null,\n                    /*permission=*/ new String[]{MANAGE_DEVICE_POLICY_WIPE_DATA, MASTER_CLEAR},\n                    USES_POLICY_WIPE_DATA,\n                    caller.getPackageName(),\n                    factoryReset ? UserHandle.USER_ALL : getAffectedUser(calledOnParentInstance));\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            if (calledOnParentInstance) {\n                Preconditions.checkCallAuthorization(calledByProfileOwnerOnOrgOwnedDevice,\n                        \"Wiping the entire device can only be done by a profile owner on \"\n                                + \"organization-owned device.\");\n            }\n            if ((flags & WIPE_RESET_PROTECTION_DATA) != 0) {\n                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                                || calledByProfileOwnerOnOrgOwnedDevice\n                                || isFinancedDeviceOwner(caller),\n                        \"Only device owners or profile owners of organization-owned device can set \"\n                                + \"WIPE_RESET_PROTECTION_DATA\");\n            }\n            synchronized (getLockObject()) {\n                admin = getActiveAdminWithPolicyForUidLocked(/* who= */ null,\n                        DeviceAdminInfo.USES_POLICY_WIPE_DATA, caller.getUid());\n            }\n            Preconditions.checkCallAuthorization(\n                    (admin != null) || hasCallingOrSelfPermission(permission.MASTER_CLEAR),\n                    \"No active admin for user %d and caller %d does not hold MASTER_CLEAR \"\n                            + \"permission\",\n                    caller.getUserId(), caller.getUid());\n        }\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_WIPE_DATA);\n\n        if (TextUtils.isEmpty(wipeReasonForUser)) {\n            wipeReasonForUser = getGenericWipeReason(\n                    calledByProfileOwnerOnOrgOwnedDevice, calledOnParentInstance);\n        }\n\n        int userId = admin != null ? admin.getUserHandle().getIdentifier()\n                : caller.getUserId();\n        Slogf.i(LOG_TAG, \"wipeDataWithReason(%s): admin=%s, user=%d\", wipeReasonForUser, admin,\n                userId);\n        if (calledByProfileOwnerOnOrgOwnedDevice) {\n            // When wipeData is called on the parent instance, it implies wiping the entire device.\n            if (calledOnParentInstance) {\n                userId = UserHandle.USER_SYSTEM;\n            } else {\n                // when wipeData is _not_ called on the parent instance, it implies relinquishing\n                // control over the device, wiping only the work profile. So the user restriction\n                // on profile removal needs to be removed first.\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userId));\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> clearOrgOwnedProfileOwnerUserRestrictions(parentUser));\n            }\n        }\n        DevicePolicyEventLogger event = DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.WIPE_DATA_WITH_REASON)\n                .setInt(flags)\n                .setStrings(calledOnParentInstance ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT);\n\n        final String adminName;\n        final ComponentName adminComp;\n        if (admin != null) {\n            if (admin.isPermissionBased) {\n                adminComp = null;\n                adminName = caller.getPackageName();\n                event.setAdmin(adminName);\n            } else {\n                adminComp = admin.info.getComponent();\n                adminName = adminComp.flattenToShortString();\n                event.setAdmin(adminComp);\n            }\n        } else {\n            adminComp = null;\n            adminName = mInjector.getPackageManager().getPackagesForUid(caller.getUid())[0];\n            Slogf.i(LOG_TAG, \"Logging wipeData() event admin as \" + adminName);\n            event.setAdmin(adminName);\n            if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n                // On headless system user mode, the call is meant to factory reset the whole\n                // device, otherwise the caller could simply remove the current user.\n                userId = UserHandle.USER_SYSTEM;\n            }\n        }\n        event.write();\n\n        String internalReason = String.format(\n                \"DevicePolicyManager.wipeDataWithReason() from %s, organization-owned? %s\",\n                adminName, calledByProfileOwnerOnOrgOwnedDevice);\n\n        wipeDataNoLock(adminComp, flags, internalReason, wipeReasonForUser, userId,\n                calledOnParentInstance, factoryReset);\n    }\n\n    private String getGenericWipeReason(\n            boolean calledByProfileOwnerOnOrgOwnedDevice, boolean calledOnParentInstance) {\n        return calledByProfileOwnerOnOrgOwnedDevice && !calledOnParentInstance\n                ? getUpdatableString(\n                        WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE,\n                        R.string.device_ownership_relinquished)\n                : getUpdatableString(\n                        WORK_PROFILE_DELETED_GENERIC_MESSAGE,\n                        R.string.work_profile_deleted_description_dpm_wipe);\n    }\n\n    /**\n     * Clears device wide policies enforced by COPE PO when relinquishing the device. This method\n     * should be invoked once the admin is gone, so that all methods that rely on calculating\n     * aggregate policy (e.g. strong auth timeout) from all admins aren't affected by its policies.\n     * This method assumes that there is no other device or profile owners left on the device.\n     * Shouldn't be called from binder thread without clearing identity.\n     */\n    private void clearOrgOwnedProfileOwnerDeviceWidePolicies(@UserIdInt int parentId) {\n        Slogf.i(LOG_TAG, \"Cleaning up device-wide policies left over from org-owned profile...\");\n        // Lockscreen message\n        mLockPatternUtils.setDeviceOwnerInfo(null);\n        // Wifi config lockdown\n        mInjector.settingsGlobalPutInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0);\n        // Security logging\n        if (mInjector.securityLogGetLoggingEnabledProperty()) {\n            mSecurityLogMonitor.stop();\n            mInjector.securityLogSetLoggingEnabledProperty(false);\n        }\n        // Network logging\n        setNetworkLoggingActiveInternal(false);\n\n        // System update policy.\n        final boolean hasSystemUpdatePolicy;\n        synchronized (getLockObject()) {\n            hasSystemUpdatePolicy = mOwners.getSystemUpdatePolicy() != null;\n            if (hasSystemUpdatePolicy) {\n                mOwners.clearSystemUpdatePolicy();\n                mOwners.writeDeviceOwner();\n            }\n        }\n        if (hasSystemUpdatePolicy) {\n            mContext.sendBroadcastAsUser(\n                    new Intent(ACTION_SYSTEM_UPDATE_POLICY_CHANGED), UserHandle.SYSTEM);\n        }\n\n        // Unsuspend personal apps if needed.\n        suspendPersonalAppsInternal(parentId, getManagedUserId(parentId), false);\n\n        // Notify FRP agent, LSS and WindowManager to ensure they don't hold on to stale policies.\n        final int frpAgentUid = getFrpManagementAgentUid();\n        if (frpAgentUid > 0) {\n            notifyResetProtectionPolicyChanged(frpAgentUid);\n        }\n        mLockSettingsInternal.refreshStrongAuthTimeout(parentId);\n\n        clearManagedSubscriptionsPolicy();\n        clearLauncherShortcutOverrides();\n        updateTelephonyCrossProfileIntentFilters(parentId, UserHandle.USER_NULL, false);\n\n        Slogf.i(LOG_TAG, \"Cleaning up device-wide policies done.\");\n    }\n\n    private void clearManagedSubscriptionsPolicy() {\n        unregisterOnSubscriptionsChangedListener();\n\n        SubscriptionManager subscriptionManager = mContext.getSystemService(\n                SubscriptionManager.class);\n        //Iterate over all the subscriptions and remove association with any user.\n        int[] subscriptionIds = subscriptionManager.getActiveSubscriptionIdList(false);\n        for (int subId : subscriptionIds) {\n            subscriptionManager.setSubscriptionUserHandle(subId, null);\n        }\n    }\n\n    private void clearLauncherShortcutOverrides() {\n        mPolicyCache.setLauncherShortcutOverrides(new ArrayMap<>());\n    }\n\n    private void updateTelephonyCrossProfileIntentFilters(int parentUserId, int profileUserId,\n            boolean enableWorkTelephony) {\n        try {\n            // This should only occur when managed profile is being removed.\n            if (!enableWorkTelephony && profileUserId == UserHandle.USER_NULL) {\n                mIPackageManager.clearCrossProfileIntentFilters(parentUserId,\n                        mContext.getPackageName());\n                return;\n            }\n            for (DefaultCrossProfileIntentFilter filter :\n                    DefaultCrossProfileIntentFiltersUtils\n                            .getDefaultCrossProfileTelephonyIntentFilters(!enableWorkTelephony)) {\n                if (removeCrossProfileIntentFilter(filter, parentUserId, profileUserId)) {\n                    Slogf.w(LOG_TAG,\n                            \"Failed to remove cross-profile intent filter: \"\n                                    + filter.filter.getIntentFilter() + \", enableWorkTelephony: \"\n                                    + enableWorkTelephony);\n                }\n            }\n            for (DefaultCrossProfileIntentFilter filter :\n                    DefaultCrossProfileIntentFiltersUtils\n                            .getDefaultCrossProfileTelephonyIntentFilters(enableWorkTelephony)) {\n                addCrossProfileIntentFilter(filter, parentUserId, profileUserId);\n            }\n        } catch (RemoteException re) {\n            Slogf.wtf(LOG_TAG, \"Error updating telephony cross profile intent filters\", re);\n        }\n    }\n\n    void addCrossProfileIntentFilter(DefaultCrossProfileIntentFilter filter, int parentUserId,\n            int profileUserId)\n            throws RemoteException {\n        if (filter.direction == DefaultCrossProfileIntentFilter.Direction.TO_PROFILE) {\n            mIPackageManager.addCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    parentUserId,\n                    profileUserId,\n                    filter.flags);\n        } else {\n            mIPackageManager.addCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    profileUserId,\n                    parentUserId,\n                    filter.flags);\n        }\n    }\n\n    boolean removeCrossProfileIntentFilter(DefaultCrossProfileIntentFilter filter, int parentUserId,\n            int profileUserId)\n            throws RemoteException {\n        if (filter.direction == DefaultCrossProfileIntentFilter.Direction.TO_PROFILE) {\n            return mIPackageManager.removeCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    parentUserId,\n                    profileUserId,\n                    filter.flags);\n        } else {\n            return mIPackageManager.removeCrossProfileIntentFilter(\n                    filter.filter.getIntentFilter(),\n                    mContext.getOpPackageName(),\n                    profileUserId,\n                    parentUserId,\n                    filter.flags);\n        }\n    }\n\n    /**\n     * @param factoryReset null: legacy behaviour, false: attempt to remove user, true: attempt to\n     *                     factory reset\n     */\n    private void wipeDataNoLock(@Nullable ComponentName admin, int flags, String internalReason,\n            String wipeReasonForUser, int userId, boolean calledOnParentInstance,\n            @Nullable Boolean factoryReset) {\n        wtfIfInLock();\n        final String adminPackage;\n        if (admin != null) {\n            adminPackage = admin.getPackageName();\n        } else {\n            int callerId = mInjector.binderGetCallingUid();\n            String[] adminPackages = mInjector.getPackageManager().getPackagesForUid(callerId);\n            Preconditions.checkState(adminPackages.length > 0,\n                    \"Caller %s does not have any associated packages\", callerId);\n            adminPackage = adminPackages[0];\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // First check whether the admin is allowed to wipe the device/user/profile.\n            final String restriction;\n            if (userId == UserHandle.USER_SYSTEM) {\n                restriction = UserManager.DISALLOW_FACTORY_RESET;\n            } else if (isManagedProfile(userId)) {\n                restriction = UserManager.DISALLOW_REMOVE_MANAGED_PROFILE;\n            } else {\n                restriction = UserManager.DISALLOW_REMOVE_USER;\n            }\n            if (isAdminAffectedByRestriction(admin, restriction, userId)) {\n                throw new SecurityException(\"Cannot wipe data. \" + restriction\n                        + \" restriction is set for user \" + userId);\n            }\n        });\n\n        boolean isSystemUser = userId == UserHandle.USER_SYSTEM;\n        boolean wipeDevice;\n        if (factoryReset == null || !mInjector.isChangeEnabled(EXPLICIT_WIPE_BEHAVIOUR,\n                adminPackage,\n                userId)) {\n            // Legacy mode\n            wipeDevice = isSystemUser;\n        } else {\n            // Explicit behaviour\n            if (factoryReset) {\n                EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                        /*admin=*/ null,\n                        /*permission=*/ new String[]{MANAGE_DEVICE_POLICY_WIPE_DATA,\n                                MASTER_CLEAR},\n                        USES_POLICY_WIPE_DATA,\n                        adminPackage,\n                        factoryReset ? UserHandle.USER_ALL :\n                                getAffectedUser(calledOnParentInstance));\n                wipeDevice = true;\n            } else {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    Preconditions.checkCallAuthorization(!isSystemUser,\n                            \"User %s is a system user and cannot be removed\", userId);\n                    boolean isLastNonHeadlessUser = getUserInfo(userId).isFull()\n                            && mUserManager.getAliveUsers().stream()\n                            .filter((it) -> it.getUserHandle().getIdentifier() != userId)\n                            .noneMatch(UserInfo::isFull);\n                    Preconditions.checkState(!isLastNonHeadlessUser,\n                            \"Removing user %s would leave the device without any active users. \"\n                                    + \"Consider factory resetting the device instead.\",\n                            userId);\n                });\n                wipeDevice = false;\n            }\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (wipeDevice) {\n                forceWipeDeviceNoLock(\n                        (flags & WIPE_EXTERNAL_STORAGE) != 0,\n                        internalReason,\n                        (flags & WIPE_EUICC) != 0,\n                        (flags & WIPE_RESET_PROTECTION_DATA) != 0);\n            } else {\n                forceWipeUser(userId, wipeReasonForUser, (flags & WIPE_SILENTLY) != 0);\n            }\n        });\n    }\n\n    private void sendWipeProfileNotification(String wipeReasonForUser, UserHandle user) {\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setContentTitle(getWorkProfileDeletedTitle())\n                        .setContentText(wipeReasonForUser)\n                        .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                        .setStyle(new Notification.BigTextStyle().bigText(wipeReasonForUser))\n                        .build();\n        mInjector.getNotificationManager().notifyAsUser(\n                /* tag= */ null, SystemMessage.NOTE_PROFILE_WIPED, notification, user);\n    }\n\n    private String getWorkProfileDeletedTitle() {\n        return getUpdatableString(WORK_PROFILE_DELETED_TITLE, R.string.work_profile_deleted);\n    }\n\n    private void clearWipeProfileNotification() {\n        mInjector.getNotificationManager().cancel(SystemMessage.NOTE_PROFILE_WIPED);\n    }\n\n    @Override\n    public void setFactoryResetProtectionPolicy(ComponentName who, String callerPackageName,\n            @Nullable FactoryResetProtectionPolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkNotNull(who, \"ComponentName is null\");\n        }\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager\n                .OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY);\n\n        final int frpManagementAgentUid = getFrpManagementAgentUidOrThrow();\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_FACTORY_RESET, caller.getPackageName(),\n                        UserHandle.USER_ALL)\n                        .getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            admin.mFactoryResetProtectionPolicy = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.binderWithCleanCallingIdentity(\n                () -> notifyResetProtectionPolicyChanged(frpManagementAgentUid));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_FACTORY_RESET_PROTECTION)\n                .setAdmin(caller.getPackageName())\n                .write();\n    }\n\n    // Shouldn't be called from binder thread without clearing identity.\n    private void notifyResetProtectionPolicyChanged(int frpManagementAgentUid) {\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_RESET_PROTECTION_POLICY_CHANGED).addFlags(\n                Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND | Intent.FLAG_RECEIVER_FOREGROUND);\n        mContext.sendBroadcastAsUser(intent,\n                UserHandle.getUserHandleForUid(frpManagementAgentUid),\n                permission.MANAGE_FACTORY_RESET_PROTECTION);\n    }\n\n    @Override\n    public FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(\n            @Nullable ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int frpManagementAgentUid = getFrpManagementAgentUidOrThrow();\n        final ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            if (who == null) {\n                Preconditions.checkCallAuthorization(frpManagementAgentUid == caller.getUid()\n                                || hasCallingPermission(permission.MASTER_CLEAR)\n                                || hasCallingPermission(MANAGE_DEVICE_POLICY_FACTORY_RESET),\n                        \"Must be called by the FRP management agent on device\");\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceOrSystemPermissionBasedAdminLocked();\n            } else {\n                Preconditions.checkCallAuthorization(\n                        isDefaultDeviceOwner(caller)\n                                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n\n        return admin != null ? admin.mFactoryResetProtectionPolicy : null;\n    }\n\n    private int getFrpManagementAgentUid() {\n        PersistentDataBlockManagerInternal pdb = mInjector.getPersistentDataBlockManagerInternal();\n        return pdb != null ? pdb.getAllowedUid() : -1;\n    }\n\n    private int getFrpManagementAgentUidOrThrow() {\n        int uid = getFrpManagementAgentUid();\n        if (uid == -1) {\n            throw new UnsupportedOperationException(\n                    \"The persistent data block service is not supported on this device\");\n        }\n        return uid;\n    }\n\n    @Override\n    public boolean isFactoryResetProtectionPolicySupported() {\n        return getFrpManagementAgentUid() != -1;\n    }\n\n    @Override\n    public void sendLostModeLocationUpdate(AndroidFuture<Boolean> future) {\n        if (!mHasFeature) {\n            future.complete(false);\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.TRIGGER_LOST_MODE));\n\n        synchronized (getLockObject()) {\n            // TODO(b/261999445): Remove\n            ActiveAdmin admin;\n            if (isHeadlessFlagEnabled()) {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                        UserHandle.USER_SYSTEM);\n            }\n            Preconditions.checkState(admin != null,\n                    \"Lost mode location updates can only be sent on an organization-owned device.\");\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                String[] providers = {LocationManager.FUSED_PROVIDER,\n                        LocationManager.NETWORK_PROVIDER, LocationManager.GPS_PROVIDER};\n                tryRetrieveAndSendLocationUpdate(admin, future, providers, /* index= */ 0);\n            });\n        }\n    }\n\n    /** Send lost mode location updates recursively, in order of the list of location providers. */\n    private void tryRetrieveAndSendLocationUpdate(ActiveAdmin admin,\n            AndroidFuture<Boolean> future, String[] providers, int index) {\n        // None of the providers were able to get location, return false\n        if (index == providers.length) {\n            future.complete(false);\n            return;\n        }\n        if (mInjector.getLocationManager().isProviderEnabled(providers[index])) {\n            mInjector.getLocationManager().getCurrentLocation(providers[index],\n                    /* cancellationSignal= */ null, mContext.getMainExecutor(), location -> {\n                        if (location != null) {\n                            mContext.sendBroadcastAsUser(\n                                    newLostModeLocationUpdateIntent(admin, location),\n                                    admin.getUserHandle());\n                            future.complete(true);\n                        } else {\n                            tryRetrieveAndSendLocationUpdate(admin, future, providers, index + 1);\n                        }\n                    }\n            );\n        } else {\n           tryRetrieveAndSendLocationUpdate(admin, future, providers, index + 1);\n        }\n    }\n\n    private Intent newLostModeLocationUpdateIntent(ActiveAdmin admin, Location location) {\n        final Intent intent = new Intent(\n                DevicePolicyManager.ACTION_LOST_MODE_LOCATION_UPDATE);\n        intent.putExtra(DevicePolicyManager.EXTRA_LOST_MODE_LOCATION, location);\n        intent.setPackage(admin.info.getPackageName());\n        return intent;\n    }\n\n    /**\n     * Called by a privileged caller holding {@code BIND_DEVICE_ADMIN} permission to retrieve\n     * the remove warning for the given device admin.\n     */\n    @Override\n    public void getRemoveWarning(ComponentName comp, final RemoteCallback result, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(comp, userHandle);\n            if (admin == null) {\n                result.sendResult(null);\n                return;\n            }\n            Intent intent = new Intent(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLE_REQUESTED);\n            intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n            intent.setComponent(admin.info.getComponent());\n            mContext.sendOrderedBroadcastAsUser(intent, new UserHandle(userHandle),\n                    null, new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    result.sendResult(getResultExtras(false));\n                }\n            }, null, Activity.RESULT_OK, null, null);\n        }\n    }\n\n    @Override\n    public void reportPasswordChanged(PasswordMetrics metrics, @UserIdInt int userId) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller));\n        // Managed Profile password can only be changed when it has a separate challenge.\n        if (!isSeparateProfileChallengeEnabled(userId)) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(userId), \"You can \"\n                    + \"not set the active password for a managed profile, userId = %d\", userId);\n        }\n\n        DevicePolicyData policy = getUserData(userId);\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n\n        synchronized (getLockObject()) {\n            policy.mFailedPasswordAttempts = 0;\n            affectedUserIds.add(userId);\n            affectedUserIds.addAll(updatePasswordValidityCheckpointLocked(\n                    userId, /* parent */ false));\n            affectedUserIds.addAll(updatePasswordExpirationsLocked(userId));\n            setExpirationAlarmCheckLocked(mContext, userId, /* parent */ false);\n\n            // Send a broadcast to each profile using this password as its primary unlock.\n            sendAdminCommandForLockscreenPoliciesLocked(\n                    DeviceAdminReceiver.ACTION_PASSWORD_CHANGED,\n                    DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, userId);\n\n            affectedUserIds.addAll(removeCaApprovalsIfNeeded(userId));\n            saveSettingsForUsersLocked(affectedUserIds);\n        }\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_CHANGED,\n                    /* complexity */ metrics.determineComplexity(), /*user*/ userId);\n        }\n    }\n\n    /**\n     * Called any time the device password is updated. Resets all password expiration clocks.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordExpirationsLocked(int userHandle) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        for (int i = 0; i < admins.size(); i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD)) {\n                affectedUserIds.add(admin.getUserHandle().getIdentifier());\n                long timeout = admin.passwordExpirationTimeout;\n                admin.passwordExpirationDate =\n                        timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public void reportFailedPasswordAttempt(int userHandle, boolean parent) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n        if (!isSeparateProfileChallengeEnabled(userHandle)) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                    \"You can not report failed password attempt if separate profile challenge is \"\n                            + \"not in place for a managed profile, userId = %d\", userHandle);\n        }\n\n        boolean wipeData = false;\n        ActiveAdmin strictestAdmin = null;\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userHandle);\n                policy.mFailedPasswordAttempts++;\n                saveSettingsLocked(userHandle);\n                if (mHasFeature) {\n                    strictestAdmin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                            userHandle, /* parent= */ false);\n                    int max = strictestAdmin != null\n                            ? strictestAdmin.maximumFailedPasswordsForWipe : 0;\n                    if (max > 0 && policy.mFailedPasswordAttempts >= max) {\n                        wipeData = true;\n                    }\n\n                    sendAdminCommandForLockscreenPoliciesLocked(\n                            DeviceAdminReceiver.ACTION_PASSWORD_FAILED,\n                            DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n        if (wipeData && strictestAdmin != null) {\n            final int userId = getUserIdToWipeForFailedPasswords(strictestAdmin);\n            Slogf.i(LOG_TAG, \"Max failed password attempts policy reached for admin: \"\n                    + strictestAdmin.info.getComponent().flattenToShortString()\n                    + \". Calling wipeData for user \" + userId);\n\n            // Attempt to wipe the device/user/profile associated with the admin, as if the\n            // admin had called wipeData(). That way we can check whether the admin is actually\n            // allowed to wipe the device (e.g. a regular device admin shouldn't be able to wipe the\n            // device if the device owner has set DISALLOW_FACTORY_RESET, but the DO should be\n            // able to do so).\n            // IMPORTANT: Call without holding the lock to prevent deadlock.\n            try {\n                wipeDataNoLock(strictestAdmin.info.getComponent(),\n                        /* flags= */ 0,\n                        /* reason= */ \"reportFailedPasswordAttempt()\",\n                        getFailedPasswordAttemptWipeMessage(),\n                        userId,\n                        /* calledOnParentInstance= */ parent,\n                        // factoryReset=null to enable U- behaviour\n                        /* factoryReset= */ null);\n            } catch (SecurityException e) {\n                Slogf.w(LOG_TAG, \"Failed to wipe user \" + userId\n                        + \" after max failed password attempts reached.\", e);\n            }\n        }\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT,\n                    /* result= */ 0, /* method strength= */ 1);\n        }\n    }\n\n    private String getFailedPasswordAttemptWipeMessage() {\n        return getUpdatableString(\n                WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE,\n               R.string.work_profile_deleted_reason_maximum_password_failure);\n    }\n\n    /**\n     * Returns which user should be wiped if this admin's maximum filed password attempts policy is\n     * violated.\n     */\n    private int getUserIdToWipeForFailedPasswords(ActiveAdmin admin) {\n        final int userId = admin.getUserHandle().getIdentifier();\n        if (admin.isPermissionBased) {\n            return userId;\n        }\n        final ComponentName component = admin.info.getComponent();\n        return isProfileOwnerOfOrganizationOwnedDevice(component, userId)\n                ? getProfileParentId(userId) : userId;\n    }\n\n    @Override\n    public void reportSuccessfulPasswordAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            if (policy.mFailedPasswordAttempts != 0 || policy.mPasswordOwner >= 0) {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    policy.mFailedPasswordAttempts = 0;\n                    policy.mPasswordOwner = -1;\n                    saveSettingsLocked(userHandle);\n                    if (mHasFeature) {\n                        sendAdminCommandForLockscreenPoliciesLocked(\n                                DeviceAdminReceiver.ACTION_PASSWORD_SUCCEEDED,\n                                DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, userHandle);\n                    }\n                });\n            }\n        }\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 1,\n                    /*method strength*/ 1);\n        }\n    }\n\n    @Override\n    public void reportFailedBiometricAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 0,\n                    /*method strength*/ 0);\n        }\n    }\n\n    @Override\n    public void reportSuccessfulBiometricAttempt(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, /*result*/ 1,\n                    /*method strength*/ 0);\n        }\n    }\n\n    @Override\n    public void reportKeyguardDismissed(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISMISSED);\n        }\n    }\n\n    @Override\n    public void reportKeyguardSecured(int userHandle) {\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));\n\n        if (mInjector.securityLogIsLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_SECURED);\n        }\n    }\n\n    @Override\n    public ComponentName setGlobalProxy(ComponentName who, String proxySpec,\n            String exclusionList) {\n        if (!mHasFeature) {\n            return null;\n        }\n        synchronized (getLockObject()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n\n            // Only check if system user has set global proxy. We don't allow other users to set it.\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            ActiveAdmin admin = getActiveAdminForCallerLocked(who,\n                    DeviceAdminInfo.USES_POLICY_SETS_GLOBAL_PROXY);\n\n            // Scan through active admins and find if anyone has already\n            // set the global proxy.\n            Set<ComponentName> compSet = policy.mAdminMap.keySet();\n            for (ComponentName component : compSet) {\n                ActiveAdmin ap = policy.mAdminMap.get(component);\n                if ((ap.specifiesGlobalProxy) && (!component.equals(who))) {\n                    // Another admin already sets the global proxy\n                    // Return it to the caller.\n                    return component;\n                }\n            }\n\n            // If the user is not system, don't set the global proxy. Fail silently.\n            if (UserHandle.getCallingUserId() != UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Only the owner is allowed to set the global proxy. User \"\n                        + UserHandle.getCallingUserId() + \" is not permitted.\");\n                return null;\n            }\n            if (proxySpec == null) {\n                admin.specifiesGlobalProxy = false;\n                admin.globalProxySpec = null;\n                admin.globalProxyExclusionList = null;\n            } else {\n\n                admin.specifiesGlobalProxy = true;\n                admin.globalProxySpec = proxySpec;\n                admin.globalProxyExclusionList = exclusionList;\n            }\n\n            // Reset the global proxy accordingly\n            // Do this using system permissions, as apps cannot write to secure settings\n            mInjector.binderWithCleanCallingIdentity(() -> resetGlobalProxyLocked(policy));\n            return null;\n        }\n    }\n\n    @Override\n    public ComponentName getGlobalProxyAdmin(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasFullCrossUsersPermission(caller, userHandle) && canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            // Scan through active admins and find if anyone has already\n            // set the global proxy.\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin ap = policy.mAdminList.get(i);\n                if (ap.specifiesGlobalProxy) {\n                    // Device admin sets the global proxy\n                    // Return it to the caller.\n                    return ap.info.getComponent();\n                }\n            }\n        }\n        // No device admin sets the global proxy.\n        return null;\n    }\n\n    @Override\n    public void setRecommendedGlobalProxy(ComponentName who, ProxyInfo proxyInfo) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getConnectivityManager().setGlobalProxy(proxyInfo));\n    }\n\n    private void resetGlobalProxyLocked(DevicePolicyData policy) {\n        final int N = policy.mAdminList.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin ap = policy.mAdminList.get(i);\n            if (ap.specifiesGlobalProxy) {\n                saveGlobalProxyLocked(ap.globalProxySpec, ap.globalProxyExclusionList);\n                return;\n            }\n        }\n        // No device admins defining global proxies - reset global proxy settings to none\n        saveGlobalProxyLocked(null, null);\n    }\n\n    private void saveGlobalProxyLocked(String proxySpec, String exclusionList) {\n        if (exclusionList == null) {\n            exclusionList = \"\";\n        }\n        if (proxySpec == null) {\n            proxySpec = \"\";\n        }\n        // Remove white spaces\n        proxySpec = proxySpec.trim();\n        String data[] = proxySpec.split(\":\");\n        int proxyPort = 8080;\n        if (data.length > 1) {\n            try {\n                proxyPort = Integer.parseInt(data[1]);\n            } catch (NumberFormatException e) {}\n        }\n        exclusionList = exclusionList.trim();\n\n        ProxyInfo proxyProperties = ProxyInfo.buildDirectProxy(data[0], proxyPort,\n                ProxyUtils.exclusionStringAsList(exclusionList));\n        if (!proxyProperties.isValid()) {\n            Slogf.e(LOG_TAG, \"Invalid proxy properties, ignoring: \" + proxyProperties.toString());\n            return;\n        }\n        mInjector.settingsGlobalPutString(Settings.Global.GLOBAL_HTTP_PROXY_HOST, data[0]);\n        mInjector.settingsGlobalPutInt(Settings.Global.GLOBAL_HTTP_PROXY_PORT, proxyPort);\n        mInjector.settingsGlobalPutString(Settings.Global.GLOBAL_HTTP_PROXY_EXCLUSION_LIST,\n                exclusionList);\n    }\n\n    /**\n     * Called by an application that is administering the device to request that the storage system\n     * be encrypted. Does nothing if the caller is on a secondary user or a managed profile.\n     *\n     * @return the new total request status (for all admins), or {@link\n     *         DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED} if called for a non-system user\n     */\n    @Override\n    public int setStorageEncryption(ComponentName who, boolean encrypt) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userHandle = UserHandle.getCallingUserId();\n        synchronized (getLockObject()) {\n            // Check for permissions\n            // Only system user can set storage encryption\n            if (userHandle != UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Only owner/system user is allowed to set storage encryption. \"\n                        + \"User \" + UserHandle.getCallingUserId() + \" is not permitted.\");\n                return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n            }\n\n            ActiveAdmin ap = getActiveAdminForCallerLocked(who,\n                    DeviceAdminInfo.USES_ENCRYPTED_STORAGE);\n\n            // Quick exit:  If the filesystem does not support encryption, we can exit early.\n            if (!isEncryptionSupported()) {\n                return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n            }\n\n            // (1) Record the value for the admin so it's sticky\n            if (ap.encryptionRequested != encrypt) {\n                ap.encryptionRequested = encrypt;\n                saveSettingsLocked(userHandle);\n            }\n\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            // (2) Compute \"max\" for all admins\n            boolean newRequested = false;\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                newRequested |= policy.mAdminList.get(i).encryptionRequested;\n            }\n\n            // Notify OS of new request\n            setEncryptionRequested(newRequested);\n\n            // Return the new global request status\n            return newRequested\n                    ? DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE\n                    : DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;\n        }\n    }\n\n    /**\n     * Get the current storage encryption request status for a given admin, or aggregate of all\n     * active admins.\n     */\n    @Override\n    public boolean getStorageEncryption(@Nullable ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            // Check for permissions if a particular caller is specified\n            if (caller.hasAdminComponent()) {\n                // When checking for a single caller, status is based on caller's request\n                ActiveAdmin ap = getActiveAdminUncheckedLocked(who, userHandle);\n                return ap != null ? ap.encryptionRequested : false;\n            }\n\n            // If no particular caller is specified, return the aggregate set of requests.\n            // This is short circuited by returning true on the first hit.\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i = 0; i < N; i++) {\n                if (policy.mAdminList.get(i).encryptionRequested) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Get the current encryption status of the device.\n     */\n    @Override\n    public int getStorageEncryptionStatus(@Nullable String callerPackage, int userHandle) {\n        if (!mHasFeature) {\n            // Ok to return current status.\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n\n        final ApplicationInfo ai;\n        try {\n            ai = mIPackageManager.getApplicationInfo(callerPackage, 0, userHandle);\n        } catch (RemoteException e) {\n            throw new SecurityException(e);\n        }\n\n        boolean legacyApp = false;\n        if (ai.targetSdkVersion <= Build.VERSION_CODES.M) {\n            legacyApp = true;\n        }\n\n        final int rawStatus = getEncryptionStatus();\n        if ((rawStatus == DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER) && legacyApp) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE;\n        }\n        return rawStatus;\n    }\n\n    /**\n     * Hook to low-levels:  This should report if the filesystem supports encrypted storage.\n     */\n    private boolean isEncryptionSupported() {\n        // Note, this can be implemented as\n        //   return getEncryptionStatus() != DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        // But is provided as a separate internal method if there's a faster way to do a\n        // simple check for supported-or-not.\n        return getEncryptionStatus() != DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n    }\n\n    /**\n     * Hook to low-levels:  Reporting the current status of encryption.\n     * @return Either {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED}\n     * or {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_PER_USER}.\n     */\n    private int getEncryptionStatus() {\n        if (mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n            return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\n        } else {\n            return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;\n        }\n    }\n\n    /**\n     * Hook to low-levels:  If needed, record the new admin setting for encryption.\n     */\n    private void setEncryptionRequested(boolean encrypt) {\n    }\n\n    /**\n     * Set whether the screen capture is disabled for the user managed by the specified admin.\n     */\n    @Override\n    public void setScreenCaptureDisabled(\n            ComponentName who, String callerPackage, boolean disabled, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackage);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            caller = getCallerIdentity(who);\n            if (parent) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            } else {\n                Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                        || isDefaultDeviceOwner(caller));\n            }\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int callerUserId = Binder.getCallingUserHandle().getIdentifier();\n            int targetUserId = parent ? getProfileParentId(callerUserId) : callerUserId;\n            EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                    who, MANAGE_DEVICE_POLICY_SCREEN_CAPTURE, caller.getPackageName(),\n                    targetUserId);\n            if ((parent && isProfileOwnerOfOrganizationOwnedDevice(caller))\n                    || isDefaultDeviceOwner(caller)) {\n                if (disabled) {\n                    mDevicePolicyEngine.setGlobalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin,\n                            new BooleanPolicyValue(disabled));\n                } else {\n                    mDevicePolicyEngine.removeGlobalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin);\n                }\n            } else {\n                if (disabled) {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin,\n                            new BooleanPolicyValue(disabled),\n                            callerUserId);\n                } else {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            admin,\n                            callerUserId);\n                }\n            }\n        } else {\n            synchronized (getLockObject()) {\n                ActiveAdmin ap = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDefaultDeviceOwnerLocked(caller.getUserId()), parent);\n                if (ap.disableScreenCapture != disabled) {\n                    ap.disableScreenCapture = disabled;\n                    saveSettingsLocked(caller.getUserId());\n                    pushScreenCapturePolicy(caller.getUserId());\n                }\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SCREEN_CAPTURE_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .write();\n    }\n\n    // Push the screen capture policy for a given userId. If screen capture is disabled by the\n    // DO or COPE PO on the parent profile, then this takes precedence as screen capture will\n    // be disabled device-wide.\n    private void pushScreenCapturePolicy(int adminUserId) {\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            return;\n        }\n        // Update screen capture device-wide if disabled by the DO or COPE PO on the parent profile.\n        // TODO(b/261999445): remove\n        ActiveAdmin admin;\n        if (isHeadlessFlagEnabled()) {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceParentLocked(\n                    mUserManagerInternal.getProfileParentId(adminUserId));\n        } else {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceParentLocked(\n                    UserHandle.USER_SYSTEM);\n        }\n        if (admin != null && admin.disableScreenCapture) {\n            setScreenCaptureDisabled(UserHandle.USER_ALL);\n            return;\n        }\n        // Otherwise, update screen capture only for the calling user.\n        admin = getProfileOwnerAdminLocked(adminUserId);\n        if (admin != null && admin.disableScreenCapture) {\n            setScreenCaptureDisabled(adminUserId);\n            return;\n        }\n        // If the admin is permission based, update only for the calling user.\n        admin = getUserData(adminUserId).createOrGetPermissionBasedAdmin(adminUserId);\n        if (admin != null && admin.disableScreenCapture) {\n            setScreenCaptureDisabled(adminUserId);\n            return;\n        }\n        setScreenCaptureDisabled(UserHandle.USER_NULL);\n    }\n\n    // Set the latest screen capture policy, overriding any existing ones.\n    // userHandle can be one of USER_ALL, USER_NULL or a concrete userId.\n    private void setScreenCaptureDisabled(int userHandle) {\n        int current = mPolicyCache.getScreenCaptureDisallowedUser();\n        if (userHandle == current) {\n            return;\n        }\n        mPolicyCache.setScreenCaptureDisallowedUser(userHandle);\n        updateScreenCaptureDisabled();\n    }\n\n    /**\n     * Returns whether or not screen capture is disabled for  any active admin.\n     */\n    @Override\n    public boolean getScreenCaptureDisabled(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice(getCallerIdentity().getUserId()));\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Boolean disallowed = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                    userHandle);\n            return disallowed != null && disallowed;\n        } else {\n            return !mPolicyCache.isScreenCaptureAllowed(userHandle);\n        }\n    }\n\n    private void updateScreenCaptureDisabled() {\n        mHandler.post(() -> {\n            try {\n                mInjector.getIWindowManager().refreshScreenCaptureDisabled();\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Unable to notify WindowManager.\", e);\n            }\n        });\n    }\n\n    @Override\n    public void setNearbyNotificationStreamingPolicy(int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mNearbyNotificationStreamingPolicy != policy) {\n                admin.mNearbyNotificationStreamingPolicy = policy;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public int getNearbyNotificationStreamingPolicy(final int userId) {\n        if (!mHasFeature) {\n            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            return admin != null\n                    ? admin.mNearbyNotificationStreamingPolicy\n                    : NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    @Override\n    public void setNearbyAppStreamingPolicy(int policy) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.mNearbyAppStreamingPolicy != policy) {\n                admin.mNearbyAppStreamingPolicy = policy;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public int getNearbyAppStreamingPolicy(final int userId) {\n        if (!mHasFeature) {\n            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            return admin != null\n                    ? admin.mNearbyAppStreamingPolicy\n                    : NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    /**\n     * Set whether auto time is required by the specified admin (must be device or profile owner).\n     */\n    @Override\n    public void setAutoTimeRequired(ComponentName who, boolean required) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDeviceOwner(caller) || isProfileOwner(caller));\n\n        boolean requireAutoTimeChanged = false;\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(!isManagedProfile(caller.getUserId()),\n                    \"Managed profile cannot set auto time required\");\n\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, who.getPackageName());\n                setGlobalUserRestrictionInternal(\n                        admin, UserManager.DISALLOW_CONFIG_DATE_TIME, required);\n            } else {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                if (admin.requireAutoTime != required) {\n                    admin.requireAutoTime = required;\n                    saveSettingsLocked(caller.getUserId());\n                    requireAutoTimeChanged = true;\n                }\n                // requireAutoTime is now backed by DISALLOW_CONFIG_DATE_TIME restriction, so\n                // propagate updated restrictions to the framework.\n                if (requireAutoTimeChanged) {\n                    pushUserRestrictions(caller.getUserId());\n                }\n            }\n        }\n        // Turn AUTO_TIME on in settings if it is required\n        if (required) {\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutInt(Settings.Global.AUTO_TIME,\n                            1 /* AUTO_TIME on */));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME_REQUIRED)\n                .setAdmin(who)\n                .setBoolean(required)\n                .write();\n    }\n\n    /**\n     * Returns whether or not auto time is required by the device owner or any profile owner.\n     */\n    @Override\n    public boolean getAutoTimeRequired() {\n        if (!mHasFeature) {\n            return false;\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Boolean required = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                            UserManager.DISALLOW_CONFIG_DATE_TIME),\n                    mInjector.binderGetCallingUserHandle().getIdentifier());\n            return required != null && required;\n        } else {\n            synchronized (getLockObject()) {\n                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null && deviceOwner.requireAutoTime) {\n                    // If the device owner enforces auto time, we don't need to check the PO's\n                    return true;\n                }\n\n                // Now check to see if any profile owner on any user enforces auto time\n                for (Integer userId : mOwners.getProfileOwnerKeys()) {\n                    ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n                    if (profileOwner != null && profileOwner.requireAutoTime) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Set whether auto time is enabled on the device.\n     */\n    @Override\n    public void setAutoTimeEnabled(@Nullable ComponentName who, String callerPackageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            // The effect of this policy is device-wide.\n            enforcePermission(SET_TIME, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n        }\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Settings.Global.AUTO_TIME, enabled ? 1 : 0));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    /**\n     * Returns whether auto time is used on the device or not.\n     */\n    @Override\n    public boolean getAutoTimeEnabled(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            enforceCanQuery(SET_TIME, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n        }\n\n        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) > 0;\n    }\n\n    /**\n     * Set whether auto time zone is enabled on the device.\n     */\n    @Override\n    public void setAutoTimeZoneEnabled(@Nullable ComponentName who, String callerPackageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            // The effect of this policy is device-wide.\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    SET_TIME_ZONE,\n                    caller.getPackageName(),\n                    UserHandle.USER_ALL\n            );\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.AUTO_TIMEZONE,\n                    // TODO(b/260573124): add correct enforcing admin when permission changes are\n                    //  merged.\n                    enforcingAdmin,\n                    new BooleanPolicyValue(enabled));\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    mInjector.settingsGlobalPutInt(Global.AUTO_TIME_ZONE, enabled ? 1 : 0));\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_AUTO_TIME_ZONE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    /**\n     * Returns whether auto time zone is used on the device or not.\n     */\n    @Override\n    public boolean getAutoTimeZoneEnabled(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isUnicornFlagEnabled()) {\n            // The effect of this policy is device-wide.\n            enforceCanQuery(SET_TIME_ZONE, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(\n                    caller));\n        }\n\n        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME_ZONE, 0) > 0;\n    }\n\n    // TODO (b/137101239): remove this method in follow-up CL\n    // since it's only used for split system user.\n    @Override\n    public void setForceEphemeralUsers(ComponentName who, boolean forceEphemeralUsers) {\n        throw new UnsupportedOperationException(\"This method was used by split system user only.\");\n    }\n\n    // TODO (b/137101239): remove this method in follow-up CL\n    // since it's only used for split system user.\n    @Override\n    public boolean getForceEphemeralUsers(ComponentName who) {\n        throw new UnsupportedOperationException(\"This method was used by split system user only.\");\n    }\n\n    @Override\n    public boolean requestBugreport(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        // TODO: If an unaffiliated user is removed, the admin will be able to request a bugreport\n        // which could still contain data related to that user. Should we disallow that, e.g. until\n        // next boot? Might not be needed given that this still requires user consent.\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REQUEST_BUGREPORT);\n\n        if (mBugreportCollectionManager.requestBugreport()) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.REQUEST_BUGREPORT)\n                    .setAdmin(who)\n                    .write();\n\n            final long currentTime = System.currentTimeMillis();\n            synchronized (getLockObject()) {\n                DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n                if (currentTime > policyData.mLastBugReportRequestTime) {\n                    policyData.mLastBugReportRequestTime = currentTime;\n                    saveSettingsLocked(UserHandle.USER_SYSTEM);\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    void sendDeviceOwnerCommand(String action, Bundle extras) {\n        final int deviceOwnerUserId;\n        final ComponentName receiverComponent;\n        synchronized (getLockObject()) {\n            deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            receiverComponent = mOwners.getDeviceOwnerComponent();\n        }\n        sendActiveAdminCommand(action, extras, deviceOwnerUserId, receiverComponent,\n                /* inForeground */ false);\n    }\n\n    void sendDeviceOwnerOrProfileOwnerCommand(String action, Bundle extras, int userId) {\n        if (userId == UserHandle.USER_ALL) {\n            userId = UserHandle.USER_SYSTEM;\n        }\n        boolean inForeground = false;\n        ComponentName receiverComponent = null;\n        if (action.equals(DeviceAdminReceiver.ACTION_NETWORK_LOGS_AVAILABLE)) {\n            inForeground = true;\n            receiverComponent = resolveDelegateReceiver(DELEGATION_NETWORK_LOGGING, action, userId);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_SECURITY_LOGS_AVAILABLE)) {\n            inForeground = true;\n            receiverComponent = resolveDelegateReceiver(\n                DELEGATION_SECURITY_LOGGING, action, userId);\n        }\n        if (receiverComponent == null) {\n            receiverComponent = getOwnerComponent(userId);\n        }\n        sendActiveAdminCommand(action, extras, userId, receiverComponent, inForeground);\n    }\n\n    private void sendProfileOwnerCommand(String action, Bundle extras, @UserIdInt int userId) {\n        sendActiveAdminCommand(action, extras, userId, mOwners.getProfileOwnerComponent(userId),\n                /* inForeground */ false);\n    }\n\n    private void sendActiveAdminCommand(String action, Bundle extras,\n            @UserIdInt int userId, ComponentName receiverComponent, boolean inForeground) {\n        final Intent intent = new Intent(action);\n        intent.setComponent(receiverComponent);\n        if (extras != null) {\n            intent.putExtras(extras);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"sendActiveAdminCommand(): broadcasting \" + action + \" to \"\n                    + receiverComponent.flattenToShortString() + \" on user \" + userId);\n        }\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    private void sendOwnerChangedBroadcast(String broadcast, int userId) {\n        final Intent intent = new Intent(broadcast)\n                .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    void sendBugreportToDeviceOwner(Uri bugreportUri, String bugreportHash) {\n        synchronized (getLockObject()) {\n            final Intent intent = new Intent(DeviceAdminReceiver.ACTION_BUGREPORT_SHARE);\n            intent.setComponent(mOwners.getDeviceOwnerComponent());\n            intent.setDataAndType(bugreportUri, RemoteBugreportManager.BUGREPORT_MIMETYPE);\n            intent.putExtra(DeviceAdminReceiver.EXTRA_BUGREPORT_HASH, bugreportHash);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n            final UriGrantsManagerInternal ugm = LocalServices\n                    .getService(UriGrantsManagerInternal.class);\n            final NeededUriGrants needed = ugm.checkGrantUriPermissionFromIntent(intent,\n                    Process.SHELL_UID, mOwners.getDeviceOwnerComponent().getPackageName(),\n                    mOwners.getDeviceOwnerUserId());\n            ugm.grantUriPermissionUncheckedFromIntent(needed, null);\n\n            mContext.sendBroadcastAsUser(intent, UserHandle.of(mOwners.getDeviceOwnerUserId()));\n        }\n    }\n\n    void setDeviceOwnerRemoteBugreportUriAndHash(String bugreportUri, String bugreportHash) {\n        synchronized (getLockObject()) {\n            mOwners.setDeviceOwnerRemoteBugreportUriAndHash(bugreportUri, bugreportHash);\n        }\n    }\n\n    Pair<String, String> getDeviceOwnerRemoteBugreportUriAndHash() {\n        synchronized (getLockObject()) {\n            final String uri = mOwners.getDeviceOwnerRemoteBugreportUri();\n            return uri == null ? null\n                    : new Pair<>(uri, mOwners.getDeviceOwnerRemoteBugreportHash());\n        }\n    }\n\n    /**\n     * Disables all device cameras according to the specified admin.\n     */\n    @Override\n    public void setCameraDisabled(ComponentName who, String callerPackageName, boolean disabled,\n            boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userId = caller.getUserId();\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_CAMERA_DISABLED);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_CAMERA,\n                    caller.getPackageName(),\n                    getProfileParentUserIfRequested(userId, parent));\n            try {\n                setBackwardCompatibleUserRestriction(\n                        caller, enforcingAdmin, UserManager.DISALLOW_CAMERA, disabled, parent);\n            } catch (IllegalStateException e) {\n                throw new IllegalStateException(\n                        \"Please use addUserRestriction or addUserRestrictionGlobally using the key\"\n                                + \" UserManager.DISALLOW_CAMERA to disable the camera locally or\"\n                                + \" globally, respectively\");\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            if (parent) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            }\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getActiveAdminForCallerLocked(who,\n                        DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA, parent);\n                if (admin.disableCamera != disabled) {\n                    admin.disableCamera = disabled;\n                    saveSettingsLocked(userId);\n                }\n            }\n            // Tell the user manager that the restrictions have changed.\n            pushUserRestrictions(userId);\n        }\n\n        final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n        if (SecurityLog.isLoggingEnabled() && who != null) {\n            SecurityLog.writeEvent(SecurityLog.TAG_CAMERA_POLICY_SET,\n                    who.getPackageName(), userId, affectedUserId, disabled ? 1 : 0);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CAMERA_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    /**\n     * Gets whether or not all device cameras are disabled for a given admin, or disabled for any\n     * active admins.\n     */\n    @Override\n    public boolean getCameraDisabled(ComponentName who, String callerPackageName, int userHandle,\n            boolean parent) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasFullCrossUsersPermission(caller, userHandle)\n                            || isCameraServerUid(caller)\n                            || hasPermission(MANAGE_DEVICE_POLICY_CAMERA,\n                                caller.getPackageName(), userHandle)\n                            || hasPermission(QUERY_ADMIN_POLICY, caller.getPackageName()));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    hasFullCrossUsersPermission(caller, userHandle) || isCameraServerUid(caller));\n            if (parent) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()));\n            }\n        }\n\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            PolicyDefinition<Boolean> policy =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                            UserManager.DISALLOW_CAMERA);\n            if (who != null) {\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackageName);\n                return Boolean.TRUE.equals(\n                        mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                                policy, admin, affectedUserId));\n            } else {\n                return Boolean.TRUE.equals(\n                        mDevicePolicyEngine.getResolvedPolicy(policy, affectedUserId));\n            }\n        } else {\n            synchronized (getLockObject()) {\n                if (who != null) {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                    return (admin != null) && admin.disableCamera;\n                }\n                // First, see if DO has set it.  If so, it's device-wide.\n                final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null && deviceOwner.disableCamera) {\n                    return true;\n                }\n\n                // Return the strictest policy across all participating admins.\n                List<ActiveAdmin> admins = getActiveAdminsForAffectedUserLocked(affectedUserId);\n\n                // Determine whether or not the device camera is disabled for any active admins.\n                for (ActiveAdmin activeAdmin : admins) {\n                    if (activeAdmin.disableCamera) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n\n    @Override\n    public void setKeyguardDisabledFeatures(\n            ComponentName who, String callerPackageName, int which, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        final int userHandle = caller.getUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            if (isUnicornFlagEnabled()) {\n                // SUPPORT USES_POLICY_DISABLE_KEYGUARD_FEATURES\n                EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_KEYGUARD, caller.getPackageName(),\n                        affectedUserId);\n                if (which == 0) {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES, admin, affectedUserId);\n                } else {\n                    // TODO(b/273723433): revisit silent masking of features\n                    if (isManagedProfile(userHandle)) {\n                        if (parent) {\n                            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                                which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                            } else {\n                                which = which\n                                        & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                            }\n                        } else {\n                            which = which & PROFILE_KEYGUARD_FEATURES;\n                        }\n                    }\n                    mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                            admin, new IntegerPolicyValue(which), affectedUserId);\n                }\n                invalidateBinderCaches();\n            } else {\n                ActiveAdmin ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);\n                if (isManagedProfile(userHandle)) {\n                    if (parent) {\n                        if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                            which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                        } else {\n                            which = which & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n                        }\n                    } else {\n                        which = which & PROFILE_KEYGUARD_FEATURES;\n                    }\n                }\n                if (ap.disabledKeyguardFeatures != which) {\n                    ap.disabledKeyguardFeatures = which;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISABLED_FEATURES_SET,\n                    caller.getPackageName(), userHandle, affectedUserId, which);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED_FEATURES)\n                .setAdmin(caller.getPackageName())\n                .setInt(which)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    /**\n     * Gets the disabled state for features in keyguard for the given admin,\n     * or the aggregate of all active admins if who is null.\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public int getKeyguardDisabledFeatures(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                if (isUnicornFlagEnabled()) {\n                    EnforcingAdmin admin = getEnforcingAdminForPackage(\n                            who, who.getPackageName(), userHandle);\n                    Integer features = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                            admin,\n                            affectedUserId);\n\n                    return features == null ? 0 : features;\n                } else {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                    return (admin != null) ? admin.disabledKeyguardFeatures : 0;\n                }\n            }\n\n            if (isUnicornFlagEnabled()) {\n                Integer features = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                        affectedUserId);\n\n                return Binder.withCleanCallingIdentity(() -> {\n                    int combinedFeatures = features == null ? 0 : features;\n                    List<UserInfo> profiles = mUserManager.getProfiles(affectedUserId);\n                    for (UserInfo profile : profiles) {\n                        int profileId = profile.id;\n                        if (profileId == affectedUserId) {\n                            continue;\n                        }\n                        Integer profileFeatures = mDevicePolicyEngine.getResolvedPolicy(\n                                PolicyDefinition.KEYGUARD_DISABLED_FEATURES,\n                                profileId);\n                        if (profileFeatures != null) {\n                            combinedFeatures |= (profileFeatures\n                                    & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER);\n                        }\n                    }\n                    return combinedFeatures;\n                });\n            }\n\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                final List<ActiveAdmin> admins;\n                if (!parent && isManagedProfile(userHandle)) {\n                    // If we are being asked about a managed profile, just return keyguard features\n                    // disabled by admins in the profile.\n                    admins = getUserDataUnchecked(userHandle).mAdminList;\n                } else {\n                    // Otherwise return those set by admins in the user and its profiles.\n                    admins = getActiveAdminsForLockscreenPoliciesLocked(\n                            getProfileParentUserIfRequested(userHandle, parent));\n                }\n\n                int which = DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE;\n                final int N = admins.size();\n                for (int i = 0; i < N; i++) {\n                    ActiveAdmin admin = admins.get(i);\n                    int userId = admin.getUserHandle().getIdentifier();\n                    boolean isRequestedUser = !parent && (userId == userHandle);\n                    if (isRequestedUser || !isManagedProfile(userId)) {\n                        // If we are being asked explicitly about this user\n                        // return all disabled features even if its a managed profile.\n                        which |= admin.disabledKeyguardFeatures;\n                    } else {\n                        // Otherwise a managed profile is only allowed to disable\n                        // some features on the parent user.\n                        which |= (admin.disabledKeyguardFeatures\n                                & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER);\n                    }\n                }\n                return which;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n    }\n\n    @Override\n    public void setKeepUninstalledPackages(ComponentName who, String callerPackage,\n            List<String> packageList) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(packageList, \"packageList is null\");\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  isDefaultDeviceOwner(caller))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_KEEP_UNINSTALLED_PACKAGES);\n\n        synchronized (getLockObject()) {\n            // Get the device owner\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            // Set list of packages to be kept even if uninstalled.\n            deviceOwner.keepUninstalledPackages = packageList;\n            // Save settings.\n            saveSettingsLocked(caller.getUserId());\n            // Notify package manager.\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_KEEP_UNINSTALLED_PACKAGES)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageList.toArray(new String[0]))\n                .write();\n    }\n\n    @Override\n    public List<String> getKeepUninstalledPackages(ComponentName who, String callerPackage) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  isDefaultDeviceOwner(caller))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));\n\n        synchronized (getLockObject()) {\n            return getKeepUninstalledPackagesLocked();\n        }\n    }\n\n    private List<String> getKeepUninstalledPackagesLocked() {\n        ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n        return (deviceOwner != null) ? deviceOwner.keepUninstalledPackages : null;\n    }\n\n    /**\n     * Logs a warning when the device doesn't have {@code PackageManager.FEATURE_DEVICE_ADMIN}.\n     *\n     * @param message action that was not executed; should not end with a period because the missing\n     * feature will be appended to it.\n     */\n    private void logMissingFeatureAction(String message) {\n        Slogf.w(LOG_TAG, message + \" because device does not have the \"\n                + PackageManager.FEATURE_DEVICE_ADMIN + \" feature.\");\n    }\n\n    @Override\n    public boolean setDeviceOwner(ComponentName admin, int userId,\n            boolean setProfileOwnerOnCurrentUserIfNecessary) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set \" + ComponentName.flattenToShortString(admin)\n                    + \" as device owner for user \" + userId);\n            return false;\n        }\n        Preconditions.checkArgument(admin != null);\n\n        final CallerIdentity caller = getCallerIdentity();\n\n        boolean hasIncompatibleAccountsOrNonAdb =\n                !isAdb(caller) || hasIncompatibleAccountsOnAnyUser();\n\n        if (!hasIncompatibleAccountsOrNonAdb) {\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(admin, userId) && hasAccountsOnAnyUser()) {\n                    Slogf.w(LOG_TAG,\n                            \"Non test-only owner can't be installed with existing accounts.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            enforceCanSetDeviceOwnerLocked(caller, admin, userId, hasIncompatibleAccountsOrNonAdb);\n\n            Preconditions.checkArgument(isPackageInstalledForUser(admin.getPackageName(), userId),\n                    \"Invalid component \" + admin + \" for device owner\");\n            final ActiveAdmin activeAdmin = getActiveAdminUncheckedLocked(admin, userId);\n            Preconditions.checkArgument(activeAdmin != null && !getUserData(\n                    userId).mRemovingAdmins.contains(admin), \"Not active admin: \" + admin);\n\n            // Shutting down backup manager service permanently.\n            toggleBackupServiceActive(UserHandle.USER_SYSTEM, /* makeActive= */ false);\n            if (isAdb(caller)) {\n                // Log device owner provisioning was started using adb.\n                MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_DEVICE_OWNER);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.PROVISIONING_ENTRY_POINT_ADB)\n                        .setAdmin(admin)\n                        .setStrings(LOG_TAG_DEVICE_OWNER)\n                        .write();\n            }\n\n            mOwners.setDeviceOwner(admin, userId);\n            mOwners.writeDeviceOwner();\n            setDeviceOwnershipSystemPropertyLocked();\n\n            //TODO(b/180371154): when provisionFullyManagedDevice is used in tests, remove this\n            // hard-coded default value setting.\n            if (isAdb(caller)) {\n                activeAdmin.mAdminCanGrantSensorsPermissions = true;\n                mPolicyCache.setAdminCanGrantSensorsPermissions(true);\n                saveSettingsLocked(userId);\n            }\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                // Restrict adding a managed profile when a device owner is set on the device.\n                // That is to prevent the co-existence of a managed profile and a device owner\n                // on the same device.\n                // Instead, the device may be provisioned with an organization-owned managed\n                // profile, such that the admin on that managed profile has extended management\n                // capabilities that can affect the entire device (but not access private data\n                // on the primary profile).\n                if (isHeadlessFlagEnabled()) {\n                    for (int u : mUserManagerInternal.getUserIds()) {\n                        mUserManager.setUserRestriction(\n                                UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                                UserHandle.of(u));\n                        // Restrict adding a clone profile when a device owner is set on the device.\n                        // That is to prevent the co-existence of a clone profile and a device owner\n                        // on the same device.\n                        // CDD for reference : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support\n                        mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                                true,\n                                UserHandle.of(u));\n                    }\n                } else {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                            true,\n                            UserHandle.of(userId));\n                    // Restrict adding a clone profile when a device owner is set on the device.\n                    // That is to prevent the co-existence of a clone profile and a device owner\n                    // on the same device.\n                    // CDD for reference : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                            true,\n                            UserHandle.of(userId));\n                }\n                // TODO Send to system too?\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED, userId);\n            });\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    admin.getPackageName(), userId, \"set-device-owner\");\n\n            Slogf.i(LOG_TAG, \"Device owner set: \" + admin + \" on user \" + userId);\n        }\n\n        if (setProfileOwnerOnCurrentUserIfNecessary\n                && mInjector.userManagerIsHeadlessSystemUserMode()) {\n            int currentForegroundUser;\n            synchronized (getLockObject()) {\n                currentForegroundUser = getCurrentForegroundUserId();\n            }\n            Slogf.i(LOG_TAG, \"setDeviceOwner(): setting \" + admin\n                    + \" as profile owner on user \" + currentForegroundUser);\n            // Sets profile owner on current foreground user since\n            // the human user will complete the DO setup workflow from there.\n            manageUserUnchecked(/* deviceOwner= */ admin, /* profileOwner= */ admin,\n                    /* managedUser= */ currentForegroundUser, /* adminExtras= */ null,\n                    /* showDisclaimer= */ false);\n        }\n        return true;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean hasDeviceOwner() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller) || isFinancedDeviceOwner(\n                        caller) || hasCallingOrSelfPermission(\n                        MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mOwners.hasDeviceOwner();\n    }\n\n    boolean isDeviceOwner(ActiveAdmin admin) {\n        return isDeviceOwner(admin.info.getComponent(), admin.getUserHandle().getIdentifier());\n    }\n\n    /**\n     * Check if the user is a Device Owner\n     *\n     * @param who    component to check against\n     * @param userId user to check\n     * @return if the user is a Device Owner\n     */\n    public boolean isDeviceOwner(@Nullable ComponentName who, int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.hasDeviceOwner() && mOwners.getDeviceOwnerUserId() == userId\n                    && mOwners.getDeviceOwnerComponent().equals(who);\n        }\n    }\n\n    /**\n     * Returns {@code true} <b>only if</b> the caller is the device owner and the device owner type\n     * is {@link DevicePolicyManager#DEVICE_OWNER_TYPE_DEFAULT}. {@code false} is returned for the\n     * case where the caller is not the device owner, there is no device owner, or the device owner\n     * type is not {@link DevicePolicyManager#DEVICE_OWNER_TYPE_DEFAULT}.\n     *\n     */\n    private boolean isDefaultDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(\n                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_DEFAULT;\n        }\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a device owner.\n     * @param caller identity of caller.\n     * @return true if {@code identity} is a device owner, false otherwise.\n     */\n    public boolean isDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller);\n        }\n    }\n\n    private boolean isDeviceOwnerLocked(CallerIdentity caller) {\n        if (!mOwners.hasDeviceOwner() || mOwners.getDeviceOwnerUserId() != caller.getUserId()) {\n            return false;\n        }\n\n        if (caller.hasAdminComponent()) {\n            return mOwners.getDeviceOwnerComponent().equals(caller.getComponentName());\n        } else {\n            return isUidDeviceOwnerLocked(caller.getUid());\n        }\n    }\n\n    private boolean isDeviceOwnerUserId(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.getDeviceOwnerComponent() != null\n                    && mOwners.getDeviceOwnerUserId() == userId;\n        }\n    }\n\n    /**\n     * Check if {@link userId} is a Profile Owner\n     *\n     * @param who    component to check against\n     * @param userId user to check\n     * @return if the user is a Profile Owner\n     */\n    public boolean isProfileOwner(@Nullable ComponentName who, int userId) {\n        final ComponentName profileOwner = mInjector.binderWithCleanCallingIdentity(\n                () -> getProfileOwnerAsUser(userId));\n        return who != null && who.equals(profileOwner);\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a profile owner.\n     * @param caller identity of caller.\n     * @return true if {@code identity} is a profile owner, false otherwise.\n     */\n    public boolean isProfileOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            final ComponentName profileOwner = mInjector.binderWithCleanCallingIdentity(() ->\n                    getProfileOwnerAsUser(caller.getUserId()));\n            // No profile owner.\n            if (profileOwner == null) {\n                return false;\n            }\n            // The admin ComponentName was specified, check it directly.\n            if (caller.hasAdminComponent()) {\n                return profileOwner.equals(caller.getComponentName());\n            } else {\n                return isUidProfileOwnerLocked(caller.getUid());\n            }\n        }\n    }\n\n    /**\n     * Checks if the app uid provided is the profile owner. This method should only be called\n     * if no componentName is available.\n     *\n     * @param appUid UID of the caller.\n     * @return true if the caller is the profile owner\n     */\n    private boolean isUidProfileOwnerLocked(int appUid) {\n        ensureLocked();\n\n        final int userId = UserHandle.getUserId(appUid);\n        final ComponentName profileOwnerComponent = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwnerComponent == null) {\n            return false;\n        }\n        for (ActiveAdmin admin : getUserData(userId).mAdminList) {\n            final ComponentName currentAdminComponent = admin.info.getComponent();\n            if (admin.getUid() == appUid && profileOwnerComponent.equals(currentAdminComponent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasProfileOwner(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.hasProfileOwner(userId);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the provided caller identity is of a profile owner of an organization\n     * owned device.\n     *\n     * @param caller identity of caller\n     * @return true if {@code identity} is a profile owner of an organization owned device, false\n     * otherwise.\n     */\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(CallerIdentity caller) {\n        return isProfileOwner(caller) && isProfileOwnerOfOrganizationOwnedDevice(\n                caller.getUserId());\n    }\n\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(int userId) {\n        synchronized (getLockObject()) {\n            return mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId);\n        }\n    }\n\n    private boolean isProfileOwnerOfOrganizationOwnedDevice(ComponentName who, int userId) {\n        return isProfileOwner(who, userId) && isProfileOwnerOfOrganizationOwnedDevice(userId);\n    }\n\n    private boolean isProfileOwnerOnUser0(CallerIdentity caller) {\n        return isProfileOwner(caller) && caller.getUserHandle().isSystem();\n    }\n\n    private boolean isPackage(CallerIdentity caller, String packageName) {\n        return isCallingFromPackage(packageName, caller.getUid());\n    }\n\n    @Override\n    public ComponentName getDeviceOwnerComponent(boolean callingUserOnly) {\n        if (!mHasFeature) {\n            return null;\n        }\n        if (!callingUserOnly) {\n            Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                    || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        }\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return null;\n            }\n            if (callingUserOnly && mInjector.userHandleGetCallingUserId() !=\n                    mOwners.getDeviceOwnerUserId()) {\n                return null;\n            }\n            return mOwners.getDeviceOwnerComponent();\n        }\n    }\n\n    private int getDeviceOwnerUserIdUncheckedLocked() {\n        return mOwners.hasDeviceOwner() ? mOwners.getDeviceOwnerUserId() : UserHandle.USER_NULL;\n    }\n\n    @Override\n    public int getDeviceOwnerUserId() {\n        if (!mHasFeature) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getDeviceOwnerUserIdUncheckedLocked();\n        }\n    }\n\n    private @UserIdInt int getMainUserId() {\n        int mainUserId = mUserManagerInternal.getMainUserId();\n        if (mainUserId == UserHandle.USER_NULL) {\n            Slogf.d(LOG_TAG, \"getMainUserId(): no main user, returning USER_SYSTEM\");\n            return UserHandle.USER_SYSTEM;\n        }\n        return mainUserId;\n    }\n\n    // TODO(b/240562946): Remove api as owner name is not used.\n    /**\n     * Returns the \"name\" of the device owner.  It'll work for non-DO users too, but requires\n     * MANAGE_USERS.\n     */\n    @Override\n    public String getDeviceOwnerName() {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return null;\n            }\n            // TODO This totally ignores the name passed to setDeviceOwner (change for b/20679292)\n            // Should setDeviceOwner/ProfileOwner still take a name?\n            String deviceOwnerPackage = mOwners.getDeviceOwnerPackageName();\n            return getApplicationLabel(deviceOwnerPackage, UserHandle.USER_SYSTEM);\n        }\n    }\n\n    /** Returns the active device owner or {@code null} if there is no device owner. */\n    @VisibleForTesting\n    ActiveAdmin getDeviceOwnerAdminLocked() {\n        ensureLocked();\n        ComponentName component = mOwners.getDeviceOwnerComponent();\n        if (component == null) {\n            return null;\n        }\n\n        DevicePolicyData policy = getUserData(mOwners.getDeviceOwnerUserId());\n        final int n = policy.mAdminList.size();\n        for (int i = 0; i < n; i++) {\n            ActiveAdmin admin = policy.mAdminList.get(i);\n            if (component.equals(admin.info.getComponent())) {\n                return admin;\n            }\n        }\n        Slogf.wtf(LOG_TAG, \"Active admin for device owner not found. component=\" + component);\n        return null;\n    }\n\n    /**\n     * @deprecated Use the version which does not take a user id.\n     */\n    @Deprecated\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(int userId) {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin == null) {\n            admin = getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n        }\n        return admin;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked() {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin == null) {\n            admin = getProfileOwnerOfOrganizationOwnedDeviceLocked();\n        }\n        return admin;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceOrSystemPermissionBasedAdminLocked() {\n        ensureLocked();\n        ActiveAdmin doOrPo = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n        if (isPermissionCheckFlagEnabled() && doOrPo == null) {\n            return getUserData(0).mPermissionBasedAdmin;\n        }\n        return doOrPo;\n    }\n\n    ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceParentLocked(int userId) {\n        ensureLocked();\n        ActiveAdmin admin = getDeviceOwnerAdminLocked();\n        if (admin != null) {\n            return admin;\n        }\n        admin = getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n        return admin != null ? admin.getParentActiveAdmin() : null;\n    }\n\n    @Override\n    public void clearDeviceOwner(String packageName) {\n        Objects.requireNonNull(packageName, \"packageName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        synchronized (getLockObject()) {\n            final ComponentName deviceOwnerComponent = mOwners.getDeviceOwnerComponent();\n            final int deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            if (!mOwners.hasDeviceOwner()\n                    || !deviceOwnerComponent.getPackageName().equals(packageName)\n                    || (deviceOwnerUserId != caller.getUserId())) {\n                throw new SecurityException(\n                        \"clearDeviceOwner can only be called by the device owner\");\n            }\n            enforceUserUnlocked(deviceOwnerUserId);\n\n            final ActiveAdmin admin = getDeviceOwnerAdminLocked();\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                clearDeviceOwnerLocked(admin, deviceOwnerUserId);\n                removeActiveAdminLocked(deviceOwnerComponent, deviceOwnerUserId);\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED,\n                        deviceOwnerUserId);\n            });\n            Slogf.i(LOG_TAG, \"Device owner removed: \" + deviceOwnerComponent);\n        }\n    }\n\n    private void clearOverrideApnUnchecked() {\n        if (!mHasTelephonyFeature) {\n            return;\n        }\n        // Disable Override APNs and remove them from database.\n        setOverrideApnsEnabledUnchecked(false);\n        final List<ApnSetting> apns = getOverrideApnsUnchecked();\n        for (int i = 0; i < apns.size(); i ++) {\n            removeOverrideApnUnchecked(apns.get(i).getId());\n        }\n    }\n\n    private void clearManagedProfileApnUnchecked() {\n        if (!mHasTelephonyFeature) {\n            return;\n        }\n        if (!LocalServices.getService(SystemServiceManager.class).isBootCompleted()) {\n            Slogf.i(LOG_TAG, \"Skip clearing managed profile Apn before boot completed\");\n            // Cannot talk to APN content provider before system boots\n            // Ideally we should delay the cleanup post boot_completed, not just\n            // skipping  it altogether.\n            return;\n        }\n        final List<ApnSetting> apns = getOverrideApnsUnchecked();\n        for (ApnSetting apn : apns) {\n            if (apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n                removeOverrideApnUnchecked(apn.getId());\n            }\n        }\n    }\n\n    private void clearDeviceOwnerLocked(ActiveAdmin admin, int userId) {\n        String ownersPackage = mOwners.getDeviceOwnerPackageName();\n        if (ownersPackage != null) {\n            mDeviceAdminServiceController.stopServiceForAdmin(\n                    ownersPackage, userId, \"clear-device-owner\");\n        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n            admin.forceEphemeralUsers = false;\n            admin.isNetworkLoggingEnabled = false;\n            admin.requireAutoTime = false;\n            mUserManagerInternal.setForceEphemeralUsers(admin.forceEphemeralUsers);\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        if (policyData.mPasswordTokenHandle != 0) {\n            mLockPatternUtils.removeEscrowToken(policyData.mPasswordTokenHandle, userId);\n            policyData.mPasswordTokenHandle = 0;\n        }\n        saveSettingsLocked(userId);\n        mPolicyCache.onUserRemoved(userId);\n        final DevicePolicyData systemPolicyData = getUserData(UserHandle.USER_SYSTEM);\n        systemPolicyData.mLastSecurityLogRetrievalTime = -1;\n        systemPolicyData.mLastBugReportRequestTime = -1;\n        systemPolicyData.mLastNetworkLogsRetrievalTime = -1;\n        saveSettingsLocked(UserHandle.USER_SYSTEM);\n        clearUserPoliciesLocked(userId);\n        clearOverrideApnUnchecked();\n        clearApplicationRestrictions(userId);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            mInjector.getPackageManagerInternal().clearBlockUninstallForUser(userId);\n        }\n\n        mOwners.clearDeviceOwner();\n        mOwners.writeDeviceOwner();\n\n        updateAdminCanGrantSensorsPermissionCache(userId);\n        clearDeviceOwnerUserRestriction(UserHandle.of(userId));\n        mInjector.securityLogSetLoggingEnabledProperty(false);\n        mSecurityLogMonitor.stop();\n        setNetworkLoggingActiveInternal(false);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(UserHandle.USER_SYSTEM, true);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            pushUserControlDisabledPackagesLocked(userId);\n        }\n        setGlobalSettingDeviceOwnerType(DEVICE_OWNER_TYPE_DEFAULT);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    private void clearApplicationRestrictions(int userId) {\n        // Changing app restrictions involves disk IO, offload it to the background thread.\n        mBackgroundHandler.post(() -> {\n            final List<PackageInfo> installedPackageInfos = mInjector.getPackageManager(userId)\n                    .getInstalledPackages(MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);\n            final UserHandle userHandle = UserHandle.of(userId);\n            for (final PackageInfo packageInfo : installedPackageInfos) {\n                mInjector.getUserManager().setApplicationRestrictions(\n                        packageInfo.packageName, null /* restrictions */, userHandle);\n            }\n        });\n    }\n\n    @Override\n    public boolean setProfileOwner(ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set \" + ComponentName.flattenToShortString(who)\n                    + \" as profile owner for user \" + userHandle);\n            return false;\n        }\n        Preconditions.checkArgument(who != null);\n\n        final CallerIdentity caller = getCallerIdentity();\n        // Cannot be called while holding the lock:\n        final boolean hasIncompatibleAccountsOrNonAdb =\n                hasIncompatibleAccountsOrNonAdbNoLock(caller, userHandle, who);\n        synchronized (getLockObject()) {\n            enforceCanSetProfileOwnerLocked(\n                    caller, who, userHandle, hasIncompatibleAccountsOrNonAdb);\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            Preconditions.checkArgument(\n                    isPackageInstalledForUser(who.getPackageName(), userHandle)\n                            && admin != null\n                            && !getUserData(userHandle).mRemovingAdmins.contains(who),\n                    \"Not active admin: \" + who);\n\n            final int parentUserId = getProfileParentId(userHandle);\n            // When trying to set a profile owner on a new user, it may be that this user is\n            // a profile - but it may not be a managed profile if there's a restriction on the\n            // parent to add managed profiles (e.g. if the device has a device owner).\n            if (parentUserId != userHandle && mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    UserHandle.of(parentUserId))) {\n                Slogf.i(LOG_TAG, \"Cannot set profile owner because of restriction.\");\n                return false;\n            }\n\n            boolean isAdb = isAdb(caller);\n            if (isAdb) {\n                // Log profile owner provisioning was started using adb.\n                MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.PROVISIONING_ENTRY_POINT_ADB)\n                        .setAdmin(who)\n                        .setStrings(LOG_TAG_PROFILE_OWNER)\n                        .write();\n            }\n\n            // Shutting down backup manager service permanently.\n            toggleBackupServiceActive(userHandle, /* makeActive= */ false);\n\n            mOwners.setProfileOwner(who, userHandle);\n            mOwners.writeProfileOwner(userHandle);\n            Slogf.i(LOG_TAG, \"Profile owner set: \" + who + \" on user \" + userHandle);\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (mUserManager.isManagedProfile(userHandle)) {\n                    maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                    ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                            true /* newOwner */);\n                    if (isAdb) {\n                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n                        // work profile by default due to b/382064697 . This would have\n                        //  impacted certain CTS test flows when they interact with the\n                        // work profile via ADB (for example installing an app into the\n                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n                        // reduce the potential impact.\n                        setLocalUserRestrictionInternal(\n                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n                    }\n                }\n\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userHandle);\n            });\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    who.getPackageName(), userHandle, \"set-profile-owner\");\n            return true;\n        }\n    }\n\n    private void toggleBackupServiceActive(int userId, boolean makeActive) {\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            if (mInjector.getIBackupManager() != null) {\n                mInjector.getIBackupManager()\n                        .setBackupServiceActive(userId, makeActive);\n            }\n        } catch (RemoteException e) {\n            throw new IllegalStateException(String.format(\"Failed %s backup service.\",\n                    makeActive ? \"activating\" : \"deactivating\"), e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n\n    }\n\n    @Override\n    public void clearProfileOwner(ComponentName who) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int userId = caller.getUserId();\n        Preconditions.checkCallingUser(!isManagedProfile(userId));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        enforceUserUnlocked(userId);\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                clearProfileOwnerLocked(admin, userId);\n                removeActiveAdminLocked(who, userId);\n                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                        userId);\n            });\n            Slogf.i(LOG_TAG, \"Profile owner \" + who + \" removed from user \" + userId);\n        }\n    }\n\n    public void clearProfileOwnerLocked(ActiveAdmin admin, int userId) {\n        String ownersPackage = mOwners.getProfileOwnerPackage(userId);\n        if (ownersPackage != null) {\n            mDeviceAdminServiceController.stopServiceForAdmin(\n                    ownersPackage, userId, \"clear-profile-owner\");\n        }\n\n        if (admin != null) {\n            admin.disableCamera = false;\n            admin.userRestrictions = null;\n            admin.defaultEnabledRestrictionsAlreadySet.clear();\n        }\n        final DevicePolicyData policyData = getUserData(userId);\n        policyData.mCurrentInputMethodSet = false;\n        policyData.mOwnerInstalledCaCerts.clear();\n        saveSettingsLocked(userId);\n        clearUserPoliciesLocked(userId);\n        clearApplicationRestrictions(userId);\n        mOwners.removeProfileOwner(userId);\n        mOwners.writeProfileOwner(userId);\n        deleteTransferOwnershipBundleLocked(userId);\n        toggleBackupServiceActive(userId, true);\n        applyProfileRestrictionsIfDeviceOwnerLocked();\n        setNetworkLoggingActiveInternal(false);\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(), userId, admin));\n        }\n    }\n\n    @Override\n    public void setDeviceOwnerLockScreenInfo(ComponentName who, CharSequence info) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.setDeviceOwnerInfo(info != null ? info.toString() : null));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_DEVICE_OWNER_LOCK_SCREEN_INFO)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getDeviceOwnerLockScreenInfo() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        return mInjector.binderWithCleanCallingIdentity(() ->\n            mLockPatternUtils.getDeviceOwnerInfo());\n    }\n\n    private void clearUserPoliciesLocked(int userId) {\n        // Reset some of the user-specific policies.\n        final DevicePolicyData policy = getUserData(userId);\n        policy.mPermissionPolicy = DevicePolicyManager.PERMISSION_POLICY_PROMPT;\n        // Clear delegations.\n        policy.mDelegationMap.clear();\n        policy.mStatusBarDisabled = false;\n        policy.mSecondaryLockscreenEnabled = false;\n        policy.mUserProvisioningState = DevicePolicyManager.STATE_USER_UNMANAGED;\n        policy.mAffiliationIds.clear();\n        resetAffiliationCacheLocked();\n        policy.mLockTaskPackages.clear();\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            updateLockTaskPackagesLocked(mContext, policy.mLockTaskPackages, userId);\n        }\n        policy.mLockTaskFeatures = DevicePolicyManager.LOCK_TASK_FEATURE_NONE;\n        saveSettingsLocked(userId);\n\n        try {\n            mIPermissionManager.updatePermissionFlagsForAllApps(\n                    PackageManager.FLAG_PERMISSION_POLICY_FIXED,\n                    0  /* flagValues */, userId);\n            pushUserRestrictions(userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Failing in updatePermissionFlagsForAllApps\", re);\n        }\n    }\n\n    @Override\n    public boolean hasUserSetupCompleted() {\n        return hasUserSetupCompleted(mInjector.userHandleGetCallingUserId());\n    }\n\n    // This checks only if the Setup Wizard has run.  Since Wear devices pair before\n    // completing Setup Wizard, and pairing involves transferring user data, calling\n    // logic may want to check mIsWatch or mPaired in addition to hasUserSetupCompleted().\n    private boolean hasUserSetupCompleted(int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        return mInjector.hasUserSetupCompleted(getUserData(userHandle));\n    }\n\n    private boolean hasPaired(int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        return getUserData(userHandle).mPaired;\n    }\n\n    @Override\n    public int getUserProvisioningState(int userHandle) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.STATE_USER_UNMANAGED;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller)\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (userHandle != caller.getUserId()) {\n            Preconditions.checkCallAuthorization(canManageUsers(caller)\n                    || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        }\n\n        return getUserData(userHandle).mUserProvisioningState;\n    }\n\n    @Override\n    public void setUserProvisioningState(int newState, int userId) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot set provisioning state \" + newState + \" for user \"\n                    + userId);\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        final CallerIdentity caller = getCallerIdentity();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            int deviceOwnerUserId = mOwners.getDeviceOwnerUserId();\n            // NOTE: multiple if statements are nested below so it can log more info on error\n            if (userId != deviceOwnerUserId) {\n                boolean hasProfileOwner = mOwners.hasProfileOwner(userId);\n                if (!hasProfileOwner) {\n                    int managedUserId = getManagedUserId(userId);\n                    if (managedUserId < 0 && newState != STATE_USER_UNMANAGED) {\n                        // No managed device, user or profile, so setting provisioning state makes\n                        // no sense.\n                        String error = \"Not allowed to change provisioning state unless a \"\n                                + \"device or profile owner is set.\";\n                        Slogf.w(LOG_TAG, \"setUserProvisioningState(newState=%d, userId=%d) failed: \"\n                                + \"deviceOwnerId=%d, hasProfileOwner=%b, managedUserId=%d, err=%s\",\n                                newState, userId, deviceOwnerUserId, hasProfileOwner,\n                                managedUserId, error);\n                        throw new IllegalStateException(error);\n                    }\n                }\n            }\n\n            synchronized (getLockObject()) {\n                boolean transitionCheckNeeded = true;\n\n                // Calling identity/permission checks.\n                if (isAdb(caller)) {\n                    // ADB shell can only move directly from un-managed to finalized as part of\n                    // directly setting profile-owner or device-owner.\n                    if (getUserProvisioningState(userId)\n                            != DevicePolicyManager.STATE_USER_UNMANAGED\n                            || newState != STATE_USER_SETUP_FINALIZED) {\n                        throw new IllegalStateException(\"Not allowed to change provisioning state \"\n                                + \"unless current provisioning state is unmanaged, and new state\"\n                                + \"is finalized.\");\n                    }\n                    transitionCheckNeeded = false;\n                }\n\n                final DevicePolicyData policyData = getUserData(userId);\n                if (transitionCheckNeeded) {\n                    // Optional state transition check for non-ADB case.\n                    checkUserProvisioningStateTransition(policyData.mUserProvisioningState,\n                            newState);\n                }\n                policyData.mUserProvisioningState = newState;\n                saveSettingsLocked(userId);\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void checkUserProvisioningStateTransition(int currentState, int newState) {\n        // Valid transitions for normal use-cases.\n        switch (currentState) {\n            case DevicePolicyManager.STATE_USER_UNMANAGED:\n                // Can move to any state from unmanaged (except itself as an edge case)..\n                if (newState != DevicePolicyManager.STATE_USER_UNMANAGED) {\n                    return;\n                }\n                break;\n            case DevicePolicyManager.STATE_USER_SETUP_INCOMPLETE:\n            case DevicePolicyManager.STATE_USER_SETUP_COMPLETE:\n                // Can only move to finalized from these states.\n                if (newState == STATE_USER_SETUP_FINALIZED) {\n                    return;\n                }\n                break;\n            case DevicePolicyManager.STATE_USER_PROFILE_COMPLETE:\n                // Current user has a managed-profile, but current user is not managed, so\n                // rather than moving to finalized state, go back to unmanaged once\n                // profile provisioning is complete.\n                if (newState == DevicePolicyManager.STATE_USER_PROFILE_FINALIZED) {\n                    return;\n                }\n                break;\n            case STATE_USER_SETUP_FINALIZED:\n                // Cannot transition out of finalized.\n                break;\n            case DevicePolicyManager.STATE_USER_PROFILE_FINALIZED:\n                // Should only move to an unmanaged state after removing the work profile.\n                if (newState == DevicePolicyManager.STATE_USER_UNMANAGED) {\n                    return;\n                }\n                break;\n        }\n\n        // Didn't meet any of the accepted state transition checks above, throw appropriate error.\n        throw new IllegalStateException(\"Cannot move to user provisioning state [\" + newState + \"] \"\n                + \"from state [\" + currentState + \"]\");\n    }\n\n    @Override\n    public void setProfileEnabled(ComponentName who) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot enable profile for \"\n                    + ComponentName.flattenToShortString(who));\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        final int userId = caller.getUserId();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(userId));\n\n        synchronized (getLockObject()) {\n            // Check if the profile is already enabled.\n            UserInfo managedProfile = getUserInfo(userId);\n            if (managedProfile.isEnabled()) {\n                Slogf.e(LOG_TAG,\n                        \"setProfileEnabled is called when the profile is already enabled\");\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setUserEnabled(userId);\n                UserInfo parent = mUserManager.getProfileParent(userId);\n                Intent intent = new Intent(Intent.ACTION_MANAGED_PROFILE_ADDED);\n                intent.putExtra(Intent.EXTRA_USER, new UserHandle(userId));\n                UserHandle parentHandle = new UserHandle(parent.id);\n                mLocalService.broadcastIntentToManifestReceivers(intent,\n                        parentHandle, /* requiresPermission= */ true);\n                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY |\n                        Intent.FLAG_RECEIVER_FOREGROUND);\n                mContext.sendBroadcastAsUser(intent, parentHandle);\n            });\n        }\n    }\n\n    @Override\n    public void setProfileName(ComponentName who, String profileName) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        final String truncatedProfileName =\n                profileName.substring(0, Math.min(profileName.length(), MAX_PROFILE_NAME_LENGTH));\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            mUserManager.setUserName(caller.getUserId(), truncatedProfileName);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_PROFILE_NAME)\n                    .setAdmin(caller.getComponentName())\n                    .write();\n        });\n    }\n\n    @Override\n    public ComponentName getProfileOwnerAsUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId)\n                || hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return mOwners.getProfileOwnerComponent(userId);\n        }\n    }\n\n    // Returns the active profile owner for this user or null if the current user has no\n    // profile owner.\n    @VisibleForTesting\n    ActiveAdmin getProfileOwnerAdminLocked(int userHandle) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userHandle);\n        if (profileOwner == null) {\n            return null;\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        final int n = policy.mAdminList.size();\n        for (int i = 0; i < n; i++) {\n            ActiveAdmin admin = policy.mAdminList.get(i);\n            if (profileOwner.equals(admin.info.getComponent())) {\n                return admin;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the ActiveAdmin associated with the PO or DO on the given user.\n     */\n    private @Nullable ActiveAdmin getDeviceOrProfileOwnerAdminLocked(int userHandle) {\n        ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n        if (admin == null && getDeviceOwnerUserIdUncheckedLocked() == userHandle) {\n            admin = getDeviceOwnerAdminLocked();\n        }\n        return admin;\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    ActiveAdmin getProfileOwnerOfOrganizationOwnedDeviceLocked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                if (userInfo.isManagedProfile()) {\n                    if (getProfileOwnerAsUser(userInfo.id) != null\n                            && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                        ComponentName who = getProfileOwnerAsUser(userInfo.id);\n                        return getActiveAdminUncheckedLocked(who, userInfo.id);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    ActiveAdmin getProfileOwnerOfOrganizationOwnedDeviceLocked() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                if (userInfo.isManagedProfile()) {\n                    if (getProfileOwnerAsUser(userInfo.id) != null\n                            && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                        ComponentName who = getProfileOwnerAsUser(userInfo.id);\n                        return getActiveAdminUncheckedLocked(who, userInfo.id);\n                    }\n                }\n            }\n            return null;\n        });\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public @Nullable ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(\n            @NonNull UserHandle userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        synchronized (getLockObject()) {\n            final ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n            final ComponentName poComponent =\n                    mOwners.getProfileOwnerComponent(userHandle.getIdentifier());\n            // Return test only admin if configured to do so.\n            // TODO(b/182994391): Replace with more generic solution to override the supervision\n            // component.\n            if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n                if (isAdminTestOnlyLocked(doComponent, userHandle.getIdentifier())) {\n                    return doComponent;\n                } else if (isAdminTestOnlyLocked(poComponent, userHandle.getIdentifier())) {\n                    return poComponent;\n                }\n            }\n\n            // Check profile owner first as that is what most likely is set.\n            if (isSupervisionComponentLocked(poComponent)) {\n                return poComponent;\n            }\n\n            if (isSupervisionComponentLocked(doComponent)) {\n                return doComponent;\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * Returns if the specified component is the supervision component.\n     */\n    @Override\n    public boolean isSupervisionComponent(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        synchronized (getLockObject()) {\n            if (mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {\n                final CallerIdentity caller = getCallerIdentity();\n                if (isAdminTestOnlyLocked(who, caller.getUserId())) {\n                    return true;\n                }\n            }\n            return isSupervisionComponentLocked(who);\n        }\n    }\n\n    private boolean isSupervisionComponentLocked(@Nullable ComponentName who) {\n        if (who == null) {\n            return false;\n        }\n\n        final String configComponent = mContext.getResources().getString(\n                com.android.internal.R.string.config_defaultSupervisionProfileOwnerComponent);\n        if (configComponent != null) {\n            final ComponentName componentName = ComponentName.unflattenFromString(configComponent);\n            if (who.equals(componentName)) {\n                return true;\n            }\n        }\n\n        // Check the system supervision role.\n        final String configPackage = mContext.getResources().getString(\n                com.android.internal.R.string.config_systemSupervision);\n\n        return who.getPackageName().equals(configPackage);\n    }\n\n    // TODO(b/240562946): Remove api as owner name is not used.\n    @Override\n    public String getProfileOwnerName(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return getProfileOwnerNameUnchecked(userHandle);\n    }\n\n    private String getProfileOwnerNameUnchecked(int userHandle) {\n        ComponentName profileOwner = getProfileOwnerAsUser(userHandle);\n        if (profileOwner == null) {\n            return null;\n        }\n        return getApplicationLabel(profileOwner.getPackageName(), userHandle);\n    }\n\n    private @UserIdInt int getOrganizationOwnedProfileUserId() {\n        for (UserInfo ui : mUserManagerInternal.getUserInfos()) {\n            if (ui.isManagedProfile() && isProfileOwnerOfOrganizationOwnedDevice(ui.id)) {\n                return ui.id;\n            }\n        }\n        return UserHandle.USER_NULL;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean isOrganizationOwnedDeviceWithManagedProfile() {\n        if (!mHasFeature) {\n            return false;\n        }\n        return getOrganizationOwnedProfileUserId() != UserHandle.USER_NULL;\n    }\n\n    @Override\n    public boolean checkDeviceIdentifierAccess(String packageName, int pid, int uid) {\n        final CallerIdentity caller = getCallerIdentity();\n        ensureCallerIdentityMatchesIfNotSystem(packageName, pid, uid, caller);\n\n        // Verify that the specified packages matches the provided uid.\n        if (!doesPackageMatchUid(packageName, uid)) {\n            return false;\n        }\n        // A device or profile owner must also have the READ_PHONE_STATE permission to access device\n        // identifiers. If the package being checked does not have this permission then deny access.\n        if (!hasPermission(permission.READ_PHONE_STATE, pid, uid)) {\n            return false;\n        }\n        return hasDeviceIdAccessUnchecked(packageName, uid);\n    }\n\n    /**\n     * Check if one the following conditions hold:\n     * (1) The device has a Device Owner, and one of the following holds:\n     *   (1.1) The caller is the Device Owner\n     *   (1.2) The caller is another app in the same user as the device owner, AND\n     *         The caller is the delegated certificate installer.\n     *   (1.3) The caller is a Profile Owner and the calling user is affiliated.\n     * (2) The user has a profile owner, AND:\n     *   (2.1) The profile owner has been granted access to Device IDs and one of the following\n     *         holds:\n     *     (2.1.1) The caller is the profile owner.\n     *     (2.1.2) The caller is from another app in the same user as the profile owner, AND\n     *             the caller is the delegated cert installer.\n     * (3) The caller holds the\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CERTIFICATES} permission.\n     *\n     *  For the device owner case, simply check that the caller is the device owner or the\n     *  delegated certificate installer.\n     *\n     *  For the profile owner case, first check that the caller is the profile owner or can\n     *  manage the DELEGATION_CERT_INSTALL scope.\n     *  If that check succeeds, ensure the profile owner was granted access to device\n     *  identifiers. The grant is transitive: The delegated cert installer is implicitly allowed\n     *  access to device identifiers in this case as part of the delegation.\n     */\n    @VisibleForTesting\n    boolean hasDeviceIdAccessUnchecked(String packageName, int uid) {\n        final int userId = UserHandle.getUserId(uid);\n        // TODO(b/280048070): Introduce a permission to handle device ID access\n        if (isPermissionCheckFlagEnabled()\n                && !(isUidProfileOwnerLocked(uid) || isUidDeviceOwnerLocked(uid))) {\n            return hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES, packageName, userId);\n        } else {\n            ComponentName deviceOwner = getDeviceOwnerComponent(true);\n            if (deviceOwner != null && (deviceOwner.getPackageName().equals(packageName)\n                    || isCallerDelegate(packageName, uid, DELEGATION_CERT_INSTALL))) {\n                return true;\n            }\n            ComponentName profileOwner = getProfileOwnerAsUser(userId);\n            final boolean isCallerProfileOwnerOrDelegate = profileOwner != null\n                    && (profileOwner.getPackageName().equals(packageName)\n                    || isCallerDelegate(packageName, uid, DELEGATION_CERT_INSTALL));\n            if (isCallerProfileOwnerOrDelegate && (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                    || isUserAffiliatedWithDevice(userId))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean doesPackageMatchUid(String packageName, int uid) {\n        final int userId = UserHandle.getUserId(uid);\n        try {\n            ApplicationInfo appInfo = mIPackageManager.getApplicationInfo(packageName, 0, userId);\n            // Since this call goes directly to PackageManagerService a NameNotFoundException is not\n            // thrown but null data can be returned; if the appInfo for the specified package cannot\n            // be found then return false to prevent crashing the app.\n            if (appInfo == null) {\n                Slogf.w(LOG_TAG, \"appInfo could not be found for package %s\", packageName);\n                return false;\n            } else if (uid != appInfo.uid) {\n                String message = String.format(\"Package %s (uid=%d) does not match provided uid %d\",\n                        packageName, appInfo.uid, uid);\n                Slogf.w(LOG_TAG, message);\n                throw new SecurityException(message);\n            }\n        } catch (RemoteException e) {\n            // If an exception is caught obtaining the appInfo just return false to prevent crashing\n            // apps due to an internal error.\n            Slogf.e(LOG_TAG, e, \"Exception caught obtaining appInfo for package %s\", packageName);\n            return false;\n        }\n        return true;\n    }\n\n    private void ensureCallerIdentityMatchesIfNotSystem(String packageName, int pid, int uid,\n            CallerIdentity caller) {\n        // If the caller is not a system app then it should only be able to check its own device\n        // identifier access.\n        int callingUid = caller.getUid();\n        int callingPid = mInjector.binderGetCallingPid();\n        if (UserHandle.getAppId(callingUid) >= Process.FIRST_APPLICATION_UID\n                && (callingUid != uid || callingPid != pid)) {\n            String message = String.format(\n                    \"Calling uid %d, pid %d cannot check device identifier access for package %s \"\n                            + \"(uid=%d, pid=%d)\", callingUid, callingPid, packageName, uid, pid);\n            Slogf.w(LOG_TAG, message);\n            throw new SecurityException(message);\n        }\n    }\n\n    /**\n     * Canonical name for a given package.\n     */\n    private String getApplicationLabel(String packageName, @UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final Context userContext;\n            try {\n                UserHandle userHandle = UserHandle.of(userId);\n                userContext = mContext.createPackageContextAsUser(packageName, /* flags= */ 0,\n                        userHandle);\n            } catch (PackageManager.NameNotFoundException nnfe) {\n                Slogf.w(LOG_TAG, nnfe, \"%s is not installed for user %d\", packageName, userId);\n                return null;\n            }\n            ApplicationInfo appInfo = userContext.getApplicationInfo();\n            CharSequence result = null;\n            if (appInfo != null) {\n                result = appInfo.loadUnsafeLabel(userContext.getPackageManager());\n            }\n            return result != null ? result.toString() : null;\n        });\n    }\n\n    /**\n     * The profile owner can only be set by adb or an app with the MANAGE_PROFILE_AND_DEVICE_OWNERS\n     * permission.\n     * The profile owner can only be set before the user setup phase has completed,\n     * except for:\n     * - SYSTEM_UID\n     * - adb unless hasIncompatibleAccountsOrNonAdb is true.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void enforceCanSetProfileOwnerLocked(\n            CallerIdentity caller, @Nullable ComponentName owner, @UserIdInt int userId,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        UserInfo info = getUserInfo(userId);\n        if (info == null) {\n            // User doesn't exist.\n            throw new IllegalArgumentException(\n                    \"Attempted to set profile owner for invalid userId: \" + userId);\n        }\n        if (info.isGuest()) {\n            throw new IllegalStateException(\"Cannot set a profile owner on a guest\");\n        }\n        if (mOwners.hasProfileOwner(userId)) {\n            StringBuilder errorMessage = new StringBuilder(\"Trying to set the profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                append(errorMessage, owner).append(\" on user \").append(userId);\n            }\n            errorMessage.append(\", but profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                appendProfileOwnerLocked(errorMessage, userId);\n            }\n\n            throw new IllegalStateException(errorMessage.append(\" is already set.\").toString());\n        }\n        if (mOwners.hasDeviceOwner() && mOwners.getDeviceOwnerUserId() == userId) {\n            StringBuilder errorMessage = new StringBuilder(\"Trying to set the profile owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                append(errorMessage, owner).append(\" on user \").append(userId);\n            }\n            errorMessage.append(\", but the user already has a device owner\");\n            if (!hasIncompatibleAccountsOrNonAdb) {\n                appendDeviceOwnerLocked(errorMessage);\n            }\n            throw new IllegalStateException(errorMessage.append('.').toString());\n        }\n        if (isAdb(caller)) {\n            if ((mIsWatch || hasUserSetupCompleted(userId))\n                    && hasIncompatibleAccountsOrNonAdb) {\n                StringBuilder errorMessage = new StringBuilder(\"Not allowed to set the profile \"\n                        + \"owner\");\n                if (!hasIncompatibleAccountsOrNonAdb) {\n                    append(errorMessage, owner).append(\" on user \").append(userId).append(' ');\n                }\n                throw new IllegalStateException(errorMessage.append(\" because there are already \"\n                        + \"some accounts on the profile.\").toString());\n            }\n            return;\n        }\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if ((mIsWatch || hasUserSetupCompleted(userId))) {\n            Preconditions.checkState(isSystemUid(caller),\n                    \"Cannot set the profile owner on a user which is already set-up\");\n\n            if (!mIsWatch) {\n                if (!isSupervisionComponentLocked(owner)) {\n                    throw new IllegalStateException(\"Unable to set non-default profile owner\"\n                            + \" post-setup \" + owner);\n                }\n            }\n        }\n    }\n\n    /**\n     * The Device owner can only be set by adb or an app with the MANAGE_PROFILE_AND_DEVICE_OWNERS\n     * permission.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void enforceCanSetDeviceOwnerLocked(\n            CallerIdentity caller, @Nullable ComponentName owner, @UserIdInt int deviceOwnerUserId,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        boolean showComponentOnError = false;\n        if (!isAdb(caller)) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        } else {\n            showComponentOnError = true;\n        }\n\n        final int code = checkDeviceOwnerProvisioningPreConditionLocked(owner,\n                /* deviceOwnerUserId= */ deviceOwnerUserId, /* callingUserId*/ caller.getUserId(),\n                isAdb(caller), hasIncompatibleAccountsOrNonAdb);\n        if (code != STATUS_OK) {\n            final String provisioningErrorStringLocked = computeProvisioningErrorStringLocked(code,\n                    deviceOwnerUserId, owner, showComponentOnError);\n            if (code == STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED) {\n                throw new ServiceSpecificException(code, provisioningErrorStringLocked);\n            } else {\n                throw new IllegalStateException(provisioningErrorStringLocked);\n            }\n        }\n    }\n\n    private String computeProvisioningErrorString(int code, @UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            return computeProvisioningErrorStringLocked(code, userId, /* newOwner= */ null,\n                    /* showComponentOnError= */ false);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private String computeProvisioningErrorStringLocked(int code, @UserIdInt int userId,\n            @Nullable ComponentName newOwner, boolean showComponentOnError) {\n        switch (code) {\n            case STATUS_OK:\n                return \"OK\";\n            case STATUS_HAS_DEVICE_OWNER: {\n                StringBuilder error = new StringBuilder(\"Trying to set the device owner\");\n                if (showComponentOnError && newOwner != null) {\n                    append(error, newOwner);\n                }\n                error.append(\", but device owner\");\n                if (showComponentOnError) {\n                    appendDeviceOwnerLocked(error);\n                }\n                return error.append(\" is already set.\").toString();\n            }\n            case STATUS_USER_HAS_PROFILE_OWNER: {\n                StringBuilder error = new StringBuilder(\"Trying to set the device owner\");\n                if (showComponentOnError && newOwner != null) {\n                    append(error, newOwner);\n                }\n                error.append(\", but the user already has a profile owner\");\n                if (showComponentOnError) {\n                    appendProfileOwnerLocked(error, userId);\n                }\n                return error.append(\".\").toString();\n            }\n            case STATUS_USER_NOT_RUNNING:\n                return \"User \" + userId + \" not running.\";\n            case STATUS_NOT_SYSTEM_USER:\n                return \"User \" + userId + \" is not system user.\";\n            case STATUS_USER_SETUP_COMPLETED:\n                return  \"Cannot set the device owner if the device is already set-up.\";\n            case STATUS_NONSYSTEM_USER_EXISTS:\n                return \"Not allowed to set the device owner because there are already several\"\n                        + \" users on the device.\";\n            case STATUS_ACCOUNTS_NOT_EMPTY:\n                return \"Not allowed to set the device owner because there are already some accounts\"\n                        + \" on the device.\";\n            case STATUS_HAS_PAIRED:\n                return \"Not allowed to set the device owner because this device has already \"\n                        + \"paired.\";\n            case STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED:\n                return \"Cannot provision an unsupported DPC into DO on a\"\n                        + \" headless device\";\n            default:\n                return \"Unexpected @ProvisioningPreCondition: \" + code;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void appendDeviceOwnerLocked(StringBuilder string) {\n        ComponentName deviceOwner = getDeviceOwnerComponent(/* callingUserOnly= */ false);\n        if (deviceOwner == null) {\n            // Shouldn't happen, but it doesn't hurt to check...\n            Slogf.wtf(LOG_TAG, \"appendDeviceOwnerLocked(): device has no DO set\");\n            return;\n        }\n        append(string, deviceOwner);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void appendProfileOwnerLocked(StringBuilder string, @UserIdInt int userId) {\n        ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n        if (profileOwner == null) {\n            // Shouldn't happen, but it doesn't hurt to check...\n            Slogf.wtf(LOG_TAG, \"profileOwner(%d): PO not set\", userId);\n            return;\n        }\n        append(string, profileOwner);\n    }\n\n    private static StringBuilder append(StringBuilder string, ComponentName component) {\n        return string.append(\" (\").append(component.flattenToShortString()).append(')');\n    }\n\n    private void enforceUserUnlocked(int userId) {\n        // Since we're doing this operation on behalf of an app, we only\n        // want to use the actual \"unlocked\" state.\n        Preconditions.checkState(mUserManager.isUserUnlocked(userId),\n                \"User must be running and unlocked\");\n    }\n\n    private void enforceUserUnlocked(@UserIdInt int userId, boolean parent) {\n        if (parent) {\n            enforceUserUnlocked(getProfileParentId(userId));\n        } else {\n            enforceUserUnlocked(userId);\n        }\n    }\n\n    private boolean canManageUsers(CallerIdentity caller) {\n        return hasCallingOrSelfPermission(permission.MANAGE_USERS);\n    }\n\n    private boolean canQueryAdminPolicy(CallerIdentity caller) {\n        return hasCallingOrSelfPermission(permission.QUERY_ADMIN_POLICY);\n    }\n\n    private boolean hasPermission(String permission, int pid, int uid) {\n        return mContext.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private boolean hasCallingPermission(String permission) {\n        return mContext.checkCallingPermission(permission) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private boolean hasCallingOrSelfPermission(String permission) {\n        return mContext.checkCallingOrSelfPermission(permission)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private boolean hasPermissionForPreflight(CallerIdentity caller, String permission) {\n        final int callingPid = mInjector.binderGetCallingPid();\n        final String packageName = mContext.getPackageName();\n\n        return PermissionChecker.checkPermissionForPreflight(mContext, permission, callingPid,\n                caller.getUid(), packageName) == PermissionChecker.PERMISSION_GRANTED;\n    }\n\n    private boolean hasFullCrossUsersPermission(CallerIdentity caller, int userHandle) {\n        return (userHandle == caller.getUserId()) || isSystemUid(caller) || isRootUid(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL);\n    }\n\n    private boolean hasCrossUsersPermission(CallerIdentity caller, int userHandle) {\n        return (userHandle == caller.getUserId()) || isSystemUid(caller) || isRootUid(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS);\n    }\n\n    private boolean canDPCManagedUserUseLockTaskLocked(int userId) {\n        if (isUserAffiliatedWithDeviceLocked(userId)) {\n            return true;\n        }\n\n        // Unaffiliated profile owners are not allowed to use lock when there is a device owner.\n        if (mOwners.hasDeviceOwner()) {\n            return false;\n        }\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner == null) {\n            return false;\n        }\n        // Managed profiles are not allowed to use lock task\n        if (isManagedProfile(userId)) {\n            return false;\n        }\n\n        return true;\n    }\n    private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId = caller.getUserId();\n\n        enforceCanQuery(MANAGE_DEVICE_POLICY_LOCK_TASK, caller.getPackageName(), userId);\n        if ((isDeviceOwner(caller) || isProfileOwner(caller))\n                && !canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n    }\n\n    private EnforcingAdmin enforceCanCallLockTaskLocked(ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        final int userId =  caller.getUserId();\n\n        EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                who,\n                MANAGE_DEVICE_POLICY_LOCK_TASK,\n                caller.getPackageName(),\n                userId\n        );\n        if ((isDeviceOwner(caller) || isProfileOwner(caller))\n                && !canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n        return enforcingAdmin;\n    }\n\n    private void enforceCanCallLockTaskLocked(CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n\n        final int userId =  caller.getUserId();\n        if (!canDPCManagedUserUseLockTaskLocked(userId)) {\n            throw new SecurityException(\"User \" + userId + \" is not allowed to use lock task\");\n        }\n    }\n\n    private boolean isSystemUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.SYSTEM_UID);\n    }\n\n    private boolean isRootUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.ROOT_UID);\n    }\n\n    private boolean isShellUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.SHELL_UID);\n    }\n\n    private boolean isCameraServerUid(CallerIdentity caller) {\n        return UserHandle.isSameApp(caller.getUid(), Process.CAMERASERVER_UID);\n    }\n\n    private @UserIdInt int getCurrentForegroundUserId() {\n        try {\n            UserInfo currentUser = mInjector.getIActivityManager().getCurrentUser();\n            if (currentUser == null) {\n                // TODO(b/206107460): should not happen on production, but it's happening on unit\n                // tests that are not properly setting the expectation (because they don't need it)\n                Slogf.wtf(LOG_TAG, \"getCurrentForegroundUserId(): mInjector.getIActivityManager()\"\n                        + \".getCurrentUser() returned null, please ignore when running unit tests\");\n                return ActivityManager.getCurrentUser();\n            }\n            return currentUser.id;\n        } catch (RemoteException e) {\n            Slogf.wtf(LOG_TAG, \"cannot get current user\", e);\n        }\n        return UserHandle.USER_NULL;\n    }\n\n    @Override\n    public List<UserHandle> listForegroundAffiliatedUsers() {\n        checkIsDeviceOwner(getCallerIdentity());\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            int userId = getCurrentForegroundUserId();\n            boolean isAffiliated;\n            synchronized (getLockObject()) {\n                isAffiliated = isUserAffiliatedWithDeviceLocked(userId);\n            }\n\n            if (!isAffiliated) return Collections.emptyList();\n\n            List<UserHandle> users = new ArrayList<>(1);\n            users.add(UserHandle.of(userId));\n\n            return users;\n        });\n    }\n\n    protected int getProfileParentId(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            UserInfo parentUser = mUserManager.getProfileParent(userHandle);\n            return parentUser != null ? parentUser.id : userHandle;\n        });\n    }\n\n    private int getProfileParentUserIfRequested(int userHandle, boolean parent) {\n        if (parent) {\n            return getProfileParentId(userHandle);\n        }\n\n        return userHandle;\n    }\n\n    private int getCredentialOwner(final int userHandle, final boolean parent) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            int effectiveUserHandle = userHandle;\n            if (parent) {\n                UserInfo parentProfile = mUserManager.getProfileParent(userHandle);\n                if (parentProfile != null) {\n                    effectiveUserHandle = parentProfile.id;\n                }\n            }\n            return mUserManager.getCredentialOwnerProfile(effectiveUserHandle);\n        });\n    }\n\n    private boolean isManagedProfile(int userHandle) {\n        final UserInfo user = getUserInfo(userHandle);\n        return user != null && user.isManagedProfile();\n    }\n\n    private void enableIfNecessary(String packageName, int userId) {\n        try {\n            final ApplicationInfo ai = mIPackageManager.getApplicationInfo(packageName,\n                    PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS, userId);\n            if (ai.enabledSetting\n                    == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) {\n                mIPackageManager.setApplicationEnabledSetting(packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        PackageManager.DONT_KILL_APP, userId, \"DevicePolicyManager\");\n            }\n        } catch (RemoteException e) {\n        }\n    }\n\n    private void dumpPerUserData(IndentingPrintWriter pw) {\n        int userCount = mUserData.size();\n        for (int i = 0; i < userCount; i++) {\n            int userId = mUserData.keyAt(i);\n            DevicePolicyData policy = getUserData(userId);\n            policy.dump(pw);\n            pw.println();\n\n            if (userId == UserHandle.USER_SYSTEM) {\n                pw.increaseIndent();\n                PersonalAppsSuspensionHelper.forUser(mContext, userId).dump(pw);\n                pw.decreaseIndent();\n                pw.println();\n            } else {\n                // pm.getUnsuspendablePackages() will fail if it's called for a different user;\n                // as this dump is mostly useful for system user anyways, we can just ignore the\n                // others (rather than changing the permission check in the PM method)\n                Slogf.d(LOG_TAG, \"skipping PersonalAppsSuspensionHelper.dump() for user \" + userId);\n            }\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter printWriter, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, LOG_TAG, printWriter)) return;\n\n        try (IndentingPrintWriter pw = new IndentingPrintWriter(printWriter, \"  \")) {\n            pw.println(\"Current Device Policy Manager state:\");\n            pw.increaseIndent();\n\n            dumpImmutableState(pw);\n            synchronized (getLockObject()) {\n                mOwners.dump(pw);\n                pw.println();\n                mDeviceAdminServiceController.dump(pw);\n                pw.println();\n                dumpPerUserData(pw);\n                pw.println();\n                mConstants.dump(pw);\n                pw.println();\n                mStatLogger.dump(pw);\n                pw.println();\n                pw.println(\"Encryption Status: \" + getEncryptionStatusName(getEncryptionStatus()));\n                pw.println(\"Logout user: \" + getLogoutUserIdUnchecked());\n                pw.println();\n\n                if (mPendingUserCreatedCallbackTokens.isEmpty()) {\n                    pw.println(\"no pending user created callback tokens\");\n                } else {\n                    int size = mPendingUserCreatedCallbackTokens.size();\n                    pw.printf(\"%d pending user created callback token%s\\n\", size,\n                            (size == 1 ? \"\" : \"s\"));\n                }\n                pw.println();\n                pw.println(\"Keep profiles running: \"\n                        + getUserData(UserHandle.USER_SYSTEM).mEffectiveKeepProfilesRunning);\n                pw.println();\n\n                mPolicyCache.dump(pw);\n                pw.println();\n                mStateCache.dump(pw);\n                pw.println();\n            }\n\n            synchronized (mSubscriptionsChangedListenerLock) {\n                pw.println(\"Subscription changed listener : \" + mSubscriptionsChangedListener);\n            }\n\n            pw.println(\"DPM global setting ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS : \"\n                    + mInjector.settingsGlobalGetString(\n                    Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS));\n            mHandler.post(() -> handleDump(pw));\n            dumpResources(pw);\n        }\n    }\n\n    // Dump state that is guarded by the handler\n    private void handleDump(IndentingPrintWriter pw) {\n        if (mNetworkLoggingNotificationUserId != UserHandle.USER_NULL) {\n            pw.println(\"mNetworkLoggingNotificationUserId:  \" + mNetworkLoggingNotificationUserId);\n        }\n    }\n\n    private void dumpImmutableState(IndentingPrintWriter pw) {\n        pw.println(\"Immutable state:\");\n        pw.increaseIndent();\n        pw.printf(\"mHasFeature=%b\\n\", mHasFeature);\n        pw.printf(\"mIsWatch=%b\\n\", mIsWatch);\n        pw.printf(\"mIsAutomotive=%b\\n\", mIsAutomotive);\n        pw.printf(\"mHasTelephonyFeature=%b\\n\", mHasTelephonyFeature);\n        pw.printf(\"mSafetyChecker=%s\\n\", mSafetyChecker);\n        pw.decreaseIndent();\n    }\n\n    private void dumpResources(IndentingPrintWriter pw) {\n        mOverlayPackagesProvider.dump(pw);\n        pw.println();\n\n        pw.println(\"Other overlayable app resources\");\n        pw.increaseIndent();\n        dumpResources(pw, mContext, \"cross_profile_apps\", R.array.cross_profile_apps);\n        dumpResources(pw, mContext, \"vendor_cross_profile_apps\", R.array.vendor_cross_profile_apps);\n        dumpResources(pw, mContext, \"config_packagesExemptFromSuspension\",\n                R.array.config_packagesExemptFromSuspension);\n        dumpResources(pw, mContext, \"policy_exempt_apps\", R.array.policy_exempt_apps);\n        dumpResources(pw, mContext, \"vendor_policy_exempt_apps\", R.array.vendor_policy_exempt_apps);\n        pw.decreaseIndent();\n        pw.println();\n    }\n\n    static void dumpResources(IndentingPrintWriter pw, Context context, String resName, int resId) {\n        dumpApps(pw, resName, context.getResources().getStringArray(resId));\n    }\n\n    static void dumpApps(IndentingPrintWriter pw, String name, String[] apps) {\n        dumpApps(pw, name, Arrays.asList(apps));\n    }\n\n    static void dumpApps(IndentingPrintWriter pw, String name, List apps) {\n        if (apps == null || apps.isEmpty()) {\n            pw.printf(\"%s: empty\\n\", name);\n            return;\n        }\n        int size = apps.size();\n        pw.printf(\"%s: %d app%s\\n\", name, size, size == 1 ? \"\" : \"s\");\n        pw.increaseIndent();\n        for (int i = 0; i < size; i++) {\n            pw.printf(\"%d: %s\\n\", i, apps.get(i));\n        }\n        pw.decreaseIndent();\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n            String[] args, ShellCallback callback, ResultReceiver resultReceiver) {\n        new DevicePolicyManagerServiceShellCommand(DevicePolicyManagerService.this).exec(\n                this, in, out, err, args, callback, resultReceiver);\n\n    }\n\n    private String getEncryptionStatusName(int encryptionStatus) {\n        switch (encryptionStatus) {\n            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:\n                return \"per-user\";\n            case DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED:\n                return \"unsupported\";\n            default:\n                return \"unknown\";\n        }\n    }\n\n    @Override\n    public void addPersistentPreferredActivity(ComponentName who, String callerPackageName,\n            IntentFilter filter, ComponentName activity) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        final int userId = caller.getUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            if (who == null) {\n                enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        MANAGE_DEVICE_POLICY_LOCK_TASK,\n                        caller.getPackageName(),\n                        userId);\n            } else {\n                Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                        || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n                enforcingAdmin = getEnforcingAdminForCaller(who, callerPackageName);\n            }\n            if (!isPackageInstalledForUser(activity.getPackageName(), userId)) {\n                // Fail early as packageManager doesn't persist the activity if its not installed.\n                return;\n            }\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                    enforcingAdmin,\n                    new ComponentNamePolicyValue(activity),\n                    userId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                long id = mInjector.binderClearCallingIdentity();\n                try {\n                    mIPackageManager.addPersistentPreferredActivity(filter, activity, userId);\n                    mIPackageManager.flushPackageRestrictionsAsUser(userId);\n                } catch (RemoteException re) {\n                    // Shouldn't happen\n                    Slog.wtf(LOG_TAG, \"Error adding persistent preferred activity\", re);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(id);\n                }\n            }\n        }\n        final String activityPackage =\n                (activity != null ? activity.getPackageName() : null);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_PERSISTENT_PREFERRED_ACTIVITY)\n                .setAdmin(caller.getPackageName())\n                .setStrings(activityPackage, getIntentFilterActions(filter))\n                .write();\n    }\n\n    @Override\n    public void clearPackagePersistentPreferredActivities(ComponentName who,\n            String callerPackageName, String packageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userId = caller.getUserId();\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            if (who == null) {\n                enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        MANAGE_DEVICE_POLICY_LOCK_TASK,\n                        caller.getPackageName(),\n                        userId);\n            } else {\n                Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                        || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n                enforcingAdmin = getEnforcingAdminForCaller(who, callerPackageName);\n            }\n            clearPackagePersistentPreferredActivitiesFromPolicyEngine(\n                    enforcingAdmin,\n                    packageName,\n                    userId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isProfileOwner(caller)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                long id = mInjector.binderClearCallingIdentity();\n                try {\n                    mIPackageManager.clearPackagePersistentPreferredActivities(packageName,\n                            userId);\n                    mIPackageManager.flushPackageRestrictionsAsUser(userId);\n                } catch (RemoteException re) {\n                    // Shouldn't happen\n                    Slogf.wtf(\n                            LOG_TAG, \"Error when clearing package persistent preferred activities\",\n                            re);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(id);\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove all persistent intent handler preferences associated with the given package that were\n     * set by this admin, note that is doesn't remove preferences set by other admins for the same\n     * package.\n     */\n    private void clearPackagePersistentPreferredActivitiesFromPolicyEngine(\n            EnforcingAdmin admin, String packageName, int userId) {\n        Set<PolicyKey> keys = mDevicePolicyEngine.getLocalPolicyKeysSetByAdmin(\n                PolicyDefinition.GENERIC_PERSISTENT_PREFERRED_ACTIVITY,\n                admin,\n                userId);\n        for (PolicyKey key : keys) {\n            if (!(key instanceof IntentFilterPolicyKey)) {\n                throw new IllegalStateException(\"PolicyKey for PERSISTENT_PREFERRED_ACTIVITY is not\"\n                        + \"of type IntentFilterPolicyKey\");\n            }\n            IntentFilterPolicyKey parsedKey =\n                    (IntentFilterPolicyKey) key;\n            IntentFilter filter = Objects.requireNonNull(parsedKey.getIntentFilter());\n\n            ComponentName preferredActivity = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                    admin,\n                    userId);\n            if (preferredActivity != null\n                    && preferredActivity.getPackageName().equals(packageName)) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(filter),\n                        admin,\n                        userId);\n            }\n        }\n    }\n\n    @Override\n    public void setDefaultSmsApplication(ComponentName admin, String callerPackageName,\n            String packageName, boolean parent) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        final int userId;\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                    caller.getPackageName(),\n                    getAffectedUser(parent));\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        if (!parent && isManagedProfile(caller.getUserId())\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                != ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            throw new IllegalStateException(\n                    \"Default sms application can only be set on the profile, when \"\n                            + \"ManagedSubscriptions policy is set\");\n        }\n\n        if (parent) {\n            userId = getProfileParentId(mInjector.userHandleGetCallingUserId());\n            mInjector.binderWithCleanCallingIdentity(() -> enforcePackageIsSystemPackage(\n                    packageName, userId));\n        } else {\n            userId = mInjector.userHandleGetCallingUserId();\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                SmsApplication.setDefaultApplicationAsUser(packageName, mContext, userId));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                    getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n\n            if (isManagedProfile(userId)) {\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> updateDialerAndSmsManagedShortcutsOverrideCache());\n            }\n\n            if (!Objects.equals(activeAdmin.mSmsPackage, packageName)) {\n                activeAdmin.mSmsPackage = packageName;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public void setDefaultDialerApplication(String packageName) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        final int callerUserId = caller.getUserId();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            CompletableFuture<Void> future = new CompletableFuture<>();\n            Consumer<Boolean> callback = successful -> {\n                if (successful) {\n                    future.complete(null);\n                } else {\n                    future.completeExceptionally(new IllegalArgumentException(\n                            packageName +  \" cannot be set as the dialer\"));\n                }\n            };\n            mRoleManager.addRoleHolderAsUser(\n                    RoleManager.ROLE_DIALER, packageName, 0, UserHandle.of(callerUserId),\n                    AsyncTask.THREAD_POOL_EXECUTOR, callback);\n            try {\n                future.get(20, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                throw new IllegalArgumentException(\"Timeout when setting the app as the dialer\", e);\n            } catch (ExecutionException e) {\n                Throwable cause = e.getCause();\n                if (cause instanceof IllegalArgumentException) {\n                    throw (IllegalArgumentException) cause;\n                } else {\n                    throw new IllegalStateException(cause);\n                }\n            }\n        });\n        // Only save the package when the setting the role succeeded without exception.\n        synchronized (getLockObject()) {\n            if (isManagedProfile(callerUserId)) {\n                mInjector.binderWithCleanCallingIdentity(\n                        () -> updateDialerAndSmsManagedShortcutsOverrideCache());\n            }\n\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(callerUserId);\n            if (!Objects.equals(admin.mDialerPackage, packageName)) {\n                admin.mDialerPackage = packageName;\n                saveSettingsLocked(callerUserId);\n            }\n        }\n    }\n\n    @Override\n    public boolean setApplicationRestrictionsManagingPackage(ComponentName admin,\n            String packageName) {\n        try {\n            setDelegatedScopePreO(admin, packageName, DELEGATION_APP_RESTRICTIONS);\n        } catch (IllegalArgumentException e) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String getApplicationRestrictionsManagingPackage(ComponentName admin) {\n        final List<String> delegatePackages = getDelegatePackages(admin,\n                DELEGATION_APP_RESTRICTIONS);\n        return delegatePackages.size() > 0 ? delegatePackages.get(0) : null;\n    }\n\n    @Override\n    public boolean isCallerApplicationRestrictionsManagingPackage(String callerPackage) {\n        return isCallerDelegate(callerPackage, getCallerIdentity().getUid(),\n                DELEGATION_APP_RESTRICTIONS);\n    }\n\n    @Override\n    public void setApplicationRestrictions(ComponentName who, String callerPackage,\n            String packageName, Bundle restrictions) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APPLICATION_RESTRICTIONS);\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    caller.getPackageName(),\n                    caller.getUserId()\n            );\n            // This check is eventually made in UMS, checking here to fail early.\n            String validationResult =\n                    FrameworkParsingPackageUtils.validateName(packageName, false, false);\n            if (validationResult != null) {\n                throw new IllegalArgumentException(\"Invalid package name: \" + validationResult);\n            }\n\n            if (restrictions == null || restrictions.isEmpty()) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        enforcingAdmin,\n                        new BundlePolicyValue(restrictions),\n                        caller.getUserId());\n            }\n            setBackwardsCompatibleAppRestrictions(\n                    caller, packageName, restrictions, caller.getUserHandle());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_APP_RESTRICTIONS)));\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setApplicationRestrictions(packageName, restrictions,\n                        caller.getUserHandle());\n            });\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_RESTRICTIONS)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName)\n                .write();\n    }\n\n    /**\n     * Set app restrictions in user manager for DPC callers only to keep backwards compatibility\n     * for the old getApplicationRestrictions API.\n     */\n    private void setBackwardsCompatibleAppRestrictions(\n            CallerIdentity caller, String packageName, Bundle restrictions, UserHandle userHandle) {\n        if ((caller.hasAdminComponent() && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_APP_RESTRICTIONS))) {\n            Bundle restrictionsToApply = restrictions == null || restrictions.isEmpty()\n                    ? getAppRestrictionsSetByAnyAdmin(packageName, userHandle)\n                    : restrictions;\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                mUserManager.setApplicationRestrictions(packageName, restrictionsToApply,\n                        userHandle);\n            });\n        } else {\n            // Notify package of changes via an intent - only sent to explicitly registered\n            // receivers. Sending here because For DPCs, this is being sent in UMS.\n            final Intent changeIntent = new Intent(Intent.ACTION_APPLICATION_RESTRICTIONS_CHANGED);\n            changeIntent.setPackage(packageName);\n            changeIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n            mContext.sendBroadcastAsUser(changeIntent, userHandle);\n        }\n    }\n\n    private Bundle getAppRestrictionsSetByAnyAdmin(String packageName, UserHandle userHandle) {\n        LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                        userHandle.getIdentifier());\n        return policies.isEmpty()\n                ? null : policies.entrySet().stream().findAny().get().getValue().getValue();\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mContext.getPackageManager().getApplicationInfoAsUser(\n                        packageName, /* flags= */ 0, userId).uid;\n            } catch (NameNotFoundException exception) {\n                return -1;\n            }\n        });\n    }\n\n    @Override\n    public void setTrustAgentConfiguration(\n            ComponentName admin, String callerPackageName, ComponentName agent,\n            PersistableBundle args, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(admin, \"admin is null\");\n        }\n\n        Objects.requireNonNull(agent, \"agent is null\");\n\n        enforceMaxPackageNameLength(agent.getPackageName());\n        final String agentAsString = agent.flattenToString();\n        enforceMaxStringLength(agentAsString, \"agent name\");\n        if (args != null) {\n            enforceMaxStringLength(args, \"args\");\n        }\n\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(admin, callerPackageName);\n                int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        admin,\n                        /*permission=*/MANAGE_DEVICE_POLICY_KEYGUARD,\n                        /*adminPolicy=*/DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES,\n                        caller.getPackageName(), affectedUserId).getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(admin,\n                        DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);\n            }\n            checkCanExecuteOrThrowUnsafe(\n                    DevicePolicyManager.OPERATION_SET_TRUST_AGENT_CONFIGURATION);\n\n            ap.trustAgentInfos.put(agentAsString, new TrustAgentInfo(args));\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public List<PersistableBundle> getTrustAgentConfiguration(ComponentName admin,\n            ComponentName agent, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return null;\n        }\n        Objects.requireNonNull(agent, \"agent null\");\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            final String componentName = agent.flattenToString();\n            if (admin != null) {\n                final ActiveAdmin ap = getActiveAdminUncheckedLocked(admin, userHandle, parent);\n                if (ap == null) return null;\n                TrustAgentInfo trustAgentInfo = ap.trustAgentInfos.get(componentName);\n                if (trustAgentInfo == null || trustAgentInfo.options == null) return null;\n                List<PersistableBundle> result = new ArrayList<>();\n                result.add(trustAgentInfo.options);\n                return result;\n            }\n\n            // Return strictest policy for this user and profiles that are visible from this user.\n            List<PersistableBundle> result = null;\n            // Search through all admins that use KEYGUARD_DISABLE_TRUST_AGENTS and keep track\n            // of the options. If any admin doesn't have options, discard options for the rest\n            // and return null.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            boolean allAdminsHaveOptions = true;\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin active = admins.get(i);\n\n                final boolean disablesTrust = (active.disabledKeyguardFeatures\n                        & DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS) != 0;\n                final TrustAgentInfo info = active.trustAgentInfos.get(componentName);\n                if (info != null && info.options != null && !info.options.isEmpty()) {\n                    if (disablesTrust) {\n                        if (result == null) {\n                            result = new ArrayList<>();\n                        }\n                        result.add(info.options);\n                    } else {\n                        Slogf.w(LOG_TAG, \"Ignoring admin %s because it has trust options but \"\n                                + \"doesn't declare KEYGUARD_DISABLE_TRUST_AGENTS\", active.info);\n                    }\n                } else if (disablesTrust) {\n                    allAdminsHaveOptions = false;\n                    break;\n                }\n            }\n            return allAdminsHaveOptions ? result : null;\n        }\n    }\n\n    @Override\n    public void setRestrictionsProvider(ComponentName who, ComponentName permissionProvider) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_RESTRICTIONS_PROVIDER);\n\n        synchronized (getLockObject()) {\n            int userHandle = caller.getUserId();\n            DevicePolicyData userData = getUserData(userHandle);\n            userData.mRestrictionsProvider = permissionProvider;\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public ComponentName getRestrictionsProvider(int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query the permission provider\"));\n        synchronized (getLockObject()) {\n            DevicePolicyData userData = getUserData(userHandle);\n            return userData != null ? userData.mRestrictionsProvider : null;\n        }\n    }\n\n    @Override\n    public void addCrossProfileIntentFilter(ComponentName who, String callerPackageName,\n            IntentFilter filter, int flags) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        int callingUserId = caller.getUserId();\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    callingUserId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(callingUserId);\n                if (parent == null) {\n                    Slogf.e(LOG_TAG, \"Cannot call addCrossProfileIntentFilter if there is no \"\n                            + \"parent\");\n                    return;\n                }\n                if ((flags & DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED) != 0) {\n                    mIPackageManager.addCrossProfileIntentFilter(\n                            filter, who.getPackageName(), callingUserId, parent.id, 0);\n                }\n                if ((flags & DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT) != 0) {\n                    mIPackageManager.addCrossProfileIntentFilter(filter, who.getPackageName(),\n                            parent.id, callingUserId, 0);\n                }\n            } catch (RemoteException re) {\n                // Shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error adding cross profile intent filter\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_CROSS_PROFILE_INTENT_FILTER)\n                .setAdmin(caller.getPackageName())\n                .setStrings(getIntentFilterActions(filter))\n                .setInt(flags)\n                .write();\n    }\n\n    private static String[] getIntentFilterActions(IntentFilter filter) {\n        if (filter == null) {\n            return null;\n        }\n        final int actionsCount = filter.countActions();\n        final String[] actions = new String[actionsCount];\n        for (int i = 0; i < actionsCount; i++) {\n            actions[i] = filter.getAction(i);\n        }\n        return actions;\n    }\n\n    @Override\n    public void clearCrossProfileIntentFilters(ComponentName who, String callerPackageName) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        int callingUserId = caller.getUserId();\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    caller.getPackageName(),\n                    callingUserId);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(callingUserId);\n                if (parent == null) {\n                    Slogf.e(LOG_TAG, \"Cannot call clearCrossProfileIntentFilter if there is no \"\n                            + \"parent\");\n                    return;\n                }\n                // Removing those that go from the managed profile to the parent.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        callingUserId, who.getPackageName());\n                // And those that go from the parent to the managed profile.\n                // If we want to support multiple managed profiles, we will have to only remove\n                // those that have callingUserId as their target.\n                mIPackageManager.clearCrossProfileIntentFilters(parent.id, who.getPackageName());\n            } catch (RemoteException re) {\n                // Shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error clearing cross profile intent filters\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n    }\n\n    /**\n     * @return true if all packages in enabledPackages are either in the list\n     * permittedList or are a system app.\n     */\n    private boolean checkPackagesInPermittedListOrSystem(List<String> enabledPackages,\n            List<String> permittedList, int userIdToCheck) {\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            // If we have an enabled packages list for a managed profile the packages\n            // we should check are installed for the parent user.\n            UserInfo user = getUserInfo(userIdToCheck);\n            if (user.isManagedProfile()) {\n                userIdToCheck = user.profileGroupId;\n            }\n\n            for (String enabledPackage : enabledPackages) {\n                boolean systemService = false;\n                try {\n                    ApplicationInfo applicationInfo = mIPackageManager.getApplicationInfo(\n                            enabledPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES,\n                            userIdToCheck);\n\n                    if (applicationInfo == null) {\n                        return false;\n                    }\n\n                    systemService = (applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;\n                } catch (RemoteException e) {\n                    Slogf.i(LOG_TAG, \"Can't talk to package managed\", e);\n                }\n                if (!systemService && !permittedList.contains(enabledPackage)) {\n                    return false;\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        return true;\n    }\n\n    /**\n     * Invoke a method in AccessibilityManager ensuring the client is removed.\n     */\n    private <T> T withAccessibilityManager(\n            int userId, Function<AccessibilityManager, T> function) {\n        // Not using AccessibilityManager.getInstance because that guesses\n        // at the user you require based on callingUid and caches for a given\n        // process.\n        final IBinder iBinder = ServiceManager.getService(Context.ACCESSIBILITY_SERVICE);\n        final IAccessibilityManager service = iBinder == null\n                ? null : IAccessibilityManager.Stub.asInterface(iBinder);\n        final AccessibilityManager am = new AccessibilityManager(mContext, service, userId);\n        try {\n            return function.apply(am);\n        } finally {\n            am.removeClient();\n        }\n    }\n\n    @Override\n    public boolean setPermittedAccessibilityServices(ComponentName who, List<String> packageList) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        if (packageList != null) {\n            for (String pkg : packageList) {\n                enforceMaxPackageNameLength(pkg);\n            }\n\n            int userId = caller.getUserId();\n            final List<AccessibilityServiceInfo> enabledServices;\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo user = getUserInfo(userId);\n                if (user.isManagedProfile()) {\n                    userId = user.profileGroupId;\n                }\n                enabledServices = withAccessibilityManager(userId,\n                        am -> am.getEnabledAccessibilityServiceList(FEEDBACK_ALL_MASK));\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n\n            if (enabledServices != null) {\n                List<String> enabledPackages = new ArrayList<>();\n                for (AccessibilityServiceInfo service : enabledServices) {\n                    enabledPackages.add(service.getResolveInfo().serviceInfo.packageName);\n                }\n                if (!checkPackagesInPermittedListOrSystem(enabledPackages, packageList,\n                        userId)) {\n                    Slogf.e(LOG_TAG, \"Cannot set permitted accessibility services, \"\n                            + \"because it contains already enabled accesibility services.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            admin.permittedAccessiblityServices = packageList;\n            saveSettingsLocked(UserHandle.getCallingUserId());\n        }\n        final String[] packageArray =\n                packageList != null ? ((List<String>) packageList).toArray(new String[0]) : null;\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMITTED_ACCESSIBILITY_SERVICES)\n                .setAdmin(who)\n                .setStrings(packageArray)\n                .write();\n        return true;\n    }\n\n    @Override\n    public List<String> getPermittedAccessibilityServices(ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.permittedAccessiblityServices;\n        }\n    }\n\n    @Override\n    public List<String> getPermittedAccessibilityServicesForUser(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller) || canQueryAdminPolicy(caller));\n\n        List<String> result = null;\n\n        synchronized (getLockObject()) {\n            // If we have multiple profiles we return the intersection of the\n            // permitted lists. This can happen in cases where we have a device\n            // and profile owner.\n            int[] profileIds = mUserManager.getProfileIdsWithDisabled(userId);\n            for (int profileId : profileIds) {\n                // Just loop though all admins, only device or profiles\n                // owners can have permitted lists set.\n                DevicePolicyData policy = getUserDataUnchecked(profileId);\n                final int N = policy.mAdminList.size();\n                for (int j = 0; j < N; j++) {\n                    ActiveAdmin admin = policy.mAdminList.get(j);\n                    List<String> fromAdmin = admin.permittedAccessiblityServices;\n                    if (fromAdmin != null) {\n                        if (result == null) {\n                            result = new ArrayList<>(fromAdmin);\n                        } else {\n                            result.retainAll(fromAdmin);\n                        }\n                    }\n                }\n            }\n        }\n\n        // If we have a permitted list add all system accessibility services.\n        if (result != null) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                UserInfo user = getUserInfo(userId);\n                if (user.isManagedProfile()) {\n                    userId = user.profileGroupId;\n                }\n                // Move AccessibilityManager out of {@link getLockObject} to prevent potential\n                // deadlock.\n                final List<AccessibilityServiceInfo> installedServices =\n                        withAccessibilityManager(userId,\n                                AccessibilityManager::getInstalledAccessibilityServiceList);\n\n                if (installedServices != null) {\n                    for (AccessibilityServiceInfo service : installedServices) {\n                        ServiceInfo serviceInfo = service.getResolveInfo().serviceInfo;\n                        ApplicationInfo applicationInfo = serviceInfo.applicationInfo;\n                        if ((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                            result.add(serviceInfo.packageName);\n                        }\n                    }\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean isAccessibilityServicePermittedByAdmin(ComponentName who, String packageName,\n            int userHandle) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if an accessibility service is disabled by admin\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin == null) {\n                return false;\n            }\n            if (admin.permittedAccessiblityServices == null) {\n                return true;\n            }\n            return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                    admin.permittedAccessiblityServices, userHandle);\n        }\n    }\n\n    @Override\n    public boolean setPermittedInputMethods(ComponentName who, String callerPackageName,\n            List<String> packageList, boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        int userId = getProfileParentUserIfRequested(\n                caller.getUserId(), calledOnParentInstance);\n        if (calledOnParentInstance) {\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            }\n            Preconditions.checkArgument(packageList == null || packageList.isEmpty(),\n                    \"Permitted input methods must allow all input methods or only \"\n                            + \"system input methods when called on the parent instance of an \"\n                            + \"organization-owned device\");\n        } else if (!isPolicyEngineForFinanceFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        if (packageList != null) {\n            for (String pkg : packageList) {\n                enforceMaxPackageNameLength(pkg);\n            }\n\n            List<InputMethodInfo> enabledImes = mInjector.binderWithCleanCallingIdentity(() ->\n                    InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(userId));\n            if (enabledImes != null) {\n                List<String> enabledPackages = new ArrayList<String>();\n                for (InputMethodInfo ime : enabledImes) {\n                    enabledPackages.add(ime.getPackageName());\n                }\n                if (!checkPackagesInPermittedListOrSystem(enabledPackages, packageList,\n                        userId)) {\n                    Slogf.e(LOG_TAG, \"Cannot set permitted input methods, because the list of \"\n                            + \"permitted input methods excludes an already-enabled input method.\");\n                    return false;\n                }\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                        caller.getPackageName(), userId);\n                if (packageList == null) {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.PERMITTED_INPUT_METHODS,\n                            admin,\n                            userId);\n                } else {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PERMITTED_INPUT_METHODS,\n                            admin,\n                            new StringSetPolicyValue(new HashSet<>(packageList)),\n                            userId);\n                }\n            } else {\n                ActiveAdmin admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()),\n                        calledOnParentInstance);\n                admin.permittedInputMethods = packageList;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMITTED_INPUT_METHODS)\n                .setAdmin(caller.getPackageName())\n                .setStrings(getStringArrayForLogging(packageList, calledOnParentInstance))\n                .write();\n        return true;\n    }\n\n    private String[] getStringArrayForLogging(List list, boolean calledOnParentInstance) {\n        List<String> stringList = new ArrayList<String>();\n        stringList.add(calledOnParentInstance ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT);\n        if (list == null) {\n            stringList.add(NULL_STRING_ARRAY);\n        } else {\n            stringList.addAll((List<String>) list);\n        }\n        return stringList.toArray(new String[0]);\n    }\n\n    @Override\n    public List<String> getPermittedInputMethods(ComponentName who, String callerPackageName,\n            boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            if (calledOnParentInstance) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller));\n            } else {\n                Preconditions.checkCallAuthorization(\n                        isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                int affectedUser = calledOnParentInstance ? getProfileParentId(\n                        caller.getUserId()) : caller.getUserId();\n                Set<String> policy = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.PERMITTED_INPUT_METHODS, affectedUser);\n                return policy == null ? null : new ArrayList<>(policy);\n            } else {\n                ActiveAdmin admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(\n                                caller.getUserId()), calledOnParentInstance);\n                return admin.permittedInputMethods;\n            }\n        }\n    }\n\n    @Override\n    public @Nullable List<String> getPermittedInputMethodsAsUser(@UserIdInt int userId) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n        Preconditions.checkCallAuthorization(canManageUsers(caller) || canQueryAdminPolicy(caller));\n        final long callingIdentity = Binder.clearCallingIdentity();\n        try {\n            return getPermittedInputMethodsUnchecked(userId);\n        } finally {\n            Binder.restoreCallingIdentity(callingIdentity);\n        }\n    }\n\n    private @Nullable List<String> getPermittedInputMethodsUnchecked(@UserIdInt int userId) {\n        List<String> result = null;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            Set<String> policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.PERMITTED_INPUT_METHODS, userId);\n            result = policy == null ? null : new ArrayList<>(policy);\n        } else {\n            synchronized (getLockObject()) {\n                // Only device or profile owners can have permitted lists set.\n                List<ActiveAdmin> admins =\n                        getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(\n                                userId);\n                for (ActiveAdmin admin : admins) {\n                    List<String> fromAdmin = admin.permittedInputMethods;\n                    if (fromAdmin != null) {\n                        if (result == null) {\n                            result = new ArrayList<String>(fromAdmin);\n                        } else {\n                            result.retainAll(fromAdmin);\n                        }\n                    }\n                }\n            }\n        }\n\n        // If we have a permitted list add all system input methods.\n        if (result != null) {\n            List<InputMethodInfo> imes = InputMethodManagerInternal\n                    .get().getInputMethodListAsUser(userId);\n            if (imes != null) {\n                for (InputMethodInfo ime : imes) {\n                    ServiceInfo serviceInfo = ime.getServiceInfo();\n                    ApplicationInfo applicationInfo = serviceInfo.applicationInfo;\n                    if ((applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                        result.add(serviceInfo.packageName);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isInputMethodPermittedByAdmin(ComponentName who, String packageName,\n            int userHandle, boolean calledOnParentInstance) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if an input method is disabled by admin\"));\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int affectedUser = calledOnParentInstance ? getProfileParentId(userHandle) : userHandle;\n            Map<EnforcingAdmin, PolicyValue<Set<String>>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.PERMITTED_INPUT_METHODS, affectedUser);\n            EnforcingAdmin admin = null;\n            for (EnforcingAdmin a : policies.keySet()) {\n                if (a.getPackageName().equals(who.getPackageName())) {\n                    if (policies.get(a).getValue() == null) {\n                        return true;\n                    } else {\n                        return checkPackagesInPermittedListOrSystem(\n                                Collections.singletonList(packageName),\n                                new ArrayList<>(policies.get(a).getValue()), affectedUser);\n                    }\n                }\n            }\n            // Admin didn't set a policy\n            return false;\n        } else {\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getParentOfAdminIfRequired(\n                        getActiveAdminUncheckedLocked(who, userHandle), calledOnParentInstance);\n                if (admin == null) {\n                    return false;\n                }\n                if (admin.permittedInputMethods == null) {\n                    return true;\n                }\n                return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                        admin.permittedInputMethods, userHandle);\n            }\n        }\n    }\n\n    @Override\n    public boolean setPermittedCrossProfileNotificationListeners(\n            ComponentName who, List<String> packageList) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n\n        if (!isManagedProfile(caller.getUserId())) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.permittedNotificationListeners = packageList;\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public List<String> getPermittedCrossProfileNotificationListeners(ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            // API contract is to return null if there are no permitted cross-profile notification\n            // listeners, including in Device Owner mode.\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.permittedNotificationListeners;\n        }\n    }\n\n    @Override\n    public boolean isNotificationListenerServicePermitted(String packageName, int userId) {\n        if (!mHasFeature) {\n            return true;\n        }\n\n        Preconditions.checkStringNotEmpty(packageName, \"packageName is null or empty\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"query if a notification listener service is permitted\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n            if (profileOwner == null || profileOwner.permittedNotificationListeners == null) {\n                return true;\n            }\n            return checkPackagesInPermittedListOrSystem(Collections.singletonList(packageName),\n                    profileOwner.permittedNotificationListeners, userId);\n\n        }\n    }\n\n    private void maybeSendAdminEnabledBroadcastLocked(int userHandle) {\n        DevicePolicyData policyData = getUserData(userHandle);\n        if (policyData.mAdminBroadcastPending) {\n            // Send the initialization data to profile owner and delete the data\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n            boolean clearInitBundle = true;\n            if (admin != null) {\n                PersistableBundle initBundle = policyData.mInitBundle;\n                clearInitBundle = sendAdminCommandLocked(admin,\n                        DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        initBundle == null ? null : new Bundle(initBundle),\n                        /* result= */ null ,\n                        /* inForeground= */ true);\n            }\n            if (clearInitBundle) {\n                // If there's no admin or we've successfully called the admin, clear the init bundle\n                // otherwise, keep it around\n                policyData.mInitBundle = null;\n                policyData.mAdminBroadcastPending = false;\n                saveSettingsLocked(userHandle);\n            }\n        }\n    }\n\n    @Override\n    public UserHandle createAndManageUser(ComponentName admin, String name,\n            ComponentName profileOwner, PersistableBundle adminExtras, int flags) {\n        Objects.requireNonNull(admin, \"admin is null\");\n        Objects.requireNonNull(profileOwner, \"profileOwner is null\");\n        if (!admin.getPackageName().equals(profileOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"profileOwner \" + profileOwner + \" and admin \"\n                    + admin + \" are not in the same package\");\n        }\n        final CallerIdentity caller = getCallerIdentity(admin);\n        // Only allow the system user to use this method\n        Preconditions.checkCallAuthorization(caller.getUserHandle().isSystem(),\n                \"createAndManageUser was called from non-system user\");\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_CREATE_AND_MANAGE_USER);\n\n        final boolean ephemeral = (flags & DevicePolicyManager.MAKE_USER_EPHEMERAL) != 0;\n        final boolean demo = (flags & DevicePolicyManager.MAKE_USER_DEMO) != 0\n                && UserManager.isDeviceInDemoMode(mContext);\n        final boolean leaveAllSystemAppsEnabled = (flags & LEAVE_ALL_SYSTEM_APPS_ENABLED) != 0;\n        final int targetSdkVersion;\n\n        // Create user.\n        UserHandle user = null;\n        synchronized (getLockObject()) {\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                targetSdkVersion = mInjector.getPackageManagerInternal().getUidTargetSdkVersion(\n                        caller.getUid());\n\n                // Return detail error code for checks inside\n                // UserManagerService.createUserInternalUnchecked.\n                DeviceStorageMonitorInternal deviceStorageMonitorInternal =\n                        LocalServices.getService(DeviceStorageMonitorInternal.class);\n                if (deviceStorageMonitorInternal.isMemoryLow()) {\n                    if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                        throw new ServiceSpecificException(\n                                UserManager.USER_OPERATION_ERROR_LOW_STORAGE, \"low device storage\");\n                    } else {\n                        return null;\n                    }\n                }\n\n                String userType = demo ? UserManager.USER_TYPE_FULL_DEMO\n                        : UserManager.USER_TYPE_FULL_SECONDARY;\n                int userInfoFlags = ephemeral ? UserInfo.FLAG_EPHEMERAL : 0;\n\n                if (!mUserManager.canAddMoreUsers(userType)) {\n                    if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                        throw new ServiceSpecificException(\n                                UserManager.USER_OPERATION_ERROR_MAX_USERS, \"user limit reached\");\n                    } else {\n                        return null;\n                    }\n                }\n\n                String[] disallowedPackages = null;\n                if (!leaveAllSystemAppsEnabled) {\n                    disallowedPackages = mOverlayPackagesProvider.getNonRequiredApps(admin,\n                            UserHandle.myUserId(), ACTION_PROVISION_MANAGED_USER).toArray(\n                            new String[0]);\n                }\n\n                Object token = new Object();\n                Slogf.d(LOG_TAG, \"Adding new pending token: \" + token);\n                mPendingUserCreatedCallbackTokens.add(token);\n                try {\n                    UserInfo userInfo = mUserManagerInternal.createUserEvenWhenDisallowed(name,\n                            userType, userInfoFlags, disallowedPackages, token);\n                    if (userInfo != null) {\n                        user = userInfo.getUserHandle();\n                    }\n                } catch (UserManager.CheckedUserOperationException e) {\n                    Slogf.e(LOG_TAG, \"Couldn't createUserEvenWhenDisallowed\", e);\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        } // synchronized\n\n        if (user == null) {\n            if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                throw new ServiceSpecificException(UserManager.USER_OPERATION_ERROR_UNKNOWN,\n                        \"failed to create user\");\n            } else {\n                return null;\n            }\n        }\n\n        final int userHandle = user.getIdentifier();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userHandle);\n\n            manageUserUnchecked(admin, profileOwner, userHandle, adminExtras,\n                    /* showDisclaimer= */ true);\n\n            if ((flags & DevicePolicyManager.SKIP_SETUP_WIZARD) != 0) {\n                Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                        Settings.Secure.USER_SETUP_COMPLETE, 1, userHandle);\n            }\n\n            sendProvisioningCompletedBroadcast(\n                    userHandle, ACTION_PROVISION_MANAGED_USER, leaveAllSystemAppsEnabled);\n\n            return user;\n        } catch (Throwable re) {\n            mUserManager.removeUser(userHandle);\n            if (targetSdkVersion >= Build.VERSION_CODES.P) {\n                throw new ServiceSpecificException(UserManager.USER_OPERATION_ERROR_UNKNOWN,\n                        re.getMessage());\n            } else {\n                return null;\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void sendProvisioningCompletedBroadcast(\n            int user, String action, boolean leaveAllSystemAppsEnabled) {\n        final Intent intent = new Intent(DevicePolicyManager.ACTION_PROVISIONING_COMPLETED)\n                .putExtra(Intent.EXTRA_USER_HANDLE, user)\n                .putExtra(Intent.EXTRA_USER, UserHandle.of(user))\n                .putExtra(\n                        DevicePolicyManager.EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED,\n                        leaveAllSystemAppsEnabled)\n                .putExtra(DevicePolicyManager.EXTRA_PROVISIONING_ACTION,\n                        action)\n                .setPackage(getManagedProvisioningPackage(mContext))\n                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        mContext.sendBroadcastAsUser(intent, UserHandle.SYSTEM);\n    }\n\n    private void manageUserUnchecked(ComponentName admin, ComponentName profileOwner,\n            @UserIdInt int userId, @Nullable PersistableBundle adminExtras,\n            boolean showDisclaimer) {\n        synchronized (getLockObject()) {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"manageUserUnchecked(): admin=\" + admin + \", po=\" + profileOwner\n                        + \", userId=\" + userId + \", hasAdminExtras=\" + (adminExtras != null)\n                        + \", showDisclaimer=\" + showDisclaimer);\n            }\n        }\n        final String adminPkg = admin.getPackageName();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                // Install the profile owner if not present.\n                if (!mIPackageManager.isPackageAvailable(adminPkg, userId)) {\n                    mIPackageManager.installExistingPackageAsUser(adminPkg, userId,\n                            PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                            PackageManager.INSTALL_REASON_POLICY,\n                            /* allowlistedRestrictedPermissions= */ null);\n                }\n            } catch (RemoteException e) {\n                // Does not happen, same process\n                Slogf.wtf(LOG_TAG, e, \"Failed to install admin package %s for user %d\",\n                        adminPkg, userId);\n            }\n        });\n\n        // Set admin.\n        setActiveAdmin(profileOwner, /* refreshing= */ true, userId);\n        setProfileOwner(profileOwner, userId);\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            policyData.mInitBundle = adminExtras;\n            policyData.mAdminBroadcastPending = true;\n            policyData.mNewUserDisclaimer = showDisclaimer\n                    ? DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED\n                    : DevicePolicyData.NEW_USER_DISCLAIMER_NOT_NEEDED;\n            saveSettingsLocked(userId);\n\n        }\n    }\n\n    private void handleNewUserCreated(UserInfo user, @Nullable Object token) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"handleNewUserCreated(): user=\" + user.toFullString()\n                    + \", token=\" + token);\n        }\n\n        final int userId = user.id;\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.handleUserCreated(user);\n        }\n\n        if (token != null) {\n            synchronized (getLockObject()) {\n                if (mPendingUserCreatedCallbackTokens.contains(token)) {\n                    // Ignore because it was triggered by createAndManageUser()\n                    Slogf.d(LOG_TAG, \"handleNewUserCreated(): ignoring for user \" + userId\n                            + \" due to token \" + token);\n                    mPendingUserCreatedCallbackTokens.remove(token);\n                    return;\n                }\n            }\n        }\n\n        if (!mOwners.hasDeviceOwner() || !user.isFull() || user.isManagedProfile()\n                || user.isGuest()) {\n            return;\n        }\n\n        if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n            ComponentName admin = mOwners.getDeviceOwnerComponent();\n            Slogf.i(LOG_TAG, \"Automatically setting profile owner (\" + admin + \") on new user \"\n                    + userId);\n            manageUserUnchecked(/* deviceOwner= */ admin, /* profileOwner= */ admin,\n                    /* managedUser= */ userId, /* adminExtras= */ null, /* showDisclaimer= */ true);\n        } else {\n            Slogf.i(LOG_TAG, \"User %d added on DO mode; setting ShowNewUserDisclaimer\", userId);\n            setShowNewUserDisclaimer(userId, DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED);\n        }\n    }\n\n    @Override\n    public void acknowledgeNewUserDisclaimer(@UserIdInt int userId) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(callerIdentity)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        setShowNewUserDisclaimer(userId, DevicePolicyData.NEW_USER_DISCLAIMER_ACKNOWLEDGED);\n    }\n\n    private void setShowNewUserDisclaimer(@UserIdInt int userId, String value) {\n        Slogf.i(LOG_TAG, \"Setting new user disclaimer for user \" + userId + \" as \" + value);\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            policyData.mNewUserDisclaimer = value;\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void showNewUserDisclaimerIfNecessary(@UserIdInt int userId) {\n        boolean mustShow;\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"showNewUserDisclaimerIfNecessary(\" + userId + \"): \"\n                        + policyData.mNewUserDisclaimer + \")\");\n            }\n            mustShow = DevicePolicyData.NEW_USER_DISCLAIMER_NEEDED\n                    .equals(policyData.mNewUserDisclaimer);\n        }\n        if (!mustShow) return;\n\n        Intent intent = new Intent(DevicePolicyManager.ACTION_SHOW_NEW_USER_DISCLAIMER);\n\n        // TODO(b/172691310): add CTS tests to make sure disclaimer is shown\n        Slogf.i(LOG_TAG, \"Dispatching ACTION_SHOW_NEW_USER_DISCLAIMER intent\");\n        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n    }\n\n    @Override\n    public boolean isNewUserDisclaimerAcknowledged(@UserIdInt int userId) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(callerIdentity)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userId);\n            return policyData.isNewUserDisclaimerAcknowledged();\n        }\n    }\n\n    @Override\n    public boolean removeUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_USER);\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            String restriction = isManagedProfile(userHandle.getIdentifier())\n                    ? UserManager.DISALLOW_REMOVE_MANAGED_PROFILE\n                    : UserManager.DISALLOW_REMOVE_USER;\n            if (isAdminAffectedByRestriction(who, restriction, caller.getUserId())) {\n                Slogf.w(LOG_TAG, \"The device owner cannot remove a user because %s is enabled, and \"\n                        + \"was not set by the device owner\", restriction);\n                return false;\n            }\n            return mUserManagerInternal.removeUserEvenWhenDisallowed(userHandle.getIdentifier());\n        });\n    }\n\n    private boolean isAdminAffectedByRestriction(\n            @Nullable ComponentName admin, String userRestriction, int userId) {\n        switch (mUserManager.getUserRestrictionSource(userRestriction, UserHandle.of(userId))) {\n            case UserManager.RESTRICTION_NOT_SET:\n                return false;\n            case UserManager.RESTRICTION_SOURCE_DEVICE_OWNER:\n            case UserManager.RESTRICTION_SOURCE_PROFILE_OWNER:\n                return !(isDeviceOwner(admin, userId) || isProfileOwner(admin, userId));\n            default:\n                return true;\n        }\n    }\n\n    @Override\n    public boolean switchUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SWITCH_USER);\n\n        boolean switched = false;\n        // Save previous logout user id in case of failure\n        int logoutUserId = getLogoutUserIdUnchecked();\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                int userId = UserHandle.USER_SYSTEM;\n                if (userHandle != null) {\n                    userId = userHandle.getIdentifier();\n                }\n                Slogf.i(LOG_TAG, \"Switching to user %d (logout user is %d)\", userId, logoutUserId);\n                setLogoutUserIdLocked(UserHandle.USER_CURRENT);\n                switched = mInjector.getIActivityManager().switchUser(userId);\n                if (!switched) {\n                    Slogf.w(LOG_TAG, \"Failed to switch to user %d\", userId);\n                } else {\n                    Slogf.d(LOG_TAG, \"Switched\");\n                }\n                return switched;\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Couldn't switch user\", e);\n                return false;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n                if (!switched) {\n                    setLogoutUserIdLocked(logoutUserId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public int getLogoutUserId() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        return getLogoutUserIdUnchecked();\n    }\n\n    private @UserIdInt int getLogoutUserIdUnchecked() {\n        synchronized (getLockObject()) {\n            return mLogoutUserId;\n        }\n    }\n\n    private void clearLogoutUser() {\n        synchronized (getLockObject()) {\n            setLogoutUserIdLocked(UserHandle.USER_NULL);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void setLogoutUserIdLocked(@UserIdInt int userId) {\n        if (userId == UserHandle.USER_CURRENT) {\n            userId = getCurrentForegroundUserId();\n        }\n\n        Slogf.d(LOG_TAG, \"setLogoutUserId(): %d -> %d\", mLogoutUserId, userId);\n        mLogoutUserId = userId;\n    }\n\n    @Override\n    public int startUserInBackground(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_START_USER_IN_BACKGROUND);\n\n        final int userId = userHandle.getIdentifier();\n        if (isManagedProfile(userId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be started in background\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (!mInjector.getActivityManagerInternal().canStartMoreUsers()) {\n                Slogf.w(LOG_TAG, \"Cannot start user %d, too many users in background\", userId);\n                return UserManager.USER_OPERATION_ERROR_MAX_RUNNING_USERS;\n            }\n\n            Slogf.i(LOG_TAG, \"Starting user %d in background\", userId);\n            if (mInjector.getIActivityManager().startUserInBackground(userId)) {\n                return UserManager.USER_OPERATION_SUCCESS;\n            } else {\n                Slogf.w(LOG_TAG, \"failed to start user %d in background\", userId);\n                return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    @Override\n    public int stopUser(ComponentName who, UserHandle userHandle) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(userHandle, \"UserHandle is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_STOP_USER);\n\n        final int userId = userHandle.getIdentifier();\n        if (isManagedProfile(userId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be stopped\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        return stopUserUnchecked(userId);\n    }\n\n    @Override\n    public int logoutUser(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOGOUT_USER);\n\n        final int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUserAffiliatedWithDeviceLocked(callingUserId)) {\n                throw new SecurityException(\"Admin \" + who +\n                        \" is neither the device owner or affiliated user's profile owner.\");\n            }\n        }\n\n        if (isManagedProfile(callingUserId)) {\n            Slogf.w(LOG_TAG, \"Managed profile cannot be logout\");\n            return UserManager.USER_OPERATION_ERROR_MANAGED_PROFILE;\n        }\n\n        if (callingUserId != mInjector\n                .binderWithCleanCallingIdentity(() -> getCurrentForegroundUserId())) {\n            Slogf.d(LOG_TAG, \"logoutUser(): user %d is in background, just stopping, not switching\",\n                    callingUserId);\n            return stopUserUnchecked(callingUserId);\n        }\n\n        return logoutUserUnchecked(/* userIdToStop= */ callingUserId);\n    }\n\n    @Override\n    public int logoutUserInternal() {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller)\n                || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n\n        int currentUserId = getCurrentForegroundUserId();\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"logout() called by uid %d; current user is %d\", caller.getUid(),\n                    currentUserId);\n        }\n        int result = logoutUserUnchecked(currentUserId);\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Result of logout(): %d\", result);\n        }\n        return result;\n    }\n\n    private int logoutUserUnchecked(@UserIdInt int userIdToStop) {\n        int logoutUserId = getLogoutUserIdUnchecked();\n        if (logoutUserId == UserHandle.USER_NULL) {\n            // Could happen on devices using headless system user mode when called before calling\n            // switchUser() or startUserInBackground() first\n            Slogf.w(LOG_TAG, \"logoutUser(): could not determine which user to switch to\");\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        }\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            Slogf.i(LOG_TAG, \"logoutUser(): switching to user %d\", logoutUserId);\n            if (!mInjector.getIActivityManager().switchUser(logoutUserId)) {\n                Slogf.w(LOG_TAG, \"Failed to switch to user %d\", logoutUserId);\n                // This should never happen as target user is determined by getPreviousUserId()\n                return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n            clearLogoutUser();\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n\n        return stopUserUnchecked(userIdToStop);\n    }\n\n    private int stopUserUnchecked(@UserIdInt int userId) {\n        Slogf.i(LOG_TAG, \"Stopping user %d\", userId);\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            switch (mInjector.getIActivityManager().stopUser(userId, true /*force*/, null)) {\n                case ActivityManager.USER_OP_SUCCESS:\n                    return UserManager.USER_OPERATION_SUCCESS;\n                case ActivityManager.USER_OP_IS_CURRENT:\n                    return UserManager.USER_OPERATION_ERROR_CURRENT_USER;\n                default:\n                    return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n            }\n        } catch (RemoteException e) {\n            // Same process, should not happen.\n            return UserManager.USER_OPERATION_ERROR_UNKNOWN;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    @Override\n    public List<UserHandle> getSecondaryUsers(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mInjector.getUserManager().getAliveUsers();\n            final List<UserHandle> userHandles = new ArrayList<>();\n            for (UserInfo userInfo : userInfos) {\n                UserHandle userHandle = userInfo.getUserHandle();\n                if (!userHandle.isSystem() && !isManagedProfile(userHandle.getIdentifier())) {\n                    userHandles.add(userInfo.getUserHandle());\n                }\n            }\n            return userHandles;\n        });\n    }\n\n    @Override\n    public boolean isEphemeralUser(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getUserManager().isUserEphemeral(caller.getUserId()));\n    }\n\n    @Override\n    public Bundle getApplicationRestrictions(ComponentName who, String callerPackage,\n            String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforceCanQueryAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    caller.getPackageName(),\n                    caller.getUserId()\n            );\n\n            LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                            caller.getUserId());\n            if (policies.isEmpty() || !policies.containsKey(enforcingAdmin)) {\n                return Bundle.EMPTY;\n            }\n            return policies.get(enforcingAdmin).getValue();\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_APP_RESTRICTIONS)));\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                Bundle bundle = mUserManager.getApplicationRestrictions(packageName,\n                        caller.getUserHandle());\n                // if no restrictions were saved, mUserManager.getApplicationRestrictions\n                // returns null, but DPM method should return an empty Bundle as per JavaDoc\n                return bundle != null ? bundle : Bundle.EMPTY;\n            });\n        }\n    }\n\n    /**\n     * Returns the apps that are non-exempt from some policies (such as suspension), and populates\n     * the given set with the apps that are exempt.\n     *\n     * @param packageNames apps to check\n     * @param outputExemptApps will be populate with subset of {@code packageNames} that is exempt\n     * from some policy restrictions\n     *\n     * @return subset of {@code packageNames} that is affected by some policy restrictions.\n     */\n    private String[] populateNonExemptAndExemptFromPolicyApps(String[] packageNames,\n            Set<String> outputExemptApps) {\n        Preconditions.checkArgument(outputExemptApps.isEmpty(), \"outputExemptApps is not empty\");\n        List<String> exemptAppsList = listPolicyExemptAppsUnchecked(mContext);\n        if (exemptAppsList.isEmpty()) {\n            return packageNames;\n        }\n        // Using a set so contains() is O(1)\n        Set<String> exemptApps = new HashSet<>(exemptAppsList);\n        List<String> nonExemptApps = new ArrayList<>(packageNames.length);\n        for (int i = 0; i < packageNames.length; i++) {\n            String app = packageNames[i];\n            if (exemptApps.contains(app)) {\n                outputExemptApps.add(app);\n            } else {\n                nonExemptApps.add(app);\n            }\n        }\n        String[] result = new String[nonExemptApps.size()];\n        nonExemptApps.toArray(result);\n        return result;\n    }\n\n    @Override\n    public String[] setPackagesSuspended(ComponentName who, String callerPackage,\n            String[] packageNames, boolean suspended) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        ActiveAdmin admin;\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PACKAGE_ACCESS)));\n            synchronized (getLockObject()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PACKAGES_SUSPENDED);\n\n        // Must remove the exempt apps from the input before calling PM, then add them back to\n        // the array returned to the caller\n        Set<String> exemptApps = new HashSet<>();\n        packageNames = populateNonExemptAndExemptFromPolicyApps(packageNames, exemptApps);\n\n        String[] nonSuspendedPackages = null;\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                nonSuspendedPackages = mInjector.getPackageManagerInternal()\n                        .setPackagesSuspendedByAdmin(caller.getUserId(), packageNames, suspended);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PACKAGES_SUSPENDED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageNames)\n                .write();\n\n        if (nonSuspendedPackages == null) {\n            Slogf.w(LOG_TAG, \"PM failed to suspend packages (%s)\", Arrays.toString(packageNames));\n            return packageNames;\n        }\n\n        ArraySet<String> changed = new ArraySet<>(packageNames);\n        if (suspended) {\n            // Only save those packages that are actually suspended. If a package is exempt or is\n            // unsuspendable, it is skipped.\n            changed.removeAll(List.of(nonSuspendedPackages));\n        } else {\n            // If an admin tries to unsuspend a package that is either exempt or is not\n            // suspendable, drop it from the stored list assuming it must be already unsuspended.\n            changed.addAll(exemptApps);\n        }\n\n        synchronized (getLockObject()) {\n            ArraySet<String> current = new ArraySet<>(admin.suspendedPackages);\n            if (suspended) {\n                current.addAll(changed);\n            } else {\n                current.removeAll(changed);\n            }\n            admin.suspendedPackages = current.isEmpty() ? null : new ArrayList<>(current);\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        if (exemptApps.isEmpty()) {\n            return nonSuspendedPackages;\n        }\n\n        String[] result = buildNonSuspendedPackagesUnionArray(nonSuspendedPackages, exemptApps);\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Returning %s\", Arrays.toString(result));\n        return result;\n    }\n\n    /**\n     * Returns an array containing the union of the given non-suspended packages and\n     * exempt apps. Assumes both parameters are non-null and non-empty.\n     */\n    private String[] buildNonSuspendedPackagesUnionArray(String[] nonSuspendedPackages,\n            Set<String> exemptApps) {\n        String[] result = new String[nonSuspendedPackages.length + exemptApps.size()];\n        int index = 0;\n        for (String app : nonSuspendedPackages) {\n            result[index++] = app;\n        }\n        for (String app : exemptApps) {\n            result[index++] = app;\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isPackageSuspended(ComponentName who, String callerPackage, String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (isUnicornFlagEnabled()) {\n            enforcePermission(\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        synchronized (getLockObject()) {\n            long id = mInjector.binderClearCallingIdentity();\n            try {\n                return mIPackageManager.isPackageSuspendedForUser(packageName, caller.getUserId());\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed talking to the package manager\", re);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public List<String> listPolicyExemptApps() {\n        CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                        || isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return listPolicyExemptAppsUnchecked(mContext);\n    }\n\n    private static List<String> listPolicyExemptAppsUnchecked(Context context) {\n        // TODO(b/181238156): decide whether it should only list the apps set by the resources,\n        // or also the \"critical\" apps defined by PersonalAppsSuspensionHelper (like SMS app).\n        // If it's the latter, refactor PersonalAppsSuspensionHelper so it (or a superclass) takes\n        // the resources on constructor.\n        String[] core = context.getResources().getStringArray(R.array.policy_exempt_apps);\n        String[] vendor = context.getResources().getStringArray(R.array.vendor_policy_exempt_apps);\n\n        int size = core.length + vendor.length;\n        Set<String> apps = new ArraySet<>(size);\n        for (String app : core) {\n            apps.add(app);\n        }\n        for (String app : vendor) {\n            apps.add(app);\n        }\n\n        return new ArrayList<>(apps);\n    }\n\n    @Override\n    public void setUserRestriction(\n            ComponentName who, String callerPackage, String key, boolean enabledFromThisOwner,\n            boolean parent) {\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackage);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        int userId = caller.getUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_USER_RESTRICTION);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            if (!isDeviceOwner(caller) && !isProfileOwner(caller)) {\n                EnforcingAdmin admin = enforcePermissionForUserRestriction(\n                        who,\n                        key,\n                        caller.getPackageName(),\n                        affectedUserId);\n                if (!mInjector.isChangeEnabled(ENABLE_COEXISTENCE_CHANGE, callerPackage, userId)) {\n                    throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n                }\n                if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                    throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n                }\n                PolicyDefinition<Boolean> policyDefinition =\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n                if (enabledFromThisOwner) {\n                    setLocalUserRestrictionInternal(\n                            admin, key, /* enabled= */ true, affectedUserId);\n                } else {\n                    // Remove any local and global policy that was set by the admin\n                    if (!policyDefinition.isLocalOnlyPolicy()) {\n                        setGlobalUserRestrictionInternal(admin, key, /* enabled= */ false);\n                    }\n                    if (!policyDefinition.isGlobalOnlyPolicy()) {\n                        setLocalUserRestrictionInternal(admin, key, /* enabled= */ false,\n                                userId);\n\n                        int parentUserId = getProfileParentId(userId);\n                        if (parentUserId != userId) {\n                            setLocalUserRestrictionInternal(\n                                    admin, key, /* enabled= */ false, parentUserId);\n                        }\n                    }\n                }\n            } else {\n                if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                    return;\n                }\n                Objects.requireNonNull(who, \"ComponentName is null\");\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n                checkAdminCanSetRestriction(caller, parent, key);\n                setBackwardCompatibleUserRestriction(\n                        caller, admin, key, enabledFromThisOwner, parent);\n            }\n        } else {\n            if (!UserRestrictionsUtils.isValidRestriction(key)) {\n                return;\n            }\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            checkAdminCanSetRestriction(caller, parent, key);\n            synchronized (getLockObject()) {\n                final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(userId), parent);\n                // Save the restriction to ActiveAdmin.\n                final Bundle restrictions = activeAdmin.ensureUserRestrictions();\n                if (enabledFromThisOwner) {\n                    restrictions.putBoolean(key, true);\n                } else {\n                    restrictions.remove(key);\n                }\n                saveUserRestrictionsLocked(userId);\n            }\n        }\n        logUserRestrictionCall(key, enabledFromThisOwner, parent, caller);\n    }\n\n    private void checkAdminCanSetRestriction(CallerIdentity caller, boolean parent, String key) {\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwnerOfOrganizationOwnedDevice(caller));\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDeviceOwner(caller) || isProfileOwner(caller));\n        }\n        synchronized (getLockObject()) {\n            if (isDefaultDeviceOwner(caller)) {\n                if (!UserRestrictionsUtils.canDeviceOwnerChange(key)) {\n                    throw new SecurityException(\"Device owner cannot set user restriction \"\n                            + key);\n                }\n                Preconditions.checkArgument(!parent,\n                        \"Cannot use the parent instance in Device Owner mode\");\n            } else if (isFinancedDeviceOwner(caller)) {\n                if (!UserRestrictionsUtils.canFinancedDeviceOwnerChange(key)) {\n                    throw new SecurityException(\"Cannot set user restriction \" + key\n                            + \" when managing a financed device\");\n                }\n                Preconditions.checkArgument(!parent,\n                        \"Cannot use the parent instance in Financed Device Owner\"\n                                + \" mode\");\n            } else {\n                boolean profileOwnerCanChangeOnItself = !parent\n                        && UserRestrictionsUtils.canProfileOwnerChange(\n                        key, caller.getUserId() == getMainUserId());\n                boolean orgOwnedProfileOwnerCanChangeGlobally = parent\n                        && isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        && UserRestrictionsUtils.canProfileOwnerOfOrganizationOwnedDeviceChange(\n                        key);\n\n                if (!profileOwnerCanChangeOnItself && !orgOwnedProfileOwnerCanChangeGlobally) {\n                    throw new SecurityException(\"Profile owner cannot set user restriction \"\n                            + key);\n                }\n            }\n        }\n    }\n    private void setBackwardCompatibleUserRestriction(\n            CallerIdentity caller, EnforcingAdmin admin, String key, boolean enabled,\n            boolean parent) {\n        synchronized (getLockObject()) {\n\n            int ownerType;\n            if (isDeviceOwner(caller)) {\n                ownerType = OWNER_TYPE_DEVICE_OWNER;\n            } else if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                ownerType = OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n            } else if (isProfileOwner(caller)) {\n                ownerType = OWNER_TYPE_PROFILE_OWNER;\n            } else {\n                throw new IllegalStateException(\"Non-DO/Non-PO cannot set restriction \" + key\n                        + \" while targetSdkVersion is less than UPSIDE_DOWN_CAKE\");\n            }\n            setBackwardCompatibleUserRestrictionLocked(ownerType, admin, caller.getUserId(), key,\n                    enabled, parent);\n        }\n    }\n\n    private void setBackwardCompatibleUserRestrictionLocked(\n            int ownerType, EnforcingAdmin admin, int userId, String key, boolean enabled,\n            boolean parent) {\n        if (ownerType == OWNER_TYPE_DEVICE_OWNER) {\n            if (UserRestrictionsUtils.isGlobal(OWNER_TYPE_DEVICE_OWNER, key)) {\n                setGlobalUserRestrictionInternal(admin, key, enabled);\n            } else {\n                setLocalUserRestrictionInternal(admin, key, enabled, userId);\n            }\n        } else if (ownerType == OWNER_TYPE_PROFILE_OWNER\n                || ownerType == OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE) {\n            if (UserRestrictionsUtils.isGlobal(OWNER_TYPE_PROFILE_OWNER, key)\n                    || (parent && ownerType == OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE\n                    && UserRestrictionsUtils.isGlobal(\n                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE, key))) {\n                setGlobalUserRestrictionInternal(admin, key, enabled);\n            } else {\n                int affectedUserId = parent\n                        ? getProfileParentId(userId) : userId;\n                setLocalUserRestrictionInternal(admin, key, enabled, affectedUserId);\n            }\n        } else {\n            throw new IllegalStateException(\"Non-DO/Non-PO cannot set restriction \" + key\n                    + \" while targetSdkVersion is less than UPSIDE_DOWN_CAKE\");\n        }\n    }\n\n    @Override\n    public void setUserRestrictionGlobally(String callerPackage, String key) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n\n        EnforcingAdmin admin = enforcePermissionForUserRestriction(\n                /* who= */ null,\n                key,\n                caller.getPackageName(),\n                UserHandle.USER_ALL\n        );\n\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_USER_RESTRICTION);\n\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            throw new IllegalStateException(\"Feature flag is not enabled.\");\n        }\n        if (isDeviceOwner(caller) || isProfileOwner(caller)) {\n            throw new SecurityException(\"Admins are not allowed to call this API.\");\n        }\n        if (!mInjector.isChangeEnabled(\n                ENABLE_COEXISTENCE_CHANGE, callerPackage, caller.getUserId())) {\n            throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n        }\n        if (!UserRestrictionsUtils.isValidRestriction(key)) {\n            throw new IllegalArgumentException(\"Invalid restriction key: \" + key);\n        }\n\n        setGlobalUserRestrictionInternal(admin, key, /* enabled= */ true);\n\n        logUserRestrictionCall(key, /* enabled= */ true, /* parent= */ false, caller);\n    }\n    private void setLocalUserRestrictionInternal(\n            EnforcingAdmin admin, String key, boolean enabled, int userId) {\n        PolicyDefinition<Boolean> policyDefinition =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n        if (enabled) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    policyDefinition,\n                    admin,\n                    new BooleanPolicyValue(true),\n                    userId);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    policyDefinition,\n                    admin,\n                    userId);\n        }\n    }\n    private void setGlobalUserRestrictionInternal(\n            EnforcingAdmin admin, String key, boolean enabled) {\n        PolicyDefinition<Boolean> policyDefinition =\n                PolicyDefinition.getPolicyDefinitionForUserRestriction(key);\n        if (enabled) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(key),\n                    admin,\n                    new BooleanPolicyValue(true));\n        } else {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    policyDefinition,\n                    admin);\n        }\n    }\n\n    private void logUserRestrictionCall(\n            String key, boolean enabled, boolean parent, CallerIdentity caller) {\n        final int eventId = enabled\n                ? DevicePolicyEnums.ADD_USER_RESTRICTION\n                : DevicePolicyEnums.REMOVE_USER_RESTRICTION;\n        DevicePolicyEventLogger\n                .createEvent(eventId)\n                .setAdmin(caller.getComponentName())\n                .setStrings(key, parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n        if (SecurityLog.isLoggingEnabled()) {\n            final int eventTag = enabled\n                    ? SecurityLog.TAG_USER_RESTRICTION_ADDED\n                    : SecurityLog.TAG_USER_RESTRICTION_REMOVED;\n            SecurityLog.writeEvent(eventTag, caller.getPackageName(), caller.getUserId(), key);\n        }\n    }\n\n    private void saveUserRestrictionsLocked(int userId) {\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // User restrictions are handled in the policy engine\n            return;\n        }\n        saveSettingsLocked(userId);\n        pushUserRestrictions(userId);\n        sendChangedNotification(userId);\n    }\n\n    /**\n     * Pushes the user restrictions originating from a specific user.\n     *\n     * If called by the profile owner of an organization-owned device, the global and local\n     * user restrictions will be an accumulation of the global user restrictions from the profile\n     * owner active admin and its parent active admin. The key of the local user restrictions set\n     * will be the target user id.\n     */\n    private void pushUserRestrictions(int originatingUserId) {\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // User restrictions are handled in the policy engine\n            return;\n        }\n        final Bundle global;\n        final RestrictionsSet local = new RestrictionsSet();\n        final boolean isDeviceOwner;\n        synchronized (getLockObject()) {\n            isDeviceOwner = mOwners.isDeviceOwnerUserId(originatingUserId);\n            if (isDeviceOwner) {\n                final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner == null) {\n                    return; // Shouldn't happen.\n                }\n                global = deviceOwner.getGlobalUserRestrictions(OWNER_TYPE_DEVICE_OWNER);\n                local.updateRestrictions(originatingUserId, deviceOwner.getLocalUserRestrictions(\n                        OWNER_TYPE_DEVICE_OWNER));\n            } else {\n                final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(originatingUserId);\n                if (profileOwner == null) {\n                    return;\n                }\n                global = profileOwner.getGlobalUserRestrictions(OWNER_TYPE_PROFILE_OWNER);\n                local.updateRestrictions(originatingUserId, profileOwner.getLocalUserRestrictions(\n                        OWNER_TYPE_PROFILE_OWNER));\n                // Global (device-wide) and local user restrictions set by the profile owner of an\n                // organization-owned device are stored in the parent ActiveAdmin instance.\n                if (isProfileOwnerOfOrganizationOwnedDevice(\n                        profileOwner.getUserHandle().getIdentifier())) {\n                    // The global restrictions set on the parent ActiveAdmin instance need to be\n                    // merged with the global restrictions set on the profile owner ActiveAdmin\n                    // instance, since both are to be applied device-wide.\n                    UserRestrictionsUtils.merge(global,\n                            profileOwner.getParentActiveAdmin().getGlobalUserRestrictions(\n                                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE));\n                    // The local restrictions set on the parent ActiveAdmin instance are only to be\n                    // applied to the primary user. They therefore need to be added the local\n                    // restriction set with the primary user id as the key, in this case the\n                    // primary user id is the target user.\n                    local.updateRestrictions(\n                            getProfileParentId(profileOwner.getUserHandle().getIdentifier()),\n                            profileOwner.getParentActiveAdmin().getLocalUserRestrictions(\n                                    OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE));\n                }\n            }\n        }\n        mUserManagerInternal.setDevicePolicyUserRestrictions(originatingUserId, global, local,\n                isDeviceOwner);\n    }\n\n    @Override\n    public Bundle getUserRestrictions(ComponentName who, String callerPackage, boolean parent) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackage);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int targetUserId = parent\n                    ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n            EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n            if (isDeviceOwner(caller) || isProfileOwner(caller)) {\n                Objects.requireNonNull(who, \"ComponentName is null\");\n                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                        || isFinancedDeviceOwner(caller)\n                        || isProfileOwner(caller)\n                        || (parent && isProfileOwnerOfOrganizationOwnedDevice(caller)));\n\n                Bundle restrictions = getUserRestrictionsFromPolicyEngine(admin, targetUserId);\n                // Add global restrictions set by the admin as well.\n                restrictions.putAll(\n                        getUserRestrictionsFromPolicyEngine(admin, UserHandle.USER_ALL));\n                return restrictions;\n            } else {\n                if (!mInjector.isChangeEnabled(\n                        ENABLE_COEXISTENCE_CHANGE, callerPackage, caller.getUserId())) {\n                    throw new IllegalStateException(\"Calling package is not targeting Android U.\");\n                }\n                return getUserRestrictionsFromPolicyEngine(admin, targetUserId);\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)\n                    || isProfileOwner(caller)\n                    || (parent && isProfileOwnerOfOrganizationOwnedDevice(caller)));\n            synchronized (getLockObject()) {\n                final ActiveAdmin activeAdmin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n                return activeAdmin.userRestrictions;\n            }\n        }\n    }\n\n    // Map of user restriction to permission.\n    private static final HashMap<String, String[]> USER_RESTRICTION_PERMISSIONS = new HashMap<>();\n    {\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.ALLOW_PARENT_PROFILE_APP_LINKING, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_CLONE_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_USER, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADD_WIFI_CONFIG, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ADJUST_VOLUME, new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AIRPLANE_MODE, new String[]{MANAGE_DEVICE_POLICY_AIRPLANE_MODE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AMBIENT_DISPLAY, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_APPS_CONTROL, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_AUTOFILL, new String[]{MANAGE_DEVICE_POLICY_AUTOFILL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_BLUETOOTH, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_BLUETOOTH_SHARING, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CAMERA, new String[]{MANAGE_DEVICE_POLICY_CAMERA});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CAMERA_TOGGLE, new String[]{MANAGE_DEVICE_POLICY_CAMERA_TOGGLE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CELLULAR_2G, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CHANGE_WIFI_STATE, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_BLUETOOTH, new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_BRIGHTNESS, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_CELL_BROADCASTS, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_CREDENTIALS, new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_DATE_TIME, new String[]{MANAGE_DEVICE_POLICY_TIME});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_DEFAULT_APPS, new String[]{MANAGE_DEFAULT_APPLICATIONS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_LOCALE, new String[]{MANAGE_DEVICE_POLICY_LOCALE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_LOCATION, new String[]{MANAGE_DEVICE_POLICY_LOCATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_PRIVATE_DNS, new String[]{MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT, new String[]{MANAGE_DEVICE_POLICY_DISPLAY});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_TETHERING, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_VPN, new String[]{MANAGE_DEVICE_POLICY_VPN});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONFIG_WIFI, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONTENT_CAPTURE, new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CONTENT_SUGGESTIONS, new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CREATE_WINDOWS, new String[]{MANAGE_DEVICE_POLICY_WINDOWS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE, new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_DATA_ROAMING, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_DEBUGGING_FEATURES, new String[]{MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_FACTORY_RESET, new String[]{MANAGE_DEVICE_POLICY_FACTORY_RESET});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_FUN, new String[]{MANAGE_DEVICE_POLICY_FUN});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_APPS, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MICROPHONE_TOGGLE, new String[]{MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MODIFY_ACCOUNTS, new String[]{MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA, new String[]{MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_NETWORK_RESET, new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_OUTGOING_BEAM, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_OUTGOING_CALLS, new String[]{MANAGE_DEVICE_POLICY_CALLS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_PRINTING, new String[]{MANAGE_DEVICE_POLICY_PRINTING});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_REMOVE_USER, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_RUN_IN_BACKGROUND, new String[]{MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SAFE_BOOT, new String[]{MANAGE_DEVICE_POLICY_SAFE_BOOT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SET_USER_ICON, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SET_WALLPAPER, new String[]{MANAGE_DEVICE_POLICY_WALLPAPER});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE, new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARE_LOCATION, new String[]{MANAGE_DEVICE_POLICY_LOCATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SMS, new String[]{MANAGE_DEVICE_POLICY_SMS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS, new String[]{MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_ULTRA_WIDEBAND_RADIO, new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNIFIED_PASSWORD, new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNINSTALL_APPS, new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNMUTE_DEVICE, new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_UNMUTE_MICROPHONE, new String[]{MANAGE_DEVICE_POLICY_MICROPHONE});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_USB_FILE_TRANSFER, new String[]{MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_USER_SWITCH, new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WIFI_DIRECT, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WIFI_TETHERING, new String[]{MANAGE_DEVICE_POLICY_WIFI});\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.ENSURE_VERIFY_APPS, new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});\n\n        // Restrictions not allowed to be set by admins.\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_RECORD_AUDIO, null);\n        USER_RESTRICTION_PERMISSIONS.put(\n                UserManager.DISALLOW_WALLPAPER, null);\n    }\n\n    private EnforcingAdmin enforcePermissionForUserRestriction(ComponentName who,\n            String userRestriction, String callerPackageName, int userId) {\n        String[] permissions = USER_RESTRICTION_PERMISSIONS.get(userRestriction);\n        if (permissions.length > 0) {\n            try {\n                return enforcePermissionsAndGetEnforcingAdmin(who, permissions, callerPackageName,\n                        userId);\n            } catch (SecurityException e) {\n                throw new SecurityException(\"Caller does not hold the required permission for this \"\n                        + \"user restriction: \" + userRestriction + \".\\n\" + e.getMessage());\n            }\n         }\n        throw new SecurityException(\"Admins are not permitted to set User Restriction: \"\n                + userRestriction);\n    }\n\n    @Override\n    public Bundle getUserRestrictionsGlobally(String callerPackage) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            throw new IllegalStateException(\"Feature flag is not enabled.\");\n        }\n\n        EnforcingAdmin admin = getEnforcingAdminForCaller(/*who=*/ null, caller.getPackageName());\n\n        return getUserRestrictionsFromPolicyEngine(admin,\n                UserHandle.USER_ALL);\n    }\n\n    /**\n     * Returns user restrictions set by the given admin for the provided {@code userId}.\n     *\n     * <p>Pass in {@link UserHandle#USER_ALL} for {@code userId} to get global restrictions set by\n     * the admin\n     */\n    private Bundle getUserRestrictionsFromPolicyEngine(EnforcingAdmin admin, int userId) {\n        Set<UserRestrictionPolicyKey> restrictionKeys =\n                mDevicePolicyEngine.getUserRestrictionPolicyKeysForAdmin(\n                        admin,\n                        userId);\n        Bundle restrictions = new Bundle();\n        for (UserRestrictionPolicyKey key : restrictionKeys) {\n            restrictions.putBoolean(key.getRestriction(), true);\n        }\n        return restrictions;\n    }\n\n    @Override\n    public boolean setApplicationHidden(ComponentName who, String callerPackage, String packageName,\n            boolean hidden, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        final int userId = parent ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_PACKAGE_STATE, caller.getPackageName(), userId);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        List<String> exemptApps = listPolicyExemptAppsUnchecked(mContext);\n        if (exemptApps.contains(packageName)) {\n            Slogf.d(LOG_TAG, \"setApplicationHidden(): ignoring %s as it's on policy-exempt list\",\n                    packageName);\n            return false;\n        }\n\n        boolean result;\n        synchronized (getLockObject()) {\n            if (parent) {\n                if (!isPolicyEngineForFinanceFlagEnabled()) {\n                    Preconditions.checkCallAuthorization(\n                            isProfileOwnerOfOrganizationOwnedDevice(\n                                    caller.getUserId()) && isManagedProfile(caller.getUserId()));\n                }\n                // Ensure the package provided is a system package, this is to ensure that this\n                // API cannot be used to leak if certain non-system package exists in the person\n                // profile.\n                mInjector.binderWithCleanCallingIdentity(() ->\n                        enforcePackageIsSystemPackage(packageName, userId));\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_APPLICATION_HIDDEN);\n\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"calling pm.setApplicationHiddenSettingAsUser(%s, %b, %d)\",\n                        packageName, hidden, userId);\n            }\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                EnforcingAdmin admin = getEnforcingAdminForCaller(who, callerPackage);\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.APPLICATION_HIDDEN(packageName),\n                        admin,\n                        new BooleanPolicyValue(hidden),\n                        userId);\n                result = mInjector.binderWithCleanCallingIdentity(() -> {\n                    try {\n                        // This is a best effort to continue returning the same value that was\n                        // returned before the policy engine migration.\n                        return mInjector.getIPackageManager().getPackageInfo(\n                                packageName, MATCH_UNINSTALLED_PACKAGES, userId) != null\n                                && (mIPackageManager.getApplicationHiddenSettingAsUser(\n                                        packageName, userId) == hidden);\n                    } catch (RemoteException e) {\n                        return false;\n                    }\n                });\n            } else {\n                result = mInjector.binderWithCleanCallingIdentity(() -> mIPackageManager\n                        .setApplicationHiddenSettingAsUser(packageName, hidden, userId));\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_APPLICATION_HIDDEN)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName, hidden ? \"hidden\" : \"not_hidden\",\n                        parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n        return result;\n    }\n\n    @Override\n    public boolean isApplicationHidden(ComponentName who, String callerPackage,\n            String packageName, boolean parent) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        int userId = parent ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // TODO: Also support DELEGATION_PACKAGE_ACCESS\n            enforcePermission(MANAGE_DEVICE_POLICY_PACKAGE_STATE, caller.getPackageName(), userId);\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(\n                            caller, DELEGATION_PACKAGE_ACCESS)));\n        }\n\n        synchronized (getLockObject()) {\n            if (parent) {\n                if (!isPolicyEngineForFinanceFlagEnabled()) {\n                    Preconditions.checkCallAuthorization(\n                            isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId())\n                                    && isManagedProfile(caller.getUserId()));\n                }\n                // Ensure the package provided is a system package.\n                mInjector.binderWithCleanCallingIdentity(() ->\n                        enforcePackageIsSystemPackage(packageName, userId));\n            }\n\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> mIPackageManager.getApplicationHiddenSettingAsUser(packageName, userId));\n        }\n    }\n\n    private void enforcePackageIsSystemPackage(String packageName, int userId)\n            throws RemoteException {\n        boolean isSystem;\n        try {\n            isSystem = isSystemApp(mIPackageManager, packageName, userId);\n        } catch (IllegalArgumentException e) {\n            isSystem = false;\n        }\n        if (!isSystem) {\n            throw new IllegalArgumentException(\"The provided package is not a system package\");\n        }\n    }\n\n    @Override\n    public void enableSystemApp(ComponentName who, String callerPackage, String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_ENABLE_SYSTEM_APP)));\n\n        final boolean isDemo = isCurrentUserDemo();\n        int userId = caller.getUserId();\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"installing \" + packageName + \" for \" + userId);\n            }\n\n            Preconditions.checkArgument(isDemo || isSystemApp(mIPackageManager, packageName,\n                    getProfileParentId(userId)), \"Only system apps can be enabled this way\");\n\n            // Install the app.\n            mIPackageManager.installExistingPackageAsUser(packageName, userId,\n                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                    PackageManager.INSTALL_REASON_POLICY, null);\n            if (isDemo) {\n                // Ensure the app is also ENABLED for demo users.\n                mIPackageManager.setApplicationEnabledSetting(packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_ENABLED,\n                        PackageManager.DONT_KILL_APP, userId, \"DevicePolicyManager\");\n            }\n        } catch (RemoteException re) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to install \" + packageName, re);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ENABLE_SYSTEM_APP)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(packageName)\n                .write();\n    }\n\n    @Override\n    public int enableSystemAppWithIntent(ComponentName who, String callerPackage, Intent intent) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_ENABLE_SYSTEM_APP)));\n\n        int numberOfAppsInstalled = 0;\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            final int parentUserId = getProfileParentId(caller.getUserId());\n            List<ResolveInfo> activitiesToEnable = mIPackageManager\n                    .queryIntentActivities(intent,\n                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                            PackageManager.MATCH_DIRECT_BOOT_AWARE\n                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n                            parentUserId)\n                    .getList();\n\n            if (VERBOSE_LOG) {\n                Slogf.d(LOG_TAG, \"Enabling system activities: \" + activitiesToEnable);\n            }\n            if (activitiesToEnable != null) {\n                for (ResolveInfo info : activitiesToEnable) {\n                    if (info.activityInfo != null) {\n                        String packageName = info.activityInfo.packageName;\n                        if (isSystemApp(mIPackageManager, packageName, parentUserId)) {\n                            numberOfAppsInstalled++;\n                            mIPackageManager.installExistingPackageAsUser(packageName,\n                                    caller.getUserId(),\n                                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                                    PackageManager.INSTALL_REASON_POLICY, null);\n                        } else {\n                            Slogf.d(LOG_TAG, \"Not enabling \" + packageName + \" since is not a\"\n                                    + \" system app\");\n                        }\n                    }\n                }\n            }\n        } catch (RemoteException e) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to resolve intent for: \" + intent, e);\n            return 0;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ENABLE_SYSTEM_APP_WITH_INTENT)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ who == null)\n                .setStrings(intent.getAction())\n                .write();\n        return numberOfAppsInstalled;\n    }\n\n    private boolean isSystemApp(IPackageManager pm, String packageName, int userId)\n            throws RemoteException {\n        ApplicationInfo appInfo = pm.getApplicationInfo(packageName, MATCH_UNINSTALLED_PACKAGES,\n                userId);\n        if (appInfo == null) {\n            throw new IllegalArgumentException(\"The application \" + packageName +\n                    \" is not present on this device\");\n        }\n        return (appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;\n    }\n\n    @Override\n    public boolean installExistingPackage(ComponentName who, String callerPackage,\n            String packageName) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage()\n                && isCallerDelegate(caller, DELEGATION_INSTALL_EXISTING_PACKAGE)));\n\n        boolean result;\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(\n                    isUserAffiliatedWithDeviceLocked(caller.getUserId()),\n                            \"Admin %s is neither the device owner or \"\n                                    + \"affiliated user's profile owner.\", who);\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"installing \" + packageName + \" for \" + caller.getUserId());\n                }\n\n                // Install the package.\n                result = mIPackageManager.installExistingPackageAsUser(packageName,\n                        caller.getUserId(),\n                        PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null)\n                        == PackageManager.INSTALL_SUCCEEDED;\n            } catch (RemoteException re) {\n                // shouldn't happen\n                Slogf.wtf(LOG_TAG, \"Error installing package\", re);\n                return false;\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n        if (result) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_EXISTING_PACKAGE)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ who == null)\n                    .setStrings(packageName)\n                    .write();\n        }\n        return result;\n    }\n\n    @Override\n    public void setAccountManagementDisabled(ComponentName who, String callerPackageName,\n            String accountType, boolean disabled, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        enforceMaxStringLength(accountType, \"account type\");\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        synchronized (getLockObject()) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                int affectedUser = getAffectedUser(parent);\n                EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                        caller.getPackageName(),\n                        affectedUser\n                );\n                if (disabled) {\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                            enforcingAdmin,\n                            new BooleanPolicyValue(disabled),\n                            affectedUser);\n                } else {\n                    mDevicePolicyEngine.removeLocalPolicy(\n                            PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                            enforcingAdmin,\n                            affectedUser);\n                }\n            } else {\n                final ActiveAdmin ap;\n                Objects.requireNonNull(who, \"ComponentName is null\");\n                /*\n                 * When called on the parent DPM instance (parent == true), affects active admin\n                 * selection in two ways:\n                 * * The ActiveAdmin must be of an org-owned profile owner.\n                 * * The parent ActiveAdmin instance should be used for managing the restriction.\n                 */\n                if (parent) {\n                    ap = getParentOfAdminIfRequired(getOrganizationOwnedProfileOwnerLocked(caller),\n                            parent);\n                } else {\n                    Preconditions.checkCallAuthorization(\n                            isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n                    ap = getParentOfAdminIfRequired(\n                            getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n                }\n                if (disabled) {\n                    ap.accountTypesWithManagementDisabled.add(accountType);\n                } else {\n                    ap.accountTypesWithManagementDisabled.remove(accountType);\n                }\n                saveSettingsLocked(UserHandle.getCallingUserId());\n            }\n        }\n    }\n\n    @Override\n    public String[] getAccountTypesWithManagementDisabled(String callerPackageName) {\n        return getAccountTypesWithManagementDisabledAsUser(UserHandle.getCallingUserId(),\n                callerPackageName, false);\n    }\n\n    @Override\n    public String[] getAccountTypesWithManagementDisabledAsUser(int userId,\n            String callerPackageName, boolean parent) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller;\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        final ArraySet<String> resultSet = new ArraySet<>();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            int affectedUser = parent ? getProfileParentId(userId) : userId;\n            caller = getCallerIdentity(callerPackageName);\n            if (!hasPermission(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                    callerPackageName, affectedUser)\n                    && !hasFullCrossUsersPermission(caller, userId)) {\n                throw new SecurityException(\"Caller does not have permission to call this on user: \"\n                        + affectedUser);\n            }\n            Set<PolicyKey> keys = mDevicePolicyEngine.getLocalPolicyKeysSetByAllAdmins(\n                    PolicyDefinition.GENERIC_ACCOUNT_MANAGEMENT_DISABLED,\n                    affectedUser);\n\n            for (PolicyKey key : keys) {\n                if (!(key instanceof AccountTypePolicyKey)) {\n                    throw new IllegalStateException(\"PolicyKey for \"\n                            + \"MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT is not of type \"\n                            + \"AccountTypePolicyKey\");\n                }\n                AccountTypePolicyKey parsedKey =\n                        (AccountTypePolicyKey) key;\n                String accountType = Objects.requireNonNull(parsedKey.getAccountType());\n\n                Boolean disabled = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                        affectedUser);\n                if (disabled != null && disabled) {\n                    resultSet.add(accountType);\n                }\n            }\n        } else {\n            caller = getCallerIdentity();\n            Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n            synchronized (getLockObject()) {\n                if (!parent) {\n                    final DevicePolicyData policy = getUserData(userId);\n                    for (ActiveAdmin admin : policy.mAdminList) {\n                        resultSet.addAll(admin.accountTypesWithManagementDisabled);\n                    }\n                }\n\n                // Check if there's a profile owner of an org-owned device and the method is called\n                // for the parent user of this profile owner.\n                final ActiveAdmin orgOwnedAdmin =\n                        getProfileOwnerOfOrganizationOwnedDeviceLocked(userId);\n                final boolean shouldGetParentAccounts = orgOwnedAdmin != null && (parent\n                        || UserHandle.getUserId(orgOwnedAdmin.getUid()) != userId);\n                if (shouldGetParentAccounts) {\n                    resultSet.addAll(\n                            orgOwnedAdmin.getParentActiveAdmin()\n                                    .accountTypesWithManagementDisabled);\n                }\n            }\n        }\n        return resultSet.toArray(new String[resultSet.size()]);\n    }\n\n    @Override\n    public void setUninstallBlocked(ComponentName who, String callerPackage, String packageName,\n            boolean uninstallBlocked) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionsAndGetEnforcingAdmin(\n                    who,\n                    new String[]{\n                            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                            MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL\n                    },\n                    caller.getPackageName(),\n                    caller.getUserId());\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.PACKAGE_UNINSTALL_BLOCKED(packageName),\n                    enforcingAdmin,\n                    new BooleanPolicyValue(uninstallBlocked),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage()\n                    && isCallerDelegate(caller, DELEGATION_BLOCK_UNINSTALL)));\n            final int userId = caller.getUserId();\n            synchronized (getLockObject()) {\n                long id = mInjector.binderClearCallingIdentity();\n                try {\n                    mIPackageManager.setBlockUninstallForUser(\n                            packageName, uninstallBlocked, userId);\n                } catch (RemoteException re) {\n                    // Shouldn't happen.\n                    Slogf.e(LOG_TAG, \"Failed to setBlockUninstallForUser\", re);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(id);\n                }\n            }\n            if (uninstallBlocked) {\n                final PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n                pmi.removeNonSystemPackageSuspensions(packageName, userId);\n                pmi.removeDistractingPackageRestrictions(packageName, userId);\n                pmi.flushPackageRestrictions(userId);\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_UNINSTALL_BLOCKED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .setStrings(packageName)\n                .write();\n    }\n\n    static void setUninstallBlockedUnchecked(\n            String packageName, boolean uninstallBlocked, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                AppGlobals.getPackageManager().setBlockUninstallForUser(\n                        packageName, uninstallBlocked, userId);\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed to setBlockUninstallForUser\", re);\n            }\n        });\n        if (uninstallBlocked) {\n            final PackageManagerInternal pmi = LocalServices.getService(\n                    PackageManagerInternal.class);\n            pmi.removeNonSystemPackageSuspensions(packageName, userId);\n            pmi.removeDistractingPackageRestrictions(packageName, userId);\n            pmi.flushPackageRestrictions(userId);\n        }\n    }\n\n    @Override\n    public boolean isUninstallBlocked(String packageName) {\n        // This function should return true if and only if the package is blocked by\n        // setUninstallBlocked(). It should still return false for other cases of blocks, such as\n        // when the package is a system app, or when it is an active device admin.\n        final int userId = UserHandle.getCallingUserId();\n\n        synchronized (getLockObject()) {\n            try {\n                return mIPackageManager.getBlockUninstallForUser(packageName, userId);\n            } catch (RemoteException re) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Failed to getBlockUninstallForUser\", re);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setCrossProfileCallerIdDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (disabled) {\n                admin.mManagedProfileCallerIdAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);\n            } else {\n                admin.mManagedProfileCallerIdAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);\n            }\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CALLER_ID_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getCrossProfileCallerIdDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess == null) {\n                return admin.disableCallerId;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Denying callerId due to PACKAGE_POLICY_SYSTEM policyType\");\n            }\n\n            return admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public boolean getCrossProfileCallerIdDisabledForUser(int userId) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileCallerIdAccess == null) {\n                return admin.disableCallerId;\n            }\n\n            return admin.mManagedProfileCallerIdAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST;\n        }\n    }\n\n    @Override\n    public void setManagedProfileCallerIdAccessPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.disableCallerId = false;\n            admin.mManagedProfileCallerIdAccess = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public PackagePolicy getManagedProfileCallerIdAccessPolicy() {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return (admin != null) ? admin.mManagedProfileCallerIdAccess : null;\n        }\n    }\n\n    @Override\n    public boolean hasManagedProfileCallerIdAccess(int userId, String packageName) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mManagedProfileCallerIdAccess == null) {\n                    return !admin.disableCallerId;\n                }\n                return admin.mManagedProfileCallerIdAccess.isPackageAllowed(packageName,\n                        mContactSystemRoleHolders);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void setManagedProfileContactsAccessPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.disableContactsSearch = false;\n            admin.mManagedProfileContactsAccess = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public PackagePolicy getManagedProfileContactsAccessPolicy() {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId())));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return (admin != null) ? admin.mManagedProfileContactsAccess : null;\n        }\n    }\n\n    @Override\n    public boolean hasManagedProfileContactsAccess(int userId, String packageName) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mManagedProfileContactsAccess == null) {\n                    return !admin.disableContactsSearch;\n                }\n\n                return admin.mManagedProfileContactsAccess.isPackageAllowed(packageName,\n                        mContactSystemRoleHolders);\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void setCrossProfileContactsSearchDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (disabled) {\n                admin.mManagedProfileContactsAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);\n            } else {\n                admin.mManagedProfileContactsAccess =\n                        new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);\n            }\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CONTACTS_SEARCH_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getCrossProfileContactsSearchDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin == null) {\n                return false;\n            }\n            if (admin.mManagedProfileContactsAccess == null) {\n                return admin.disableContactsSearch;\n            }\n            return admin.mManagedProfileContactsAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public boolean getCrossProfileContactsSearchDisabledForUser(int userId) {\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin == null) {\n                return false;\n            }\n\n            if (admin.mManagedProfileContactsAccess == null) {\n                return admin.disableContactsSearch;\n            }\n            if (admin.mManagedProfileContactsAccess.getPolicyType()\n                    == PackagePolicy.PACKAGE_POLICY_ALLOWLIST_AND_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Denying contacts due to PACKAGE_POLICY_SYSTEM policyType\");\n            }\n            return admin.mManagedProfileContactsAccess.getPolicyType()\n                    != PackagePolicy.PACKAGE_POLICY_BLOCKLIST;\n        }\n    }\n\n    @Override\n    public void startManagedQuickContact(String actualLookupKey, long actualContactId,\n            boolean isContactIdIgnored, long actualDirectoryId, Intent originalIntent) {\n        final Intent intent = QuickContact.rebuildManagedQuickContactsIntent(actualLookupKey,\n                actualContactId, isContactIdIgnored, actualDirectoryId, originalIntent);\n        final int callingUserId = UserHandle.getCallingUserId();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                final int managedUserId = getManagedUserId(callingUserId);\n                if (managedUserId < 0) {\n                    return;\n                }\n                if (isCrossProfileQuickContactDisabled(managedUserId)) {\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"Cross-profile contacts access disabled for user %d\",\n                                managedUserId);\n                    }\n                    return;\n                }\n                ContactsInternal.startQuickContactWithErrorToastForUser(\n                        mContext, intent, new UserHandle(managedUserId));\n            }\n        });\n    }\n\n    /**\n     * @return true if cross-profile QuickContact is disabled\n     */\n    private boolean isCrossProfileQuickContactDisabled(@UserIdInt int userId) {\n        return getCrossProfileCallerIdDisabledForUser(userId)\n                && getCrossProfileContactsSearchDisabledForUser(userId);\n    }\n\n    /**\n     * @return the user ID of the managed user that is linked to the current user, if any.\n     * Otherwise UserHandle.USER_NULL (-10000).\n     */\n    public int getManagedUserId(@UserIdInt int callingUserId) {\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"getManagedUserId: callingUserId=%d\", callingUserId);\n\n        for (UserInfo ui : mUserManager.getProfiles(callingUserId)) {\n            if (ui.id == callingUserId || !ui.isManagedProfile()) {\n                continue; // Caller user self, or not a managed profile.  Skip.\n            }\n            if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Managed user=%d\", ui.id);\n            return ui.id;\n        }\n        if (VERBOSE_LOG)  Slogf.v(LOG_TAG, \"Managed user not found.\");\n        return UserHandle.USER_NULL;\n    }\n\n    /**\n     * Returns the userId of the managed profile on the device.\n     * If none exists, return {@link UserHandle#USER_NULL}.\n     *\n     * We assume there is only one managed profile across all users\n     * on the device, which is true for now (HSUM or not) but could\n     * change in future.\n     */\n    private @UserIdInt int getManagedUserId() {\n        // On HSUM, there is only one main user and only the main user\n        // can have a managed profile (for now). On non-HSUM, only user 0\n        // can host the managed profile and user 0 is the main user.\n        // So in both cases, we could just get the main user and\n        // search for the profile user under it.\n        UserHandle mainUser = mUserManager.getMainUser();\n        if (mainUser == null) return UserHandle.USER_NULL;\n        return getManagedUserId(mainUser.getIdentifier());\n    }\n\n    @Override\n    public void setBluetoothContactSharingDisabled(ComponentName who, boolean disabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (admin.disableBluetoothContactSharing != disabled) {\n                admin.disableBluetoothContactSharing = disabled;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_BLUETOOTH_CONTACT_SHARING_DISABLED)\n                .setAdmin(who)\n                .setBoolean(disabled)\n                .write();\n    }\n\n    @Override\n    public boolean getBluetoothContactSharingDisabled(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.disableBluetoothContactSharing;\n        }\n    }\n\n    @Override\n    public boolean getBluetoothContactSharingDisabledForUser(int userId) {\n        // TODO: Should there be a check to make sure this relationship is\n        // within a profile group?\n        // enforceSystemProcess(\"getCrossProfileCallerIdDisabled can only be called by system\");\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            return (admin != null) ? admin.disableBluetoothContactSharing : false;\n        }\n    }\n\n    @Override\n    public void setSecondaryLockscreenEnabled(ComponentName who, boolean enabled) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        // Check can set secondary lockscreen enabled\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        Preconditions.checkCallAuthorization(!isManagedProfile(caller.getUserId()),\n                \"User %d is not allowed to call setSecondaryLockscreenEnabled\",\n                        caller.getUserId());\n\n        synchronized (getLockObject()) {\n            // Allow testOnly admins to bypass supervision config requirement.\n            Preconditions.checkCallAuthorization(isAdminTestOnlyLocked(who, caller.getUserId())\n                    || isSupervisionComponentLocked(caller.getComponentName()), \"Admin %s is not \"\n                    + \"the default supervision component\", caller.getComponentName());\n            DevicePolicyData policy = getUserData(caller.getUserId());\n            policy.mSecondaryLockscreenEnabled = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public boolean isSecondaryLockscreenEnabled(@NonNull UserHandle userHandle) {\n        synchronized (getLockObject()) {\n            return getUserData(userHandle.getIdentifier()).mSecondaryLockscreenEnabled;\n        }\n    }\n\n    private boolean isManagedProfileOwner(CallerIdentity caller) {\n        return isProfileOwner(caller) && isManagedProfile(caller.getUserId());\n    }\n\n    @Override\n    public void setPreferentialNetworkServiceConfigs(\n            List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                        && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller),\n                \"Caller is not managed profile owner or device owner;\"\n                        + \" only managed profile owner or device owner may control the preferential\"\n                        + \" network service\");\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            if (!requiredAdmin.mPreferentialNetworkServiceConfigs.equals(\n                    preferentialNetworkServiceConfigs)) {\n                requiredAdmin.mPreferentialNetworkServiceConfigs =\n                        new ArrayList<>(preferentialNetworkServiceConfigs);\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        updateNetworkPreferenceForUser(caller.getUserId(), preferentialNetworkServiceConfigs);\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PREFERENTIAL_NETWORK_SERVICE_ENABLED)\n                .setBoolean(preferentialNetworkServiceConfigs\n                        .stream().anyMatch(c -> c.isEnabled()))\n                .write();\n    }\n\n    @Override\n    public List<PreferentialNetworkServiceConfig> getPreferentialNetworkServiceConfigs() {\n        if (!mHasFeature) {\n            return List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization((isProfileOwner(caller)\n                        && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller),\n                \"Caller is not managed profile owner or device owner;\"\n                        + \" only managed profile owner or device owner may retrieve the \"\n                        + \"preferential network service configurations\");\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            return requiredAdmin.mPreferentialNetworkServiceConfigs;\n        }\n    }\n\n    @Override\n    public void setLockTaskPackages(ComponentName who, String callerPackageName, String[] packages)\n            throws SecurityException {\n        Objects.requireNonNull(packages, \"packages is null\");\n        for (String pkg : packages) {\n            enforceMaxPackageNameLength(pkg);\n        }\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_PACKAGES);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            synchronized (getLockObject()) {\n                enforcingAdmin = enforceCanCallLockTaskLocked(who, caller.getPackageName());\n            }\n            LockTaskPolicy currentPolicy = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    caller.getUserId());\n            LockTaskPolicy policy;\n            if (currentPolicy == null) {\n                policy = new LockTaskPolicy(Set.of(packages));\n            } else {\n                policy = new LockTaskPolicy(currentPolicy);\n                policy.setPackages(Set.of(packages));\n            }\n            if (policy.getPackages().isEmpty()) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        policy,\n                        caller.getUserId());\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                final int userHandle = caller.getUserId();\n                setLockTaskPackagesLocked(userHandle, new ArrayList<>(Arrays.asList(packages)));\n            }\n        }\n    }\n\n    private void setLockTaskPackagesLocked(int userHandle, List<String> packages) {\n        DevicePolicyData policy = getUserData(userHandle);\n        policy.mLockTaskPackages = packages;\n\n        // Store the settings persistently.\n        saveSettingsLocked(userHandle);\n        updateLockTaskPackagesLocked(mContext, packages, userHandle);\n    }\n\n    @Override\n    public String[] getLockTaskPackages(ComponentName who, String callerPackageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userHandle = caller.getUserId();\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            synchronized (getLockObject()) {\n                enforceCanQueryLockTaskLocked(who, caller.getPackageName());\n            }\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, userHandle);\n            if (policy == null) {\n                return new String[0];\n            } else {\n                return policy.getPackages().toArray(new String[policy.getPackages().size()]);\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                final List<String> packages = getUserData(userHandle).mLockTaskPackages;\n                return packages.toArray(new String[packages.size()]);\n            }\n        }\n    }\n\n    @Override\n    public boolean isLockTaskPermitted(String pkg) {\n        // Check policy-exempt apps first, as it doesn't require the lock\n        if (listPolicyExemptAppsUnchecked(mContext).contains(pkg)) {\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"isLockTaskPermitted(%s): returning true for policy-exempt app\",\n                            pkg);\n            }\n            return true;\n        }\n\n        final int userId = mInjector.userHandleGetCallingUserId();\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, userId);\n            if (policy == null) {\n                return false;\n            }\n            return policy.getPackages().contains(pkg);\n        } else {\n            synchronized (getLockObject()) {\n                return getUserData(userId).mLockTaskPackages.contains(pkg);\n            }\n        }\n    }\n\n    @Override\n    public void setLockTaskFeatures(ComponentName who, String callerPackageName, int flags) {\n        // Throw if Overview is used without Home.\n        boolean hasHome = (flags & LOCK_TASK_FEATURE_HOME) != 0;\n        boolean hasOverview = (flags & LOCK_TASK_FEATURE_OVERVIEW) != 0;\n        Preconditions.checkArgument(hasHome || !hasOverview,\n                \"Cannot use LOCK_TASK_FEATURE_OVERVIEW without LOCK_TASK_FEATURE_HOME\");\n        boolean hasNotification = (flags & LOCK_TASK_FEATURE_NOTIFICATIONS) != 0;\n        Preconditions.checkArgument(hasHome || !hasNotification,\n            \"Cannot use LOCK_TASK_FEATURE_NOTIFICATIONS without LOCK_TASK_FEATURE_HOME\");\n\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userHandle = caller.getUserId();\n        synchronized (getLockObject()) {\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_FEATURES);\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin;\n            synchronized (getLockObject()) {\n                enforcingAdmin = enforceCanCallLockTaskLocked(who, caller.getPackageName());\n                enforceCanSetLockTaskFeaturesOnFinancedDevice(caller, flags);\n            }\n            LockTaskPolicy currentPolicy = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.LOCK_TASK,\n                    enforcingAdmin,\n                    caller.getUserId());\n            LockTaskPolicy policy;\n            if (currentPolicy == null) {\n                policy = new LockTaskPolicy(flags);\n            } else {\n                policy = new LockTaskPolicy(currentPolicy);\n                policy.setFlags(flags);\n            }\n            if (policy.getPackages().isEmpty()\n                    && policy.getFlags() == DevicePolicyManager.LOCK_TASK_FEATURE_NONE) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.LOCK_TASK,\n                        enforcingAdmin,\n                        policy,\n                        caller.getUserId());\n            }\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                enforceCanSetLockTaskFeaturesOnFinancedDevice(caller, flags);\n                setLockTaskFeaturesLocked(userHandle, flags);\n            }\n        }\n    }\n\n    private void setLockTaskFeaturesLocked(int userHandle, int flags) {\n        DevicePolicyData policy = getUserData(userHandle);\n        policy.mLockTaskFeatures = flags;\n        saveSettingsLocked(userHandle);\n        updateLockTaskFeaturesLocked(flags, userHandle);\n    }\n\n    @Override\n    public int getLockTaskFeatures(ComponentName who, String callerPackageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final int userHandle = caller.getUserId();\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            synchronized (getLockObject()) {\n                enforceCanQueryLockTaskLocked(who, caller.getPackageName());\n            }\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, userHandle);\n            if (policy == null) {\n                // We default on the power button menu, in order to be consistent with pre-P\n                // behaviour.\n                return DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\n            }\n            return policy.getFlags();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                enforceCanCallLockTaskLocked(caller);\n                return getUserData(userHandle).mLockTaskFeatures;\n            }\n        }\n    }\n\n    private void maybeClearLockTaskPolicyLocked() {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n            for (int i = userInfos.size() - 1; i >= 0; i--) {\n                int userId = userInfos.get(i).id;\n                if (canDPCManagedUserUseLockTaskLocked(userId)) {\n                    continue;\n                }\n\n                if (isPolicyEngineForFinanceFlagEnabled()) {\n                    Map<EnforcingAdmin, PolicyValue<LockTaskPolicy>> policies =\n                            mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                                    PolicyDefinition.LOCK_TASK, userId);\n                    Set<EnforcingAdmin> admins = new HashSet<>(policies.keySet());\n                    for (EnforcingAdmin admin : admins) {\n                        if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n                            mDevicePolicyEngine.removeLocalPolicy(\n                                    PolicyDefinition.LOCK_TASK, admin, userId);\n                        }\n                    }\n                } else {\n                    final List<String> lockTaskPackages = getUserData(userId).mLockTaskPackages;\n                    // TODO(b/278438525): handle in the policy engine\n                    if (!lockTaskPackages.isEmpty()) {\n                        Slogf.d(LOG_TAG,\n                                \"User id \" + userId\n                                        + \" not affiliated. Clearing lock task packages\");\n                        setLockTaskPackagesLocked(userId, Collections.<String>emptyList());\n                    }\n                    final int lockTaskFeatures = getUserData(userId).mLockTaskFeatures;\n                    if (lockTaskFeatures != DevicePolicyManager.LOCK_TASK_FEATURE_NONE) {\n                        Slogf.d(LOG_TAG,\n                                \"User id \" + userId\n                                        + \" not affiliated. Clearing lock task features\");\n                        setLockTaskFeaturesLocked(userId,\n                                DevicePolicyManager.LOCK_TASK_FEATURE_NONE);\n                    }\n                }\n            }\n        });\n    }\n\n    private void enforceCanSetLockTaskFeaturesOnFinancedDevice(CallerIdentity caller, int flags) {\n        int allowedFlags = LOCK_TASK_FEATURE_SYSTEM_INFO | LOCK_TASK_FEATURE_KEYGUARD\n                | LOCK_TASK_FEATURE_HOME | LOCK_TASK_FEATURE_GLOBAL_ACTIONS\n                | LOCK_TASK_FEATURE_NOTIFICATIONS | LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\n\n        if (!isFinancedDeviceOwner(caller)) {\n            return;\n        }\n\n        if ((flags & ~(allowedFlags)) != 0) {\n            throw new SecurityException(\n                    \"Permitted lock task features when managing a financed device: \"\n                            + \"LOCK_TASK_FEATURE_SYSTEM_INFO, LOCK_TASK_FEATURE_KEYGUARD, \"\n                            + \"LOCK_TASK_FEATURE_HOME, LOCK_TASK_FEATURE_GLOBAL_ACTIONS, \"\n                            + \"LOCK_TASK_FEATURE_NOTIFICATIONS\"\n                            + \" or LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK\");\n        }\n    }\n\n    @Override\n    public void notifyLockTaskModeChanged(boolean isEnabled, String pkg, int userHandle) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"call notifyLockTaskModeChanged\"));\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle);\n\n            if (policy.mStatusBarDisabled) {\n                // Status bar is managed by LockTaskController during LockTask, so we cancel this\n                // policy when LockTask starts, and reapply it when LockTask ends\n                setStatusBarDisabledInternal(!isEnabled, userHandle);\n            }\n\n            Bundle adminExtras = new Bundle();\n            adminExtras.putString(DeviceAdminReceiver.EXTRA_LOCK_TASK_PACKAGE, pkg);\n            for (ActiveAdmin admin : policy.mAdminList) {\n                final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userHandle);\n                final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userHandle);\n                // TODO(b/281738975): Should we be logging this for all admins?\n                if (ownsDevice || ownsProfile) {\n                    if (isEnabled) {\n                        sendAdminCommandLocked(admin, DeviceAdminReceiver.ACTION_LOCK_TASK_ENTERING,\n                                adminExtras, null);\n                    } else {\n                        sendAdminCommandLocked(admin, DeviceAdminReceiver.ACTION_LOCK_TASK_EXITING);\n                    }\n                    DevicePolicyEventLogger\n                            .createEvent(DevicePolicyEnums.SET_LOCKTASK_MODE_ENABLED)\n                            .setAdmin(admin.info == null ? null : admin.info.getPackageName())\n                            .setBoolean(isEnabled)\n                            .setStrings(pkg)\n                            .write();\n                }\n            }\n        }\n        // TODO(b/281738975): Should we be logging this for all admins?\n        for(EnforcingAdmin admin : mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                PolicyDefinition.LOCK_TASK, userHandle).keySet()) {\n            if (admin.hasAuthority(EnforcingAdmin.DPC_AUTHORITY)) {\n                // already handled above\n                continue;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_LOCKTASK_MODE_ENABLED)\n                    .setAdmin(admin.getPackageName())\n                    .setBoolean(isEnabled)\n                    .setStrings(pkg)\n                    .write();\n        }\n    }\n\n    @Override\n    public void setGlobalSetting(ComponentName who, String setting, String value) {\n        final CallerIdentity caller = getCallerIdentity(who);\n        if (Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS.equals(setting)) {\n            Preconditions.checkCallAuthorization(isCallerDevicePolicyManagementRoleHolder(caller));\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutString(setting, value));\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_GLOBAL_SETTING)\n                .setAdmin(who)\n                .setStrings(setting, value)\n                .write();\n\n        synchronized (getLockObject()) {\n            // Some settings are no supported any more. However we do not want to throw a\n            // SecurityException to avoid breaking apps.\n            if (GLOBAL_SETTINGS_DEPRECATED.contains(setting)) {\n                Slogf.i(LOG_TAG, \"Global setting no longer supported: %s\", setting);\n                return;\n            }\n\n            if (!GLOBAL_SETTINGS_ALLOWLIST.contains(setting)\n                    && !UserManager.isDeviceInDemoMode(mContext)) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: device owners cannot update %1$s\", setting));\n            }\n\n            if (Settings.Global.STAY_ON_WHILE_PLUGGED_IN.equals(setting)) {\n                // ignore if it contradicts an existing policy\n                long timeMs = getMaximumTimeToLock(\n                        who, mInjector.userHandleGetCallingUserId(), /* parent */ false);\n                if (timeMs > 0 && timeMs < Long.MAX_VALUE) {\n                    return;\n                }\n            }\n\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mInjector.settingsGlobalPutString(setting, value));\n        }\n    }\n\n    @Override\n    public void setSystemSetting(ComponentName who, String setting, String value) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkStringNotEmpty(setting, \"String setting is null or empty\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_SYSTEM_SETTING);\n\n        synchronized (getLockObject()) {\n            if (!SYSTEM_SETTINGS_ALLOWLIST.contains(setting)) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: device owners cannot update %1$s\", setting));\n            }\n\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    mInjector.settingsSystemPutStringForUser(setting, value, caller.getUserId()));\n        }\n    }\n\n    @Override\n    public void setConfiguredNetworksLockdownState(\n            ComponentName who, String callerPackageName, boolean lockdown) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(who);\n            Preconditions.checkNotNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalPutInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN,\n                        lockdown ? 1 : 0));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ALLOW_MODIFICATION_OF_ADMIN_CONFIGURED_NETWORKS)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(lockdown)\n                .write();\n    }\n\n    @Override\n    public boolean hasLockdownAdminConfiguredNetworks(ComponentName who) {\n        if (!mHasFeature) {\n            return false;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, who.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkNotNull(who, \"ComponentName is null\");\n\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.settingsGlobalGetInt(Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0) > 0);\n    }\n\n    @Override\n    public void setLocationEnabled(ComponentName who, boolean locationEnabled) {\n        Preconditions.checkNotNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        UserHandle userHandle = caller.getUserHandle();\n        if (mIsAutomotive && !locationEnabled) {\n            Slogf.i(LOG_TAG, \"setLocationEnabled(%s, %b): ignoring for user %s on automotive build\",\n                    who.flattenToShortString(), locationEnabled, userHandle);\n            return;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean wasLocationEnabled = mInjector.getLocationManager().isLocationEnabledForUser(\n                    userHandle);\n            Slogf.v(LOG_TAG, \"calling locationMgr.setLocationEnabledForUser(%b, %s) when it was %b\",\n                    locationEnabled, userHandle, wasLocationEnabled);\n            mInjector.getLocationManager().setLocationEnabledForUser(locationEnabled, userHandle);\n\n            // make a best effort to only show the notification if the admin is actually enabling\n            // location. this is subject to race conditions with settings changes, but those are\n            // unlikely to realistically interfere\n            if (locationEnabled && !wasLocationEnabled) {\n                showLocationSettingsEnabledNotification(userHandle);\n            }\n        });\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                .setAdmin(who)\n                .setStrings(Settings.Secure.LOCATION_MODE, Integer.toString(\n                        locationEnabled ? Settings.Secure.LOCATION_MODE_ON\n                                : Settings.Secure.LOCATION_MODE_OFF))\n                .write();\n    }\n\n    private void showLocationSettingsEnabledNotification(UserHandle user) {\n        Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)\n                .addFlags(FLAG_ACTIVITY_NEW_TASK);\n        // Fill the component explicitly to prevent the PendingIntent from being intercepted\n        // and fired with crafted target. b/155183624\n        ActivityInfo targetInfo = intent.resolveActivityInfo(\n                mInjector.getPackageManager(user.getIdentifier()),\n                PackageManager.MATCH_SYSTEM_ONLY);\n        if (targetInfo != null) {\n            intent.setComponent(targetInfo.getComponentName());\n        } else {\n            Slogf.wtf(LOG_TAG, \"Failed to resolve intent for location settings\");\n        }\n\n        // Simple notification clicks are immutable\n        PendingIntent locationSettingsIntent = mInjector.pendingIntentGetActivityAsUser(mContext, 0,\n                intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE, null,\n                user);\n        Notification notification = new Notification.Builder(mContext,\n                SystemNotificationChannels.DEVICE_ADMIN)\n                .setSmallIcon(R.drawable.ic_info_outline)\n                .setContentTitle(getLocationChangedTitle())\n                .setContentText(getLocationChangedText())\n                .setColor(mContext.getColor(R.color.system_notification_accent_color))\n                .setShowWhen(true)\n                .setContentIntent(locationSettingsIntent)\n                .setAutoCancel(true)\n                .build();\n        mHandler.post(() -> mInjector.getNotificationManager().notify(\n                SystemMessage.NOTE_LOCATION_CHANGED, notification));\n    }\n\n    private String getLocationChangedTitle() {\n        return getUpdatableString(\n                LOCATION_CHANGED_TITLE, R.string.location_changed_notification_title);\n    }\n\n    private String getLocationChangedText() {\n        return getUpdatableString(\n                LOCATION_CHANGED_MESSAGE, R.string.location_changed_notification_text);\n    }\n\n    @Override\n    public boolean setTime(@Nullable ComponentName who, String callerPackageName, long millis) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            // This is a global action.\n            enforcePermission(SET_TIME, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        // Don't allow set time when auto time is on.\n        if (mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) == 1) {\n            return false;\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_TIME)\n                .setAdmin(caller.getPackageName())\n                .write();\n        mInjector.binderWithCleanCallingIdentity(() -> mInjector.getAlarmManager().setTime(millis));\n        return true;\n    }\n\n    @Override\n    public boolean setTimeZone(@Nullable ComponentName who, String callerPackageName,\n            String timeZone) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            // This is a global action.\n            enforcePermission(SET_TIME_ZONE, caller.getPackageName(), UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n\n        // Don't allow set timezone when auto timezone is on.\n        if (mInjector.settingsGlobalGetInt(Global.AUTO_TIME_ZONE, 0) == 1) {\n            return false;\n        }\n        String logInfo = \"DevicePolicyManager.setTimeZone()\";\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getAlarmManagerInternal()\n                        .setTimeZone(timeZone, TIME_ZONE_CONFIDENCE_HIGH, logInfo));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_TIME_ZONE)\n                .setAdmin(caller.getPackageName())\n                .write();\n        return true;\n    }\n\n    @Override\n    public void setSecureSetting(ComponentName who, String setting, String value) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (isDeviceOwner(who, callingUserId)) {\n                if (!SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.contains(setting)\n                        && !isCurrentUserDemo()) {\n                    throw new SecurityException(String.format(\n                            \"Permission denial: Device owners cannot update %1$s\", setting));\n                }\n            } else if (!SECURE_SETTINGS_ALLOWLIST.contains(setting) && !isCurrentUserDemo()) {\n                throw new SecurityException(String.format(\n                        \"Permission denial: Profile owners cannot update %1$s\", setting));\n            }\n            if (setting.equals(Settings.Secure.LOCATION_MODE)\n                    && isSetSecureSettingLocationModeCheckEnabled(who.getPackageName(),\n                    callingUserId)) {\n                throw new UnsupportedOperationException(Settings.Secure.LOCATION_MODE + \" is \"\n                        + \"deprecated. Please use setLocationEnabled() instead.\");\n            }\n            if (setting.equals(Settings.Secure.INSTALL_NON_MARKET_APPS)) {\n                if (getTargetSdk(who.getPackageName(), callingUserId) >= Build.VERSION_CODES.O) {\n                    throw new UnsupportedOperationException(Settings.Secure.INSTALL_NON_MARKET_APPS\n                            + \" is deprecated. Please use one of the user restrictions \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES + \" or \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY + \" instead.\");\n                }\n                if (!mUserManager.isManagedProfile(callingUserId)) {\n                    Slogf.e(LOG_TAG, \"Ignoring setSecureSetting request for \"\n                            + setting + \". User restriction \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES + \" or \"\n                            + UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY\n                            + \" should be used instead.\");\n                } else {\n                    try {\n                        setUserRestriction(who, who.getPackageName(),\n                                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,\n                                (Integer.parseInt(value) == 0) ? true : false, /* parent */ false);\n                        DevicePolicyEventLogger\n                                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                                .setAdmin(who)\n                                .setStrings(setting, value)\n                                .write();\n                    } catch (NumberFormatException exc) {\n                        Slogf.e(LOG_TAG, \"Invalid value: \" + value + \" for setting \" + setting);\n                    }\n                }\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (Settings.Secure.DEFAULT_INPUT_METHOD.equals(setting)) {\n                    final String currentValue = mInjector.settingsSecureGetStringForUser(\n                            Settings.Secure.DEFAULT_INPUT_METHOD, callingUserId);\n                    if (!TextUtils.equals(currentValue, value)) {\n                        // Tell the content observer that the next change will be due to the owner\n                        // changing the value. There is a small race condition here that we cannot\n                        // avoid: Change notifications are sent asynchronously, so it is possible\n                        // that there are prior notifications queued up before the one we are about\n                        // to trigger. This is a corner case that will have no impact in practice.\n                        mSetupContentObserver.addPendingChangeByOwnerLocked(callingUserId);\n                    }\n                    getUserData(callingUserId).mCurrentInputMethodSet = true;\n                    saveSettingsLocked(callingUserId);\n                }\n                mInjector.settingsSecurePutStringForUser(setting, value, callingUserId);\n                // Notify the user if it's the location mode setting that's been set, to any value\n                // other than 'off'.\n                if (setting.equals(Settings.Secure.LOCATION_MODE)\n                        && (Integer.parseInt(value) != 0)) {\n                    showLocationSettingsEnabledNotification(UserHandle.of(callingUserId));\n                }\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURE_SETTING)\n                .setAdmin(who)\n                .setStrings(setting, value)\n                .write();\n    }\n\n    private boolean isSetSecureSettingLocationModeCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(USE_SET_LOCATION_ENABLED, packageName, userId);\n    }\n\n    @Override\n    public void setMasterVolumeMuted(ComponentName who, boolean on) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_MASTER_VOLUME_MUTED);\n\n        synchronized (getLockObject()) {\n            setUserRestriction(who, who.getPackageName(), UserManager.DISALLOW_UNMUTE_DEVICE, on,\n                    /* parent */ false);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_MASTER_VOLUME_MUTED)\n                    .setAdmin(who)\n                    .setBoolean(on)\n                    .write();\n        }\n    }\n\n    @Override\n    public boolean isMasterVolumeMuted(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            AudioManager audioManager =\n                    (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);\n            return audioManager.isMasterMute();\n        }\n    }\n\n    @Override\n    public void setUserIcon(ComponentName who, Bitmap icon) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            mInjector.binderWithCleanCallingIdentity(\n                    () -> mUserManagerInternal.setUserIcon(caller.getUserId(), icon));\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USER_ICON)\n                .setAdmin(who)\n                .write();\n    }\n\n    @Override\n    public boolean setKeyguardDisabled(ComponentName who, boolean disabled) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                    String.format(\n                            \"Admin %s is neither the device owner or affiliated user's profile \"\n                                    + \"owner.\", who));\n        }\n        if (isManagedProfile(userId)) {\n            throw new SecurityException(\"Managed profile cannot disable keyguard\");\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_KEYGUARD_DISABLED);\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            // disallow disabling the keyguard if a password is currently set\n            if (disabled && mLockPatternUtils.isSecure(userId)) {\n                return false;\n            }\n            mLockPatternUtils.setLockScreenDisabled(disabled, userId);\n            if (disabled) {\n                mInjector\n                        .getIWindowManager()\n                        .dismissKeyguard(null /* callback */, null /* message */);\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED)\n                    .setAdmin(who)\n                    .setBoolean(disabled)\n                    .write();\n        } catch (RemoteException e) {\n            // Same process, does not happen.\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean setStatusBarDisabled(ComponentName who, String callerPackageName,\n            boolean disabled) {\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        if (isUnicornFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_STATUS_BAR, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUnicornFlagEnabled()) {\n                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                        \"Admin \" + who + \" is neither the device owner or affiliated \"\n                                + \"user's profile owner.\");\n                if (isManagedProfile(userId)) {\n                    throw new SecurityException(\"Managed profile cannot disable status bar\");\n                }\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_STATUS_BAR_DISABLED);\n\n            DevicePolicyData policy = getUserData(userId);\n            if (policy.mStatusBarDisabled != disabled) {\n                boolean isLockTaskMode = false;\n                try {\n                    isLockTaskMode = mInjector.getIActivityTaskManager().getLockTaskModeState()\n                            != LOCK_TASK_MODE_NONE;\n                } catch (RemoteException e) {\n                    Slogf.e(LOG_TAG, \"Failed to get LockTask mode\");\n                }\n                if (!isLockTaskMode) {\n                    if (!setStatusBarDisabledInternal(disabled, userId)) {\n                        return false;\n                    }\n                }\n                policy.mStatusBarDisabled = disabled;\n                saveSettingsLocked(userId);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_STATUS_BAR_DISABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(disabled)\n                .write();\n        return true;\n    }\n\n    private boolean setStatusBarDisabledInternal(boolean disabled, int userId) {\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            IStatusBarService statusBarService = IStatusBarService.Stub.asInterface(\n                    ServiceManager.checkService(Context.STATUS_BAR_SERVICE));\n            if (statusBarService != null) {\n                int flags1 = disabled ? STATUS_BAR_DISABLE_MASK : StatusBarManager.DISABLE_NONE;\n                int flags2 = disabled ? STATUS_BAR_DISABLE2_MASK : StatusBarManager.DISABLE2_NONE;\n                statusBarService.disableForUser(flags1, mToken, mContext.getPackageName(), userId);\n                statusBarService.disable2ForUser(flags2, mToken, mContext.getPackageName(), userId);\n                return true;\n            }\n        } catch (RemoteException e) {\n            Slogf.e(LOG_TAG, \"Failed to disable the status bar\", e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isStatusBarDisabled(String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        if (isUnicornFlagEnabled()) {\n            enforceCanQuery(\n                    MANAGE_DEVICE_POLICY_STATUS_BAR, caller.getPackageName(), caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        }\n\n        int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            if (!isUnicornFlagEnabled()) {\n                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId),\n                        \"Admin \" + callerPackage\n                                + \" is neither the device owner or affiliated user's profile owner.\");\n                if (isManagedProfile(userId)) {\n                    throw new SecurityException(\"Managed profile cannot disable status bar\");\n                }\n            }\n            DevicePolicyData policy = getUserData(userId);\n            return policy.mStatusBarDisabled;\n        }\n    }\n\n    private Set<String> getPackagesSuspendedByAdmin(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (admin == null || admin.suspendedPackages == null) {\n                return Collections.emptySet();\n            } else {\n                return new ArraySet<>(admin.suspendedPackages);\n            }\n        }\n    }\n\n    /**\n     * We need to update the internal state of whether a user has completed setup or a\n     * device has paired once. After that, we ignore any changes that reset the\n     * Settings.Secure.USER_SETUP_COMPLETE or Settings.Secure.DEVICE_PAIRED change\n     * as we don't trust any apps that might try to reset them.\n     * <p>\n     * Unfortunately, we don't know which user's setup state was changed, so we write all of\n     * them.\n     */\n    void updateUserSetupCompleteAndPaired() {\n        List<UserInfo> users = mUserManager.getAliveUsers();\n        final int N = users.size();\n        for (int i = 0; i < N; i++) {\n            int userHandle = users.get(i).id;\n            if (mInjector.settingsSecureGetIntForUser(Settings.Secure.USER_SETUP_COMPLETE, 0,\n                    userHandle) != 0) {\n                DevicePolicyData policy = getUserData(userHandle);\n                if (!policy.mUserSetupComplete) {\n                    policy.mUserSetupComplete = true;\n                    if (userHandle == UserHandle.USER_SYSTEM) {\n                        mStateCache.setDeviceProvisioned(true);\n                    }\n                    synchronized (getLockObject()) {\n                        saveSettingsLocked(userHandle);\n                    }\n                }\n            }\n            if (mIsWatch && mInjector.settingsSecureGetIntForUser(Settings.Secure.DEVICE_PAIRED, 0,\n                    userHandle) != 0) {\n                DevicePolicyData policy = getUserData(userHandle);\n                if (!policy.mPaired) {\n                    policy.mPaired = true;\n                    synchronized (getLockObject()) {\n                        saveSettingsLocked(userHandle);\n                    }\n                }\n            }\n        }\n    }\n\n    private class SetupContentObserver extends ContentObserver {\n        private final Uri mUserSetupComplete = Settings.Secure.getUriFor(\n                Settings.Secure.USER_SETUP_COMPLETE);\n        private final Uri mDeviceProvisioned = Settings.Global.getUriFor(\n                Settings.Global.DEVICE_PROVISIONED);\n        private final Uri mPaired = Settings.Secure.getUriFor(Settings.Secure.DEVICE_PAIRED);\n        private final Uri mDefaultImeChanged = Settings.Secure.getUriFor(\n                Settings.Secure.DEFAULT_INPUT_METHOD);\n\n        @GuardedBy(\"getLockObject()\")\n        private Set<Integer> mUserIdsWithPendingChangesByOwner = new ArraySet<>();\n\n        public SetupContentObserver(Handler handler) {\n            super(handler);\n        }\n\n        void register() {\n            mInjector.registerContentObserver(mUserSetupComplete, false, this, UserHandle.USER_ALL);\n            mInjector.registerContentObserver(mDeviceProvisioned, false, this, UserHandle.USER_ALL);\n            if (mIsWatch) {\n                mInjector.registerContentObserver(mPaired, false, this, UserHandle.USER_ALL);\n            }\n            mInjector.registerContentObserver(mDefaultImeChanged, false, this, UserHandle.USER_ALL);\n        }\n\n        @GuardedBy(\"getLockObject()\")\n        private void addPendingChangeByOwnerLocked(int userId) {\n            mUserIdsWithPendingChangesByOwner.add(userId);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri, int userId) {\n            if (mUserSetupComplete.equals(uri) || (mIsWatch && mPaired.equals(uri))) {\n                updateUserSetupCompleteAndPaired();\n            } else if (mDeviceProvisioned.equals(uri)) {\n                synchronized (getLockObject()) {\n                    // Set PROPERTY_DEVICE_OWNER_PRESENT, for the SUW case where setting the property\n                    // is delayed until device is marked as provisioned.\n                    setDeviceOwnershipSystemPropertyLocked();\n                }\n            } else if (mDefaultImeChanged.equals(uri)) {\n                synchronized (getLockObject()) {\n                    if (mUserIdsWithPendingChangesByOwner.contains(userId)) {\n                        // This change notification was triggered by the owner changing the current\n                        // IME. Ignore it.\n                        mUserIdsWithPendingChangesByOwner.remove(userId);\n                    } else {\n                        // This change notification was triggered by the user manually changing the\n                        // current IME.\n                        getUserData(userId).mCurrentInputMethodSet = false;\n                        saveSettingsLocked(userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private class DevicePolicyConstantsObserver extends ContentObserver {\n        final Uri mConstantsUri =\n                Settings.Global.getUriFor(Settings.Global.DEVICE_POLICY_CONSTANTS);\n\n        DevicePolicyConstantsObserver(Handler handler) {\n            super(handler);\n        }\n\n        void register() {\n            mInjector.registerContentObserver(\n                    mConstantsUri, /* notifyForDescendents= */ false, this, UserHandle.USER_ALL);\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri, int userId) {\n            mConstants = loadConstants();\n            invalidateBinderCaches();\n\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final Intent intent = new Intent(\n                        DevicePolicyManager.ACTION_DEVICE_POLICY_CONSTANTS_CHANGED);\n                intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n                final List<UserInfo> users = mUserManager.getAliveUsers();\n                for (int i = 0; i < users.size(); i++) {\n                    mContext.sendBroadcastAsUser(intent, UserHandle.of(users.get(i).id));\n                }\n            });\n        }\n    }\n\n    @VisibleForTesting\n    final class LocalService extends DevicePolicyManagerInternal\n            implements DevicePolicyManagerLiteInternal {\n        private List<OnCrossProfileWidgetProvidersChangeListener> mWidgetProviderListeners;\n\n        @Override\n        public List<String> getCrossProfileWidgetProviders(int profileId) {\n            synchronized (getLockObject()) {\n                if (mOwners == null) {\n                    return Collections.emptyList();\n                }\n                ComponentName ownerComponent = mOwners.getProfileOwnerComponent(profileId);\n                if (ownerComponent == null) {\n                    return Collections.emptyList();\n                }\n\n                DevicePolicyData policy = getUserDataUnchecked(profileId);\n                ActiveAdmin admin = policy.mAdminMap.get(ownerComponent);\n\n                if (admin == null || admin.crossProfileWidgetProviders == null\n                        || admin.crossProfileWidgetProviders.isEmpty()) {\n                    return Collections.emptyList();\n                }\n\n                return admin.crossProfileWidgetProviders;\n            }\n        }\n\n        @Override\n        public void addOnCrossProfileWidgetProvidersChangeListener(\n                OnCrossProfileWidgetProvidersChangeListener listener) {\n            synchronized (getLockObject()) {\n                if (mWidgetProviderListeners == null) {\n                    mWidgetProviderListeners = new ArrayList<>();\n                }\n                if (!mWidgetProviderListeners.contains(listener)) {\n                    mWidgetProviderListeners.add(listener);\n                }\n            }\n        }\n\n        @Override\n        public @Nullable ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(\n                @NonNull UserHandle userHandle) {\n            return DevicePolicyManagerService.this.getProfileOwnerOrDeviceOwnerSupervisionComponent(\n                    userHandle);\n        }\n\n        @Override\n        public boolean isActiveDeviceOwner(int uid) {\n            return isDefaultDeviceOwner(new CallerIdentity(uid, null, null));\n        }\n\n        @Override\n        public boolean isActiveProfileOwner(int uid) {\n            return isProfileOwner(new CallerIdentity(uid, null, null));\n        }\n\n        @Override\n        public boolean isActiveSupervisionApp(int uid) {\n            if (!isProfileOwner(new CallerIdentity(uid, null, null))) {\n                return false;\n            }\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerAdminLocked(UserHandle.getUserId(uid));\n                if (admin == null) {\n                    return false;\n                }\n\n                return isSupervisionComponentLocked(admin.info.getComponent());\n            }\n        }\n\n        private void notifyCrossProfileProvidersChanged(int userId, List<String> packages) {\n            final List<OnCrossProfileWidgetProvidersChangeListener> listeners;\n            synchronized (getLockObject()) {\n                listeners = new ArrayList<>(mWidgetProviderListeners);\n            }\n            final int listenerCount = listeners.size();\n            for (int i = 0; i < listenerCount; i++) {\n                OnCrossProfileWidgetProvidersChangeListener listener = listeners.get(i);\n                listener.onCrossProfileWidgetProvidersChanged(userId, packages);\n            }\n        }\n\n        @Override\n        public Intent createShowAdminSupportIntent(int userId, boolean useDefaultIfNoAdmin) {\n            // This method is called from AM with its lock held, so don't take the DPMS lock.\n            // b/29242568\n\n            if (getEnforcingAdminAndUserDetailsInternal(userId, null) != null\n                    || useDefaultIfNoAdmin) {\n                return DevicePolicyManagerService.this.createShowAdminSupportIntent(userId);\n            }\n            return null;\n        }\n\n        @Override\n        public Intent createUserRestrictionSupportIntent(int userId, String userRestriction) {\n            Intent intent = null;\n            if (getEnforcingAdminAndUserDetailsInternal(userId, userRestriction) != null) {\n                intent = DevicePolicyManagerService.this.createShowAdminSupportIntent(userId);\n                intent.putExtra(DevicePolicyManager.EXTRA_RESTRICTION, userRestriction);\n            }\n            return intent;\n        }\n\n        @Override\n        public boolean isUserAffiliatedWithDevice(int userId) {\n            return DevicePolicyManagerService.this.isUserAffiliatedWithDeviceLocked(userId);\n        }\n\n        @Override\n        public boolean canSilentlyInstallPackage(String callerPackage, int callerUid) {\n            if (callerPackage == null) {\n                return false;\n            }\n\n            CallerIdentity caller = new CallerIdentity(callerUid, null, null);\n            if (isUserAffiliatedWithDevice(UserHandle.getUserId(callerUid))\n                    && (isActiveProfileOwner(callerUid)\n                    || isDefaultDeviceOwner(caller) || isFinancedDeviceOwner(caller))) {\n                // device owner or a profile owner affiliated with the device owner\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void reportSeparateProfileChallengeChanged(@UserIdInt int userId) {\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                synchronized (getLockObject()) {\n                    updateMaximumTimeToLockLocked(userId);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                }\n            });\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SEPARATE_PROFILE_CHALLENGE_CHANGED)\n                    .setBoolean(isSeparateProfileChallengeEnabled(userId))\n                    .write();\n            invalidateBinderCaches();\n        }\n\n        @Override\n        public CharSequence getPrintingDisabledReasonForUser(@UserIdInt int userId) {\n            synchronized (getLockObject()) {\n                if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_PRINTING,\n                        UserHandle.of(userId))) {\n                    Slogf.e(LOG_TAG, \"printing is enabled for user %d\", userId);\n                    return null;\n                }\n                String ownerPackage = mOwners.getProfileOwnerPackage(userId);\n                if (ownerPackage == null) {\n                    ownerPackage = mOwners.getDeviceOwnerPackageName();\n                }\n                final String packageName = ownerPackage;\n                PackageManager pm = mInjector.getPackageManager();\n                PackageInfo packageInfo = mInjector.binderWithCleanCallingIdentity(() -> {\n                    try {\n                        return pm.getPackageInfo(packageName, 0);\n                    } catch (NameNotFoundException e) {\n                        Slogf.e(LOG_TAG, \"getPackageInfo error\", e);\n                        return null;\n                    }\n                });\n                if (packageInfo == null) {\n                    Slogf.e(LOG_TAG, \"packageInfo is inexplicably null\");\n                    return null;\n                }\n                ApplicationInfo appInfo = packageInfo.applicationInfo;\n                if (appInfo == null) {\n                    Slogf.e(LOG_TAG, \"appInfo is inexplicably null\");\n                    return null;\n                }\n                CharSequence appLabel = pm.getApplicationLabel(appInfo);\n                if (appLabel == null) {\n                    Slogf.e(LOG_TAG, \"appLabel is inexplicably null\");\n                    return null;\n                }\n                return getUpdatableString(\n                        PRINTING_DISABLED_NAMED_ADMIN,\n                        R.string.printing_disabled_by,\n                        appLabel);\n            }\n        }\n\n        @Override\n        protected DevicePolicyCache getDevicePolicyCache() {\n            return mPolicyCache;\n        }\n\n        @Override\n        protected DeviceStateCache getDeviceStateCache() {\n            return mStateCache;\n        }\n\n        @Override\n        public List<String> getAllCrossProfilePackages(int userId) {\n            return DevicePolicyManagerService.this.getAllCrossProfilePackages(userId);\n        }\n\n        @Override\n        public List<String> getDefaultCrossProfilePackages() {\n            return DevicePolicyManagerService.this.getDefaultCrossProfilePackages();\n        }\n\n        @Override\n        public void broadcastIntentToManifestReceivers(\n                Intent intent, UserHandle parentHandle, boolean requiresPermission) {\n            Objects.requireNonNull(intent);\n            Objects.requireNonNull(parentHandle);\n            Slogf.i(LOG_TAG, \"Sending %s broadcast to manifest receivers.\", intent.getAction());\n            broadcastIntentToCrossProfileManifestReceivers(\n                    intent, parentHandle, requiresPermission);\n            broadcastExplicitIntentToRoleHolder(\n                    intent, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, parentHandle);\n        }\n\n        @Override\n        public void enforcePermission(String callerPackage, String permission, int targetUserId) {\n            DevicePolicyManagerService.this.enforcePermission(permission, callerPackage,\n                    targetUserId);\n        }\n\n        @Override\n        public boolean hasPermission(String callerPackage, String permission, int targetUserId) {\n            return DevicePolicyManagerService.this.hasPermission(permission, callerPackage,\n                    targetUserId);\n        }\n\n        private void broadcastIntentToCrossProfileManifestReceivers(\n                Intent intent, UserHandle userHandle, boolean requiresPermission) {\n            final int userId = userHandle.getIdentifier();\n            try {\n                final List<ResolveInfo> receivers = mIPackageManager.queryIntentReceivers(\n                        intent, /* resolvedType= */ null,\n                        STOCK_PM_FLAGS, userId).getList();\n                for (ResolveInfo receiver : receivers) {\n                    final String packageName = receiver.getComponentInfo().packageName;\n                    if (checkCrossProfilePackagePermissions(packageName, userId,\n                            requiresPermission)\n                            || checkModifyQuietModePermission(packageName, userId)) {\n                        Slogf.i(LOG_TAG, \"Sending %s broadcast to %s.\", intent.getAction(),\n                                packageName);\n                        final Intent packageIntent = new Intent(intent)\n                                .setComponent(receiver.getComponentInfo().getComponentName())\n                                .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n                        mContext.sendBroadcastAsUser(packageIntent, userHandle);\n                    }\n                }\n            } catch (RemoteException ex) {\n                Slogf.w(LOG_TAG, \"Cannot get list of broadcast receivers for %s because: %s.\",\n                        intent.getAction(), ex);\n            }\n        }\n\n        /**\n         * Checks whether the package {@code packageName} has the {@code MODIFY_QUIET_MODE}\n         * permission granted for the user {@code userId}.\n         */\n        private boolean checkModifyQuietModePermission(String packageName, @UserIdInt int userId) {\n            try {\n                final int uid = Objects.requireNonNull(\n                        mInjector.getPackageManager().getApplicationInfoAsUser(\n                                Objects.requireNonNull(packageName), /* flags= */ 0, userId)).uid;\n                return PackageManager.PERMISSION_GRANTED\n                        == ActivityManager.checkComponentPermission(\n                        android.Manifest.permission.MODIFY_QUIET_MODE, uid, /* owningUid= */\n                        -1, /* exported= */ true);\n            } catch (NameNotFoundException ex) {\n                Slogf.w(LOG_TAG, \"Cannot find the package %s to check for permissions.\",\n                        packageName);\n                return false;\n            }\n        }\n\n        /**\n         * Checks whether the package {@code packageName} has the required permissions to receive\n         * cross-profile broadcasts on behalf of the user {@code userId}.\n         */\n        private boolean checkCrossProfilePackagePermissions(String packageName,\n                @UserIdInt int userId, boolean requiresPermission) {\n            final PackageManagerInternal pmInternal = LocalServices.getService(\n                    PackageManagerInternal.class);\n            final AndroidPackage androidPackage = pmInternal.getPackage(packageName);\n            if (androidPackage == null || !androidPackage.isCrossProfile()) {\n                return false;\n            }\n            if (!requiresPermission) {\n                return true;\n            }\n            if (!isPackageEnabled(packageName, userId)) {\n                return false;\n            }\n            try {\n                final CrossProfileAppsInternal crossProfileAppsService = LocalServices.getService(\n                        CrossProfileAppsInternal.class);\n                return crossProfileAppsService.verifyPackageHasInteractAcrossProfilePermission(\n                        packageName, userId);\n            } catch (NameNotFoundException ex) {\n                Slogf.w(LOG_TAG, \"Cannot find the package %s to check for permissions.\",\n                        packageName);\n                return false;\n            }\n        }\n\n        private boolean isPackageEnabled(String packageName, @UserIdInt int userId) {\n            final int callingUid = Binder.getCallingUid();\n            final long ident = Binder.clearCallingIdentity();\n            try {\n                final PackageInfo info = mInjector.getPackageManagerInternal()\n                        .getPackageInfo(\n                                packageName,\n                                MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE,\n                                callingUid,\n                                userId);\n                return info != null && info.applicationInfo.enabled;\n            } finally {\n                Binder.restoreCallingIdentity(ident);\n            }\n        }\n\n        @Override\n        public ComponentName getProfileOwnerAsUser(@UserIdInt int userId) {\n            return DevicePolicyManagerService.this.getProfileOwnerAsUser(userId);\n        }\n\n        @Override\n        public int getDeviceOwnerUserId() {\n            return DevicePolicyManagerService.this.getDeviceOwnerUserId();\n        }\n\n        @Override\n        public boolean isDeviceOrProfileOwnerInCallingUser(String packageName) {\n            return isDeviceOwnerInCallingUser(packageName)\n                    || isProfileOwnerInCallingUser(packageName);\n        }\n\n        private boolean isDeviceOwnerInCallingUser(String packageName) {\n            final ComponentName deviceOwnerInCallingUser =\n                    DevicePolicyManagerService.this.getDeviceOwnerComponent(\n                            /* callingUserOnly= */ true);\n            return deviceOwnerInCallingUser != null\n                    && packageName.equals(deviceOwnerInCallingUser.getPackageName());\n        }\n\n        private boolean isProfileOwnerInCallingUser(String packageName) {\n            final ComponentName profileOwnerInCallingUser =\n                    getProfileOwnerAsUser(UserHandle.getCallingUserId());\n            return profileOwnerInCallingUser != null\n                    && packageName.equals(profileOwnerInCallingUser.getPackageName());\n        }\n\n        @Override\n        public boolean supportsResetOp(int op) {\n            return op == AppOpsManager.OP_INTERACT_ACROSS_PROFILES\n                    && LocalServices.getService(CrossProfileAppsInternal.class) != null;\n        }\n\n        @Override\n        public void resetOp(int op, String packageName, @UserIdInt int userId) {\n            if (op != AppOpsManager.OP_INTERACT_ACROSS_PROFILES) {\n                throw new IllegalArgumentException(\"Unsupported op for DPM reset: \" + op);\n            }\n            LocalServices.getService(CrossProfileAppsInternal.class)\n                    .setInteractAcrossProfilesAppOp(\n                            packageName, findInteractAcrossProfilesResetMode(packageName), userId);\n        }\n\n        @Override\n        public Set<String> getPackagesSuspendedByAdmin(@UserIdInt int userId) {\n            return DevicePolicyManagerService.this.getPackagesSuspendedByAdmin(userId);\n        }\n\n        @Override\n        public void notifyUnsafeOperationStateChanged(DevicePolicySafetyChecker checker, int reason,\n                boolean isSafe) {\n            // TODO(b/178494483): use EventLog instead\n            // TODO(b/178494483): log metrics?\n            if (VERBOSE_LOG) {\n                Slogf.v(LOG_TAG, \"notifyUnsafeOperationStateChanged(): %s=%b\",\n                        DevicePolicyManager.operationSafetyReasonToString(reason), isSafe);\n            }\n            Preconditions.checkArgument(mSafetyChecker == checker,\n                    \"invalid checker: should be %s, was %s\", mSafetyChecker, checker);\n\n            Bundle extras = new Bundle();\n            extras.putInt(DeviceAdminReceiver.EXTRA_OPERATION_SAFETY_REASON, reason);\n            extras.putBoolean(DeviceAdminReceiver.EXTRA_OPERATION_SAFETY_STATE, isSafe);\n\n            if (mOwners.hasDeviceOwner()) {\n                if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Notifying DO\");\n                sendDeviceOwnerCommand(DeviceAdminReceiver.ACTION_OPERATION_SAFETY_STATE_CHANGED,\n                        extras);\n            }\n            for (int profileOwnerId : mOwners.getProfileOwnerKeys()) {\n                if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Notifying PO for user \" + profileOwnerId);\n                sendProfileOwnerCommand(DeviceAdminReceiver.ACTION_OPERATION_SAFETY_STATE_CHANGED,\n                        extras, profileOwnerId);\n            }\n        }\n\n        @Override\n        public boolean isKeepProfilesRunningEnabled() {\n            return getUserDataUnchecked(UserHandle.USER_SYSTEM).mEffectiveKeepProfilesRunning;\n        }\n\n        private @Mode int findInteractAcrossProfilesResetMode(String packageName) {\n            return getDefaultCrossProfilePackages().contains(packageName)\n                    ? AppOpsManager.MODE_ALLOWED\n                    : AppOpsManager.opToDefaultMode(AppOpsManager.OP_INTERACT_ACROSS_PROFILES);\n        }\n\n        @Override\n        public boolean isUserOrganizationManaged(@UserIdInt int userHandle) {\n            return getDeviceStateCache().isUserOrganizationManaged(userHandle);\n        }\n\n        @Override\n        public boolean isApplicationExemptionsFlagEnabled() {\n            return DeviceConfig.getBoolean(\n                    NAMESPACE_DEVICE_POLICY_MANAGER,\n                    APPLICATION_EXEMPTIONS_FLAG,\n                    DEFAULT_APPLICATION_EXEMPTIONS_FLAG);\n        }\n\n        @Override\n        public List<Bundle> getApplicationRestrictionsPerAdminForUser(\n                String packageName, @UserIdInt int userId) {\n            if (UserHandle.getCallingUserId() != userId\n                    || !UserHandle.isSameApp(\n                    Binder.getCallingUid(), getUidForPackage(packageName, userId))) {\n                final int uid = Binder.getCallingUid();\n                if (!UserHandle.isSameApp(uid, Process.SYSTEM_UID) && uid != Process.ROOT_UID) {\n                    throw new SecurityException(\"Only system may: get application restrictions for \"\n                            + \"other user/app \" + packageName);\n                }\n            }\n            LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(\n                            PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),\n                            userId);\n            List<Bundle> restrictions = new ArrayList<>();\n            for (EnforcingAdmin admin : policies.keySet()) {\n                restrictions.add(policies.get(admin).getValue());\n            }\n            if (!restrictions.isEmpty()) {\n                return restrictions;\n            }\n\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                // Could be a device that has a DPC that hasn't migrated yet, so just return any\n                // restrictions saved in userManager.\n                Bundle bundle = mUserManager.getApplicationRestrictions(\n                        packageName, UserHandle.of(userId));\n                if (bundle == null || bundle.isEmpty()) {\n                    return new ArrayList<>();\n                }\n                return List.of(bundle);\n            });\n        }\n\n        public List<EnforcingUser> getUserRestrictionSources(String restriction,\n                @UserIdInt int userId) {\n            PolicyDefinition<Boolean> policy =\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction);\n\n            Set<EnforcingAdmin> localAdmins =\n                    mDevicePolicyEngine.getLocalPoliciesSetByAdmins(policy, userId).keySet();\n\n            Set<EnforcingAdmin> globalAdmins =\n                    mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policy).keySet();\n\n            List<EnforcingUser> enforcingUsers = new ArrayList();\n            enforcingUsers.addAll(getEnforcingUsers(localAdmins));\n            enforcingUsers.addAll(getEnforcingUsers(globalAdmins));\n            return enforcingUsers;\n        }\n\n        private List<EnforcingUser> getEnforcingUsers(Set<EnforcingAdmin> admins) {\n            List<EnforcingUser> enforcingUsers = new ArrayList();\n            ComponentName deviceOwner = mOwners.getDeviceOwnerComponent();\n            for (EnforcingAdmin admin : admins) {\n                if (deviceOwner != null\n                        && deviceOwner.getPackageName().equals(admin.getPackageName())) {\n                    enforcingUsers.add(new EnforcingUser(admin.getUserId(),\n                            UserManager.RESTRICTION_SOURCE_DEVICE_OWNER));\n                } else {\n                    enforcingUsers.add(new EnforcingUser(admin.getUserId(),\n                            UserManager.RESTRICTION_SOURCE_PROFILE_OWNER));\n                }\n            }\n            return enforcingUsers;\n        }\n    }\n\n    private Intent createShowAdminSupportIntent(int userId) {\n        // This method is called with AMS lock held, so don't take DPMS lock\n        final Intent intent = new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS);\n        intent.putExtra(Intent.EXTRA_USER_ID, userId);\n        intent.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        return intent;\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA},\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE} and  {@link\n     *                    DevicePolicyManager#POLICY_SUSPEND_PACKAGES}.\n     */\n    private Bundle getEnforcingAdminAndUserDetailsInternal(int userId, String restriction) {\n        Bundle result = null;\n\n        // For POLICY_SUSPEND_PACKAGES return PO or DO to keep the behavior same as\n        // before the bug fix for b/192245204.\n        if (restriction == null || DevicePolicyManager.POLICY_SUSPEND_PACKAGES.equals(\n                restriction)) {\n            ComponentName profileOwner = mOwners.getProfileOwnerComponent(userId);\n            if (profileOwner != null) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                        profileOwner);\n                return result;\n            }\n            final Pair<Integer, ComponentName> deviceOwner =\n                    mOwners.getDeviceOwnerUserIdAndComponent();\n            if (deviceOwner != null && deviceOwner.first == userId) {\n                result = new Bundle();\n                result.putInt(Intent.EXTRA_USER_ID, userId);\n                result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                        deviceOwner.second);\n                return result;\n            }\n        } else if (DevicePolicyManager.POLICY_DISABLE_SCREEN_CAPTURE.equals(restriction)) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                Boolean value = mDevicePolicyEngine.getResolvedPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED, userId);\n                if (value != null && value) {\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n            } else {\n                synchronized (getLockObject()) {\n                    final DevicePolicyData policy = getUserData(userId);\n                    final int N = policy.mAdminList.size();\n                    for (int i = 0; i < N; i++) {\n                        final ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.disableScreenCapture) {\n                            result = new Bundle();\n                            result.putInt(Intent.EXTRA_USER_ID, userId);\n                            result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                    admin.info.getComponent());\n                            return result;\n                        }\n                    }\n                }\n            }\n        } else if (DevicePolicyManager.POLICY_DISABLE_CAMERA.equals(restriction)) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                PolicyDefinition<Boolean> policyDefinition =\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                                UserManager.DISALLOW_CAMERA);\n                Boolean value = mDevicePolicyEngine.getResolvedPolicy(policyDefinition, userId);\n                if (value != null && value) {\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n            } else {\n                synchronized (getLockObject()) {\n                    final DevicePolicyData policy = getUserData(userId);\n                    final int N = policy.mAdminList.size();\n                    for (int i = 0; i < N; i++) {\n                        final ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.disableCamera) {\n                            result = new Bundle();\n                            result.putInt(Intent.EXTRA_USER_ID, userId);\n                            result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                    admin.info.getComponent());\n                            return result;\n                        }\n                    }\n                    // For the camera, a device owner on a different user can disable it globally,\n                    // so we need an additional check.\n                    if (result == null\n                            && DevicePolicyManager.POLICY_DISABLE_CAMERA.equals(restriction)) {\n                        final ActiveAdmin admin = getDeviceOwnerAdminLocked();\n                        if (admin != null && admin.disableCamera) {\n                            result = new Bundle();\n                            result.putInt(Intent.EXTRA_USER_ID, mOwners.getDeviceOwnerUserId());\n                            result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                    admin.info.getComponent());\n                            return result;\n                        }\n                    }\n                }\n            }\n        } else {\n            long ident = mInjector.binderClearCallingIdentity();\n            try {\n                // TODO(b/277908283): check in the policy engine instead of calling user manager.\n                List<UserManager.EnforcingUser> sources = mUserManager\n                        .getUserRestrictionSources(restriction, UserHandle.of(userId));\n                if (sources == null) {\n                    // The restriction is not enforced.\n                    return null;\n                }\n                int sizeBefore = sources.size();\n                if (sizeBefore > 1) {\n                    Slogf.d(LOG_TAG, \"getEnforcingAdminAndUserDetailsInternal(%d, %s): \"\n                            + \"%d sources found, excluding those set by UserManager\",\n                            userId, restriction, sizeBefore);\n                    sources = getDevicePolicySources(sources);\n                }\n                if (sources.isEmpty()) {\n                    // The restriction is not enforced (or is just enforced by the system)\n                    return null;\n                }\n\n                if (sources.size() > 1) {\n                    // In this case, we'll show an admin support dialog that does not\n                    // specify the admin.\n                    // TODO(b/128928355): if this restriction is enforced by multiple DPCs, return\n                    // the admin for the calling user.\n                    Slogf.w(LOG_TAG, \"getEnforcingAdminAndUserDetailsInternal(%d, %s): multiple \"\n                            + \"sources for restriction %s on user %d\",\n                            userId, restriction, restriction, userId);\n                    result = new Bundle();\n                    result.putInt(Intent.EXTRA_USER_ID, userId);\n                    return result;\n                }\n                final UserManager.EnforcingUser enforcingUser = sources.get(0);\n                final int sourceType = enforcingUser.getUserRestrictionSource();\n                if (sourceType == UserManager.RESTRICTION_SOURCE_PROFILE_OWNER\n                        || sourceType == UserManager.RESTRICTION_SOURCE_DEVICE_OWNER) {\n                    ActiveAdmin admin = getMostProbableDPCAdminForLocalPolicy(userId);\n                    if (admin != null) {\n                        result = new Bundle();\n                        result.putInt(Intent.EXTRA_USER_ID, admin.getUserHandle().getIdentifier());\n                        result.putParcelable(DevicePolicyManager.EXTRA_DEVICE_ADMIN,\n                                admin.info.getComponent());\n                        return result;\n                    }\n                } else if (sourceType == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                    /*\n                     * In this case, the user restriction is enforced by the system.\n                     * So we won't show an admin support intent, even if it is also\n                     * enforced by a profile/device owner.\n                     */\n                    return null;\n                }\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        return null;\n    }\n\n    /**\n     *  Excludes restrictions imposed by UserManager.\n     */\n    private List<UserManager.EnforcingUser> getDevicePolicySources(\n            List<UserManager.EnforcingUser> sources) {\n        int sizeBefore = sources.size();\n        List<UserManager.EnforcingUser> realSources = new ArrayList<>(sizeBefore);\n        for (int i = 0; i < sizeBefore; i++) {\n            UserManager.EnforcingUser source = sources.get(i);\n            int type = source.getUserRestrictionSource();\n            if (type != UserManager.RESTRICTION_SOURCE_PROFILE_OWNER\n                    && type != UserManager.RESTRICTION_SOURCE_DEVICE_OWNER) {\n                // TODO(b/128928355): add unit test\n                Slogf.d(LOG_TAG, \"excluding source of type %s at index %d\",\n                        userRestrictionSourceToString(type), i);\n                continue;\n            }\n            realSources.add(source);\n        }\n        return realSources;\n    }\n\n    private static String userRestrictionSourceToString(@UserRestrictionSource int source) {\n        return DebugUtils.flagsToString(UserManager.class, \"RESTRICTION_\", source);\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     * @return Details of admin and user which enforced the restriction for the userId.\n     */\n    @Override\n    public Bundle getEnforcingAdminAndUserDetails(int userId, String restriction) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()));\n        return getEnforcingAdminAndUserDetailsInternal(userId, restriction);\n    }\n\n    /**\n     * @param restriction The restriction enforced by admin. It could be any user restriction or\n     *                    policy like {@link DevicePolicyManager#POLICY_DISABLE_CAMERA} and\n     *                    {@link DevicePolicyManager#POLICY_DISABLE_SCREEN_CAPTURE}.\n     */\n    @Override\n    public Intent createAdminSupportIntent(String restriction) {\n        Objects.requireNonNull(restriction);\n        final CallerIdentity caller = getCallerIdentity();\n        final int userId = caller.getUserId();\n        Intent intent = null;\n        if (getEnforcingAdminAndUserDetailsInternal(userId, restriction) != null) {\n            intent = createShowAdminSupportIntent(userId);\n            intent.putExtra(DevicePolicyManager.EXTRA_RESTRICTION, restriction);\n        }\n        return intent;\n    }\n\n    /**\n     * Returns true if specified admin is allowed to limit passwords and has a\n     * {@code mPasswordPolicy.quality} of at least {@code minPasswordQuality}\n     */\n    private static boolean isLimitPasswordAllowed(ActiveAdmin admin, int minPasswordQuality) {\n        if (admin.mPasswordPolicy.quality < minPasswordQuality) {\n            return false;\n        }\n        return admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    @Override\n    public void setCredentialManagerPolicy(PackagePolicy policy) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canWriteCredentialManagerPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            if (Objects.equals(admin.mCredentialManagerPolicy, policy)) {\n                return;\n            }\n\n            admin.mCredentialManagerPolicy = policy;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    private boolean canWriteCredentialManagerPolicy(CallerIdentity caller) {\n        return (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))\n                        || isDefaultDeviceOwner(caller)\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS);\n    }\n\n    @Override\n    public PackagePolicy getCredentialManagerPolicy(int userId) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                canWriteCredentialManagerPolicy(caller) || canQueryAdminPolicy(caller));\n        if (userId != caller.getUserId()) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS));\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userId);\n            return (admin != null) ? admin.mCredentialManagerPolicy : null;\n        }\n    }\n\n    @Override\n    public void setSystemUpdatePolicy(\n            ComponentName who, String callerPackageName, SystemUpdatePolicy policy) {\n        if (policy != null) {\n            // throws exception if policy type is invalid\n            policy.validateType();\n            // throws exception if freeze period is invalid\n            policy.validateFreezePeriods();\n            Pair<LocalDate, LocalDate> record = mOwners.getSystemUpdateFreezePeriodRecord();\n            // throws exception if freeze period is incompatible with previous freeze period record\n            policy.validateAgainstPreviousFreezePeriod(record.first, record.second,\n                    LocalDate.now());\n        }\n        CallerIdentity caller;\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                caller = getCallerIdentity(who, callerPackageName);\n                enforcePermission(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, caller.getPackageName(),\n                        UserHandle.USER_ALL);\n            } else {\n                caller = getCallerIdentity(who);\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        || isDefaultDeviceOwner(caller));\n            }\n\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_SYSTEM_UPDATE_POLICY);\n\n            if (policy == null) {\n                mOwners.clearSystemUpdatePolicy();\n            } else {\n                mOwners.setSystemUpdatePolicy(policy);\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ false);\n            }\n            mOwners.writeDeviceOwner();\n        }\n        mInjector.binderWithCleanCallingIdentity(() -> mContext.sendBroadcastAsUser(\n                new Intent(ACTION_SYSTEM_UPDATE_POLICY_CHANGED), UserHandle.SYSTEM));\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SYSTEM_UPDATE_POLICY)\n                .setAdmin(caller.getPackageName())\n                .setInt(policy != null ? policy.getPolicyType() : 0)\n                .write();\n    }\n\n    @Override\n    public SystemUpdatePolicy getSystemUpdatePolicy() {\n        synchronized (getLockObject()) {\n            SystemUpdatePolicy policy =  mOwners.getSystemUpdatePolicy();\n            if (policy != null && !policy.isValid()) {\n                Slogf.w(LOG_TAG, \"Stored system update policy is invalid, return null instead.\");\n                return null;\n            }\n            return policy;\n        }\n    }\n\n    private static boolean withinRange(Pair<LocalDate, LocalDate> range, LocalDate date) {\n        return (!date.isBefore(range.first) && !date.isAfter(range.second));\n    }\n\n    /**\n     * keeps track of the last continuous period when the system is under OTA freeze.\n     *\n     * DPMS keeps track of the previous dates during which OTA was freezed as a result of an\n     * system update policy with freeze periods in effect. This is needed to make robust\n     * validation on new system update polices, for example to prevent the OTA from being\n     * frozen for more than 90 days if the DPC keeps resetting a new 24-hour freeze period\n     * on midnight everyday, or having freeze periods closer than 60 days apart by DPC resetting\n     * a new freeze period after a few days.\n     *\n     * @param saveIfChanged whether to persist the result on disk if freeze period record is\n     *            updated. This should only be set to {@code false} if there is a guaranteed\n     *            mOwners.writeDeviceOwner() later in the control flow to reduce the number of\n     *            disk writes. Otherwise you risk inconsistent on-disk state.\n     *\n     * @see SystemUpdatePolicy#validateAgainstPreviousFreezePeriod\n     */\n    private void updateSystemUpdateFreezePeriodsRecord(boolean saveIfChanged) {\n        Slogf.d(LOG_TAG, \"updateSystemUpdateFreezePeriodsRecord\");\n        synchronized (getLockObject()) {\n            final SystemUpdatePolicy policy = mOwners.getSystemUpdatePolicy();\n            if (policy == null) {\n                return;\n            }\n            final LocalDate now = LocalDate.now();\n            final Pair<LocalDate, LocalDate> currentPeriod = policy.getCurrentFreezePeriod(now);\n            if (currentPeriod == null) {\n                return;\n            }\n            final Pair<LocalDate, LocalDate> record = mOwners.getSystemUpdateFreezePeriodRecord();\n            final LocalDate start = record.first;\n            final LocalDate end = record.second;\n            final boolean changed;\n            if (end == null || start == null) {\n                // Start a new period if there is none at the moment\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n            } else if (now.equals(end.plusDays(1))) {\n                // Extend the existing period\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(start, now);\n            } else if (now.isAfter(end.plusDays(1))) {\n                if (withinRange(currentPeriod, start) && withinRange(currentPeriod, end)) {\n                    // The device might be off for some period. If the past freeze record\n                    // is within range of the current freeze period, assume the device was off\n                    // during the period [end, now] and extend the freeze record to [start, now].\n                    changed = mOwners.setSystemUpdateFreezePeriodRecord(start, now);\n                } else {\n                    changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n                }\n            } else if (now.isBefore(start)) {\n                // Systm clock was adjusted backwards, restart record\n                changed = mOwners.setSystemUpdateFreezePeriodRecord(now, now);\n            } else /* start <= now <= end */ {\n                changed = false;\n            }\n            if (changed && saveIfChanged) {\n                mOwners.writeDeviceOwner();\n            }\n        }\n    }\n\n    @Override\n    public void clearSystemUpdatePolicyFreezePeriodRecord() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(permission.CLEAR_FREEZE_PERIOD),\n                \"Caller must be shell, or hold CLEAR_FREEZE_PERIOD permission to call \"\n                        + \"clearSystemUpdatePolicyFreezePeriodRecord\");\n        synchronized (getLockObject()) {\n            // Print out current record to help diagnosed CTS failures\n            Slogf.i(LOG_TAG, \"Clear freeze period record: \"\n                    + mOwners.getSystemUpdateFreezePeriodRecordAsString());\n            if (mOwners.setSystemUpdateFreezePeriodRecord(null, null)) {\n                mOwners.writeDeviceOwner();\n            }\n        }\n    }\n\n    /**\n     * Checks if any of the packages associated with the UID of the app provided is that\n     * of the device owner.\n     * @param appUid UID of the app to check.\n     * @return {@code true} if any of the packages are the device owner, {@code false} otherwise.\n     */\n    private boolean isUidDeviceOwnerLocked(int appUid) {\n        ensureLocked();\n        final String deviceOwnerPackageName = mOwners.getDeviceOwnerComponent()\n                .getPackageName();\n        try {\n            String[] pkgs = mInjector.getIPackageManager().getPackagesForUid(appUid);\n            if (pkgs == null) {\n                return false;\n            }\n\n            for (String pkg : pkgs) {\n                if (deviceOwnerPackageName.equals(pkg)) {\n                    return true;\n                }\n            }\n        } catch (RemoteException e) {\n            return false;\n        }\n        return false;\n    }\n\n    @Override\n    public void notifyPendingSystemUpdate(@Nullable SystemUpdateInfo info) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.NOTIFY_PENDING_SYSTEM_UPDATE),\n                \"Only the system update service can broadcast update information\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (!mUserManager.getUserInfo(UserHandle.getCallingUserId()).isMain()) {\n                Slogf.w(LOG_TAG, \"Only the system update service in the main user can broadcast \"\n                        + \"update information.\");\n                return;\n            }\n        });\n\n        if (!mOwners.saveSystemUpdateInfo(info)) {\n            // Pending system update hasn't changed, don't send duplicate notification.\n            return;\n        }\n\n        final Intent intent = new Intent(DeviceAdminReceiver.ACTION_NOTIFY_PENDING_SYSTEM_UPDATE)\n                .putExtra(DeviceAdminReceiver.EXTRA_SYSTEM_UPDATE_RECEIVED_TIME,\n                        info == null ? -1 : info.getReceivedTime());\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                // Broadcast to device owner first if there is one.\n                if (mOwners.hasDeviceOwner()) {\n                    final UserHandle deviceOwnerUser =\n                            UserHandle.of(mOwners.getDeviceOwnerUserId());\n                    intent.setComponent(mOwners.getDeviceOwnerComponent());\n                    mContext.sendBroadcastAsUser(intent, deviceOwnerUser);\n                }\n            }\n            // Get running users.\n            final int runningUserIds[];\n            try {\n                runningUserIds = mInjector.getIActivityManager().getRunningUserIds();\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slogf.e(LOG_TAG, \"Could not retrieve the list of running users\", e);\n                return;\n            }\n            // Send broadcasts to corresponding profile owners if any.\n            for (final int userId : runningUserIds) {\n                synchronized (getLockObject()) {\n                    final ComponentName profileOwnerPackage =\n                            mOwners.getProfileOwnerComponent(userId);\n                    if (profileOwnerPackage != null) {\n                        intent.setComponent(profileOwnerPackage);\n                        mContext.sendBroadcastAsUser(intent, UserHandle.of(userId));\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public SystemUpdateInfo getPendingSystemUpdate(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return mOwners.getSystemUpdateInfo();\n    }\n\n    @Override\n    public void setPermissionPolicy(ComponentName admin, String callerPackage, int policy) {\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller,\n                DELEGATION_PERMISSION_GRANT)));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PERMISSION_POLICY);\n\n        final int forUser = caller.getUserId();\n        synchronized (getLockObject()) {\n            DevicePolicyData userPolicy = getUserData(forUser);\n            if (userPolicy.mPermissionPolicy != policy) {\n                userPolicy.mPermissionPolicy = policy;\n                mPolicyCache.setPermissionPolicy(forUser, policy);\n                saveSettingsLocked(forUser);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERMISSION_POLICY)\n                .setAdmin(caller.getPackageName())\n                .setInt(policy)\n                .setBoolean(/* isDelegate */ admin == null)\n                .write();\n    }\n\n    private void updatePermissionPolicyCache(int userId) {\n        synchronized (getLockObject()) {\n            DevicePolicyData userPolicy = getUserData(userId);\n            mPolicyCache.setPermissionPolicy(userId, userPolicy.mPermissionPolicy);\n        }\n    }\n\n    @Override\n    public int getPermissionPolicy(ComponentName admin) throws RemoteException {\n        int userId = UserHandle.getCallingUserId();\n        return mPolicyCache.getPermissionPolicy(userId);\n    }\n\n    @Override\n    public void setPermissionGrantState(ComponentName admin, String callerPackage,\n            String packageName, String permission, int grantState, RemoteCallback callback)\n            throws RemoteException {\n        Objects.requireNonNull(callback);\n\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_PERMISSION_GRANT_STATE);\n\n        synchronized (getLockObject()) {\n            if (isFinancedDeviceOwner(caller)) {\n                enforcePermissionGrantStateOnFinancedDevice(packageName, permission);\n            }\n        }\n        EnforcingAdmin enforcingAdmin;\n        if (isUnicornFlagEnabled()) {\n            enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                    callerPackage,\n                    caller.getUserId());\n            if (SENSOR_PERMISSIONS.contains(permission)\n                    && grantState == PERMISSION_GRANT_STATE_GRANTED\n                    && (!canAdminGrantSensorsPermissions() || isCallerDelegate(caller))) {\n                if (mInjector.isChangeEnabled(THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS,\n                        caller.getPackageName(), caller.getUserId())) {\n                    throw new SecurityException(\n                            \"Caller not permitted to grant sensor permissions.\");\n                } else {\n                    // This is to match the legacy behaviour.\n                    callback.sendResult(Bundle.EMPTY);\n                    return;\n                }\n            }\n            // Check all the states where Exceptions aren't thrown but the permission\n            // isn't granted either.\n            if (!canGrantPermission(caller, permission, packageName)) {\n                callback.sendResult(null);\n                return;\n            }\n        } else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PERMISSION_GRANT)));\n            synchronized (getLockObject()) {\n                long ident = mInjector.binderClearCallingIdentity();\n                try {\n                    boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                            >= android.os.Build.VERSION_CODES.Q;\n                    if (!isPostQAdmin) {\n                        // Legacy admins assume that they cannot control pre-M apps\n                        if (getTargetSdk(packageName, caller.getUserId())\n                                < android.os.Build.VERSION_CODES.M) {\n                            callback.sendResult(null);\n                            return;\n                        }\n                    }\n                    if (!isRuntimePermission(permission)) {\n                        callback.sendResult(null);\n                        return;\n                    }\n                } catch (SecurityException e) {\n                    Slogf.e(LOG_TAG, \"Could not set permission grant state\", e);\n                    callback.sendResult(null);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(ident);\n                }\n            }\n        }\n        // TODO(b/278710449): enable when we stop policy enforecer callback from blocking the main\n        //  thread\n        if (false) {\n            // TODO(b/266924257): decide how to handle the internal state if the package doesn't\n            //  exist, or the permission isn't requested by the app, because we could end up with\n            //  inconsistent state between the policy engine and package manager. Also a package\n            //  might get removed or has it's permission updated after we've set the policy.\n            if (grantState == PERMISSION_GRANT_STATE_DEFAULT) {\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.PERMISSION_GRANT(packageName, permission),\n                        enforcingAdmin,\n                        caller.getUserId());\n            } else {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PERMISSION_GRANT(packageName, permission),\n                        enforcingAdmin,\n                        new IntegerPolicyValue(grantState),\n                        caller.getUserId());\n            }\n            int newState = mInjector.binderWithCleanCallingIdentity(() ->\n                    getPermissionGrantStateForUser(\n                            packageName, permission, caller, caller.getUserId()));\n            if (newState == grantState) {\n                callback.sendResult(Bundle.EMPTY);\n            } else {\n                callback.sendResult(null);\n            }\n        } else {\n            synchronized (getLockObject()) {\n                long ident = mInjector.binderClearCallingIdentity();\n                try {\n                    boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                            >= android.os.Build.VERSION_CODES.Q;\n                    if (grantState == PERMISSION_GRANT_STATE_GRANTED\n                            || grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED\n                            || grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT) {\n                        AdminPermissionControlParams permissionParams =\n                                new AdminPermissionControlParams(packageName, permission,\n                                        grantState,\n                                        canAdminGrantSensorsPermissions());\n                        mInjector.getPermissionControllerManager(caller.getUserHandle())\n                                .setRuntimePermissionGrantStateByDeviceAdmin(\n                                        caller.getPackageName(),\n                                        permissionParams, mContext.getMainExecutor(),\n                                        (permissionWasSet) -> {\n                                            if (isPostQAdmin && !permissionWasSet) {\n                                                callback.sendResult(null);\n                                                return;\n                                            }\n                                            callback.sendResult(Bundle.EMPTY);\n                                        });\n                    }\n                } catch (SecurityException e) {\n                    Slogf.e(LOG_TAG, \"Could not set permission grant state\", e);\n\n                    callback.sendResult(null);\n                } finally {\n                    mInjector.binderRestoreCallingIdentity(ident);\n                }\n            }\n        }\n        DevicePolicyEventLogger.createEvent(DevicePolicyEnums.SET_PERMISSION_GRANT_STATE)\n                .setAdmin(caller.getPackageName())\n                .setStrings(permission)\n                .setInt(grantState)\n                .setBoolean(/* isDelegate */ isCallerDelegate(caller))\n                .write();\n    }\n\n    private static final List<String> SENSOR_PERMISSIONS = new ArrayList<>();\n    {\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACCESS_FINE_LOCATION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACCESS_BACKGROUND_LOCATION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACCESS_COARSE_LOCATION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.CAMERA);\n        SENSOR_PERMISSIONS.add(Manifest.permission.RECORD_AUDIO);\n        SENSOR_PERMISSIONS.add(Manifest.permission.ACTIVITY_RECOGNITION);\n        SENSOR_PERMISSIONS.add(Manifest.permission.BODY_SENSORS);\n        SENSOR_PERMISSIONS.add(Manifest.permission.BACKGROUND_CAMERA);\n        SENSOR_PERMISSIONS.add(Manifest.permission.RECORD_BACKGROUND_AUDIO);\n        SENSOR_PERMISSIONS.add(Manifest.permission.BODY_SENSORS_BACKGROUND);\n    }\n\n    private boolean canGrantPermission(CallerIdentity caller, String permission,\n            String targetPackageName) {\n        boolean isPostQAdmin = getTargetSdk(caller.getPackageName(), caller.getUserId())\n                >= android.os.Build.VERSION_CODES.Q;\n        if (!isPostQAdmin) {\n            // Legacy admins assume that they cannot control pre-M apps\n            if (getTargetSdk(targetPackageName, caller.getUserId())\n                    < android.os.Build.VERSION_CODES.M) {\n                return false;\n            }\n        }\n        if (!isRuntimePermission(permission)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void enforcePermissionGrantStateOnFinancedDevice(\n            String packageName, String permission) {\n        if (!Manifest.permission.READ_PHONE_STATE.equals(permission)) {\n            throw new SecurityException(permission + \" cannot be used when managing a financed\"\n                    + \" device for permission grant state\");\n        } else if (!mOwners.getDeviceOwnerPackageName().equals(packageName)) {\n            throw new SecurityException(\"Device owner package is the only package that can be used\"\n                    + \" for permission grant state when managing a financed device\");\n        }\n    }\n\n    @Override\n    public int getPermissionGrantState(ComponentName admin, String callerPackage,\n            String packageName, String permission) throws RemoteException {\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        if (isUnicornFlagEnabled()) {\n            enforceCanQuery(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, caller.getPackageName(),\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(isSystemUid(caller) || (caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                    || isFinancedDeviceOwner(caller)))\n                    || (caller.hasPackage() && isCallerDelegate(caller,\n                    DELEGATION_PERMISSION_GRANT)));\n        }\n\n        synchronized (getLockObject()) {\n            if (isFinancedDeviceOwner(caller)) {\n                enforcePermissionGrantStateOnFinancedDevice(packageName, permission);\n            }\n            return mInjector.binderWithCleanCallingIdentity(() -> getPermissionGrantStateForUser(\n                    packageName, permission, caller, caller.getUserId()));\n        }\n    }\n\n    private int getPermissionGrantStateForUser(\n            String packageName, String permission, CallerIdentity caller, int userId)\n            throws RemoteException {\n        int granted;\n        if (getTargetSdk(caller.getPackageName(), caller.getUserId())\n                < android.os.Build.VERSION_CODES.Q) {\n            // The per-Q behavior was to not check the app-ops state.\n            granted = mIPackageManager.checkPermission(permission, packageName, userId);\n        } else {\n            try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n                var packageState = snapshot.getPackageStates().get(packageName);\n                if (packageState == null) {\n                    Slog.w(LOG_TAG, \"Can't get permission state for missing package \"\n                            + packageName);\n                    return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n                } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                    Slog.w(LOG_TAG, \"Can't get permission state for uninstalled package \"\n                            + packageName);\n                    return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n                } else {\n                    if (PermissionChecker.checkPermissionForPreflight(mContext, permission,\n                            PermissionChecker.PID_UNKNOWN,\n                            UserHandle.getUid(userId, packageState.getAppId()), packageName)\n                            != PermissionChecker.PERMISSION_GRANTED) {\n                        granted = PackageManager.PERMISSION_DENIED;\n                    } else {\n                        granted = PackageManager.PERMISSION_GRANTED;\n                    }\n\n                }\n            }\n        }\n        int permFlags = mInjector.getPackageManager().getPermissionFlags(\n                permission, packageName, UserHandle.of(userId));\n        if ((permFlags & PackageManager.FLAG_PERMISSION_POLICY_FIXED)\n                != PackageManager.FLAG_PERMISSION_POLICY_FIXED) {\n            // Not controlled by policy\n            return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n        } else {\n            // Policy controlled so return result based on permission grant state\n            return granted == PackageManager.PERMISSION_GRANTED\n                    ? DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED\n                    : DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;\n        }\n    }\n\n    boolean isPackageInstalledForUser(String packageName, int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                PackageInfo pi = mInjector.getIPackageManager().getPackageInfo(packageName, 0,\n                        userHandle);\n                return (pi != null) && (pi.applicationInfo.flags != 0);\n            } catch (RemoteException re) {\n                throw new RuntimeException(\"Package manager has died\", re);\n            }\n        });\n    }\n\n    private boolean isRuntimePermission(String permissionName) {\n        try {\n            final PackageManager packageManager = mInjector.getPackageManager();\n            PermissionInfo permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            return (permissionInfo.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)\n                    == PermissionInfo.PROTECTION_DANGEROUS;\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public boolean isProvisioningAllowed(String action, String packageName) {\n        Objects.requireNonNull(packageName);\n        final CallerIdentity caller = getCallerIdentity();\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final List<String> callerUidPackageNames = Arrays.asList(\n                    mInjector.getPackageManager().getPackagesForUid(caller.getUid()));\n            Preconditions.checkArgument(callerUidPackageNames.contains(packageName),\n                    \"Caller uid doesn't match the one for the provided package.\");\n\n            return checkProvisioningPreconditionSkipPermission(action, packageName, caller.getUserId())\n                    == STATUS_OK;\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int checkProvisioningPrecondition(String action, String packageName) {\n        Objects.requireNonNull(packageName, \"packageName is null\");\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        long originalId = mInjector.binderClearCallingIdentity();\n        try {\n            return checkProvisioningPreconditionSkipPermission(\n                    action, packageName, caller.getUserId());\n        } finally {\n            mInjector.binderRestoreCallingIdentity(originalId);\n        }\n\n    }\n    private int checkProvisioningPreconditionSkipPermission(String action,\n            String packageName, int userId) {\n        if (!mHasFeature) {\n            logMissingFeatureAction(\"Cannot check provisioning for action \" + action);\n            return STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\n        }\n        if (!isProvisioningAllowed()) {\n            return STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\n        }\n        final int code = checkProvisioningPreConditionSkipPermissionNoLog(\n                action, packageName, userId);\n        if (code != STATUS_OK) {\n            Slogf.d(LOG_TAG, \"checkProvisioningPreCondition(\" + action + \", \" + packageName\n                    + \") failed: \"\n                    + computeProvisioningErrorString(code, mInjector.userHandleGetCallingUserId()));\n        }\n        return code;\n    }\n\n    /**\n     *  Checks if provisioning is allowed during regular usage (non-developer/CTS). This could\n     *  return {@code false} if the device has an overlaid config value set to false. If not set,\n     *  the default is true.\n     */\n    private boolean isProvisioningAllowed() {\n        boolean isDeveloperMode = isDeveloperMode(mContext);\n        boolean isProvisioningAllowedForNormalUsers = SystemProperties.getBoolean(\n                ALLOW_USER_PROVISIONING_KEY, /* defValue= */ true);\n\n        return isDeveloperMode || isProvisioningAllowedForNormalUsers;\n    }\n\n    private static boolean isDeveloperMode(Context context) {\n        return Global.getInt(context.getContentResolver(), Global.ADB_ENABLED, 0) > 0;\n    }\n\n    private int checkProvisioningPreConditionSkipPermissionNoLog(String action,\n            String packageName, int userId) {\n        if (action != null) {\n            switch (action) {\n                case DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE:\n                    return checkManagedProfileProvisioningPreCondition(packageName, userId);\n                case DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE:\n                case DevicePolicyManager.ACTION_PROVISION_FINANCED_DEVICE:\n                    return checkDeviceOwnerProvisioningPreCondition(userId);\n            }\n        }\n        throw new IllegalArgumentException(\"Unknown provisioning action \" + action);\n    }\n\n    /**\n     * The device owner can only be set before the setup phase of the primary user has completed,\n     * except for adb command if no accounts or additional users are present on the device.\n     */\n    private int checkDeviceOwnerProvisioningPreConditionLocked(@Nullable ComponentName owner,\n            @UserIdInt int deviceOwnerUserId, @UserIdInt int callingUserId, boolean isAdb,\n            boolean hasIncompatibleAccountsOrNonAdb) {\n        if (mOwners.hasDeviceOwner()) {\n            return STATUS_HAS_DEVICE_OWNER;\n        }\n        if (mOwners.hasProfileOwner(deviceOwnerUserId)) {\n            return STATUS_USER_HAS_PROFILE_OWNER;\n        }\n\n        if (!mUserManager.isUserRunning(new UserHandle(deviceOwnerUserId))) {\n            return STATUS_USER_NOT_RUNNING;\n        }\n        if (mIsWatch && hasPaired(UserHandle.USER_SYSTEM)) {\n            return STATUS_HAS_PAIRED;\n        }\n\n        boolean isHeadlessSystemUserMode = mInjector.userManagerIsHeadlessSystemUserMode();\n\n        if (isHeadlessSystemUserMode) {\n            if (deviceOwnerUserId != UserHandle.USER_SYSTEM) {\n                Slogf.e(LOG_TAG, \"In headless system user mode, \"\n                        + \"device owner can only be set on headless system user.\");\n                return STATUS_NOT_SYSTEM_USER;\n            }\n\n            if (owner != null) {\n                DeviceAdminInfo adminInfo = findAdmin(\n                        owner, deviceOwnerUserId, /* throwForMissingPermission= */ false);\n\n                if (adminInfo.getHeadlessDeviceOwnerMode()\n                        != HEADLESS_DEVICE_OWNER_MODE_AFFILIATED) {\n                    return STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\n                }\n            }\n        }\n\n        if (isAdb) {\n            // If shell command runs after user setup completed check device status. Otherwise, OK.\n            if (mIsWatch || hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                // DO can be setup only if there are no users which are neither created by default\n                // nor marked as FOR_TESTING\n\n                if (nonTestNonPrecreatedUsersExist()) {\n                    return STATUS_NONSYSTEM_USER_EXISTS;\n                }\n\n                int currentForegroundUser = getCurrentForegroundUserId();\n                if (callingUserId != currentForegroundUser\n                        && mInjector.userManagerIsHeadlessSystemUserMode()\n                        && currentForegroundUser == UserHandle.USER_SYSTEM) {\n                    Slogf.wtf(LOG_TAG, \"In headless system user mode, \"\n                            + \"current user cannot be system user when setting device owner\");\n                    return STATUS_SYSTEM_USER;\n                }\n                if (hasIncompatibleAccountsOrNonAdb) {\n                    return STATUS_ACCOUNTS_NOT_EMPTY;\n                }\n            }\n            return STATUS_OK;\n        } else {\n            // DO has to be user 0\n            if (deviceOwnerUserId != UserHandle.USER_SYSTEM) {\n                return STATUS_NOT_SYSTEM_USER;\n            }\n            // Only provision DO before setup wizard completes\n            if (hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                return STATUS_USER_SETUP_COMPLETED;\n            }\n            return STATUS_OK;\n        }\n    }\n\n    /**\n     * True if there are any users on the device which were not setup by default (1 usually, 2 for\n     * devices with a headless system user) and also are not marked as FOR_TESTING.\n     */\n    private boolean nonTestNonPrecreatedUsersExist() {\n        int allowedUsers = UserManager.isHeadlessSystemUserMode() ? 2 : 1;\n        return mUserManagerInternal.getUsers(/* excludeDying= */ true).stream()\n                .filter(u -> !u.isForTesting())\n                .count() > allowedUsers;\n    }\n\n    private int checkDeviceOwnerProvisioningPreCondition(@UserIdInt int callingUserId) {\n        synchronized (getLockObject()) {\n            final int deviceOwnerUserId = mInjector.userManagerIsHeadlessSystemUserMode()\n                    ? UserHandle.USER_SYSTEM\n                    : callingUserId;\n            Slogf.i(LOG_TAG, \"Calling user %d, device owner will be set on user %d\",\n                    callingUserId, deviceOwnerUserId);\n            // hasIncompatibleAccountsOrNonAdb doesn't matter since the caller is not adb.\n            return checkDeviceOwnerProvisioningPreConditionLocked(/* owner unknown */ null,\n                    deviceOwnerUserId, callingUserId, /* isAdb= */ false,\n                    /* hasIncompatibleAccountsOrNonAdb=*/ true);\n        }\n    }\n\n    private int checkManagedProfileProvisioningPreCondition(String packageName,\n            @UserIdInt int callingUserId) {\n        if (!hasFeatureManagedUsers()) {\n            return STATUS_MANAGED_USERS_NOT_SUPPORTED;\n        }\n        if (getProfileOwnerAsUser(callingUserId) != null) {\n            // Managed user cannot have a managed profile.\n            return STATUS_USER_HAS_PROFILE_OWNER;\n        }\n\n        final long ident = mInjector.binderClearCallingIdentity();\n        try {\n            final UserHandle callingUserHandle = UserHandle.of(callingUserId);\n            final boolean hasDeviceOwner;\n            synchronized (getLockObject()) {\n                hasDeviceOwner = getDeviceOwnerAdminLocked() != null;\n            }\n\n            final boolean addingProfileRestricted = mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, callingUserHandle);\n\n            if (mUserManager.getUserInfo(callingUserId).isProfile()) {\n                Slogf.i(LOG_TAG, \"Calling user %d is a profile, cannot add another.\",\n                        callingUserId);\n                // The check is called from inside a managed profile. A managed profile cannot\n                // be provisioned from within another managed profile.\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n\n            // If there's a device owner, the restriction on adding a managed profile must be set.\n            if (hasDeviceOwner && !addingProfileRestricted) {\n                Slogf.wtf(LOG_TAG, \"Has a device owner but no restriction on adding a profile.\");\n            }\n\n            // Do not allow adding a managed profile if there's a restriction.\n            if (addingProfileRestricted) {\n                Slogf.i(LOG_TAG, \"Adding a profile is restricted: User %s Has device owner? %b\",\n                        callingUserHandle, hasDeviceOwner);\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n\n            // Bail out if we are trying to provision a work profile but one already exists.\n            if (!mUserManager.canAddMoreManagedProfiles(\n                    callingUserId, /* allowedToRemoveOne= */ false)) {\n                Slogf.i(LOG_TAG, \"Cannot add more managed profiles.\");\n                return STATUS_CANNOT_ADD_MANAGED_PROFILE;\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return STATUS_OK;\n    }\n\n    private void checkIsDeviceOwner(CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller), caller.getUid()\n                + \" is not device owner\");\n    }\n\n    /**\n     * Return device owner or profile owner set on a given user.\n     */\n    private @Nullable ComponentName getOwnerComponent(int userId) {\n        synchronized (getLockObject()) {\n            if (mOwners.getDeviceOwnerUserId() == userId) {\n                return mOwners.getDeviceOwnerComponent();\n            }\n            if (mOwners.hasProfileOwner(userId)) {\n                return mOwners.getProfileOwnerComponent(userId);\n            }\n        }\n        return null;\n    }\n\n    private boolean hasFeatureManagedUsers() {\n        try {\n            return mIPackageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS, 0);\n        } catch (RemoteException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public String getWifiMacAddress(ComponentName admin, String callerPackageName) {\n//        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n//        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackageName);\n//        if (isPermissionCheckFlagEnabled()) {\n//            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, UserHandle.USER_ALL);\n//        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n//        }\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            String[] macAddresses = mInjector.getWifiManager().getFactoryMacAddresses();\n            if (macAddresses == null) {\n                return null;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.GET_WIFI_MAC_ADDRESS)\n                    .setAdmin(caller.getPackageName())\n                    .write();\n            return macAddresses.length > 0 ? macAddresses[0] : null;\n        });\n    }\n\n    /**\n     * Returns the target sdk version number that the given packageName was built for\n     * in the given user.\n     */\n    private int getTargetSdk(String packageName, int userId) {\n        final ApplicationInfo ai;\n        try {\n            ai = mIPackageManager.getApplicationInfo(packageName, 0, userId);\n            return ai == null ? 0 : ai.targetSdkVersion;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return 0;\n        }\n    }\n\n    @Override\n    public boolean isManagedProfile(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        return isManagedProfile(caller.getUserId());\n    }\n\n    @Override\n    public void reboot(ComponentName admin) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REBOOT);\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Make sure there are no ongoing calls on the device.\n            if (mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {\n                throw new IllegalStateException(\"Cannot be called with ongoing call on the device\");\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.REBOOT)\n                    .setAdmin(admin)\n                    .write();\n            mInjector.powerManagerReboot(PowerManager.REBOOT_REQUESTED_BY_DEVICE_OWNER);\n        });\n    }\n\n    @Override\n    public void setShortSupportMessage(@Nullable ComponentName who, String callerPackageName,\n            CharSequence message) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller;\n        ActiveAdmin admin;\n\n        message = truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                admin = getActiveAdminForUidLocked(who, caller.getUid());\n            }\n        }\n\n        synchronized (getLockObject()) {\n            if (!TextUtils.equals(admin.shortSupportMessage, message)) {\n                admin.shortSupportMessage = message;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SHORT_SUPPORT_MESSAGE)\n                .setAdmin(caller.getPackageName())\n                .write();\n    }\n\n    @Override\n    public CharSequence getShortSupportMessage(@Nullable ComponentName who,\n            String callerPackageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller;\n        ActiveAdmin admin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            synchronized (getLockObject()) {\n                admin = getActiveAdminForUidLocked(who, caller.getUid());\n            }\n        }\n        return admin.shortSupportMessage;\n    }\n\n    @Override\n    public void setLongSupportMessage(@NonNull ComponentName who, CharSequence message) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        message = truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n            if (!TextUtils.equals(admin.longSupportMessage, message)) {\n                admin.longSupportMessage = message;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_LONG_SUPPORT_MESSAGE)\n                .setAdmin(who)\n                .write();\n    }\n\n    @Override\n    public CharSequence getLongSupportMessage(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());\n            return admin.longSupportMessage;\n        }\n    }\n\n    @Override\n    public CharSequence getShortSupportMessageForUser(@NonNull ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query support message for user\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin != null) {\n                return admin.shortSupportMessage;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public CharSequence getLongSupportMessageForUser(@NonNull ComponentName who, int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query support message for user\"));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n            if (admin != null) {\n                return admin.longSupportMessage;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void setOrganizationColor(@NonNull ComponentName who, int color) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.organizationColor = color;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ORGANIZATION_COLOR)\n                .setAdmin(caller.getComponentName())\n                .write();\n    }\n\n    @Override\n    public void setOrganizationColorForUser(int color, int userId) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n        Preconditions.checkCallAuthorization(isManagedProfile(userId), \"You can not \"\n                + \"set organization color outside a managed profile, userId = %d\", userId);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            admin.organizationColor = color;\n            saveSettingsLocked(userId);\n        }\n    }\n\n    @Override\n    public int getOrganizationColor(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.organizationColor;\n        }\n    }\n\n    @Override\n    public int getOrganizationColorForUser(int userHandle) {\n        if (!mHasFeature) {\n            return ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(isManagedProfile(userHandle), \"You can \"\n                + \"not get organization color outside a managed profile, userId = %d\", userHandle);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userHandle);\n            return (profileOwner != null)\n                    ? profileOwner.organizationColor\n                    : ActiveAdmin.DEF_ORGANIZATION_COLOR;\n        }\n    }\n\n    @Override\n    public void setOrganizationName(@Nullable ComponentName who, String callerPackageName,\n            CharSequence text) {\n        if (!mHasFeature) {\n            return;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        ActiveAdmin admin = null;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n        }\n\n        text = truncateIfLonger(text, MAX_ORG_NAME_LENGTH);\n\n        synchronized (getLockObject()) {\n            if (!isPermissionCheckFlagEnabled()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            if (!TextUtils.equals(admin.organizationName, text)) {\n                admin.organizationName = (text == null || text.length() == 0)\n                        ? null : text.toString();\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public CharSequence getOrganizationName(@Nullable ComponentName who, String callerPackageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n        CallerIdentity caller = getCallerIdentity(who);\n        ActiveAdmin admin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforceCanQueryAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n            Preconditions.checkCallAuthorization(isDeviceOwner(caller) || isProfileOwner(caller));\n\n            synchronized (getLockObject()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n\n        return admin.organizationName;\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public CharSequence getDeviceOwnerOrganizationName() {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || canManageUsers(caller) || isFinancedDeviceOwner(caller));\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwnerAdmin = getDeviceOwnerAdminLocked();\n            return deviceOwnerAdmin == null ? null : deviceOwnerAdmin.organizationName;\n        }\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public CharSequence getOrganizationNameForUser(int userHandle) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n        Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                \"You can not get organization name outside a managed profile, userId = %d\",\n                userHandle);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userHandle);\n            return (profileOwner != null)\n                    ? profileOwner.organizationName\n                    : null;\n        }\n    }\n\n    @Override\n    public List<String> setMeteredDataDisabledPackages(ComponentName who, List<String> packageNames) {\n        Objects.requireNonNull(who);\n        Objects.requireNonNull(packageNames);\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Admin %s does not own the profile\", caller.getComponentName());\n\n        if (!mHasFeature) {\n            return packageNames;\n        }\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                final List<String> excludedPkgs = removeInvalidPkgsForMeteredDataRestriction(\n                        caller.getUserId(), packageNames);\n                admin.meteredDisabledPackages = packageNames;\n                pushMeteredDisabledPackages(caller.getUserId());\n                saveSettingsLocked(caller.getUserId());\n                return excludedPkgs;\n            });\n        }\n    }\n\n    private List<String> removeInvalidPkgsForMeteredDataRestriction(\n            int userId, List<String> pkgNames) {\n        final Set<String> activeAdmins = getActiveAdminPackagesLocked(userId);\n        final List<String> excludedPkgs = new ArrayList<>();\n        for (int i = pkgNames.size() - 1; i >= 0; --i) {\n            final String pkgName = pkgNames.get(i);\n            // If the package is an active admin, don't restrict it.\n            if (activeAdmins.contains(pkgName)) {\n                excludedPkgs.add(pkgName);\n                continue;\n            }\n            // If the package doesn't exist, don't restrict it.\n            try {\n                if (!mInjector.getIPackageManager().isPackageAvailable(pkgName, userId)) {\n                    excludedPkgs.add(pkgName);\n                }\n            } catch (RemoteException e) {\n                // Should not happen\n            }\n        }\n        pkgNames.removeAll(excludedPkgs);\n        return excludedPkgs;\n    }\n\n    @Override\n    public List<String> getMeteredDataDisabledPackages(ComponentName who) {\n        Objects.requireNonNull(who);\n\n        if (!mHasFeature) {\n            return new ArrayList<>();\n        }\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Admin %s does not own the profile\", caller.getComponentName());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            return admin.meteredDisabledPackages == null\n                    ? new ArrayList<>() : admin.meteredDisabledPackages;\n        }\n    }\n\n    @Override\n    public boolean isMeteredDataDisabledPackageForUser(ComponentName who,\n            String packageName, int userId) {\n        Objects.requireNonNull(who);\n\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG, \"query restricted pkgs for a specific user\"));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId);\n            if (admin != null && admin.meteredDisabledPackages != null) {\n                return admin.meteredDisabledPackages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void setProfileOwnerOnOrganizationOwnedDevice(ComponentName who, int userId,\n            boolean isProfileOwnerOnOrganizationOwnedDevice) {\n        if (!mHasFeature) {\n            return;\n        }\n        // As the caller is the system, it must specify the component name of the profile owner\n        // as a safety check.\n        Objects.requireNonNull(who);\n\n        final CallerIdentity caller = getCallerIdentity();\n        // Only adb or system apps with the right permission can mark a profile owner on\n        // organization-owned device.\n        if (!(isAdb(caller) || hasCallingPermission(permission.MARK_DEVICE_ORGANIZATION_OWNED)\n                || hasCallingPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS))) {\n            throw new SecurityException(\n                    \"Only the system can mark a profile owner of organization-owned device.\");\n        }\n        // Only a test admin can be unmarked as a profile owner on an organization-owned device.\n        synchronized (getLockObject()) {\n            if (!isProfileOwnerOnOrganizationOwnedDevice && !isAdminTestOnlyLocked(who, userId)) {\n                throw new SecurityException(\"Only a test admin can be unmarked as a \"\n                        + \"profile owner of organization-owned device.\");\n            }\n        }\n\n        if (isAdb(caller)) {\n            if (hasIncompatibleAccountsOrNonAdbNoLock(caller, userId, who)) {\n                throw new SecurityException(\n                        \"Can only be called from ADB if the device has no accounts.\");\n            }\n        } else {\n            if (hasUserSetupCompleted(UserHandle.USER_SYSTEM)) {\n                throw new IllegalStateException(\n                        \"Cannot mark profile owner as managing an organization-owned device after\"\n                                + \" set-up\");\n            }\n        }\n\n        // Grant access under lock.\n        synchronized (getLockObject()) {\n            setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(who, userId,\n                    isProfileOwnerOnOrganizationOwnedDevice);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(\n            ComponentName who, int userId, boolean isProfileOwnerOnOrganizationOwnedDevice) {\n        // Make sure that the user has a profile owner and that the specified\n        // component is the profile owner of that user.\n        if (!isProfileOwner(who, userId)) {\n            throw new IllegalArgumentException(String.format(\n                    \"Component %s is not a Profile Owner of user %d\",\n                    who.flattenToString(), userId));\n        }\n\n        Slogf.i(LOG_TAG, \"%s %s as profile owner on organization-owned device for user %d\",\n                isProfileOwnerOnOrganizationOwnedDevice ? \"Marking\" : \"Unmarking\",\n                who.flattenToString(), userId);\n\n        // First, set restriction on removing the profile.\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Clear restriction as user.\n            final UserHandle parentUser = mUserManager.getProfileParent(UserHandle.of(userId));\n            if (parentUser == null) {\n                throw new IllegalStateException(String.format(\"User %d is not a profile\", userId));\n            }\n\n            mUserManager.setUserRestriction(UserManager.DISALLOW_REMOVE_MANAGED_PROFILE,\n                    isProfileOwnerOnOrganizationOwnedDevice,\n                    parentUser);\n            mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                    isProfileOwnerOnOrganizationOwnedDevice,\n                    parentUser);\n        });\n\n        // setProfileOwnerOfOrganizationOwnedDevice will trigger writing of the profile owner\n        // data, no need to do it manually.\n        mOwners.setProfileOwnerOfOrganizationOwnedDevice(userId,\n                isProfileOwnerOnOrganizationOwnedDevice);\n    }\n\n    private void pushMeteredDisabledPackages(int userId) {\n        wtfIfInLock();\n        mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackages(\n                getMeteredDisabledPackages(userId), userId);\n    }\n\n    private Set<String> getMeteredDisabledPackages(int userId) {\n        synchronized (getLockObject()) {\n            final Set<String> restrictedPkgs = new ArraySet<>();\n            final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (admin != null && admin.meteredDisabledPackages != null) {\n                restrictedPkgs.addAll(admin.meteredDisabledPackages);\n            }\n\n            return restrictedPkgs;\n        }\n    }\n\n    @Override\n    public void setAffiliationIds(ComponentName admin, List<String> ids) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (ids == null) {\n            throw new IllegalArgumentException(\"ids must not be null\");\n        }\n        for (String id : ids) {\n            Preconditions.checkArgument(!TextUtils.isEmpty(id), \"ids must not have empty string\");\n            enforceMaxStringLength(id, \"affiliation id\");\n        }\n\n        final Set<String> affiliationIds = new ArraySet<>(ids);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n        final int callingUserId = caller.getUserId();\n\n        synchronized (getLockObject()) {\n            getUserData(callingUserId).mAffiliationIds = affiliationIds;\n            saveSettingsLocked(callingUserId);\n            mStateCache.setHasAffiliationWithDevice(callingUserId,\n                    isUserAffiliatedWithDeviceLocked(callingUserId));\n            if (callingUserId == UserHandle.USER_SYSTEM) {\n                resetAffiliationCacheLocked();\n            } else if (callingUserId != UserHandle.USER_SYSTEM && isDeviceOwner(admin,\n                    callingUserId)) {\n                // Affiliation ids specified by the device owner are additionally stored in\n                // UserHandle.USER_SYSTEM's DevicePolicyData.\n                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds = affiliationIds;\n                mStateCache.setHasAffiliationWithDevice(UserHandle.USER_SYSTEM, true);\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n\n            // Affiliation status for any user, not just the calling user, might have changed.\n            // The device owner user will still be affiliated after changing its affiliation ids,\n            // but as a result of that other users might become affiliated or un-affiliated.\n            maybePauseDeviceWideLoggingLocked();\n            maybeResumeDeviceWideLoggingLocked();\n            maybeClearLockTaskPolicyLocked();\n            updateAdminCanGrantSensorsPermissionCache(callingUserId);\n        }\n    }\n\n    private void resetAffiliationCacheLocked() {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo user : mUserManager.getUsers()) {\n                mStateCache.setHasAffiliationWithDevice(user.id,\n                        isUserAffiliatedWithDeviceLocked(user.id));\n            }\n        });\n    }\n\n    @Override\n    public List<String> getAffiliationIds(ComponentName admin) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n\n        Objects.requireNonNull(admin);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            return new ArrayList<String>(getUserData(caller.getUserId()).mAffiliationIds);\n        }\n    }\n\n    @Override\n    public boolean isCallingUserAffiliated() {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return isUserAffiliatedWithDeviceLocked(mInjector.userHandleGetCallingUserId());\n        }\n    }\n\n    @Override\n    public boolean isAffiliatedUser(@UserIdInt int userId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasCrossUsersPermission(caller, userId));\n\n        return isUserAffiliatedWithDevice(userId);\n    }\n\n    private boolean isUserAffiliatedWithDevice(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n            return isUserAffiliatedWithDeviceLocked(userId);\n        }\n    }\n\n    private boolean isUserAffiliatedWithDeviceLocked(@UserIdInt int userId) {\n        if (!mOwners.hasDeviceOwner()) {\n            return false;\n        }\n        if (userId == UserHandle.USER_SYSTEM) {\n            // The system user is always affiliated in a DO device,\n            // even if in headless system user mode.\n            return true;\n        }\n        if (userId == mOwners.getDeviceOwnerUserId()) {\n            // The user that the DO is installed on is always affiliated with the device.\n            return true;\n        }\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner == null) {\n            return false;\n        }\n\n        final Set<String> userAffiliationIds = getUserData(userId).mAffiliationIds;\n        final Set<String> deviceAffiliationIds =\n                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds;\n        for (String id : userAffiliationIds) {\n            if (deviceAffiliationIds.contains(id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean areAllUsersAffiliatedWithDeviceLocked() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n            for (int i = 0; i < userInfos.size(); i++) {\n                int userId = userInfos.get(i).id;\n                if (!isUserAffiliatedWithDeviceLocked(userId)) {\n                    Slogf.d(LOG_TAG, \"User id \" + userId + \" not affiliated.\");\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private @UserIdInt int getSecurityLoggingEnabledUser() {\n        synchronized (getLockObject()) {\n            if (mOwners.hasDeviceOwner()) {\n                return UserHandle.USER_ALL;\n            }\n        }\n        // TODO: Add check for permission-based\n        return getOrganizationOwnedProfileUserId();\n    }\n\n    @Override\n    public void setSecurityLoggingEnabled(ComponentName admin, String packageName,\n            boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, caller.getPackageName(),\n                        UserHandle.USER_ALL);\n            } else {\n                if (admin != null) {\n                    Preconditions.checkCallAuthorization(\n                            isProfileOwnerOfOrganizationOwnedDevice(caller)\n                                    || isDefaultDeviceOwner(caller));\n                } else {\n                    // A delegate app passes a null admin component, which is expected\n                    Preconditions.checkCallAuthorization(\n                            isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n                }\n            }\n\n            if (enabled == mInjector.securityLogGetLoggingEnabledProperty()) {\n                return;\n            }\n            mInjector.securityLogSetLoggingEnabledProperty(enabled);\n            if (enabled) {\n                mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());\n                maybePauseDeviceWideLoggingLocked();\n            } else {\n                mSecurityLogMonitor.stop();\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_SECURITY_LOGGING_ENABLED)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    @Override\n    public boolean isSecurityLoggingEnabled(ComponentName admin, String packageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            if (!isSystemUid(getCallerIdentity())) {\n                final CallerIdentity caller = getCallerIdentity(admin, packageName);\n                if (isPermissionCheckFlagEnabled()) {\n                    enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                            caller.getPackageName(), UserHandle.USER_ALL);\n                } else {\n                    if (admin != null) {\n                        Preconditions.checkCallAuthorization(\n                                isProfileOwnerOfOrganizationOwnedDevice(caller)\n                                        || isDefaultDeviceOwner(caller));\n                    } else {\n                        // A delegate app passes a null admin component, which is expected\n                        Preconditions.checkCallAuthorization(\n                                isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n                    }\n                }\n            }\n            return mInjector.securityLogGetLoggingEnabledProperty();\n        }\n    }\n\n    private void recordSecurityLogRetrievalTime() {\n        synchronized (getLockObject()) {\n            final long currentTime = System.currentTimeMillis();\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (currentTime > policyData.mLastSecurityLogRetrievalTime) {\n                policyData.mLastSecurityLogRetrievalTime = currentTime;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public ParceledListSlice<SecurityEvent> retrievePreRebootSecurityLogs(ComponentName admin,\n            String packageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n            enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            if (admin != null) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller)\n                                || isDefaultDeviceOwner(caller));\n            } else {\n                // A delegate app passes a null admin component, which is expected\n                Preconditions.checkCallAuthorization(\n                        isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n            }\n\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.RETRIEVE_PRE_REBOOT_SECURITY_LOGS)\n                .setAdmin(caller.getPackageName())\n                .write();\n\n        if (!mContext.getResources().getBoolean(R.bool.config_supportPreRebootSecurityLogs)\n                || !mInjector.securityLogGetLoggingEnabledProperty()) {\n            return null;\n        }\n\n        recordSecurityLogRetrievalTime();\n        ArrayList<SecurityEvent> output = new ArrayList<SecurityEvent>();\n        try {\n            SecurityLog.readPreviousEvents(output);\n            int enabledUser = getSecurityLoggingEnabledUser();\n            if (enabledUser != UserHandle.USER_ALL) {\n                SecurityLog.redactEvents(output, enabledUser);\n            }\n            return new ParceledListSlice<SecurityEvent>(output);\n        } catch (IOException e) {\n            Slogf.w(LOG_TAG, \"Fail to read previous events\" , e);\n            return new ParceledListSlice<SecurityEvent>(Collections.<SecurityEvent>emptyList());\n        }\n    }\n\n    @Override\n    public ParceledListSlice<SecurityEvent> retrieveSecurityLogs(ComponentName admin,\n            String packageName) {\n        if (!mHasFeature) {\n            return null;\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n\n            enforcePermission(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            if (admin != null) {\n                Preconditions.checkCallAuthorization(\n                        isProfileOwnerOfOrganizationOwnedDevice(caller)\n                        || isDefaultDeviceOwner(caller));\n            } else {\n                // A delegate app passes a null admin component, which is expected\n                Preconditions.checkCallAuthorization(\n                        isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));\n            }\n            Preconditions.checkCallAuthorization(isOrganizationOwnedDeviceWithManagedProfile()\n                    || areAllUsersAffiliatedWithDeviceLocked());\n        }\n\n        if (!mInjector.securityLogGetLoggingEnabledProperty()) {\n            return null;\n        }\n\n        recordSecurityLogRetrievalTime();\n\n        List<SecurityEvent> logs = mSecurityLogMonitor.retrieveLogs();\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.RETRIEVE_SECURITY_LOGS)\n                .setAdmin(caller.getPackageName())\n                .write();\n        return logs != null ? new ParceledListSlice<SecurityEvent>(logs) : null;\n    }\n\n    @Override\n    public long forceSecurityLogs() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(permission.FORCE_DEVICE_POLICY_MANAGER_LOGS),\n                \"Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call \"\n                        + \"forceSecurityLogs\");\n        if (!mInjector.securityLogGetLoggingEnabledProperty()) {\n            throw new IllegalStateException(\"logging is not available\");\n        }\n        return mSecurityLogMonitor.forceLogs();\n    }\n\n    @Override\n    public boolean isUninstallInQueue(final String packageName) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n\n        UserPackage packageUserPair = UserPackage.of(caller.getUserId(), packageName);\n        synchronized (getLockObject()) {\n            return mPackagesToRemove.contains(packageUserPair);\n        }\n    }\n\n    @Override\n    public void uninstallPackageWithActiveAdmins(final String packageName) {\n        Preconditions.checkArgument(!TextUtils.isEmpty(packageName));\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n\n        final int userId = caller.getUserId();\n        enforceUserUnlocked(userId);\n\n        final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n        if (profileOwner != null && packageName.equals(profileOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"Cannot uninstall a package with a profile owner\");\n        }\n\n        final ComponentName deviceOwner = getDeviceOwnerComponent(/* callingUserOnly= */ false);\n        if (getDeviceOwnerUserId() == userId && deviceOwner != null\n                && packageName.equals(deviceOwner.getPackageName())) {\n            throw new IllegalArgumentException(\"Cannot uninstall a package with a device owner\");\n        }\n\n        final UserPackage packageUserPair = UserPackage.of(userId, packageName);\n        synchronized (getLockObject()) {\n            mPackagesToRemove.add(packageUserPair);\n        }\n\n        // All active admins on the user.\n        final List<ComponentName> allActiveAdmins = getActiveAdmins(userId);\n\n        // Active admins in the target package.\n        final List<ComponentName> packageActiveAdmins = new ArrayList<>();\n        if (allActiveAdmins != null) {\n            for (ComponentName activeAdmin : allActiveAdmins) {\n                if (packageName.equals(activeAdmin.getPackageName())) {\n                    packageActiveAdmins.add(activeAdmin);\n                    removeActiveAdmin(activeAdmin, userId);\n                }\n            }\n        }\n        if (packageActiveAdmins.size() == 0) {\n            startUninstallIntent(packageName, userId);\n        } else {\n            mHandler.postDelayed(new Runnable() {\n                @Override\n                public void run() {\n                    for (ComponentName activeAdmin : packageActiveAdmins) {\n                        removeAdminArtifacts(activeAdmin, userId);\n                    }\n                    startUninstallIntent(packageName, userId);\n                }\n            }, DEVICE_ADMIN_DEACTIVATE_TIMEOUT); // Start uninstall after timeout anyway.\n        }\n    }\n\n    @Override\n    public boolean isDeviceProvisioned() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(canManageUsers(caller));\n\n        synchronized (getLockObject()) {\n            return getUserDataUnchecked(UserHandle.USER_SYSTEM).mUserSetupComplete;\n        }\n    }\n\n    private boolean isCurrentUserDemo() {\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            final int userId = mInjector.userHandleGetCallingUserId();\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> mUserManager.getUserInfo(userId).isDemo());\n        }\n        return false;\n    }\n\n    private void removePackageIfRequired(final String packageName, final int userId) {\n        if (!packageHasActiveAdmins(packageName, userId)) {\n            // Will not do anything if uninstall was not requested or was already started.\n            startUninstallIntent(packageName, userId);\n        }\n    }\n\n    private void startUninstallIntent(final String packageName, final int userId) {\n        final UserPackage packageUserPair = UserPackage.of(userId, packageName);\n        synchronized (getLockObject()) {\n            if (!mPackagesToRemove.contains(packageUserPair)) {\n                // Do nothing if uninstall was not requested or was already started.\n                return;\n            }\n            mPackagesToRemove.remove(packageUserPair);\n        }\n        if (!isPackageInstalledForUser(packageName, userId)) {\n            // Package does not exist. Nothing to do.\n            return;\n        }\n\n        try { // force stop the package before uninstalling\n            mInjector.getIActivityManager().forceStopPackage(packageName, userId);\n        } catch (RemoteException re) {\n            Slogf.e(LOG_TAG, \"Failure talking to ActivityManager while force stopping package\");\n        }\n        final Uri packageURI = Uri.parse(\"package:\" + packageName);\n        final Intent uninstallIntent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageURI);\n        uninstallIntent.setFlags(FLAG_ACTIVITY_NEW_TASK);\n        mContext.startActivityAsUser(uninstallIntent, UserHandle.of(userId));\n    }\n\n    /**\n     * Removes the admin from the policy. Ideally called after the admin's\n     * {@link DeviceAdminReceiver#onDisabled(Context, Intent)} has been successfully completed.\n     *\n     * @param adminReceiver The admin to remove\n     * @param userHandle The user for which this admin has to be removed.\n     */\n    private void removeAdminArtifacts(final ComponentName adminReceiver, final int userHandle) {\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            final DevicePolicyData policy = getUserData(userHandle);\n            final boolean doProxyCleanup = admin.info.usesPolicy(\n                    DeviceAdminInfo.USES_POLICY_SETS_GLOBAL_PROXY);\n            policy.mAdminList.remove(admin);\n            policy.mAdminMap.remove(adminReceiver);\n            policy.validatePasswordOwner();\n            if (doProxyCleanup) {\n                resetGlobalProxyLocked(policy);\n            }\n            pushActiveAdminPackagesLocked(userHandle);\n            saveSettingsLocked(userHandle);\n            updateMaximumTimeToLockLocked(userHandle);\n            policy.mRemovingAdmins.remove(adminReceiver);\n            pushScreenCapturePolicy(userHandle);\n\n            Slogf.i(LOG_TAG, \"Device admin \" + adminReceiver + \" removed from user \" + userHandle);\n        }\n        pushMeteredDisabledPackages(userHandle);\n        // The removed admin might have disabled camera, so update user\n        // restrictions.\n        pushUserRestrictions(userHandle);\n    }\n\n    @Override\n    public void setDeviceProvisioningConfigApplied() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            policy.mDeviceProvisioningConfigApplied = true;\n            saveSettingsLocked(UserHandle.USER_SYSTEM);\n        }\n    }\n\n    @Override\n    public boolean isDeviceProvisioningConfigApplied() {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            return policy.mDeviceProvisioningConfigApplied;\n        }\n    }\n\n    /**\n     * Force update internal persistent state from Settings.Secure.USER_SETUP_COMPLETE.\n     *\n     * It's added for testing only. Please use this API carefully if it's used by other system app\n     * and bare in mind Settings.Secure.USER_SETUP_COMPLETE can be modified by user and other system\n     * apps.\n     */\n    @Override\n    public void forceUpdateUserSetupComplete(@UserIdInt int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        boolean isUserCompleted = mInjector.settingsSecureGetIntForUser(\n                Settings.Secure.USER_SETUP_COMPLETE, 0, userId) != 0;\n        DevicePolicyData policy = getUserData(userId);\n        policy.mUserSetupComplete = isUserCompleted;\n        mStateCache.setDeviceProvisioned(isUserCompleted);\n        synchronized (getLockObject()) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    @Override\n    public void setBackupServiceEnabled(ComponentName admin, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n\n        toggleBackupServiceActive(caller.getUserId(), enabled);\n    }\n\n    @Override\n    public boolean isBackupServiceEnabled(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                try {\n                    IBackupManager ibm = mInjector.getIBackupManager();\n                    return ibm != null && ibm.isBackupServiceActive(caller.getUserId());\n                } catch (RemoteException e) {\n                    throw new IllegalStateException(\"Failed requesting backup service state.\", e);\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean bindDeviceAdminServiceAsUser(\n            @NonNull ComponentName admin, @NonNull IApplicationThread caller,\n            @Nullable IBinder activtiyToken, @NonNull Intent serviceIntent,\n            @NonNull IServiceConnection connection, long flags, @UserIdInt int targetUserId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Objects.requireNonNull(admin);\n        Objects.requireNonNull(caller);\n        Objects.requireNonNull(serviceIntent);\n        Preconditions.checkArgument(\n                serviceIntent.getComponent() != null || serviceIntent.getPackage() != null,\n                \"Service intent must be explicit (with a package name or component): \"\n                        + serviceIntent);\n        Objects.requireNonNull(connection);\n        Preconditions.checkArgument(mInjector.userHandleGetCallingUserId() != targetUserId,\n                \"target user id must be different from the calling user id\");\n\n        if (!getBindDeviceAdminTargetUsers(admin).contains(UserHandle.of(targetUserId))) {\n            throw new SecurityException(\"Not allowed to bind to target user id\");\n        }\n\n        final String targetPackage;\n        synchronized (getLockObject()) {\n            targetPackage = getOwnerPackageNameForUserLocked(targetUserId);\n        }\n\n        final long callingIdentity = mInjector.binderClearCallingIdentity();\n        try {\n            // Validate and sanitize the incoming service intent.\n            final Intent sanitizedIntent =\n                    createCrossUserServiceIntent(serviceIntent, targetPackage, targetUserId);\n            if (sanitizedIntent == null) {\n                // Fail, cannot lookup the target service.\n                return false;\n            }\n            // Ask ActivityManager to bind it. Notice that we are binding the service with the\n            // caller app instead of DevicePolicyManagerService.\n            return mInjector.getIActivityManager().bindService(\n                    caller, activtiyToken, serviceIntent,\n                    serviceIntent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    connection, flags, mContext.getOpPackageName(),\n                    targetUserId) != 0;\n        } catch (RemoteException ex) {\n            // Same process, should not happen.\n        } finally {\n            mInjector.binderRestoreCallingIdentity(callingIdentity);\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public @NonNull List<UserHandle> getBindDeviceAdminTargetUsers(@NonNull ComponentName admin) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(admin);\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final int callingUserId = caller.getUserId();\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                ArrayList<UserHandle> targetUsers = new ArrayList<>();\n                if (!isDeviceOwner(admin, callingUserId)) {\n                    // Profile owners can only bind to the device owner.\n                    if (canUserBindToDeviceOwnerLocked(callingUserId)) {\n                        targetUsers.add(UserHandle.of(mOwners.getDeviceOwnerUserId()));\n                    }\n                } else {\n                    // Caller is the device owner: Look for profile owners that it can bind to.\n                    final List<UserInfo> userInfos = mUserManager.getAliveUsers();\n                    for (int i = 0; i < userInfos.size(); i++) {\n                        final int userId = userInfos.get(i).id;\n                        if (userId != callingUserId && canUserBindToDeviceOwnerLocked(userId)) {\n                            targetUsers.add(UserHandle.of(userId));\n                        }\n                    }\n                }\n\n                return targetUsers;\n            });\n        }\n    }\n\n    private boolean canUserBindToDeviceOwnerLocked(int userId) {\n        // There has to be a device owner, under another user id.\n        if (!mOwners.hasDeviceOwner() || userId == mOwners.getDeviceOwnerUserId()) {\n            return false;\n        }\n\n        // The user must have a profile owner that belongs to the same package as the device owner.\n        if (!mOwners.hasProfileOwner(userId) || !TextUtils.equals(\n                mOwners.getDeviceOwnerPackageName(), mOwners.getProfileOwnerPackage(userId))) {\n            return false;\n        }\n\n        // The user must be affiliated.\n        return isUserAffiliatedWithDeviceLocked(userId);\n    }\n\n    private boolean hasIncompatibleAccountsOnAnyUser() {\n        if (mHasIncompatibleAccounts == null) {\n            // Hasn't loaded for the first time yet - assume the worst\n            return true;\n        }\n\n        for (boolean hasIncompatible : mHasIncompatibleAccounts.values()) {\n            if (hasIncompatible) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private boolean hasIncompatibleAccounts(int userId) {\n        return mHasIncompatibleAccounts == null ? true\n                : mHasIncompatibleAccounts.getOrDefault(userId, /* default= */ false);\n    }\n\n    /**\n     * Return true if a given user has any accounts that'll prevent installing a device or profile\n     * owner {@code owner}.\n     * - If the user has no accounts, then return false.\n     * - Otherwise, if the owner is unknown (== null), or is not test-only, then return true.\n     * - Otherwise, if there's any account that does not have ..._ALLOWED, or does have\n     *   ..._DISALLOWED, return true.\n     * - Otherwise return false.\n     *\n     * If the caller is *not* ADB, it also returns true.  The returned value shouldn't be used\n     * when the caller is not ADB.\n     *\n     * DO NOT CALL IT WITH THE DPMS LOCK HELD.\n     */\n    private boolean hasIncompatibleAccountsOrNonAdbNoLock(CallerIdentity caller,\n            int userId, @Nullable ComponentName owner) {\n        if (!isAdb(caller)) {\n            return true;\n        }\n        wtfIfInLock();\n\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            AccountManager am =\n                    mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                            .getSystemService(AccountManager.class);\n            Account[] accounts = am.getAccounts();\n            if (accounts.length == 0) {\n                return false;\n            }\n            synchronized (getLockObject()) {\n                if (owner == null || !isAdminTestOnlyLocked(owner, userId)) {\n                    Slogf.w(LOG_TAG,\n                            \"Non test-only owner can't be installed with existing accounts.\");\n                    return true;\n                }\n            }\n\n            boolean compatible = !hasIncompatibleAccounts(userId);\n            if (compatible) {\n                Slogf.w(LOG_TAG, \"All accounts are compatible\");\n            } else {\n                Slogf.e(LOG_TAG, \"Found incompatible accounts\");\n            }\n            return !compatible;\n        });\n    }\n\n    ThreadPoolExecutor calculateHasIncompatibleAccountsExecutor = new ThreadPoolExecutor(\n            1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());\n\n    @Override\n    public void calculateHasIncompatibleAccounts() {\n        if (calculateHasIncompatibleAccountsExecutor.getQueue().size() > 1) {\n            return;\n        }\n        new CalculateHasIncompatibleAccountsTask().executeOnExecutor(\n                calculateHasIncompatibleAccountsExecutor, null);\n    }\n\n    @Nullable\n    private volatile Map<Integer, Boolean> mHasIncompatibleAccounts;\n\n    class CalculateHasIncompatibleAccountsTask extends AsyncTask<\n            Void, Void, Map<Integer, Boolean>> {\n        private static final String[] FEATURE_ALLOW =\n                {DevicePolicyManager.ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_ALLOWED};\n        private static final String[] FEATURE_DISALLOW =\n                {DevicePolicyManager.ACCOUNT_FEATURE_DEVICE_OR_PROFILE_OWNER_DISALLOWED};\n\n        @Override\n        protected Map<Integer, Boolean> doInBackground(Void... args) {\n            List<UserInfo> users = mUserManagerInternal.getUsers(/* excludeDying= */ true);\n            Map<Integer, Boolean> results = new HashMap<>();\n            for (UserInfo userInfo : users) {\n                results.put(userInfo.id, userHasIncompatibleAccounts(userInfo.id));\n            }\n\n            return results;\n        }\n\n        private boolean userHasIncompatibleAccounts(int id) {\n            AccountManager am = mContext.createContextAsUser(UserHandle.of(id), /* flags= */ 0)\n                    .getSystemService(AccountManager.class);\n            Account[] accounts = am.getAccounts();\n\n            for (Account account : accounts) {\n                if (hasAccountFeatures(am, account, FEATURE_DISALLOW)) {\n                    return true;\n                }\n                if (!hasAccountFeatures(am, account, FEATURE_ALLOW)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        @Override\n        protected void onPostExecute(Map<Integer, Boolean> results) {\n            mHasIncompatibleAccounts = Collections.unmodifiableMap(results);\n\n            Slogf.i(LOG_TAG, \"Finished calculating hasIncompatibleAccountsTask\");\n        }\n\n        private static boolean hasAccountFeatures(AccountManager am, Account account,\n                String[] features) {\n            try {\n                return am.hasFeatures(account, features, null, null).getResult();\n            } catch (Exception e) {\n                Slogf.w(LOG_TAG, \"Failed to get account feature\", e);\n                return false;\n            }\n        }\n    };\n\n    private boolean isAdb(CallerIdentity caller) {\n        return isShellUid(caller) || isRootUid(caller);\n    }\n\n    @Override\n    public void setNetworkLoggingEnabled(@Nullable ComponentName admin,\n            @NonNull String packageName, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        final boolean isManagedProfileOwner = isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId());\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                && (isDefaultDeviceOwner(caller) || isManagedProfileOwner))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING)));\n\n        synchronized (getLockObject()) {\n            if (enabled == isNetworkLoggingEnabledInternalLocked()) {\n                // already in the requested state\n                return;\n            }\n            final ActiveAdmin activeAdmin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n            activeAdmin.isNetworkLoggingEnabled = enabled;\n            if (!enabled) {\n                activeAdmin.numNetworkLoggingNotifications = 0;\n                activeAdmin.lastNetworkLoggingNotificationTimeMs = 0;\n            }\n            saveSettingsLocked(caller.getUserId());\n            setNetworkLoggingActiveInternal(enabled);\n\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.SET_NETWORK_LOGGING_ENABLED)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setInt(enabled ? 1 : 0)\n                    .setStrings(isManagedProfileOwner\n                            ? LOG_TAG_PROFILE_OWNER : LOG_TAG_DEVICE_OWNER)\n                    .write();\n        }\n    }\n\n    private void setNetworkLoggingActiveInternal(boolean active) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean shouldSendNotification = false;\n            synchronized (getLockObject()) {\n                if (active) {\n                    if (mNetworkLogger == null) {\n                        final int affectedUserId = getNetworkLoggingAffectedUser();\n                        mNetworkLogger = new NetworkLogger(this,\n                                mInjector.getPackageManagerInternal(),\n                                affectedUserId == UserHandle.USER_SYSTEM\n                                        ? UserHandle.USER_ALL : affectedUserId);\n                    }\n                    if (!mNetworkLogger.startNetworkLogging()) {\n                        mNetworkLogger = null;\n                        Slogf.wtf(LOG_TAG, \"Network logging could not be started due to the logging\"\n                                + \" service not being available yet.\");\n                    }\n                    maybePauseDeviceWideLoggingLocked();\n                    shouldSendNotification = shouldSendNetworkLoggingNotificationLocked();\n                } else {\n                    if (mNetworkLogger != null && !mNetworkLogger.stopNetworkLogging()) {\n                        Slogf.wtf(LOG_TAG, \"Network logging could not be stopped due to the logging\"\n                                + \" service not being available yet.\");\n                    }\n                    mNetworkLogger = null;\n                }\n            }\n            if (active) {\n                if (shouldSendNotification) {\n                    mHandler.post(() -> handleSendNetworkLoggingNotification());\n                }\n            } else {\n                mHandler.post(() -> handleCancelNetworkLoggingNotification());\n            }\n        });\n    }\n\n    private @UserIdInt int getNetworkLoggingAffectedUser() {\n        synchronized (getLockObject()) {\n            if (mOwners.hasDeviceOwner()) {\n                return mOwners.getDeviceOwnerUserId();\n            } else {\n                return mInjector.binderWithCleanCallingIdentity(\n                        () -> getManagedUserId());\n            }\n        }\n    }\n\n    private ActiveAdmin getNetworkLoggingControllingAdminLocked() {\n        int affectedUserId = getNetworkLoggingAffectedUser();\n        if (affectedUserId < 0) {\n            return null;\n        }\n        return getDeviceOrProfileOwnerAdminLocked(affectedUserId);\n    }\n\n    @Override\n    public long forceNetworkLogs() {\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                || hasCallingOrSelfPermission(permission.FORCE_DEVICE_POLICY_MANAGER_LOGS),\n                \"Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call \"\n                        + \"forceNetworkLogs\");\n        synchronized (getLockObject()) {\n            if (!isNetworkLoggingEnabledInternalLocked()) {\n                throw new IllegalStateException(\"logging is not available\");\n            }\n            if (mNetworkLogger != null) {\n                return mInjector.binderWithCleanCallingIdentity(\n                        () -> mNetworkLogger.forceBatchFinalization());\n            }\n            return 0;\n        }\n    }\n\n    /** Pauses security and network logging if there are unaffiliated users on the device */\n    @GuardedBy(\"getLockObject()\")\n    private void maybePauseDeviceWideLoggingLocked() {\n        if (!areAllUsersAffiliatedWithDeviceLocked()) {\n            if (mOwners.hasDeviceOwner()) {\n                Slogf.i(LOG_TAG, \"There are unaffiliated users, network logging will be \"\n                        + \"paused if enabled.\");\n                if (mNetworkLogger != null) {\n                    mNetworkLogger.pause();\n                }\n            }\n            // TODO: We need to also enable this when someone is managing using permission\n            if (!isOrganizationOwnedDeviceWithManagedProfile()) {\n                Slogf.i(LOG_TAG,\n                        \"Not org-owned managed profile device, security logging will be \"\n                                + \"paused if enabled.\");\n                mSecurityLogMonitor.pause();\n            }\n        }\n    }\n\n    /** Resumes security and network logging (if they are enabled) if all users are affiliated */\n    @GuardedBy(\"getLockObject()\")\n    private void maybeResumeDeviceWideLoggingLocked() {\n        boolean allUsersAffiliated = areAllUsersAffiliatedWithDeviceLocked();\n        boolean orgOwnedProfileDevice = isOrganizationOwnedDeviceWithManagedProfile();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (allUsersAffiliated || orgOwnedProfileDevice) {\n                mSecurityLogMonitor.resume();\n            }\n            // If there is no device owner, then per-user network logging may be enabled for the\n            // managed profile. In which case, all users do not need to be affiliated.\n            if (allUsersAffiliated || !mOwners.hasDeviceOwner()) {\n                if (mNetworkLogger != null) {\n                    mNetworkLogger.resume();\n                }\n            }\n        });\n    }\n\n    /** Deletes any security and network logs that might have been collected so far */\n    @GuardedBy(\"getLockObject()\")\n    private void discardDeviceWideLogsLocked() {\n        mSecurityLogMonitor.discardLogs();\n        if (mNetworkLogger != null) {\n            mNetworkLogger.discardLogs();\n        }\n        // TODO: We should discard pre-boot security logs here too, as otherwise those\n        // logs (which might contain data from the user just removed) will be\n        // available after next boot.\n    }\n\n    /**\n     * This API is cached: invalidate with invalidateBinderCaches().\n     */\n    @Override\n    public boolean isNetworkLoggingEnabled(@Nullable ComponentName admin,\n            @NonNull String packageName) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  (isDefaultDeviceOwner(caller)\n                || (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING))\n                || hasCallingOrSelfPermission(permission.MANAGE_USERS));\n\n        synchronized (getLockObject()) {\n            return isNetworkLoggingEnabledInternalLocked();\n        }\n    }\n\n    private boolean isNetworkLoggingEnabledInternalLocked() {\n        ActiveAdmin activeAdmin = getNetworkLoggingControllingAdminLocked();\n        return (activeAdmin != null) && activeAdmin.isNetworkLoggingEnabled;\n    }\n\n    /*\n     * A maximum of 1200 events are returned, and the total marshalled size is in the order of\n     * 100kB, so returning a List instead of ParceledListSlice is acceptable.\n     * Ideally this would be done with ParceledList, however it only supports homogeneous types.\n     *\n     * @see NetworkLoggingHandler#MAX_EVENTS_PER_BATCH\n     */\n    @Override\n    public List<NetworkEvent> retrieveNetworkLogs(@Nullable ComponentName admin,\n            @NonNull String packageName, long batchToken) {\n        if (!mHasFeature) {\n            return null;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, packageName);\n        final boolean isManagedProfileOwner = isProfileOwner(caller)\n                && isManagedProfile(caller.getUserId());\n        Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                &&  (isDefaultDeviceOwner(caller) || isManagedProfileOwner))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_NETWORK_LOGGING)));\n        if (mOwners.hasDeviceOwner()) {\n            checkAllUsersAreAffiliatedWithDevice();\n        }\n\n        synchronized (getLockObject()) {\n            if (mNetworkLogger == null || !isNetworkLoggingEnabledInternalLocked()) {\n                return null;\n            }\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.RETRIEVE_NETWORK_LOGS)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setStrings(isManagedProfileOwner\n                            ? LOG_TAG_PROFILE_OWNER : LOG_TAG_DEVICE_OWNER)\n                    .write();\n\n            final long currentTime = System.currentTimeMillis();\n            DevicePolicyData policyData = getUserData(caller.getUserId());\n            if (currentTime > policyData.mLastNetworkLogsRetrievalTime) {\n                policyData.mLastNetworkLogsRetrievalTime = currentTime;\n                saveSettingsLocked(caller.getUserId());\n            }\n            return mNetworkLogger.retrieveLogs(batchToken);\n        }\n    }\n\n    /**\n     * Returns whether it's time to post another network logging notification. When returning true,\n     * this method has the side-effect of updating the recorded last network logging notification\n     * time to now.\n     */\n    private boolean shouldSendNetworkLoggingNotificationLocked() {\n        ensureLocked();\n        // Send a network logging notification if the admin is a device owner, not profile owner.\n        final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n        if (deviceOwner == null || !deviceOwner.isNetworkLoggingEnabled) {\n            return false;\n        }\n        if (deviceOwner.numNetworkLoggingNotifications\n                >= ActiveAdmin.DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN) {\n            return false;\n        }\n        final long now = System.currentTimeMillis();\n        if (now - deviceOwner.lastNetworkLoggingNotificationTimeMs < MS_PER_DAY) {\n            return false;\n        }\n        deviceOwner.numNetworkLoggingNotifications++;\n        if (deviceOwner.numNetworkLoggingNotifications\n                >= ActiveAdmin.DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN) {\n            deviceOwner.lastNetworkLoggingNotificationTimeMs = 0;\n        } else {\n            deviceOwner.lastNetworkLoggingNotificationTimeMs = now;\n        }\n        saveSettingsLocked(deviceOwner.getUserHandle().getIdentifier());\n        return true;\n    }\n\n    private void handleSendNetworkLoggingNotification() {\n        final PackageManagerInternal pm = mInjector.getPackageManagerInternal();\n        final Intent intent = new Intent(DevicePolicyManager.ACTION_SHOW_DEVICE_MONITORING_DIALOG);\n        intent.setPackage(pm.getSystemUiServiceComponent().getPackageName());\n        mNetworkLoggingNotificationUserId = getCurrentForegroundUserId();\n        // Simple notification clicks are immutable\n        final PendingIntent pendingIntent = PendingIntent.getBroadcastAsUser(mContext, 0, intent,\n                PendingIntent.FLAG_IMMUTABLE, UserHandle.CURRENT);\n\n        final String title = getNetworkLoggingTitle();\n        final String text = getNetworkLoggingText();\n        Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                .setSmallIcon(R.drawable.ic_info_outline)\n                .setContentTitle(title)\n                .setContentText(text)\n                .setTicker(title)\n                .setShowWhen(true)\n                .setContentIntent(pendingIntent)\n                .setStyle(new Notification.BigTextStyle().bigText(text))\n                .build();\n        Slogf.i(LOG_TAG, \"Sending network logging notification to user %d\",\n                mNetworkLoggingNotificationUserId);\n        mInjector.getNotificationManager().notifyAsUser(/* tag= */ null,\n                SystemMessage.NOTE_NETWORK_LOGGING, notification,\n                UserHandle.of(mNetworkLoggingNotificationUserId));\n    }\n\n    private String getNetworkLoggingTitle() {\n        return getUpdatableString(\n                NETWORK_LOGGING_TITLE, R.string.network_logging_notification_title);\n    }\n\n    private String getNetworkLoggingText() {\n        return getUpdatableString(\n                NETWORK_LOGGING_MESSAGE, R.string.network_logging_notification_text);\n    }\n\n    private void handleCancelNetworkLoggingNotification() {\n        if (mNetworkLoggingNotificationUserId == UserHandle.USER_NULL) {\n            // Happens when setNetworkLoggingActive(false) is called before called with true\n            Slogf.d(LOG_TAG, \"Not cancelling network logging notification for USER_NULL\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Cancelling network logging notification for user %d\",\n                mNetworkLoggingNotificationUserId);\n        mInjector.getNotificationManager().cancelAsUser(/* tag= */ null,\n                SystemMessage.NOTE_NETWORK_LOGGING,\n                UserHandle.of(mNetworkLoggingNotificationUserId));\n        mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n    }\n\n    /**\n     * Return the package name of owner in a given user.\n     */\n    private String getOwnerPackageNameForUserLocked(int userId) {\n        return mOwners.getDeviceOwnerUserId() == userId\n                ? mOwners.getDeviceOwnerPackageName()\n                : mOwners.getProfileOwnerPackage(userId);\n    }\n\n    /**\n     * @param rawIntent Original service intent specified by caller. It must be explicit.\n     * @param expectedPackageName The expected package name of the resolved service.\n     * @return Intent that have component explicitly set. {@code null} if no service is resolved\n     *     with the given intent.\n     * @throws SecurityException if the intent is resolved to an invalid service.\n     */\n    private Intent createCrossUserServiceIntent(\n            @NonNull Intent rawIntent, @NonNull String expectedPackageName,\n            @UserIdInt int targetUserId) throws RemoteException, SecurityException {\n        ResolveInfo info = mIPackageManager.resolveService(\n                rawIntent,\n                rawIntent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                0,  // flags\n                targetUserId);\n        if (info == null || info.serviceInfo == null) {\n            Slogf.e(LOG_TAG, \"Fail to look up the service: %s or user %d is not running\", rawIntent,\n                    targetUserId);\n            return null;\n        }\n        if (!expectedPackageName.equals(info.serviceInfo.packageName)) {\n            throw new SecurityException(\"Only allow to bind service in \" + expectedPackageName);\n        }\n        // STOPSHIP(b/37624960): Remove info.serviceInfo.exported before release.\n        if (info.serviceInfo.exported && !BIND_DEVICE_ADMIN.equals(info.serviceInfo.permission)) {\n            throw new SecurityException(\n                    \"Service must be protected by BIND_DEVICE_ADMIN permission\");\n        }\n        // It is the system server to bind the service, it would be extremely dangerous if it\n        // can be exploited to bind any service. Set the component explicitly to make sure we\n        // do not bind anything accidentally.\n        rawIntent.setComponent(info.serviceInfo.getComponentName());\n        return rawIntent;\n    }\n\n    @Override\n    public long getLastSecurityLogRetrievalTime() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller));\n        return getUserData(UserHandle.USER_SYSTEM).mLastSecurityLogRetrievalTime;\n     }\n\n    @Override\n    public long getLastBugReportRequestTime() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || canManageUsers(caller));\n        return getUserData(UserHandle.USER_SYSTEM).mLastBugReportRequestTime;\n     }\n\n    @Override\n    public long getLastNetworkLogRetrievalTime() {\n        final CallerIdentity caller = getCallerIdentity();\n\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || (isProfileOwner(caller) && isManagedProfile(caller.getUserId()))\n                || canManageUsers(caller));\n        final int affectedUserId = getNetworkLoggingAffectedUser();\n        return affectedUserId >= 0 ? getUserData(affectedUserId).mLastNetworkLogsRetrievalTime : -1;\n    }\n\n    @Override\n    public boolean setResetPasswordToken(ComponentName admin, String callerPackageName,\n            byte[] token) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        if (token == null || token.length < 32) {\n            throw new IllegalArgumentException(\"token must be at least 32-byte long\");\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        final int userId = caller.getUserId();\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            long tokenHandle = addEscrowToken(\n                    token, currentTokenHandle == null ? 0 : currentTokenHandle, userId);\n            if (tokenHandle == 0) {\n                return false;\n            }\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    new LongPolicyValue(tokenHandle),\n                    userId);\n            return true;\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                policy.mPasswordTokenHandle = addEscrowToken(\n                        token, policy.mPasswordTokenHandle, userId);\n                saveSettingsLocked(userId);\n                return policy.mPasswordTokenHandle != 0;\n            }\n        }\n    }\n\n    private long addEscrowToken(byte[] token, long currentPasswordTokenHandle, int userId) {\n        resetEscrowToken(currentPasswordTokenHandle, userId);\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.addEscrowToken(\n                token, userId, /* EscrowTokenStateChangeCallback= */ null));\n    }\n\n    private boolean resetEscrowToken(long tokenHandle, int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            if (tokenHandle != 0) {\n                return mLockPatternUtils.removeEscrowToken(tokenHandle, userId);\n            }\n            return false;\n        });\n    }\n\n    @Override\n    public boolean clearResetPasswordToken(ComponentName admin, String callerPackageName) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        final int userId = caller.getUserId();\n        boolean result = false;\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            if (currentTokenHandle != null) {\n                result = resetEscrowToken(currentTokenHandle, userId);\n                mDevicePolicyEngine.removeLocalPolicy(\n                        PolicyDefinition.RESET_PASSWORD_TOKEN,\n                        enforcingAdmin,\n                        userId);\n            }\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    result = resetEscrowToken(policy.mPasswordTokenHandle, userId);\n                    policy.mPasswordTokenHandle = 0;\n                    saveSettingsLocked(userId);\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isResetPasswordTokenActive(ComponentName admin, String callerPackageName) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n        int userId = caller.getUserId();\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            return isResetPasswordTokenActiveForUserLocked(\n                    currentTokenHandle == null ? 0 : currentTokenHandle, userId);\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                return isResetPasswordTokenActiveForUserLocked(policy.mPasswordTokenHandle, userId);\n            }\n        }\n    }\n\n    private boolean isResetPasswordTokenActiveForUserLocked(\n            long passwordTokenHandle, int userHandle) {\n        if (passwordTokenHandle != 0) {\n            return mInjector.binderWithCleanCallingIdentity(() ->\n                    mLockPatternUtils.isEscrowTokenActive(passwordTokenHandle, userHandle));\n        }\n        return false;\n    }\n\n    @Override\n    public boolean resetPasswordWithToken(ComponentName admin, String callerPackageName,\n            String passwordOrNull, byte[] token,\n            int flags) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return false;\n        }\n        Objects.requireNonNull(token);\n\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n        } else {\n            caller = getCallerIdentity(admin);\n        }\n\n        int userId = caller.getUserId();\n        boolean result = false;\n        final String password = passwordOrNull != null ? passwordOrNull : \"\";\n\n        if (isUnicornFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    admin,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    caller.getPackageName(),\n                    userId);\n            Long currentTokenHandle = mDevicePolicyEngine.getLocalPolicySetByAdmin(\n                    PolicyDefinition.RESET_PASSWORD_TOKEN,\n                    enforcingAdmin,\n                    userId);\n            if (currentTokenHandle != null && currentTokenHandle != 0) {\n                result = resetPasswordInternal(password, currentTokenHandle, token, flags, caller);\n            } else {\n                Slogf.w(LOG_TAG, \"No saved token handle\");\n            }\n        } else {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                DevicePolicyData policy = getUserData(userId);\n                if (policy.mPasswordTokenHandle != 0) {\n                    result = resetPasswordInternal(\n                            password, policy.mPasswordTokenHandle, token, flags, caller);\n                } else {\n                    Slogf.w(LOG_TAG, \"No saved token handle\");\n                }\n            }\n        }\n\n        if (result) {\n            if (isUnicornFlagEnabled()) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD_WITH_TOKEN)\n                        .setAdmin(callerPackageName)\n                        .write();\n            } else {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD_WITH_TOKEN)\n                        .setAdmin(caller.getComponentName())\n                        .write();\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public boolean isCurrentInputMethodSetByOwner() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller) || isSystemUid(caller),\n                \"Only profile owner, device owner and system may call this method.\");\n        return getUserData(caller.getUserId()).mCurrentInputMethodSet;\n    }\n\n    @Override\n    public StringParceledListSlice getOwnerInstalledCaCerts(@NonNull UserHandle user) {\n        final int userId = user.getIdentifier();\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                (isProfileOwner(caller) || isDefaultDeviceOwner(caller) || canQueryAdminPolicy(\n                        caller)) && hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return new StringParceledListSlice(\n                    new ArrayList<>(getUserData(userId).mOwnerInstalledCaCerts));\n        }\n    }\n\n    @Override\n    public void clearApplicationUserData(ComponentName admin, String packageName,\n            IPackageDataObserver callback) {\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Objects.requireNonNull(packageName, \"packageName is null\");\n        Objects.requireNonNull(callback, \"callback is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_CLEAR_APPLICATION_USER_DATA);\n\n        long ident = mInjector.binderClearCallingIdentity();\n        try {\n            ActivityManager.getService().clearApplicationUserData(packageName, false, callback,\n                    caller.getUserId());\n        } catch(RemoteException re) {\n            // Same process, should not happen.\n        } catch (SecurityException se) {\n            // This can happen e.g. for device admin packages, do not throw out the exception,\n            // because callers have no means to know beforehand for which packages this might\n            // happen. If so, we send back that removal failed.\n            Slogf.w(LOG_TAG, \"Not allowed to clear application user data for package \"\n                    + packageName, se);\n            try {\n                callback.onRemoveCompleted(packageName, false);\n            } catch (RemoteException re) {\n                // Caller is no longer available, ignore\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public void setLogoutEnabled(ComponentName admin, boolean enabled) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOGOUT_ENABLED);\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner.isLogoutEnabled == enabled) {\n                // already in the requested state\n                return;\n            }\n            deviceOwner.isLogoutEnabled = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n    }\n\n    @Override\n    public boolean isLogoutEnabled() {\n        if (!mHasFeature) {\n            return false;\n        }\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return (deviceOwner != null) && deviceOwner.isLogoutEnabled;\n        }\n    }\n\n    @Override\n    public List<String> getDisallowedSystemApps(ComponentName admin, int userId,\n            String provisioningAction) throws RemoteException {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return new ArrayList<>(\n                mOverlayPackagesProvider.getNonRequiredApps(admin, userId, provisioningAction));\n    }\n\n    @Override\n    public void transferOwnership(@NonNull ComponentName admin, @NonNull ComponentName target,\n            @Nullable PersistableBundle bundle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        Objects.requireNonNull(target, \"Target cannot be null.\");\n        Preconditions.checkArgument(!admin.equals(target),\n                \"Provided administrator and target are the same object.\");\n        Preconditions.checkArgument(!admin.getPackageName().equals(target.getPackageName()),\n                \"Provided administrator and target have the same package name.\");\n        if (bundle != null) {\n            enforceMaxStringLength(bundle, \"bundle\");\n        }\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n        final int callingUserId = caller.getUserId();\n        final DevicePolicyData policy = getUserData(callingUserId);\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(target, callingUserId,\n                /* throwForMissingPermission= */ true);\n        checkActiveAdminPrecondition(target, incomingDeviceInfo, policy);\n        Preconditions.checkArgument(incomingDeviceInfo.supportsTransferOwnership(),\n                \"Provided target does not support ownership transfer.\");\n\n        final long id = mInjector.binderClearCallingIdentity();\n        String ownerType = null;\n        try {\n            synchronized (getLockObject()) {\n                /*\n                * We must ensure the whole process is atomic to prevent the device from ending up\n                * in an invalid state (e.g. no active admin). This could happen if the device\n                * is rebooted or work mode is turned off mid-transfer.\n                * In order to guarantee atomicity, we:\n                *\n                * 1. Save an atomic journal file describing the transfer process\n                * 2. Perform the transfer itself\n                * 3. Delete the journal file\n                *\n                * That way if the journal file exists on device boot, we know that the transfer\n                * must be reverted back to the original administrator. This logic is implemented in\n                * revertTransferOwnershipIfNecessaryLocked.\n                * */\n                if (bundle == null) {\n                    bundle = new PersistableBundle();\n                }\n                if (isProfileOwner(caller)) {\n                    ownerType = ADMIN_TYPE_PROFILE_OWNER;\n                    prepareTransfer(admin, target, bundle, callingUserId,\n                            ADMIN_TYPE_PROFILE_OWNER);\n                    transferProfileOwnershipLocked(admin, target, callingUserId);\n                    sendProfileOwnerCommand(DeviceAdminReceiver.ACTION_TRANSFER_OWNERSHIP_COMPLETE,\n                            getTransferOwnershipAdminExtras(bundle), callingUserId);\n                    postTransfer(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED, callingUserId);\n                    if (isUserAffiliatedWithDeviceLocked(callingUserId)) {\n                        notifyAffiliatedProfileTransferOwnershipComplete(callingUserId);\n                    }\n                } else if (isDefaultDeviceOwner(caller)) {\n                    ownerType = ADMIN_TYPE_DEVICE_OWNER;\n                    prepareTransfer(admin, target, bundle, callingUserId,\n                            ADMIN_TYPE_DEVICE_OWNER);\n                    transferDeviceOwnershipLocked(admin, target, callingUserId);\n                    sendDeviceOwnerCommand(DeviceAdminReceiver.ACTION_TRANSFER_OWNERSHIP_COMPLETE,\n                            getTransferOwnershipAdminExtras(bundle));\n                    postTransfer(DevicePolicyManager.ACTION_DEVICE_OWNER_CHANGED, callingUserId);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.TRANSFER_OWNERSHIP)\n                .setAdmin(admin)\n                .setStrings(target.getPackageName(), ownerType)\n                .write();\n    }\n\n    private void prepareTransfer(ComponentName admin, ComponentName target,\n            PersistableBundle bundle, int callingUserId, String adminType) {\n        saveTransferOwnershipBundleLocked(bundle, callingUserId);\n        mTransferOwnershipMetadataManager.saveMetadataFile(\n                new TransferOwnershipMetadataManager.Metadata(admin, target,\n                        callingUserId, adminType));\n    }\n\n    private void postTransfer(String broadcast, int callingUserId) {\n        deleteTransferOwnershipMetadataFileLocked();\n        sendOwnerChangedBroadcast(broadcast, callingUserId);\n    }\n\n    private void notifyAffiliatedProfileTransferOwnershipComplete(int callingUserId) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(callingUserId));\n        sendDeviceOwnerCommand(\n                DeviceAdminReceiver.ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE, extras);\n    }\n\n    /**\n     * Transfers the profile owner for user with id profileOwnerUserId from admin to target.\n     */\n    private void transferProfileOwnershipLocked(ComponentName admin, ComponentName target,\n            int profileOwnerUserId) {\n        transferActiveAdminUncheckedLocked(target, admin, profileOwnerUserId);\n        mOwners.transferProfileOwner(target, profileOwnerUserId);\n        Slogf.i(LOG_TAG, \"Profile owner set: \" + target + \" on user \" + profileOwnerUserId);\n        mOwners.writeProfileOwner(profileOwnerUserId);\n        mDeviceAdminServiceController.startServiceForAdmin(\n                target.getPackageName(), profileOwnerUserId, \"transfer-profile-owner\");\n    }\n\n    /**\n     * Transfers the device owner for user with id userId from admin to target.\n     */\n    private void transferDeviceOwnershipLocked(ComponentName admin, ComponentName target, int userId) {\n        transferActiveAdminUncheckedLocked(target, admin, userId);\n        mOwners.transferDeviceOwnership(target);\n        Slogf.i(LOG_TAG, \"Device owner set: \" + target + \" on user \" + userId);\n        mOwners.writeDeviceOwner();\n        mDeviceAdminServiceController.startServiceForAdmin(\n                target.getPackageName(), userId, \"transfer-device-owner\");\n    }\n\n    private Bundle getTransferOwnershipAdminExtras(PersistableBundle bundle) {\n        Bundle extras = new Bundle();\n        if (bundle != null) {\n            extras.putParcelable(EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE, bundle);\n        }\n        return extras;\n    }\n\n    @Override\n    public void setStartUserSessionMessage(\n            ComponentName admin, CharSequence startUserSessionMessage) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final String startUserSessionMessageString =\n                startUserSessionMessage != null ? startUserSessionMessage.toString() : null;\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (TextUtils.equals(deviceOwner.startUserSessionMessage, startUserSessionMessage)) {\n                return;\n            }\n            deviceOwner.startUserSessionMessage = startUserSessionMessageString;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.getActivityManagerInternal()\n                .setSwitchingFromSystemUserMessage(startUserSessionMessageString);\n    }\n\n    @Override\n    public void setEndUserSessionMessage(ComponentName admin, CharSequence endUserSessionMessage) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final String endUserSessionMessageString =\n                endUserSessionMessage != null ? endUserSessionMessage.toString() : null;\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (TextUtils.equals(deviceOwner.endUserSessionMessage, endUserSessionMessage)) {\n                return;\n            }\n            deviceOwner.endUserSessionMessage = endUserSessionMessageString;\n            saveSettingsLocked(caller.getUserId());\n        }\n\n        mInjector.getActivityManagerInternal()\n                .setSwitchingToSystemUserMessage(endUserSessionMessageString);\n    }\n\n    @Override\n    public String getStartUserSessionMessage(ComponentName admin) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return deviceOwner.startUserSessionMessage;\n        }\n    }\n\n    @Override\n    public String getEndUserSessionMessage(ComponentName admin) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            return deviceOwner.endUserSessionMessage;\n        }\n    }\n\n    private void deleteTransferOwnershipMetadataFileLocked() {\n        mTransferOwnershipMetadataManager.deleteMetadataFile();\n    }\n\n    @Override\n    @Nullable\n    public PersistableBundle getTransferOwnershipBundle() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller));\n\n        synchronized (getLockObject()) {\n            final int callingUserId = caller.getUserId();\n            final File bundleFile = new File(\n                    mPathProvider.getUserSystemDirectory(callingUserId),\n                    TRANSFER_OWNERSHIP_PARAMETERS_XML);\n            if (!bundleFile.exists()) {\n                return null;\n            }\n            try (FileInputStream stream = new FileInputStream(bundleFile)) {\n                TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                parser.next();\n                return PersistableBundle.restoreFromXml(parser);\n            } catch (IOException | XmlPullParserException | IllegalArgumentException e) {\n                Slogf.e(LOG_TAG, \"Caught exception while trying to load the \"\n                        + \"owner transfer parameters from file \" + bundleFile, e);\n                return null;\n            }\n        }\n    }\n\n    @Override\n    public int addOverrideApn(@NonNull ComponentName who, @NonNull ApnSetting apnSetting) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return -1;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(apnSetting, \"ApnSetting is null in addOverrideApn\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        if (apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.addDevicePolicyOverrideApn(mContext, apnSetting));\n        } else {\n            Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to add override apn\");\n            return INVALID_APN_ID;\n        }\n    }\n\n    @Override\n    public boolean updateOverrideApn(@NonNull ComponentName who, int apnId,\n            @NonNull ApnSetting apnSetting) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(apnSetting, \"ApnSetting is null in updateOverrideApn\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        ApnSetting apn = getApnSetting(apnId);\n        if (apn != null && apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE\n                && apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        if (apnId < 0) {\n            return false;\n        }\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.modifyDevicePolicyOverrideApn(mContext, apnId, apnSetting));\n        } else {\n            Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to modify override apn\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean removeOverrideApn(@NonNull ComponentName who, int apnId) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        ApnSetting apn = getApnSetting(apnId);\n        if (apn != null && apn.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isManagedProfileOwner(caller));\n        } else {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n        return removeOverrideApnUnchecked(apnId);\n    }\n\n    private boolean removeOverrideApnUnchecked(int apnId) {\n        if(apnId < 0) {\n            return false;\n        }\n        int numDeleted = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().delete(\n                        Uri.withAppendedPath(DPC_URI, Integer.toString(apnId)), null, null));\n        return numDeleted > 0;\n    }\n\n    private ApnSetting getApnSetting(int apnId) {\n        if (apnId < 0) {\n            return null;\n        }\n        ApnSetting apnSetting = null;\n        Cursor cursor = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().query(\n                        Uri.withAppendedPath(DPC_URI, Integer.toString(apnId)), null, null, null,\n                        Telephony.Carriers.DEFAULT_SORT_ORDER));\n        if (cursor != null) {\n            while (cursor.moveToNext()) {\n                apnSetting = ApnSetting.makeApnSetting(cursor);\n                if (apnSetting != null) {\n                    break;\n                }\n            }\n            cursor.close();\n        }\n        return apnSetting;\n    }\n\n    @Override\n    public List<ApnSetting> getOverrideApns(@NonNull ComponentName who) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isManagedProfileOwner(caller));\n        List<ApnSetting> apnSettings = getOverrideApnsUnchecked();\n        if (isProfileOwner(caller)) {\n            List<ApnSetting> apnSettingList = new ArrayList<>();\n            for (ApnSetting apnSetting : apnSettings) {\n                if (apnSetting.getApnTypeBitmask() == ApnSetting.TYPE_ENTERPRISE) {\n                    apnSettingList.add(apnSetting);\n                }\n            }\n            return apnSettingList;\n        } else {\n            return apnSettings;\n        }\n    }\n\n    private List<ApnSetting> getOverrideApnsUnchecked() {\n        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);\n        if (tm != null) {\n            return mInjector.binderWithCleanCallingIdentity(\n                    () -> tm.getDevicePolicyOverrideApns(mContext));\n        }\n        Slogf.w(LOG_TAG, \"TelephonyManager is null when trying to get override apns\");\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setOverrideApnsEnabled(@NonNull ComponentName who, boolean enabled) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_OVERRIDE_APNS_ENABLED);\n\n        setOverrideApnsEnabledUnchecked(enabled);\n    }\n\n    private void setOverrideApnsEnabledUnchecked(boolean enabled) {\n        ContentValues value = new ContentValues();\n        value.put(ENFORCE_KEY, enabled);\n        mInjector.binderWithCleanCallingIdentity(() -> mContext.getContentResolver().update(\n                    ENFORCE_MANAGED_URI, value, null, null));\n    }\n\n    @Override\n    public boolean isOverrideApnEnabled(@NonNull ComponentName who) {\n        if (!mHasFeature || !mHasTelephonyFeature) {\n            return false;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        Cursor enforceCursor = mInjector.binderWithCleanCallingIdentity(\n                () -> mContext.getContentResolver().query(\n                        ENFORCE_MANAGED_URI, null, null, null, null));\n\n        if (enforceCursor == null) {\n            return false;\n        }\n        try {\n            if (enforceCursor.moveToFirst()) {\n                return enforceCursor.getInt(enforceCursor.getColumnIndex(ENFORCE_KEY)) == 1;\n            }\n        } catch (IllegalArgumentException e) {\n            Slogf.e(LOG_TAG, \"Cursor returned from ENFORCE_MANAGED_URI doesn't contain \"\n                    + \"correct info.\", e);\n        } finally {\n            enforceCursor.close();\n        }\n        return false;\n    }\n\n    @VisibleForTesting\n    void saveTransferOwnershipBundleLocked(PersistableBundle bundle, int userId) {\n        final File parametersFile = new File(\n                mPathProvider.getUserSystemDirectory(userId),\n                TRANSFER_OWNERSHIP_PARAMETERS_XML);\n        final AtomicFile atomicFile = new AtomicFile(parametersFile);\n        FileOutputStream stream = null;\n        try {\n            stream = atomicFile.startWrite();\n            final TypedXmlSerializer serializer = Xml.resolveSerializer(stream);\n            serializer.startDocument(null, true);\n            serializer.startTag(null, TAG_TRANSFER_OWNERSHIP_BUNDLE);\n            bundle.saveToXml(serializer);\n            serializer.endTag(null, TAG_TRANSFER_OWNERSHIP_BUNDLE);\n            serializer.endDocument();\n            atomicFile.finishWrite(stream);\n        } catch (IOException | XmlPullParserException e) {\n            Slogf.e(LOG_TAG, \"Caught exception while trying to save the \"\n                    + \"owner transfer parameters to file \" + parametersFile, e);\n            parametersFile.delete();\n            atomicFile.failWrite(stream);\n        }\n    }\n\n    void deleteTransferOwnershipBundleLocked(int userId) {\n        final File parametersFile = new File(mPathProvider.getUserSystemDirectory(userId),\n                TRANSFER_OWNERSHIP_PARAMETERS_XML);\n        parametersFile.delete();\n    }\n\n    private void logPasswordQualitySetIfSecurityLogEnabled(ComponentName who, int userId,\n            boolean parent, PasswordPolicy passwordPolicy) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_SET, who.getPackageName(),\n                    userId, affectedUserId, passwordPolicy.length, passwordPolicy.quality,\n                    passwordPolicy.letters, passwordPolicy.nonLetter, passwordPolicy.numeric,\n                    passwordPolicy.upperCase, passwordPolicy.lowerCase, passwordPolicy.symbols);\n        }\n    }\n\n    private static String getManagedProvisioningPackage(Context context) {\n        return context.getResources().getString(R.string.config_managed_provisioning_package);\n    }\n\n    private void putPrivateDnsSettings(int mode, @Nullable String host) {\n        // Set Private DNS settings using system permissions, as apps cannot write\n        // to global settings.\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            ConnectivitySettingsManager.setPrivateDnsMode(mContext, mode);\n            ConnectivitySettingsManager.setPrivateDnsHostname(mContext, host);\n        });\n    }\n\n    @Override\n    public int setGlobalPrivateDns(@NonNull ComponentName who, int mode, String privateDnsHost) {\n        if (!mHasFeature) {\n            return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        checkAllUsersAreAffiliatedWithDevice();\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_GLOBAL_PRIVATE_DNS);\n\n        switch (mode) {\n            case PRIVATE_DNS_MODE_OPPORTUNISTIC:\n                if (!TextUtils.isEmpty(privateDnsHost)) {\n                    throw new IllegalArgumentException(\n                            \"Host provided for opportunistic mode, but is not needed.\");\n                }\n                putPrivateDnsSettings(ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC,\n                        null);\n                return PRIVATE_DNS_SET_NO_ERROR;\n            case PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:\n                if (TextUtils.isEmpty(privateDnsHost)\n                        || !NetworkUtilsInternal.isWeaklyValidatedHostname(privateDnsHost)) {\n                    throw new IllegalArgumentException(\n                            String.format(\"Provided hostname %s is not valid\", privateDnsHost));\n                }\n\n                // Connectivity check will have been performed in the DevicePolicyManager before\n                // the call here.\n                putPrivateDnsSettings(\n                        ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME,\n                        privateDnsHost);\n                return PRIVATE_DNS_SET_NO_ERROR;\n            default:\n                throw new IllegalArgumentException(\n                        String.format(\"Provided mode, %d, is not a valid mode.\", mode));\n        }\n    }\n\n    @Override\n    public int getGlobalPrivateDnsMode(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return PRIVATE_DNS_MODE_UNKNOWN;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n\n        final int currentMode = ConnectivitySettingsManager.getPrivateDnsMode(mContext);\n        switch (currentMode) {\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF:\n                return PRIVATE_DNS_MODE_OFF;\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC:\n                return PRIVATE_DNS_MODE_OPPORTUNISTIC;\n            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:\n                return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\n        }\n\n        return PRIVATE_DNS_MODE_UNKNOWN;\n    }\n\n    @Override\n    public String getGlobalPrivateDnsHost(@NonNull ComponentName who) {\n        if (!mHasFeature) {\n            return null;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        return mInjector.settingsGlobalGetString(PRIVATE_DNS_SPECIFIER);\n    }\n\n    @Override\n    public void installUpdateFromFile(ComponentName admin, String callerPackageName,\n            ParcelFileDescriptor updateFileDescriptor, StartInstallingUpdateCallback callback) {\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(admin, \"ComponentName is null\");\n        }\n\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(admin, callerPackageName);\n            enforcePermission(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            caller = getCallerIdentity(admin);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_SYSTEM_UPDATE);\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.INSTALL_SYSTEM_UPDATE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(isDeviceAB())\n                .write();\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            UpdateInstaller updateInstaller;\n            if (isDeviceAB()) {\n                updateInstaller = new AbUpdateInstaller(\n                        mContext, updateFileDescriptor, callback, mInjector, mConstants);\n            } else {\n                updateInstaller = new NonAbUpdateInstaller(\n                        mContext, updateFileDescriptor, callback, mInjector, mConstants);\n            }\n            updateInstaller.startInstallUpdate();\n        });\n    }\n\n    private boolean isDeviceAB() {\n        return \"true\".equalsIgnoreCase(android.os.SystemProperties\n                .get(AB_DEVICE_KEY, \"\"));\n    }\n\n    @Override\n    public void setCrossProfileCalendarPackages(ComponentName who, List<String> packageNames) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            admin.mCrossProfileCalendarPackages = packageNames;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_CALENDAR_PACKAGES)\n                .setAdmin(who)\n                .setStrings(packageNames == null ? null\n                        : packageNames.toArray(new String[packageNames.size()]))\n                .write();\n    }\n\n    @Override\n    public List<String> getCrossProfileCalendarPackages(ComponentName who) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mCrossProfileCalendarPackages;\n        }\n    }\n\n    @Override\n    public boolean isPackageAllowedToAccessCalendarForUser(String packageName,\n            @UserIdInt int userId) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name is null or empty\");\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final int packageUid;\n        try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n            var packageState = snapshot.getPackageStates().get(packageName);\n            if (packageState == null) {\n                Slogf.w(LOG_TAG, \"Couldn't find package %s in user %d\", packageName,\n                        userId);\n                return false;\n            } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                Slogf.w(LOG_TAG, \"Couldn't find installed package %s in user %d\", packageName,\n                        userId);\n                return false;\n            } else {\n                packageUid = UserHandle.getUid(userId, packageState.getAppId());\n            }\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        if (caller.getUid() != packageUid) {\n            Preconditions.checkCallAuthorization(\n                    hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS)\n                            || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL));\n        }\n\n        synchronized (getLockObject()) {\n            if (mInjector.settingsSecureGetIntForUser(\n                    Settings.Secure.CROSS_PROFILE_CALENDAR_ENABLED, 0, userId) == 0) {\n                return false;\n            }\n            final ActiveAdmin admin = getProfileOwnerAdminLocked(userId);\n            if (admin != null) {\n                if (admin.mCrossProfileCalendarPackages == null) {\n                    return true;\n                }\n                return admin.mCrossProfileCalendarPackages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public List<String> getCrossProfileCalendarPackagesForUser(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS)\n                        || hasCallingOrSelfPermission(permission.INTERACT_ACROSS_USERS_FULL));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerAdminLocked(userHandle);\n            if (admin != null) {\n                return admin.mCrossProfileCalendarPackages;\n            }\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public void setCrossProfilePackages(ComponentName who, List<String> packageNames) {\n        if (!mHasFeature) {\n            return;\n        }\n\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Objects.requireNonNull(packageNames, \"Package names is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final List<String> previousCrossProfilePackages;\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            previousCrossProfilePackages = admin.mCrossProfilePackages;\n            if (packageNames.equals(previousCrossProfilePackages)) {\n                return;\n            }\n            admin.mCrossProfilePackages = packageNames;\n            saveSettingsLocked(caller.getUserId());\n        }\n        logSetCrossProfilePackages(who, packageNames);\n        final CrossProfileApps crossProfileApps =\n                mContext.createContextAsUser(\n                        caller.getUserHandle(), /* flags= */ 0)\n                        .getSystemService(CrossProfileApps.class);\n        mInjector.binderWithCleanCallingIdentity(\n        () -> crossProfileApps.resetInteractAcrossProfilesAppOps(\n                        previousCrossProfilePackages, new HashSet<>(packageNames)));\n    }\n\n    private void logSetCrossProfilePackages(ComponentName who, List<String> packageNames) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_PACKAGES)\n                .setAdmin(who)\n                .setStrings(packageNames.toArray(new String[packageNames.size()]))\n                .write();\n    }\n\n    @Override\n    public List<String> getCrossProfilePackages(ComponentName who) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mCrossProfilePackages;\n        }\n    }\n\n    @Override\n    public List<String> getAllCrossProfilePackages(int userId) {\n        if (!mHasFeature) {\n            return Collections.emptyList();\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                isSystemUid(caller) || isRootUid(caller) || hasCallingPermission(\n                        permission.INTERACT_ACROSS_USERS) || hasCallingPermission(\n                        permission.INTERACT_ACROSS_USERS_FULL) || hasPermissionForPreflight(\n                                                caller, permission.INTERACT_ACROSS_PROFILES));\n\n        synchronized (getLockObject()) {\n            final List<ActiveAdmin> admins = getProfileOwnerAdminsForProfileGroup(userId);\n            final List<String> packages = getCrossProfilePackagesForAdmins(admins);\n\n            packages.addAll(getDefaultCrossProfilePackages());\n\n            return packages;\n        }\n    }\n\n    private List<String> getCrossProfilePackagesForAdmins(List<ActiveAdmin> admins) {\n        final List<String> packages = new ArrayList<>();\n        for (int i = 0; i < admins.size(); i++) {\n            packages.addAll(admins.get(i).mCrossProfilePackages);\n        }\n        return packages;\n    }\n\n    @Override\n    public List<String> getDefaultCrossProfilePackages() {\n        Set<String> crossProfilePackages = new HashSet<>();\n\n        Collections.addAll(crossProfilePackages, mContext.getResources()\n                .getStringArray(R.array.cross_profile_apps));\n        Collections.addAll(crossProfilePackages, mContext.getResources()\n                .getStringArray(R.array.vendor_cross_profile_apps));\n\n        return new ArrayList<>(crossProfilePackages);\n    }\n\n    private List<ActiveAdmin> getProfileOwnerAdminsForProfileGroup(int userId) {\n        synchronized (getLockObject()) {\n            final List<ActiveAdmin> admins = new ArrayList<>();\n            int[] users = mUserManager.getProfileIdsWithDisabled(userId);\n            for (int i = 0; i < users.length; i++) {\n                final ComponentName componentName = getProfileOwnerAsUser(users[i]);\n                if (componentName != null) {\n                    ActiveAdmin admin = getActiveAdminUncheckedLocked(componentName, users[i]);\n                    if (admin != null) {\n                        admins.add(admin);\n                    }\n                }\n            }\n            return admins;\n        }\n    }\n\n    @Override\n    public boolean isManagedKiosk() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        long id = mInjector.binderClearCallingIdentity();\n        try {\n            return isManagedKioskInternal();\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private boolean isUnattendedManagedKioskUnchecked() {\n        try {\n            return isManagedKioskInternal()\n                    && getPowerManagerInternal().wasDeviceIdleFor(UNATTENDED_MANAGED_KIOSK_MS);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override\n    public boolean isUnattendedManagedKiosk() {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())\n                || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return mInjector.binderWithCleanCallingIdentity(() -> isUnattendedManagedKioskUnchecked());\n    }\n\n    /**\n     * Returns whether the device is currently being used as a publicly-accessible dedicated device.\n     * Assumes that feature checks and permission checks have already been performed, and that the\n     * calling identity has been cleared.\n     */\n    private boolean isManagedKioskInternal() throws RemoteException {\n        return mOwners.hasDeviceOwner()\n                && mInjector.getIActivityManager().getLockTaskModeState()\n                        == ActivityManager.LOCK_TASK_MODE_LOCKED\n                && !isLockTaskFeatureEnabled(DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO)\n                && !deviceHasKeyguard()\n                && !inEphemeralUserSession();\n    }\n\n    private boolean isLockTaskFeatureEnabled(int lockTaskFeature) throws RemoteException {\n        int lockTaskFeatures = 0;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            LockTaskPolicy policy = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.LOCK_TASK, getCurrentForegroundUserId());\n            lockTaskFeatures = policy == null\n                    // We default on the power button menu, in order to be consistent with pre-P\n                    // behaviour.\n                    ? DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS\n                    : policy.getFlags();\n        } else {\n            //TODO(b/175285301): Explicitly get the user's identity to check.\n            lockTaskFeatures =\n                    getUserData(getCurrentForegroundUserId()).mLockTaskFeatures;\n        }\n        return (lockTaskFeatures & lockTaskFeature) == lockTaskFeature;\n    }\n\n    private boolean deviceHasKeyguard() {\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            if (mLockPatternUtils.isSecure(userInfo.id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean inEphemeralUserSession() {\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            if (mInjector.getUserManager().isUserEphemeral(userInfo.id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private PowerManagerInternal getPowerManagerInternal() {\n        return mInjector.getPowerManagerInternal();\n    }\n\n    @Override\n    public boolean startViewCalendarEventInManagedProfile(String packageName, long eventId,\n            long start, long end, boolean allDay, int flags) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name is empty\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        if (!isCallingFromPackage(packageName, caller.getUid())) {\n            throw new SecurityException(\"Input package name doesn't align with actual \"\n                    + \"calling package.\");\n        }\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            final int workProfileUserId = getManagedUserId(caller.getUserId());\n            if (workProfileUserId < 0) {\n                return false;\n            }\n            if (!isPackageAllowedToAccessCalendarForUser(packageName, workProfileUserId)) {\n                Slogf.d(LOG_TAG, \"Package %s is not allowed to access cross-profile calendar APIs\",\n                        packageName);\n                return false;\n            }\n            final Intent intent = new Intent(\n                    CalendarContract.ACTION_VIEW_MANAGED_PROFILE_CALENDAR_EVENT);\n            intent.setPackage(packageName);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_ID, eventId);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, start);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end);\n            intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY, allDay);\n            intent.setFlags(flags);\n            try {\n                mContext.startActivityAsUser(intent, UserHandle.of(workProfileUserId));\n            } catch (ActivityNotFoundException e) {\n                Slogf.e(LOG_TAG, \"View event activity not found\", e);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    @Override\n    public void setApplicationExemptions(String callerPackage, String packageName,\n            int[] exemptions) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name cannot be empty.\");\n        Objects.requireNonNull(exemptions, \"Application exemptions must not be null.\");\n        Preconditions.checkArgument(areApplicationExemptionsValid(exemptions),\n                \"Invalid application exemption constant found in application exemptions set.\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS));\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        final ApplicationInfo packageInfo;\n        packageInfo = getPackageInfoWithNullCheck(packageName, caller);\n\n        for (Map.Entry<Integer, String> entry :\n                APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.entrySet()) {\n            int currentMode = mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    entry.getValue(), packageInfo.uid, packageInfo.packageName);\n            int newMode = ArrayUtils.contains(exemptions, entry.getKey())\n                    ? MODE_ALLOWED : MODE_DEFAULT;\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                if (currentMode != newMode) {\n                    mInjector.getAppOpsManager()\n                            .setMode(entry.getValue(),\n                                    packageInfo.uid,\n                                    packageName,\n                                    newMode);\n                }\n            });\n        }\n        String[] appOpExemptions = new String[exemptions.length];\n        for (int i = 0; i < exemptions.length; i++) {\n            appOpExemptions[i] = APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.get(exemptions[i]);\n        }\n        DevicePolicyEventLogger\n            .createEvent(DevicePolicyEnums.SET_APPLICATION_EXEMPTIONS)\n            .setAdmin(caller.getPackageName())\n            .setStrings(packageName, appOpExemptions)\n            .write();\n    }\n\n    @Override\n    public int[] getApplicationExemptions(String packageName) {\n        if (!mHasFeature) {\n            return new int[0];\n        }\n        Preconditions.checkStringNotEmpty(packageName, \"Package name cannot be empty.\");\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS));\n\n        final CallerIdentity caller = getCallerIdentity();\n        final ApplicationInfo packageInfo;\n        packageInfo = getPackageInfoWithNullCheck(packageName, caller);\n\n        IntArray appliedExemptions = new IntArray(0);\n        for (Map.Entry<Integer, String> entry :\n                APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.entrySet()) {\n            if (mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    entry.getValue(), packageInfo.uid, packageInfo.packageName) == MODE_ALLOWED) {\n                appliedExemptions.add(entry.getKey());\n            }\n        }\n        return appliedExemptions.toArray();\n    }\n\n    private ApplicationInfo getPackageInfoWithNullCheck(String packageName, CallerIdentity caller) {\n        final ApplicationInfo packageInfo =\n                mInjector.getPackageManagerInternal().getApplicationInfo(\n                        packageName,\n                        /* flags= */ 0,\n                        caller.getUid(),\n                        caller.getUserId());\n        if (packageInfo == null) {\n            throw new ServiceSpecificException(\n                    DevicePolicyManager.ERROR_PACKAGE_NAME_NOT_FOUND,\n                    \"Package name not found.\");\n        }\n        return packageInfo;\n    }\n\n    private boolean areApplicationExemptionsValid(int[] exemptions) {\n        for (int exemption : exemptions) {\n            if (!APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.containsKey(exemption)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isCallingFromPackage(String packageName, int callingUid) {\n        try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {\n            var packageState = snapshot.getPackageStates().get(packageName);\n            var userId = UserHandle.getUserId(callingUid);\n            if (packageState == null) {\n                Slogf.d(LOG_TAG, \"Calling UID \" + callingUid + \" not found\");\n                return false;\n            } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {\n                Slogf.d(LOG_TAG, \"Calling UID \" + callingUid + \" not installed\");\n                return false;\n            } else {\n                return callingUid == UserHandle.getUid(userId, packageState.getAppId());\n            }\n        }\n    }\n\n    private DevicePolicyConstants loadConstants() {\n        return DevicePolicyConstants.loadFromString(\n                mInjector.settingsGlobalGetString(Global.DEVICE_POLICY_CONSTANTS));\n    }\n\n    @Override\n    public void setUserControlDisabledPackages(ComponentName who, String callerPackageName,\n            List<String> packages) {\n        Objects.requireNonNull(packages, \"packages is null\");\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        checkCanExecuteOrThrowUnsafe(\n                DevicePolicyManager.OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            Binder.withCleanCallingIdentity(() -> {\n                if (packages.isEmpty()) {\n                    removeUserControlDisabledPackages(caller, enforcingAdmin);\n                } else {\n                    addUserControlDisabledPackages(caller, enforcingAdmin, new HashSet<>(packages));\n                }\n            });\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n                if (!Objects.equals(admin.protectedPackages, packages)) {\n                    admin.protectedPackages = packages.isEmpty() ? null : packages;\n                    saveSettingsLocked(caller.getUserId());\n                    pushUserControlDisabledPackagesLocked(caller.getUserId());\n                }\n            }\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USER_CONTROL_DISABLED_PACKAGES)\n                .setAdmin(caller.getPackageName())\n                .setStrings(packages.toArray(new String[packages.size()]))\n                .write();\n    }\n\n    private void addUserControlDisabledPackages(CallerIdentity caller,\n            EnforcingAdmin enforcingAdmin, Set<String> packages) {\n        if (isDeviceOwner(caller)) {\n            mDevicePolicyEngine.setGlobalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    new StringSetPolicyValue(packages));\n        } else {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    new StringSetPolicyValue(packages),\n                    caller.getUserId());\n        }\n    }\n\n    private void removeUserControlDisabledPackages(CallerIdentity caller,\n            EnforcingAdmin enforcingAdmin) {\n        if (isDeviceOwner(caller)) {\n            mDevicePolicyEngine.removeGlobalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin);\n        } else {\n            mDevicePolicyEngine.removeLocalPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    enforcingAdmin,\n                    caller.getUserId());\n        }\n    }\n\n    @Override\n    public List<String> getUserControlDisabledPackages(ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller;\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            enforceCanQuery(\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            // This retrieves the policy for the calling user only, DOs for example can't know\n            // what's enforced globally or on another user.\n            Set<String> packages = mDevicePolicyEngine.getResolvedPolicy(\n                    PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                    caller.getUserId());\n            return packages == null ? Collections.emptyList() : packages.stream().toList();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                    || isProfileOwner(caller) || isFinancedDeviceOwner(caller));\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(caller.getUserId());\n                return admin.protectedPackages != null\n                        ? admin.protectedPackages : Collections.emptyList();\n            }\n        }\n    }\n\n    @Override\n    public void setCommonCriteriaModeEnabled(ComponentName who, String callerPackageName,\n            boolean enabled) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n        }\n        final ActiveAdmin admin;\n\n        if (isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin enforcingAdmin = enforcePermissionAndGetEnforcingAdmin(\n                    who,\n                    MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                    caller.getPackageName(),\n                    caller.getUserId());\n            admin = enforcingAdmin.getActiveAdmin();\n        } else {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Common Criteria mode can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n            synchronized (getLockObject()) {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n        }\n        synchronized (getLockObject()) {\n            admin.mCommonCriteriaMode = enabled;\n            saveSettingsLocked(caller.getUserId());\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_COMMON_CRITERIA_MODE)\n                .setAdmin(caller.getPackageName())\n                .setBoolean(enabled)\n                .write();\n    }\n\n    @Override\n    public boolean isCommonCriteriaModeEnabled(ComponentName who) {\n        if (who != null) {\n            final CallerIdentity caller = getCallerIdentity(who);\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Common Criteria mode can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n\n            synchronized (getLockObject()) {\n                final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                return admin.mCommonCriteriaMode;\n            }\n        }\n\n        // Return aggregated state if caller is not admin (who == null).\n        synchronized (getLockObject()) {\n            // Only DO or COPE PO can turn on CC mode, so take a shortcut here and only look at\n            // their ActiveAdmin, instead of iterating through all admins.\n            ActiveAdmin admin;\n            // TODO(b/261999445): remove\n            if (isHeadlessFlagEnabled()) {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                        UserHandle.USER_SYSTEM);\n            }\n            return admin != null ? admin.mCommonCriteriaMode : false;\n        }\n    }\n\n    @Override\n    public @PersonalAppsSuspensionReason int getPersonalAppsSuspendedReasons(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // DO shouldn't be able to use this method.\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            final long deadline = admin.mProfileOffDeadline;\n            final int result = makeSuspensionReasons(admin.mSuspendPersonalApps,\n                    deadline != 0 && mInjector.systemCurrentTimeMillis() > deadline);\n            Slogf.d(LOG_TAG, \"getPersonalAppsSuspendedReasons user: %d; result: %d\",\n                    mInjector.userHandleGetCallingUserId(), result);\n            return result;\n        }\n    }\n\n    private @PersonalAppsSuspensionReason int makeSuspensionReasons(\n            boolean explicit, boolean timeout) {\n        int result = PERSONAL_APPS_NOT_SUSPENDED;\n        if (explicit) {\n            result |= PERSONAL_APPS_SUSPENDED_EXPLICITLY;\n        }\n        if (timeout) {\n            result |= PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\n        }\n        return result;\n    }\n\n    @Override\n    public void setPersonalAppsSuspended(ComponentName who, boolean suspended) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        Preconditions.checkState(canHandleCheckPolicyComplianceIntent(caller));\n\n        final int callingUserId = caller.getUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(callingUserId);\n            boolean shouldSaveSettings = false;\n            if (admin.mSuspendPersonalApps != suspended) {\n                admin.mSuspendPersonalApps = suspended;\n                shouldSaveSettings = true;\n            }\n            if (admin.mProfileOffDeadline != 0) {\n                admin.mProfileOffDeadline = 0;\n                shouldSaveSettings = true;\n            }\n            if (shouldSaveSettings) {\n                saveSettingsLocked(callingUserId);\n            }\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> updatePersonalAppsSuspension(\n                callingUserId));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PERSONAL_APPS_SUSPENDED)\n                .setAdmin(caller.getComponentName())\n                .setBoolean(suspended)\n                .write();\n    }\n\n    /** Starts an activity to check policy compliance or request compliance acknowledgement. */\n    private void triggerPolicyComplianceCheckIfNeeded(int profileUserId, boolean suspended) {\n        synchronized (getLockObject()) {\n            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner == null) {\n                Slogf.wtf(LOG_TAG, \"Profile owner not found for compliance check\");\n                return;\n            }\n            if (suspended) {\n                // If suspended, DPC will need to show an activity.\n                final Intent intent = new Intent(ACTION_CHECK_POLICY_COMPLIANCE);\n                intent.setPackage(profileOwner.info.getPackageName());\n                mContext.startActivityAsUser(intent, UserHandle.of(profileUserId));\n            } else if (profileOwner.mProfileOffDeadline > 0) {\n                // If not suspended, but deadline set, DPC needs to acknowledge compliance so that\n                // the deadline can be reset.\n                sendAdminCommandLocked(profileOwner, ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED,\n                        /* adminExtras= */ null, /* receiver= */ null, /* inForeground = */ true);\n            }\n        }\n    }\n\n    /**\n     * Checks whether personal apps should be suspended according to the policy and applies the\n     * change if needed.\n     */\n    private boolean updatePersonalAppsSuspension(int profileUserId) {\n        final boolean shouldSuspend;\n        synchronized (getLockObject()) {\n            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner != null) {\n                // Profile is considered \"off\" when it is either not running or is running locked\n                // or is in quiet mode, i.e. when the admin cannot sync policies or show UI.\n                boolean profileUserOff =\n                        !mUserManagerInternal.isUserUnlockingOrUnlocked(profileUserId)\n                        || mUserManager.isQuietModeEnabled(UserHandle.of(profileUserId));\n                final int notificationState = updateProfileOffDeadlineLocked(\n                        profileUserId, profileOwner, profileUserOff);\n                final boolean suspendedExplicitly = profileOwner.mSuspendPersonalApps;\n                final boolean suspendedByTimeout = profileOwner.mProfileOffDeadline == -1;\n                Slogf.d(LOG_TAG,\n                        \"Personal apps suspended explicitly: %b, by timeout: %b, notification: %d\",\n                        suspendedExplicitly, suspendedByTimeout, notificationState);\n                updateProfileOffDeadlineNotificationLocked(\n                        profileUserId, profileOwner, notificationState);\n                shouldSuspend = suspendedExplicitly || suspendedByTimeout;\n            } else {\n                shouldSuspend = false;\n            }\n        }\n\n        final int parentUserId = getProfileParentId(profileUserId);\n        suspendPersonalAppsInternal(parentUserId, profileUserId, shouldSuspend);\n        return shouldSuspend;\n    }\n\n    /**\n     * Checks work profile time off policy, scheduling personal apps suspension via alarm if\n     * necessary.\n     * @return notification state\n     */\n    private int updateProfileOffDeadlineLocked(\n            int profileUserId, ActiveAdmin profileOwner, boolean off) {\n        final long now = mInjector.systemCurrentTimeMillis();\n        if (profileOwner.mProfileOffDeadline != 0 && now > profileOwner.mProfileOffDeadline) {\n            Slogf.i(LOG_TAG, \"Profile off deadline has been reached, off: \" + off);\n            if (profileOwner.mProfileOffDeadline != -1) {\n                // Move the deadline far to the past so that it cannot be rolled back by TZ change.\n                profileOwner.mProfileOffDeadline = -1;\n                saveSettingsLocked(profileUserId);\n            }\n            return off ? PROFILE_OFF_NOTIFICATION_SUSPENDED : PROFILE_OFF_NOTIFICATION_NONE;\n        }\n        boolean shouldSaveSettings = false;\n        if (profileOwner.mSuspendPersonalApps) {\n            // When explicit suspension is active, deadline shouldn't be set.\n            if (profileOwner.mProfileOffDeadline != 0) {\n                profileOwner.mProfileOffDeadline = 0;\n                shouldSaveSettings = true;\n            }\n        } else if (profileOwner.mProfileOffDeadline != 0\n                && (profileOwner.mProfileMaximumTimeOffMillis == 0)) {\n            // There is a deadline but either there is no policy -> clear\n            // the deadline.\n            Slogf.i(LOG_TAG, \"Profile off deadline is reset to zero\");\n            profileOwner.mProfileOffDeadline = 0;\n            shouldSaveSettings = true;\n        } else if (profileOwner.mProfileOffDeadline == 0\n                && (profileOwner.mProfileMaximumTimeOffMillis != 0 && off)) {\n            // There profile is locked and there is a policy, but the deadline is not set -> set the\n            // deadline.\n            Slogf.i(LOG_TAG, \"Profile off deadline is set.\");\n            profileOwner.mProfileOffDeadline = now + profileOwner.mProfileMaximumTimeOffMillis;\n            shouldSaveSettings = true;\n        }\n\n        if (shouldSaveSettings) {\n            saveSettingsLocked(profileUserId);\n        }\n\n        final long alarmTime;\n        final int notificationState;\n        if (!off || profileOwner.mProfileOffDeadline == 0) {\n            alarmTime = 0;\n            notificationState = PROFILE_OFF_NOTIFICATION_NONE;\n        } else if (profileOwner.mProfileOffDeadline - now < MANAGED_PROFILE_OFF_WARNING_PERIOD) {\n            // The deadline is close, upon the alarm personal apps should be suspended.\n            alarmTime = profileOwner.mProfileOffDeadline;\n            notificationState = PROFILE_OFF_NOTIFICATION_WARNING;\n        } else {\n            // The deadline is quite far, upon the alarm we should warn the user first, so the\n            // alarm is scheduled earlier than the actual deadline.\n            alarmTime = profileOwner.mProfileOffDeadline - MANAGED_PROFILE_OFF_WARNING_PERIOD;\n            notificationState = PROFILE_OFF_NOTIFICATION_NONE;\n        }\n\n        final AlarmManager am = mInjector.getAlarmManager();\n        final Intent intent = new Intent(ACTION_PROFILE_OFF_DEADLINE);\n        intent.setPackage(mContext.getPackageName());\n        // Broadcast alarms sent by system are immutable\n        final PendingIntent pi = mInjector.pendingIntentGetBroadcast(\n                mContext, REQUEST_PROFILE_OFF_DEADLINE, intent,\n                PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                        | PendingIntent.FLAG_IMMUTABLE);\n\n        if (alarmTime == 0) {\n            Slogf.i(LOG_TAG, \"Profile off deadline alarm is removed.\");\n            am.cancel(pi);\n        } else {\n            Slogf.i(LOG_TAG, \"Profile off deadline alarm is set.\");\n            am.set(AlarmManager.RTC, alarmTime, pi);\n        }\n\n        return notificationState;\n    }\n\n    private void suspendPersonalAppsInternal(\n            int parentUserId, int profileUserId, boolean suspended) {\n        if (getUserData(parentUserId).mAppsSuspended == suspended) {\n            return;\n        }\n        Slogf.i(LOG_TAG, \"%s personal apps for user %d\", suspended ? \"Suspending\" : \"Unsuspending\",\n                parentUserId);\n\n        if (isPolicyEngineForFinanceFlagEnabled()) {\n            // TODO(b/280602237): migrate properly\n            ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);\n            if (profileOwner != null) {\n                EnforcingAdmin admin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        profileOwner.info.getComponent(),\n                        profileUserId,\n                        profileOwner);\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.PERSONAL_APPS_SUSPENDED,\n                        admin,\n                        new BooleanPolicyValue(suspended),\n                        parentUserId);\n            }\n        } else {\n            if (suspended) {\n                suspendPersonalAppsInPackageManager(parentUserId);\n            } else {\n                mInjector.getPackageManagerInternal().unsuspendForSuspendingPackage(\n                        PLATFORM_PACKAGE_NAME, parentUserId);\n            }\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(parentUserId).mAppsSuspended = suspended;\n            saveSettingsLocked(parentUserId);\n        }\n    }\n\n    private void suspendPersonalAppsInPackageManager(int userId) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final String[] appsToSuspend = mInjector.getPersonalAppsForSuspension(userId);\n            final String[] failedApps = mInjector.getPackageManagerInternal()\n                    .setPackagesSuspendedByAdmin(userId, appsToSuspend, true);\n            if (!ArrayUtils.isEmpty(failedApps)) {\n                Slogf.wtf(LOG_TAG, \"Failed to suspend apps: \" + String.join(\",\", failedApps));\n            }\n        });\n    }\n\n    private void notifyIfManagedSubscriptionsAreUnavailable(\n            UserHandle managedProfile, boolean managedProfileAvailable) {\n        if (!isManagedProfile(managedProfile.getIdentifier())) {\n            Slog.wtf(\n                    LOG_TAG,\n                    \"Expected managed profile when notified of profile availability change.\");\n        }\n        if (getManagedSubscriptionsPolicy().getPolicyType()\n                != ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            // There may be a subscription in the personal profile, in which case calls and\n            // texts may still be available. No need to notify the user.\n            return;\n        }\n        if (managedProfileAvailable) {\n            // When quiet mode is switched off calls and texts then become available to the user,\n            // so no need to keep showing the notification.\n            mInjector\n                    .getNotificationManager()\n                    .cancel(SystemMessage.NOTE_ALL_MANAGED_SUBSCRIPTIONS_AND_MANAGED_PROFILE_OFF);\n            return;\n        }\n        final Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        intent.putExtra(Intent.EXTRA_USER_HANDLE, managedProfile.getIdentifier());\n        final PendingIntent pendingIntent =\n                mInjector.pendingIntentGetBroadcast(\n                        mContext,\n                        /* requestCode= */ 0,\n                        intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n        final Notification.Action turnProfileOnButton =\n                new Notification.Action.Builder(\n                        /* icon= */ null, getUnpauseWorkAppsButtonText(), pendingIntent)\n                        .build();\n\n        final Bundle extras = new Bundle();\n        extras.putString(\n                Notification.EXTRA_SUBSTITUTE_APP_NAME, getWorkProfileContentDescription());\n        final Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(R.drawable.ic_phone_disabled)\n                        .setContentTitle(getUnpauseWorkAppsForTelephonyTitle())\n                        .setContentText(getUnpauseWorkAppsForTelephonyText())\n                        .setStyle(new Notification.BigTextStyle().bigText(\n                                getUnpauseWorkAppsForTelephonyText()))\n                        .addAction(turnProfileOnButton)\n                        .addExtras(extras)\n                        .setOngoing(false)\n                        .setShowWhen(true)\n                        .setAutoCancel(true)\n                        .build();\n\n        mInjector\n                .getNotificationManager()\n                .notifyAsUser(\n                        /* tag= */ null,\n                        SystemMessage.NOTE_ALL_MANAGED_SUBSCRIPTIONS_AND_MANAGED_PROFILE_OFF,\n                        notification,\n                        UserHandle.of(getProfileParentId(managedProfile.getIdentifier())));\n    }\n\n    private String getUnpauseWorkAppsButtonText() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON,\n                R.string.work_profile_telephony_paused_turn_on_button);\n    }\n\n    private String getUnpauseWorkAppsForTelephonyTitle() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_TITLE, R.string.work_profile_telephony_paused_title);\n    }\n\n    private String getUnpauseWorkAppsForTelephonyText() {\n        return getUpdatableString(\n                WORK_PROFILE_TELEPHONY_PAUSED_BODY,\n                R.string.work_profile_telephony_paused_text);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileOffDeadlineNotificationLocked(\n            int profileUserId, ActiveAdmin profileOwner, int notificationState) {\n        if (notificationState == PROFILE_OFF_NOTIFICATION_NONE) {\n            mInjector.getNotificationManager().cancel(SystemMessage.NOTE_PERSONAL_APPS_SUSPENDED);\n            return;\n        }\n\n        final Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        intent.setPackage(mContext.getPackageName());\n        intent.putExtra(Intent.EXTRA_USER_HANDLE, profileUserId);\n\n        // Simple notification action button clicks are immutable\n        final PendingIntent pendingIntent = mInjector.pendingIntentGetBroadcast(mContext,\n                0 /* requestCode */, intent,\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n\n        final Notification.Action turnProfileOnButton = new Notification.Action.Builder(\n                /* icon= */ null, getPersonalAppSuspensionButtonText(), pendingIntent).build();\n\n        final String text;\n        final boolean ongoing;\n        if (notificationState == PROFILE_OFF_NOTIFICATION_WARNING) {\n            // Round to the closest integer number of days.\n            final int maxDays = (int)\n                    ((profileOwner.mProfileMaximumTimeOffMillis + MS_PER_DAY / 2) / MS_PER_DAY);\n            final String date = DateUtils.formatDateTime(\n                    mContext, profileOwner.mProfileOffDeadline, DateUtils.FORMAT_SHOW_DATE);\n            final String time = DateUtils.formatDateTime(\n                    mContext, profileOwner.mProfileOffDeadline, DateUtils.FORMAT_SHOW_TIME);\n            text = getPersonalAppSuspensionSoonText(date, time, maxDays);\n            ongoing = false;\n        } else {\n            text = getPersonalAppSuspensionText();\n            ongoing = true;\n        }\n        final int color = mContext.getColor(R.color.personal_apps_suspension_notification_color);\n        final Bundle extras = new Bundle();\n        // TODO: Create a separate string for this.\n        extras.putString(\n                Notification.EXTRA_SUBSTITUTE_APP_NAME, getWorkProfileContentDescription());\n\n        final Notification notification =\n                new Notification.Builder(mContext, SystemNotificationChannels.DEVICE_ADMIN)\n                        .setSmallIcon(R.drawable.ic_corp_badge_no_background)\n                        .setOngoing(ongoing)\n                        .setAutoCancel(false)\n                        .setContentTitle(getPersonalAppSuspensionTitle())\n                        .setContentText(text)\n                        .setStyle(new Notification.BigTextStyle().bigText(text))\n                        .setColor(color)\n                        .addAction(turnProfileOnButton)\n                        .addExtras(extras)\n                        .build();\n\n        mHandler.post(() -> mInjector.getNotificationManager().notifyAsUser(\n                null, SystemMessage.NOTE_PERSONAL_APPS_SUSPENDED, notification,\n                UserHandle.of(getProfileParentId(profileUserId))));\n    }\n\n    private String getPersonalAppSuspensionButtonText() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE,\n                R.string.personal_apps_suspended_turn_profile_on);\n    }\n\n    private String getPersonalAppSuspensionTitle() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_TITLE, R.string.personal_apps_suspension_title);\n    }\n\n    private String getPersonalAppSuspensionText() {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_MESSAGE, R.string.personal_apps_suspension_text);\n    }\n\n    private String getPersonalAppSuspensionSoonText(String date, String time, int maxDays) {\n        return getUpdatableString(\n                PERSONAL_APP_SUSPENSION_SOON_MESSAGE, R.string.personal_apps_suspension_soon_text,\n                date, time, maxDays);\n    }\n\n    private String getWorkProfileContentDescription() {\n        return getUpdatableString(\n                NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION,\n                R.string.notification_work_profile_content_description);\n    }\n\n    @Override\n    public void setManagedProfileMaximumTimeOff(ComponentName who, long timeoutMillis) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        Preconditions.checkArgumentNonnegative(timeoutMillis, \"Timeout must be non-negative.\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        // DO shouldn't be able to use this method.\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        Preconditions.checkState(canHandleCheckPolicyComplianceIntent(caller));\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(userId);\n\n            // Ensure the timeout is long enough to avoid having bad user experience.\n            if (timeoutMillis > 0 && timeoutMillis < MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD\n                    && !isAdminTestOnlyLocked(who, userId)) {\n                timeoutMillis = MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD;\n            }\n            if (admin.mProfileMaximumTimeOffMillis == timeoutMillis) {\n                return;\n            }\n            admin.mProfileMaximumTimeOffMillis = timeoutMillis;\n            saveSettingsLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(\n                () -> updatePersonalAppsSuspension(userId));\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_MANAGED_PROFILE_MAXIMUM_TIME_OFF)\n                .setAdmin(caller.getComponentName())\n                .setTimePeriod(timeoutMillis)\n                .write();\n    }\n\n    private boolean canHandleCheckPolicyComplianceIntent(CallerIdentity caller) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            final Intent intent = new Intent(DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE);\n            intent.setPackage(caller.getPackageName());\n            final List<ResolveInfo> handlers =\n                    mInjector.getPackageManager().queryIntentActivitiesAsUser(intent, /* flags= */\n                            0, caller.getUserId());\n            return !handlers.isEmpty();\n        });\n        return true;\n    }\n\n    @Override\n    public long getManagedProfileMaximumTimeOff(ComponentName who) {\n        Objects.requireNonNull(who, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mProfileMaximumTimeOffMillis;\n        }\n    }\n\n    @Override\n    public void acknowledgeDeviceCompliant() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        enforceUserUnlocked(caller.getUserId());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (admin.mProfileOffDeadline > 0) {\n                admin.mProfileOffDeadline = 0;\n                saveSettingsLocked(caller.getUserId());\n            }\n        }\n    }\n\n    @Override\n    public boolean isComplianceAcknowledgementRequired() {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller));\n        enforceUserUnlocked(caller.getUserId());\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            return admin.mProfileOffDeadline != 0;\n        }\n    }\n\n    @Override\n    public boolean canProfileOwnerResetPasswordWhenLocked(int userId) {\n        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity()),\n                String.format(NOT_SYSTEM_CALLER_MSG,\n                        \"call canProfileOwnerResetPasswordWhenLocked\"));\n        synchronized (getLockObject()) {\n            final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(userId);\n            DevicePolicyData policy = getUserData(userId);\n            if (poAdmin == null\n                    || getEncryptionStatus() != ENCRYPTION_STATUS_ACTIVE_PER_USER\n                    || !isResetPasswordTokenActiveForUserLocked(\n                            policy.mPasswordTokenHandle, userId)) {\n                return false;\n            }\n            final ApplicationInfo poAppInfo;\n            try {\n                poAppInfo = mIPackageManager.getApplicationInfo(\n                        poAdmin.info.getPackageName(), 0 /* flags */, userId);\n            } catch (RemoteException e) {\n                Slogf.e(LOG_TAG, \"Failed to query PO app info\", e);\n                return false;\n            }\n            if (poAppInfo == null) {\n                Slogf.wtf(LOG_TAG, \"Cannot find AppInfo for profile owner\");\n                return false;\n            }\n            if (!poAppInfo.isEncryptionAware()) {\n                return false;\n            }\n            Slogf.d(LOG_TAG, \"PO should be able to reset password from direct boot\");\n            return true;\n        }\n    }\n\n    @Override\n    public String getEnrollmentSpecificId(String callerPackage) {\n        if (!mHasFeature) {\n            return \"\";\n        }\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(\n                isDefaultDeviceOwner(caller) || isProfileOwner(caller)\n                        || isCallerDelegate(caller, DELEGATION_CERT_INSTALL));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getDeviceOrProfileOwnerAdminLocked(\n                    caller.getUserId());\n            final String esid = requiredAdmin.mEnrollmentSpecificId;\n            return esid != null ? esid : \"\";\n        }\n    }\n\n    @Override\n    public void setOrganizationIdForUser(\n            @NonNull String callerPackage, @NonNull String organizationId, int userId) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(callerPackage);\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        // Only the DPC can set this ID.\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                \"Only a Device Owner or Profile Owner may set the Enterprise ID.\");\n        // Empty enterprise ID must not be provided in calls to this method.\n        Preconditions.checkArgument(!TextUtils.isEmpty(organizationId),\n                \"Enterprise ID may not be empty.\");\n\n        Slogf.i(LOG_TAG, \"Setting Enterprise ID to %s for user %d\", organizationId, userId);\n\n        synchronized (mESIDInitilizationLock) {\n            if (mEsidCalculator == null) {\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    mEsidCalculator = mInjector.newEnterpriseSpecificIdCalculator();\n                });\n            }\n        }\n\n        final String ownerPackage;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            // As the caller is the system, it must specify the component name of the profile owner\n            // as a safety check.\n            Preconditions.checkCallAuthorization(\n                    owner != null && owner.getUserHandle().getIdentifier() == userId,\n                    String.format(\"The Profile Owner or Device Owner may only set the Enterprise ID\"\n                            + \" on its own user, called on user %d but owner user is %d\", userId,\n                            owner.getUserHandle().getIdentifier()));\n            ownerPackage = owner.info.getPackageName();\n            Preconditions.checkState(\n                    TextUtils.isEmpty(owner.mOrganizationId) || owner.mOrganizationId.equals(\n                            organizationId),\n                    \"The organization ID has been previously set to a different value and cannot \"\n                            + \"be changed\");\n            final String dpcPackage = owner.info.getPackageName();\n            final String esid = mEsidCalculator.calculateEnterpriseId(dpcPackage,\n                    organizationId);\n            owner.mOrganizationId = organizationId;\n            owner.mEnrollmentSpecificId = esid;\n            saveSettingsLocked(userId);\n        }\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_ORGANIZATION_ID)\n                .setAdmin(ownerPackage)\n                .setBoolean(isManagedProfile(userId))\n                .write();\n    }\n\n    @Override\n    public void clearOrganizationIdForUser(int userHandle) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userHandle);\n            owner.mOrganizationId = null;\n            owner.mEnrollmentSpecificId = null;\n            saveSettingsLocked(userHandle);\n        }\n    }\n\n    @Override\n    public UserHandle createAndProvisionManagedProfile(\n            @NonNull ManagedProfileProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null\");\n\n        final ComponentName admin = provisioningParams.getProfileAdminComponentName();\n        Objects.requireNonNull(admin, \"admin is null\");\n\n        final CallerIdentity caller = getCallerIdentity(callerPackage);\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        provisioningParams.logParams(callerPackage);\n\n        UserInfo userInfo = null;\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_PROFILE, admin.getPackageName(), caller.getUserId());\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n\n            final long startTime = SystemClock.elapsedRealtime();\n\n            onCreateAndProvisionManagedProfileStarted(provisioningParams);\n\n            final Set<String> nonRequiredApps = provisioningParams.isLeaveAllSystemAppsEnabled()\n                    ? Collections.emptySet()\n                    : mOverlayPackagesProvider.getNonRequiredApps(\n                            admin, caller.getUserId(), ACTION_PROVISION_MANAGED_PROFILE);\n            if (nonRequiredApps.isEmpty()) {\n                Slogf.i(LOG_TAG, \"No disallowed packages for the managed profile.\");\n            } else {\n                for (String packageName : nonRequiredApps) {\n                    Slogf.i(LOG_TAG, \"Disallowed package [\" + packageName + \"]\");\n                }\n            }\n\n            userInfo = mUserManager.createProfileForUserEvenWhenDisallowed(\n                    provisioningParams.getProfileName(),\n                    UserManager.USER_TYPE_PROFILE_MANAGED,\n                    UserInfo.FLAG_DISABLED,\n                    caller.getUserId(),\n                    nonRequiredApps.toArray(new String[nonRequiredApps.size()]));\n            if (userInfo == null) {\n                throw new ServiceSpecificException(\n                        ERROR_PROFILE_CREATION_FAILED,\n                        \"Error creating profile, createProfileForUserEvenWhenDisallowed \"\n                                + \"returned null.\");\n            }\n            resetInteractAcrossProfilesAppOps(caller.getUserId());\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_CREATE_PROFILE_MS,\n                    startTime,\n                    callerPackage);\n\n            maybeInstallDevicePolicyManagementRoleHolderInUser(userInfo.id);\n\n            installExistingAdminPackage(userInfo.id, admin.getPackageName());\n            if (!enableAdminAndSetProfileOwner(userInfo.id, caller.getUserId(), admin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SETTING_PROFILE_OWNER_FAILED,\n                        \"Error setting profile owner.\");\n            }\n            setUserSetupComplete(userInfo.id);\n\n            startProfileForSetup(userInfo.id, callerPackage);\n            maybeMigrateAccount(\n                    userInfo.id, caller.getUserId(), provisioningParams.getAccountToMigrate(),\n                    provisioningParams.isKeepingAccountOnMigration(), callerPackage);\n\n            if (provisioningParams.isOrganizationOwnedProvisioning()) {\n                synchronized (getLockObject()) {\n                    setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(admin, userInfo.id,\n                            true);\n                }\n            }\n\n            onCreateAndProvisionManagedProfileCompleted(provisioningParams);\n\n            sendProvisioningCompletedBroadcast(\n                    userInfo.id,\n                    ACTION_PROVISION_MANAGED_PROFILE,\n                    provisioningParams.isLeaveAllSystemAppsEnabled());\n\n            return userInfo.getUserHandle();\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(callerPackage)\n                    .write();\n            // In case of any errors during provisioning, remove the newly created profile.\n            if (userInfo != null) {\n                mUserManager.removeUserEvenWhenDisallowed(userInfo.id);\n            }\n            throw e;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void finalizeWorkProfileProvisioning(UserHandle managedProfileUser,\n            Account migratedAccount) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        if (!isManagedProfile(managedProfileUser.getIdentifier())) {\n            throw new IllegalStateException(\"Given user is not a managed profile\");\n        }\n        ComponentName profileOwnerComponent =\n                mOwners.getProfileOwnerComponent(managedProfileUser.getIdentifier());\n        if (profileOwnerComponent == null) {\n            throw new IllegalStateException(\"There is no profile owner on the given profile\");\n        }\n        Intent primaryProfileSuccessIntent = new Intent(ACTION_MANAGED_PROFILE_PROVISIONED);\n        primaryProfileSuccessIntent.setPackage(profileOwnerComponent.getPackageName());\n        primaryProfileSuccessIntent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES\n                | Intent.FLAG_RECEIVER_FOREGROUND);\n        primaryProfileSuccessIntent.putExtra(Intent.EXTRA_USER, managedProfileUser);\n\n        if (migratedAccount != null) {\n            primaryProfileSuccessIntent.putExtra(EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE,\n                    migratedAccount);\n        }\n\n        mContext.sendBroadcastAsUser(primaryProfileSuccessIntent,\n                UserHandle.of(getProfileParentId(managedProfileUser.getIdentifier())));\n    }\n\n    /**\n     * Callback called at the beginning of {@link #createAndProvisionManagedProfile(\n     * ManagedProfileProvisioningParams, String)} after the relevant prechecks have passed.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onCreateAndProvisionManagedProfileStarted(\n            ManagedProfileProvisioningParams provisioningParams) {}\n\n    /**\n     * Callback called at the end of {@link #createAndProvisionManagedProfile(\n     * ManagedProfileProvisioningParams, String)} after all the other provisioning tasks\n     * have completed successfully.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onCreateAndProvisionManagedProfileCompleted(\n            ManagedProfileProvisioningParams provisioningParams) {}\n\n    private void maybeInstallDevicePolicyManagementRoleHolderInUser(int targetUserId) {\n        String devicePolicyManagerRoleHolderPackageName =\n                getRoleHolderPackageName(mContext, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT);\n        if (devicePolicyManagerRoleHolderPackageName == null) {\n            Slogf.d(LOG_TAG, \"No device policy management role holder specified.\");\n            return;\n        }\n        try {\n            if (mIPackageManager.isPackageAvailable(\n                    devicePolicyManagerRoleHolderPackageName, targetUserId)) {\n                Slogf.d(LOG_TAG, \"The device policy management role holder \"\n                        + devicePolicyManagerRoleHolderPackageName + \" is already installed in \"\n                        + \"user \" + targetUserId);\n                return;\n            }\n            Slogf.d(LOG_TAG, \"Installing the device policy management role holder \"\n                    + devicePolicyManagerRoleHolderPackageName + \" in user \" + targetUserId);\n            mIPackageManager.installExistingPackageAsUser(\n                    devicePolicyManagerRoleHolderPackageName,\n                    targetUserId,\n                    PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                    PackageManager.INSTALL_REASON_POLICY,\n                    /* whiteListedPermissions= */ null);\n        } catch (RemoteException e) {\n            // Does not happen, same process\n        }\n    }\n\n    /**\n     * If multiple packages hold the role, returns the first package in the list.\n     */\n    @Nullable\n    private String getRoleHolderPackageName(Context context, String role) {\n        return getRoleHolderPackageNameOnUser(context, role, Process.myUserHandle());\n    }\n\n    /**\n     * If multiple packages hold the role, returns the first package in the list.\n     */\n    @Nullable\n    private String getRoleHolderPackageNameOnUser(Context context, String role, UserHandle user) {\n        RoleManager roleManager = context.getSystemService(RoleManager.class);\n\n        // Calling identity needs to be cleared as this method is used in the permissions checks.\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<String> roleHolders = roleManager.getRoleHoldersAsUser(role, user);\n            if (roleHolders.isEmpty()) {\n                return null;\n            }\n            return roleHolders.get(0);\n        });\n    }\n\n    private boolean isCallerDevicePolicyManagementRoleHolder(CallerIdentity caller) {\n        return doesCallerHoldRole(caller, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT);\n    }\n\n    private boolean isCallerSystemSupervisionRoleHolder(CallerIdentity caller) {\n        return doesCallerHoldRole(caller, RoleManager.ROLE_SYSTEM_SUPERVISION);\n    }\n\n    /**\n     * Check if the caller is holding the given role on the calling user.\n     *\n     * @param caller the caller you wish to check\n     * @param role the name of the role to check for.\n     * @return {@code true} if the caller holds the role, {@code false} otherwise.\n     */\n    private boolean doesCallerHoldRole(CallerIdentity caller, String role) {\n        int callerUid = caller.getUid();\n        String roleHolderPackageName =\n                getRoleHolderPackageNameOnUser(role, caller.getUserId());\n        int roleHolderUid = mInjector.getPackageManagerInternal().getPackageUid(\n                roleHolderPackageName, 0, caller.getUserId());\n\n        return callerUid == roleHolderUid;\n    }\n\n    /**\n     * Return the package name of the role holder on the given user.\n     *\n     * <p>If the userId passed in is {@link UserHandle.USER_ALL} then every user will be checked and\n     * the package name of the role holder on the first user where there is a role holder is\n     * returned.\n     *\n     * @param role the name of the role to check for.\n     * @param userId the userId to check for the role holder on.\n     * @return the package name of the role holder\n     */\n    @Nullable\n    private String getRoleHolderPackageNameOnUser(String role, int userId) {\n        RoleManager roleManager = mContext.getSystemService(RoleManager.class);\n\n        // Clear calling identity as the RoleManager APIs require privileged permissions.\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<UserInfo> users;\n            // Interpret USER_ALL as meaning \"any\" user.\n            if (userId == UserHandle.USER_ALL) {\n                users = mInjector.getUserManagerInternal().getUsers(/*excludeDying=*/ true);\n            } else {\n                users = List.of(new UserInfo(userId, /*name=*/ null, /*flags=*/ 0));\n            }\n            for (UserInfo user : users) {\n                List<String> roleHolders =\n                        roleManager.getRoleHoldersAsUser(role, user.getUserHandle());\n                if (!roleHolders.isEmpty()) {\n                    return roleHolders.get(0);\n                }\n            }\n            return null;\n        });\n    }\n\n    private void resetInteractAcrossProfilesAppOps(@UserIdInt int userId) {\n        mInjector.getCrossProfileApps(userId).clearInteractAcrossProfilesAppOps();\n        pregrantDefaultInteractAcrossProfilesAppOps(userId);\n    }\n\n    private void pregrantDefaultInteractAcrossProfilesAppOps(@UserIdInt int userId) {\n        final String op =\n                AppOpsManager.permissionToOp(Manifest.permission.INTERACT_ACROSS_PROFILES);\n        for (String packageName : getConfigurableDefaultCrossProfilePackages(userId)) {\n            if (!appOpIsDefaultOrAllowed(userId, op, packageName)) {\n                continue;\n            }\n            mInjector.getCrossProfileApps(userId).setInteractAcrossProfilesAppOp(\n                    packageName, MODE_ALLOWED);\n        }\n    }\n\n    private Set<String> getConfigurableDefaultCrossProfilePackages(@UserIdInt int userId) {\n        List<String> defaultPackages = getDefaultCrossProfilePackages();\n        return defaultPackages.stream().filter(\n                mInjector.getCrossProfileApps(userId)::canConfigureInteractAcrossProfiles).collect(\n                Collectors.toSet());\n    }\n\n    private boolean appOpIsDefaultOrAllowed(@UserIdInt int userId, String op, String packageName) {\n        try {\n            final int uid = mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0).\n                    getPackageManager().getPackageUid(packageName, /* flags= */ 0);\n            int mode = mInjector.getAppOpsManager().unsafeCheckOpNoThrow(\n                    op, uid, packageName);\n            return mode == MODE_ALLOWED || mode == MODE_DEFAULT;\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    private void installExistingAdminPackage(int userId, String packageName) {\n        try {\n            final int status = mContext.getPackageManager().installExistingPackageAsUser(\n                    packageName,\n                    userId);\n            if (status != PackageManager.INSTALL_SUCCEEDED) {\n                throw new ServiceSpecificException(\n                        ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED,\n                        String.format(\"Failed to install existing package %s for user %d with \"\n                                        + \"result code %d\",\n                                packageName, userId, status));\n            }\n        } catch (NameNotFoundException e) {\n            throw new ServiceSpecificException(\n                    ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED,\n                    String.format(\"Failed to install existing package %s for user %d: %s\",\n                            packageName, userId, e.getMessage()));\n        }\n    }\n\n    private boolean enableAdminAndSetProfileOwner(\n            @UserIdInt int userId, @UserIdInt int callingUserId, ComponentName adminComponent) {\n        enableAndSetActiveAdmin(userId, callingUserId, adminComponent);\n        return setProfileOwner(adminComponent, userId);\n    }\n\n    private void enableAndSetActiveAdmin(\n            @UserIdInt int userId, @UserIdInt int callingUserId, ComponentName adminComponent) {\n        final String adminPackage = adminComponent.getPackageName();\n        enablePackage(adminPackage, callingUserId);\n        setActiveAdmin(adminComponent, /* refreshing= */ true, userId);\n    }\n\n    private void enablePackage(String packageName, @UserIdInt int userId) {\n        try {\n            final int enabledSetting = mIPackageManager.getApplicationEnabledSetting(\n                    packageName, userId);\n            if (enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT\n                    && enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {\n                mIPackageManager.setApplicationEnabledSetting(\n                        packageName,\n                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,\n                        // Device policy app may have launched ManagedProvisioning, play nice and\n                        // don't kill it as a side-effect of this call.\n                        PackageManager.DONT_KILL_APP,\n                        userId,\n                        mContext.getOpPackageName());\n            }\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error setting application enabled\", e);\n        }\n    }\n\n    private void setUserSetupComplete(@UserIdInt int userId) {\n        Settings.Secure.putIntForUser(\n                mContext.getContentResolver(), USER_SETUP_COMPLETE, 1, userId);\n    }\n\n    private void startProfileForSetup(@UserIdInt int userId, String callerPackage)\n            throws IllegalStateException {\n        Slogf.i(LOG_TAG, \"Starting profile %d as requested by package %s\", userId, callerPackage);\n        final long startTime = SystemClock.elapsedRealtime();\n        final UserUnlockedBlockingReceiver unlockedReceiver = new UserUnlockedBlockingReceiver(\n                userId);\n        mContext.registerReceiverAsUser(\n                unlockedReceiver,\n                new UserHandle(userId),\n                new IntentFilter(Intent.ACTION_USER_UNLOCKED),\n                /* broadcastPermission = */ null,\n                /* scheduler= */ null);\n        try {\n            // Must call startProfileEvenWhenDisabled(), as profile is not enabled yet\n            if (!mInjector.getActivityManagerInternal().startProfileEvenWhenDisabled(userId)) {\n                throw new ServiceSpecificException(ERROR_STARTING_PROFILE_FAILED,\n                        String.format(\"Unable to start user %d in background\", userId));\n            }\n\n            if (!unlockedReceiver.waitForUserUnlocked()) {\n                throw new ServiceSpecificException(ERROR_STARTING_PROFILE_FAILED,\n                        String.format(\"Timeout whilst waiting for unlock of user %d.\", userId));\n            }\n            logEventDuration(\n                    DevicePolicyEnums.PLATFORM_PROVISIONING_START_PROFILE_MS,\n                    startTime,\n                    callerPackage);\n        } finally {\n            mContext.unregisterReceiver(unlockedReceiver);\n        }\n    }\n\n    private void maybeMigrateAccount(\n            @UserIdInt int targetUserId, @UserIdInt int sourceUserId, Account accountToMigrate,\n            boolean keepAccountMigrated, String callerPackage) {\n        final UserHandle sourceUser = UserHandle.of(sourceUserId);\n        final UserHandle targetUser = UserHandle.of(targetUserId);\n        if (accountToMigrate == null) {\n            Slogf.d(LOG_TAG, \"No account to migrate.\");\n            return;\n        }\n        if (sourceUser.equals(targetUser)) {\n            Slogf.w(LOG_TAG, \"sourceUser and targetUser are the same, won't migrate account.\");\n            return;\n        }\n        copyAccount(targetUser, sourceUser, accountToMigrate, callerPackage);\n        if (!keepAccountMigrated) {\n            removeAccount(accountToMigrate, sourceUserId);\n        }\n    }\n\n    private void copyAccount(\n            UserHandle targetUser, UserHandle sourceUser, Account accountToMigrate,\n            String callerPackage) {\n        final long startTime = SystemClock.elapsedRealtime();\n        try {\n            final AccountManager accountManager = mContext.getSystemService(AccountManager.class);\n            final boolean copySucceeded = accountManager.copyAccountToUser(\n                    accountToMigrate,\n                    sourceUser,\n                    targetUser,\n                    /* callback= */ null, /* handler= */ null)\n                    .getResult(60 * 3, TimeUnit.SECONDS);\n            if (copySucceeded) {\n                logCopyAccountStatus(COPY_ACCOUNT_SUCCEEDED, callerPackage);\n                logEventDuration(\n                        DevicePolicyEnums.PLATFORM_PROVISIONING_COPY_ACCOUNT_MS,\n                        startTime,\n                        callerPackage);\n            } else {\n                logCopyAccountStatus(COPY_ACCOUNT_FAILED, callerPackage);\n                Slogf.e(LOG_TAG, \"Failed to copy account to \" + targetUser);\n            }\n        } catch (OperationCanceledException e) {\n            // Account migration is not considered a critical operation.\n            logCopyAccountStatus(COPY_ACCOUNT_TIMED_OUT, callerPackage);\n            Slogf.e(LOG_TAG, \"Exception copying account to \" + targetUser, e);\n        } catch (AuthenticatorException | IOException e) {\n            logCopyAccountStatus(COPY_ACCOUNT_EXCEPTION, callerPackage);\n            Slogf.e(LOG_TAG, \"Exception copying account to \" + targetUser, e);\n        }\n    }\n\n    private static void logCopyAccountStatus(@CopyAccountStatus int status, String callerPackage) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_COPY_ACCOUNT_STATUS)\n                .setInt(status)\n                .setStrings(callerPackage)\n                .write();\n    }\n\n    private void removeAccount(Account account, @UserIdInt int sourceUserId) {\n        final AccountManager accountManager = mContext.createContextAsUser(\n                        UserHandle.of(sourceUserId), /* flags= */ 0)\n                .getSystemService(AccountManager.class);\n        try {\n            final Bundle result = accountManager.removeAccount(account,\n                    null, null /* callback */, null /* handler */).getResult(60, TimeUnit.SECONDS);\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, /* default */ false)) {\n                Slogf.i(LOG_TAG, \"Account removed from the primary user.\");\n            } else {\n                // TODO(174768447): Revisit start activity logic.\n                final Intent removeIntent = result.getParcelable(AccountManager.KEY_INTENT, android.content.Intent.class);\n                removeIntent.addFlags(FLAG_ACTIVITY_NEW_TASK);\n                if (removeIntent != null) {\n                    Slogf.i(LOG_TAG, \"Starting activity to remove account\");\n                    new Handler(Looper.getMainLooper()).post(() -> {\n                        mContext.startActivity(removeIntent);\n                    });\n                } else {\n                    Slogf.e(LOG_TAG, \"Could not remove account from the primary user.\");\n                }\n            }\n        } catch (OperationCanceledException | AuthenticatorException | IOException e) {\n            Slogf.e(LOG_TAG, \"Exception removing account from the primary user.\", e);\n        }\n    }\n\n    @Override\n    public void provisionFullyManagedDevice(\n            @NonNull FullyManagedDeviceProvisioningParams provisioningParams,\n            @NonNull String callerPackage) {\n        Objects.requireNonNull(provisioningParams, \"provisioningParams is null.\");\n        Objects.requireNonNull(callerPackage, \"callerPackage is null.\");\n\n        ComponentName deviceAdmin = provisioningParams.getDeviceAdminComponentName();\n        Objects.requireNonNull(deviceAdmin, \"admin is null.\");\n        Objects.requireNonNull(provisioningParams.getOwnerName(), \"owner name is null.\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS)\n                        || (hasCallingOrSelfPermission(permission.PROVISION_DEMO_DEVICE)\n                        && provisioningParams.isDemoDevice()));\n\n        provisioningParams.logParams(callerPackage);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int result = checkProvisioningPreconditionSkipPermission(\n                    ACTION_PROVISION_MANAGED_DEVICE, deviceAdmin.getPackageName(),\n                    caller.getUserId());\n            if (result != STATUS_OK) {\n                throw new ServiceSpecificException(\n                        ERROR_PRE_CONDITION_FAILED,\n                        \"Provisioning preconditions failed with result: \" + result);\n            }\n            onProvisionFullyManagedDeviceStarted(provisioningParams);\n\n            // These properties are global so will apply on all users\n            setTimeAndTimezone(provisioningParams.getTimeZone(), provisioningParams.getLocalTime());\n            setLocale(provisioningParams.getLocale());\n\n            int deviceOwnerUserId = UserHandle.USER_SYSTEM;\n            if (!removeNonRequiredAppsForManagedDevice(\n                    deviceOwnerUserId,\n                    provisioningParams.isLeaveAllSystemAppsEnabled(),\n                    deviceAdmin)) {\n                throw new ServiceSpecificException(\n                        ERROR_REMOVE_NON_REQUIRED_APPS_FAILED,\n                        \"PackageManager failed to remove non required apps.\");\n            }\n\n\n            if (!setActiveAdminAndDeviceOwner(deviceOwnerUserId, deviceAdmin)) {\n                throw new ServiceSpecificException(\n                        ERROR_SET_DEVICE_OWNER_FAILED, \"Failed to set device owner.\");\n            }\n\n            disallowAddUser();\n            setAdminCanGrantSensorsPermissionForUserUnchecked(\n                    deviceOwnerUserId, provisioningParams.canDeviceOwnerGrantSensorsPermissions());\n            setDemoDeviceStateUnchecked(deviceOwnerUserId, provisioningParams.isDemoDevice());\n            onProvisionFullyManagedDeviceCompleted(provisioningParams);\n            sendProvisioningCompletedBroadcast(\n                    deviceOwnerUserId,\n                    ACTION_PROVISION_MANAGED_DEVICE,\n                    provisioningParams.isLeaveAllSystemAppsEnabled());\n        } catch (Exception e) {\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.PLATFORM_PROVISIONING_ERROR)\n                    .setStrings(callerPackage)\n                    .write();\n            throw e;\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Callback called at the beginning of {@link #provisionFullyManagedDevice(\n     * FullyManagedDeviceProvisioningParams, String)} after the relevant prechecks have passed.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onProvisionFullyManagedDeviceStarted(\n            FullyManagedDeviceProvisioningParams provisioningParams) {}\n\n    /**\n     * Callback called at the end of {@link #provisionFullyManagedDevice(\n     * FullyManagedDeviceProvisioningParams, String)} after all the other provisioning tasks\n     * have completed successfully.\n     *\n     * <p>The logic in this method blocks provisioning.\n     *\n     * <p>This method is meant to be overridden by OEMs.\n     */\n    private void onProvisionFullyManagedDeviceCompleted(\n            FullyManagedDeviceProvisioningParams provisioningParams) {}\n\n    private void setTimeAndTimezone(String timeZone, long localTime) {\n        try {\n            final AlarmManager alarmManager = mContext.getSystemService(AlarmManager.class);\n            if (timeZone != null) {\n                alarmManager.setTimeZone(timeZone);\n            }\n            if (localTime > 0) {\n                alarmManager.setTime(localTime);\n            }\n        } catch (Exception e) {\n            // Do not stop provisioning and ignore this error.\n            Slogf.e(LOG_TAG, \"Alarm manager failed to set the system time/timezone.\", e);\n        }\n    }\n\n    private void setLocale(Locale locale) {\n        if (locale == null || locale.equals(Locale.getDefault())) {\n            return;\n        }\n        try {\n            // If locale is different from current locale this results in a configuration change,\n            // which will trigger the restarting of the activity.\n            LocalePicker.updateLocale(locale);\n        } catch (Exception e) {\n            // Do not stop provisioning and ignore this error.\n            Slogf.e(LOG_TAG, \"Failed to set the system locale.\", e);\n        }\n    }\n\n    private boolean removeNonRequiredAppsForManagedDevice(\n            @UserIdInt int userId, boolean leaveAllSystemAppsEnabled, ComponentName admin) {\n        Set<String> packagesToDelete = leaveAllSystemAppsEnabled\n                ? Collections.emptySet()\n                : mOverlayPackagesProvider.getNonRequiredApps(\n                        admin, userId, ACTION_PROVISION_MANAGED_DEVICE);\n\n        removeNonInstalledPackages(packagesToDelete, userId);\n        if (packagesToDelete.isEmpty()) {\n            Slogf.i(LOG_TAG, \"No packages to delete on user \" + userId);\n            return true;\n        }\n\n        NonRequiredPackageDeleteObserver packageDeleteObserver =\n                new NonRequiredPackageDeleteObserver(packagesToDelete.size());\n        for (String packageName : packagesToDelete) {\n            Slogf.i(LOG_TAG, \"Deleting package [\" + packageName + \"] as user \" + userId);\n            mContext.getPackageManager().deletePackageAsUser(\n                    packageName,\n                    packageDeleteObserver,\n                    PackageManager.DELETE_SYSTEM_APP,\n                    userId);\n        }\n        Slogf.i(LOG_TAG, \"Waiting for non required apps to be deleted\");\n        return packageDeleteObserver.awaitPackagesDeletion();\n    }\n\n    private void removeNonInstalledPackages(Set<String> packages, @UserIdInt int userId) {\n        final Set<String> toBeRemoved = new HashSet<>();\n        for (String packageName : packages) {\n            if (!isPackageInstalledForUser(packageName, userId)) {\n                toBeRemoved.add(packageName);\n            }\n        }\n        packages.removeAll(toBeRemoved);\n    }\n\n    private void disallowAddUser() {\n        if (!isHeadlessFlagEnabled() || mIsAutomotive) {\n            // Auto still enables adding users due to the communal nature of those devices\n            if (mInjector.userManagerIsHeadlessSystemUserMode()) {\n                Slogf.i(LOG_TAG, \"Not setting DISALLOW_ADD_USER on headless system user mode.\");\n                return;\n            }\n        }\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {\n                mUserManager.setUserRestriction(\n                        UserManager.DISALLOW_ADD_USER, /* value= */ true, userHandle);\n            }\n        }\n    }\n\n    private boolean setActiveAdminAndDeviceOwner(\n            @UserIdInt int userId, ComponentName adminComponent) {\n        enableAndSetActiveAdmin(userId, userId, adminComponent);\n        // TODO(b/178187130): Directly set DO and remove the check once silent provisioning is no\n        //  longer used.\n        if (getDeviceOwnerComponent(/* callingUserOnly= */ true) == null) {\n            return setDeviceOwner(adminComponent, userId,\n                    /* setProfileOwnerOnCurrentUserIfNecessary= */ true);\n        }\n        return true;\n    }\n\n    private static void logEventDuration(int eventId, long startTime, String callerPackage) {\n        final long duration = SystemClock.elapsedRealtime() - startTime;\n        DevicePolicyEventLogger\n                .createEvent(eventId)\n                .setTimePeriod(duration)\n                .setStrings(callerPackage)\n                .write();\n    }\n\n    @Override\n    public void resetDefaultCrossProfileIntentFilters(@UserIdInt int userId) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                final List<UserInfo> profiles = mUserManager.getProfiles(userId);\n                final int numOfProfiles = profiles.size();\n                if (numOfProfiles <= 1) {\n                    return;\n                }\n\n                final String managedProvisioningPackageName = getManagedProvisioningPackage(\n                        mContext);\n                // Removes cross profile intent filters from the parent to all the profiles.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        userId, mContext.getOpPackageName());\n                // Setting and resetting default cross profile intent filters was previously handled\n                // by Managed Provisioning. For backwards compatibility, clear any intent filters\n                // that were set by ManagedProvisioning.\n                mIPackageManager.clearCrossProfileIntentFilters(\n                        userId, managedProvisioningPackageName);\n\n                // For each profile reset cross profile intent filters\n                for (int i = 0; i < numOfProfiles; i++) {\n                    UserInfo profile = profiles.get(i);\n                    mIPackageManager.clearCrossProfileIntentFilters(\n                            profile.id, mContext.getOpPackageName());\n                    // Clear any intent filters that were set by ManagedProvisioning.\n                    mIPackageManager.clearCrossProfileIntentFilters(\n                            profile.id, managedProvisioningPackageName);\n\n                    mUserManagerInternal.setDefaultCrossProfileIntentFilters(userId, profile.id);\n                }\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error resetting default cross profile intent filters\", e);\n            }\n        });\n    }\n\n    private void setAdminCanGrantSensorsPermissionForUserUnchecked(@UserIdInt int userId,\n            boolean canGrant) {\n        Slogf.d(LOG_TAG, \"setAdminCanGrantSensorsPermissionForUserUnchecked(%d, %b)\",\n                userId, canGrant);\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n\n            Preconditions.checkState(\n                    isDeviceOwner(owner) && owner.getUserHandle().getIdentifier() == userId,\n                    \"May only be set on a the user of a device owner.\");\n\n            owner.mAdminCanGrantSensorsPermissions = canGrant;\n            mPolicyCache.setAdminCanGrantSensorsPermissions(canGrant);\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void setDemoDeviceStateUnchecked(@UserIdInt int userId, boolean isDemoDevice) {\n        Slogf.d(LOG_TAG, \"setDemoDeviceStateUnchecked(%d, %b)\",\n                userId, isDemoDevice);\n        if (!isDemoDevice) {\n            return;\n        }\n        synchronized (getLockObject()) {\n            mInjector.settingsGlobalPutStringForUser(\n                    Settings.Global.DEVICE_DEMO_MODE, Integer.toString(/* value= */ 1), userId);\n        }\n\n        setUserProvisioningState(STATE_USER_SETUP_FINALIZED, userId);\n    }\n\n    private void updateAdminCanGrantSensorsPermissionCache(@UserIdInt int userId) {\n        synchronized (getLockObject()) {\n\n            ActiveAdmin owner;\n            // If the user is affiliated the device (either a DO itself, or an affiliated PO),\n            // use mAdminCanGrantSensorsPermissions from the DO\n            if (isUserAffiliatedWithDeviceLocked(userId)) {\n                owner = getDeviceOwnerAdminLocked();\n            } else {\n                owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            }\n            boolean canGrant = owner != null ? owner.mAdminCanGrantSensorsPermissions : false;\n            mPolicyCache.setAdminCanGrantSensorsPermissions(canGrant);\n        }\n    }\n\n    private void updateNetworkPreferenceForUser(int userId,\n            List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs) {\n        if (!isManagedProfile(userId) && !isDeviceOwnerUserId(userId)) {\n            return;\n        }\n        List<ProfileNetworkPreference> preferences = new ArrayList<>();\n        for (PreferentialNetworkServiceConfig preferentialNetworkServiceConfig :\n                preferentialNetworkServiceConfigs) {\n            ProfileNetworkPreference.Builder preferenceBuilder =\n                    new ProfileNetworkPreference.Builder();\n            if (preferentialNetworkServiceConfig.isEnabled()) {\n                if (preferentialNetworkServiceConfig.isFallbackToDefaultConnectionAllowed()) {\n                    preferenceBuilder.setPreference(PROFILE_NETWORK_PREFERENCE_ENTERPRISE);\n                } else if (preferentialNetworkServiceConfig.shouldBlockNonMatchingNetworks()) {\n                    preferenceBuilder.setPreference(\n                            PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING);\n                } else {\n                    preferenceBuilder.setPreference(\n                            PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK);\n                }\n                preferenceBuilder.setIncludedUids(\n                        preferentialNetworkServiceConfig.getIncludedUids());\n                preferenceBuilder.setExcludedUids(\n                        preferentialNetworkServiceConfig.getExcludedUids());\n                preferenceBuilder.setPreferenceEnterpriseId(\n                        preferentialNetworkServiceConfig.getNetworkId());\n            } else {\n                preferenceBuilder.setPreference(PROFILE_NETWORK_PREFERENCE_DEFAULT);\n            }\n\n\n            preferences.add(preferenceBuilder.build());\n        }\n        Slogf.d(LOG_TAG, \"updateNetworkPreferenceForUser to \" + preferences);\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getConnectivityManager().setProfileNetworkPreferences(\n                        UserHandle.of(userId), preferences,\n                        null /* executor */, null /* listener */));\n    }\n\n    @Override\n    public boolean canAdminGrantSensorsPermissions() {\n        if (!mHasFeature) {\n            return false;\n        }\n\n        return mPolicyCache.canAdminGrantSensorsPermissions();\n    }\n\n    @Override\n    public void setDeviceOwnerType(@NonNull ComponentName admin,\n            @DeviceOwnerType int deviceOwnerType) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        synchronized (getLockObject()) {\n            setDeviceOwnerTypeLocked(admin, deviceOwnerType);\n        }\n    }\n\n    private void setDeviceOwnerTypeLocked(ComponentName admin,\n            @DeviceOwnerType int deviceOwnerType) {\n        String packageName = admin.getPackageName();\n        boolean isAdminTestOnly;\n\n        verifyDeviceOwnerTypePreconditionsLocked(admin);\n\n        isAdminTestOnly = isAdminTestOnlyLocked(admin, mOwners.getDeviceOwnerUserId());\n        Preconditions.checkState(isAdminTestOnly\n                        || !mOwners.isDeviceOwnerTypeSetForDeviceOwner(packageName),\n                \"Test only admins can only set the device owner type more than once\");\n\n        mOwners.setDeviceOwnerType(packageName, deviceOwnerType, isAdminTestOnly);\n        setGlobalSettingDeviceOwnerType(deviceOwnerType);\n    }\n\n    // TODO(b/237065504): Allow mainline modules to get the device owner type. This is a workaround\n    // to get the device owner type in PermissionController. See HibernationPolicy.kt.\n    private void setGlobalSettingDeviceOwnerType(int deviceOwnerType) {\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.settingsGlobalPutInt(\"device_owner_type\", deviceOwnerType));\n    }\n\n    @Override\n    @DeviceOwnerType\n    public int getDeviceOwnerType(@NonNull ComponentName admin) {\n        synchronized (getLockObject()) {\n            verifyDeviceOwnerTypePreconditionsLocked(admin);\n            return getDeviceOwnerTypeLocked(admin.getPackageName());\n        }\n    }\n\n    @DeviceOwnerType\n    private int getDeviceOwnerTypeLocked(String packageName) {\n        return mOwners.getDeviceOwnerType(packageName);\n    }\n\n    /**\n     * {@code true} is returned <b>only if</b> the caller is the device owner and the device owner\n     * type is {@link DevicePolicyManager#DEVICE_OWNER_TYPE_FINANCED}. {@code false} is returned for\n     * the case where the caller is not the device owner, there is no device owner, or the device\n     * owner type is not {@link DevicePolicyManager#DEVICE_OWNER_TYPE_FINANCED}.\n     */\n    private boolean isFinancedDeviceOwner(CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(\n                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_FINANCED;\n        }\n    }\n\n    private void verifyDeviceOwnerTypePreconditionsLocked(@NonNull ComponentName admin) {\n        Preconditions.checkState(mOwners.hasDeviceOwner(), \"there is no device owner\");\n        Preconditions.checkState(mOwners.getDeviceOwnerComponent().equals(admin),\n                \"admin is not the device owner\");\n    }\n\n    @Override\n    public void setUsbDataSignalingEnabled(String packageName, boolean enabled) {\n        Objects.requireNonNull(packageName, \"Admin package name must be provided\");\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        if (!isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"USB data signaling can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n            Preconditions.checkState(canUsbDataSignalingBeDisabled(),\n                    \"USB data signaling cannot be disabled.\");\n        }\n\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        /* admin= */ null, MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n                        caller.getPackageName(),\n                        caller.getUserId()).getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n\n            if (admin.mUsbDataSignalingEnabled != enabled) {\n                admin.mUsbDataSignalingEnabled = enabled;\n                saveSettingsLocked(caller.getUserId());\n                updateUsbDataSignal();\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_USB_DATA_SIGNALING)\n                .setAdmin(packageName)\n                .setBoolean(enabled)\n                .write();\n    }\n\n    private void updateUsbDataSignal() {\n        if (!canUsbDataSignalingBeDisabled()) {\n            return;\n        }\n        final boolean usbEnabled;\n        synchronized (getLockObject()) {\n            usbEnabled = isUsbDataSignalingEnabledInternalLocked();\n        }\n        if (!mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getUsbManager().enableUsbDataSignal(usbEnabled))) {\n            Slogf.w(LOG_TAG, \"Failed to set usb data signaling state\");\n        }\n    }\n\n    @Override\n    public boolean isUsbDataSignalingEnabled(String packageName) {\n        final CallerIdentity caller = getCallerIdentity(packageName);\n        synchronized (getLockObject()) {\n            // If the caller is an admin, return the policy set by itself. Otherwise\n            // return the device-wide policy.\n            if (isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                return getProfileOwnerOrDeviceOwnerLocked(\n                        caller.getUserId()).mUsbDataSignalingEnabled;\n            } else {\n                return isUsbDataSignalingEnabledInternalLocked();\n            }\n        }\n    }\n\n    @Override\n    public boolean isUsbDataSignalingEnabledForUser(int userId) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isSystemUid(caller));\n\n        synchronized (getLockObject()) {\n            return isUsbDataSignalingEnabledInternalLocked();\n        }\n    }\n\n    private boolean isUsbDataSignalingEnabledInternalLocked() {\n        // TODO(b/261999445): remove\n        ActiveAdmin admin;\n        if (isHeadlessFlagEnabled()) {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n        } else {\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                    UserHandle.USER_SYSTEM);\n        }\n        return admin == null || admin.mUsbDataSignalingEnabled;\n    }\n\n    @Override\n    public boolean canUsbDataSignalingBeDisabled() {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getUsbManager() != null\n                        && mInjector.getUsbManager().getUsbHalVersion() >= UsbManager.USB_HAL_V1_3\n        );\n    }\n\n    private void notifyMinimumRequiredWifiSecurityLevelChanged(int level) {\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getWifiManager()\n                        .notifyMinimumRequiredWifiSecurityLevelChanged(level));\n    }\n\n    private void notifyWifiSsidPolicyChanged(WifiSsidPolicy policy) {\n        if (policy == null) {\n            // If policy doesn't limit SSIDs, no need to disconnect anything.\n            return;\n        }\n        mInjector.binderWithCleanCallingIdentity(\n                () -> mInjector.getWifiManager().notifyWifiSsidPolicyChanged(policy));\n    }\n\n    @Override\n    public void setMinimumRequiredWifiSecurityLevel(String callerPackageName, int level) {\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"Wi-Fi minimum security level can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n        }\n\n        boolean valueChanged = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(/* admin= */ null,\n                        MANAGE_DEVICE_POLICY_WIFI, caller.getPackageName(), caller.getUserId())\n                        .getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            if (admin.mWifiMinimumSecurityLevel != level) {\n                admin.mWifiMinimumSecurityLevel = level;\n                saveSettingsLocked(caller.getUserId());\n                valueChanged = true;\n            }\n        }\n        if (valueChanged) notifyMinimumRequiredWifiSecurityLevelChanged(level);\n    }\n\n    @Override\n    public int getMinimumRequiredWifiSecurityLevel() {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            // TODO(b/261999445): remove\n            if (isHeadlessFlagEnabled()) {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                        UserHandle.USER_SYSTEM);\n            }\n            return (admin == null) ? DevicePolicyManager.WIFI_SECURITY_OPEN\n                    : admin.mWifiMinimumSecurityLevel;\n        }\n    }\n\n    @Override\n    public WifiSsidPolicy getWifiSsidPolicy(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity();\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_WIFI, callerPackageName,\n                    caller.getUserId());\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                            || canQueryAdminPolicy(caller),\n                    \"SSID policy can only be retrieved by a device owner or \"\n                            + \"a profile owner on an organization-owned device or \"\n                            + \"an app with the QUERY_ADMIN_POLICY permission.\");\n        }\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceOrSystemPermissionBasedAdminLocked();\n            return admin != null ? admin.mWifiSsidPolicy : null;\n        }\n    }\n\n    @Override\n    public void setWifiSsidPolicy(String callerPackageName, WifiSsidPolicy policy) {\n        CallerIdentity caller;\n\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller),\n                    \"SSID denylist can only be controlled by a device owner or \"\n                            + \"a profile owner on an organization-owned device.\");\n        }\n\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        /* admin= */ null, MANAGE_DEVICE_POLICY_WIFI,\n                        caller.getPackageName(),\n                        caller.getUserId()).getActiveAdmin();\n            } else {\n                admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n            }\n            if (!Objects.equals(policy, admin.mWifiSsidPolicy)) {\n                admin.mWifiSsidPolicy = policy;\n                changed = true;\n            }\n            if (changed) saveSettingsLocked(caller.getUserId());\n        }\n        if (changed) {\n            notifyWifiSsidPolicyChanged(policy);\n        }\n    }\n\n    @Override\n    public void setDrawables(@NonNull List<DevicePolicyDrawableResource> drawables) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(drawables, \"drawables must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.updateDrawables(drawables)) {\n                sendDrawableUpdatedBroadcast(\n                        drawables.stream().map(s -> s.getDrawableId()).collect(\n                                Collectors.toList()));\n            }\n        });\n    }\n\n    @Override\n    public void resetDrawables(@NonNull List<String> drawableIds) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(drawableIds, \"drawableIds must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.removeDrawables(drawableIds)) {\n                sendDrawableUpdatedBroadcast(drawableIds);\n            }\n        });\n    }\n\n    @Override\n    public ParcelableResource getDrawable(\n            String drawableId, String drawableStyle, String drawableSource) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mDeviceManagementResourcesProvider.getDrawable(\n                        drawableId, drawableStyle, drawableSource));\n    }\n\n    private void sendDrawableUpdatedBroadcast(List<String> drawableIds) {\n        sendResourceUpdatedBroadcast(EXTRA_RESOURCE_TYPE_DRAWABLE, drawableIds);\n    }\n\n    @Override\n    public void setStrings(@NonNull List<DevicePolicyStringResource> strings) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        Objects.requireNonNull(strings, \"strings must be provided.\");\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.updateStrings(strings)) {\n                sendStringsUpdatedBroadcast(\n                        strings.stream().map(s -> s.getStringId()).collect(Collectors.toList()));\n            }\n        });\n    }\n\n    @Override\n    public void resetStrings(@NonNull List<String> stringIds) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES));\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            if (mDeviceManagementResourcesProvider.removeStrings(stringIds)) {\n                sendStringsUpdatedBroadcast(stringIds);\n            }\n        });\n    }\n\n    @Override\n    public ParcelableResource getString(String stringId) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mDeviceManagementResourcesProvider.getString(stringId));\n    }\n\n    private void sendStringsUpdatedBroadcast(List<String> stringIds) {\n        sendResourceUpdatedBroadcast(EXTRA_RESOURCE_TYPE_STRING, stringIds);\n    }\n\n    private void sendResourceUpdatedBroadcast(int resourceType, List<String> resourceIds) {\n        final Intent intent = new Intent(ACTION_DEVICE_POLICY_RESOURCE_UPDATED);\n        intent.putExtra(EXTRA_RESOURCE_IDS, resourceIds.toArray(String[]::new));\n        intent.putExtra(EXTRA_RESOURCE_TYPE, resourceType);\n        intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n\n        List<UserInfo> users = mUserManager.getAliveUsers();\n        for (int i = 0; i < users.size(); i++) {\n            UserHandle user = users.get(i).getUserHandle();\n            mContext.sendBroadcastAsUser(intent, user);\n        }\n    }\n\n    private String getUpdatableString(\n            String updatableStringId, int defaultStringId, Object... formatArgs) {\n        ParcelableResource resource = mDeviceManagementResourcesProvider.getString(\n                updatableStringId);\n        if (resource == null) {\n            return ParcelableResource.loadDefaultString(() ->\n                    mContext.getString(defaultStringId, formatArgs));\n        }\n        return resource.getString(\n                mContext, () -> mContext.getString(defaultStringId, formatArgs), formatArgs);\n    }\n\n    public boolean isDpcDownloaded() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        ContentResolver cr = mContext.getContentResolver();\n\n        return mInjector.binderWithCleanCallingIdentity(() -> Settings.Secure.getIntForUser(\n                cr, MANAGED_PROVISIONING_DPC_DOWNLOADED,\n                /* def= */ 0, /* userHandle= */ cr.getUserId())\n                == 1);\n    }\n\n    public void setDpcDownloaded(boolean downloaded) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        int setTo = downloaded ? 1 : 0;\n\n        mInjector.binderWithCleanCallingIdentity(() -> Settings.Secure.putInt(\n                mContext.getContentResolver(), MANAGED_PROVISIONING_DPC_DOWNLOADED, setTo));\n    }\n\n    @Override\n    public void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.MANAGE_ROLE_HOLDERS));\n        setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                /* currentRoleHolder= */ null, /* allowBypass= */ false);\n    }\n\n    @Override\n    public boolean shouldAllowBypassingDevicePolicyManagementRoleQualification() {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                android.Manifest.permission.MANAGE_ROLE_HOLDERS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            if (getUserData(\n                    UserHandle.USER_SYSTEM).mBypassDevicePolicyManagementRoleQualifications) {\n                return true;\n            }\n            return shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal();\n        });\n    }\n\n    private boolean shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal() {\n        if (nonTestNonPrecreatedUsersExist()) {\n            return false;\n        }\n\n\n        return !hasIncompatibleAccountsOnAnyUser();\n    }\n\n    private boolean hasAccountsOnAnyUser() {\n        long callingIdentity = Binder.clearCallingIdentity();\n        try {\n            for (UserInfo user : mUserManagerInternal.getUsers(/* excludeDying= */ true)) {\n                AccountManager am = mContext.createContextAsUser(\n                                UserHandle.of(user.id), /* flags= */ 0)\n                        .getSystemService(AccountManager.class);\n                Account[] accounts = am.getAccounts();\n                if (accounts.length != 0) {\n                    return true;\n                }\n            }\n\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(callingIdentity);\n        }\n    }\n\n    private void setBypassDevicePolicyManagementRoleQualificationStateInternal(\n            String currentRoleHolder, boolean allowBypass) {\n        boolean stateChanged = false;\n        DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n        if (policy.mBypassDevicePolicyManagementRoleQualifications != allowBypass) {\n            policy.mBypassDevicePolicyManagementRoleQualifications = allowBypass;\n            stateChanged = true;\n        }\n        if (!Objects.equals(currentRoleHolder, policy.mCurrentRoleHolder)) {\n            policy.mCurrentRoleHolder = currentRoleHolder;\n            stateChanged = true;\n        }\n        if (stateChanged) {\n            synchronized (getLockObject()) {\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    private final class DevicePolicyManagementRoleObserver implements OnRoleHoldersChangedListener {\n        private RoleManager mRm;\n        private final Executor mExecutor;\n        private final Context mContext;\n\n        DevicePolicyManagementRoleObserver(@NonNull Context context) {\n            mContext = context;\n            mExecutor = mContext.getMainExecutor();\n            mRm = mContext.getSystemService(RoleManager.class);\n        }\n\n        public void register() {\n            mRm.addOnRoleHoldersChangedListenerAsUser(mExecutor, this, UserHandle.ALL);\n        }\n\n        @Override\n        public void onRoleHoldersChanged(@NonNull String roleName, @NonNull UserHandle user) {\n            mDevicePolicyEngine.handleRoleChanged(roleName, user.getIdentifier());\n            if (RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT.equals(roleName)) {\n                handleDevicePolicyManagementRoleChange(user);\n                return;\n            }\n            if (RoleManager.ROLE_FINANCED_DEVICE_KIOSK.equals(roleName)) {\n                handleFinancedDeviceKioskRoleChange();\n                return;\n            }\n        }\n\n        private void handleDevicePolicyManagementRoleChange(UserHandle user) {\n            String newRoleHolder = getDeviceManagementRoleHolder(user);\n            if (isDefaultRoleHolder(newRoleHolder)) {\n                Slogf.i(LOG_TAG,\n                        \"onRoleHoldersChanged: Default role holder is set, returning early\");\n                return;\n            }\n            if (newRoleHolder == null) {\n                Slogf.i(LOG_TAG,\n                        \"onRoleHoldersChanged: New role holder is null, returning early\");\n                return;\n            }\n            if (shouldAllowBypassingDevicePolicyManagementRoleQualificationInternal()) {\n                Slogf.w(LOG_TAG,\n                        \"onRoleHoldersChanged: Updating current role holder to \" + newRoleHolder);\n                setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                        newRoleHolder, /* allowBypass= */ true);\n                return;\n            }\n            DevicePolicyData policy = getUserData(UserHandle.USER_SYSTEM);\n            if (!newRoleHolder.equals(policy.mCurrentRoleHolder)) {\n                Slogf.w(LOG_TAG,\n                        \"onRoleHoldersChanged: You can't set a different role holder, role \"\n                                + \"is getting revoked from \" + newRoleHolder);\n                setBypassDevicePolicyManagementRoleQualificationStateInternal(\n                        /* currentRoleHolder= */ null, /* allowBypass= */ false);\n                mRm.removeRoleHolderAsUser(\n                        RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT,\n                        newRoleHolder,\n                        /* flags= */ 0,\n                        user,\n                        mExecutor,\n                        successful -> {});\n            }\n        }\n\n        private void handleFinancedDeviceKioskRoleChange() {\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                return;\n            }\n            Slog.i(LOG_TAG, \"Handling action \" + ACTION_DEVICE_FINANCING_STATE_CHANGED);\n            Intent intent = new Intent(ACTION_DEVICE_FINANCING_STATE_CHANGED);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                for (UserInfo userInfo : mUserManager.getUsers()) {\n                    UserHandle user = userInfo.getUserHandle();\n                    broadcastExplicitIntentToRoleHolder(\n                            intent, RoleManager.ROLE_SYSTEM_SUPERVISION, user);\n                    broadcastExplicitIntentToRoleHolder(\n                            intent, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, user);\n                    ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(user.getIdentifier());\n                    if (admin == null) {\n                        continue;\n                    }\n                    if (!isProfileOwnerOfOrganizationOwnedDevice(\n                            admin.info.getComponent(), user.getIdentifier())\n                            && !isDeviceOwner(admin)\n                            && !(isProfileOwner(admin.info.getComponent(), user.getIdentifier())\n                            && admin.getUserHandle().isSystem())) {\n                        continue;\n                    }\n                    // Don't send the broadcast twice if the DPC is the same package as the\n                    // DMRH\n                    if (admin.info.getPackageName().equals(getDeviceManagementRoleHolder(user))) {\n                        continue;\n                    }\n                    broadcastExplicitIntentToPackage(\n                            intent, admin.info.getPackageName(), admin.getUserHandle());\n                }\n            });\n        }\n\n        private String getDeviceManagementRoleHolder(UserHandle user) {\n            return DevicePolicyManagerService.this.getRoleHolderPackageNameOnUser(\n                    mContext, RoleManager.ROLE_DEVICE_POLICY_MANAGEMENT, user);\n        }\n\n        private boolean isDefaultRoleHolder(String packageName) {\n            String defaultRoleHolder = getDefaultRoleHolderPackageName();\n            if (packageName == null || defaultRoleHolder == null) {\n                return false;\n            }\n            if (!defaultRoleHolder.equals(packageName)) {\n                return false;\n            }\n            return hasSigningCertificate(\n                    packageName, getDefaultRoleHolderPackageSignature());\n        }\n\n        private boolean hasSigningCertificate(String packageName, String  certificateString) {\n            if (packageName == null || certificateString == null) {\n                return false;\n            }\n            byte[] certificate;\n            try {\n                certificate = new Signature(certificateString).toByteArray();\n            } catch (IllegalArgumentException e) {\n                Slogf.w(LOG_TAG, \"Cannot parse signing certificate: \" + certificateString, e);\n                return false;\n            }\n            PackageManager pm = mInjector.getPackageManager();\n            return pm.hasSigningCertificate(\n                    packageName, certificate, PackageManager.CERT_INPUT_SHA256);\n        }\n\n        private String getDefaultRoleHolderPackageName() {\n            String[] info = getDefaultRoleHolderPackageNameAndSignature();\n            if (info == null) {\n                return null;\n            }\n            return info[0];\n        }\n\n        private String getDefaultRoleHolderPackageSignature() {\n            String[] info = getDefaultRoleHolderPackageNameAndSignature();\n            if (info == null || info.length < 2) {\n                return null;\n            }\n            return info[1];\n        }\n\n        private String[] getDefaultRoleHolderPackageNameAndSignature() {\n            String packageNameAndSignature = mContext.getString(\n                    com.android.internal.R.string.config_devicePolicyManagement);\n            if (TextUtils.isEmpty(packageNameAndSignature)) {\n                return null;\n            }\n            if (packageNameAndSignature.contains(\":\")) {\n                return packageNameAndSignature.split(\":\");\n            }\n            return new String[]{packageNameAndSignature};\n        }\n    }\n\n    private void broadcastExplicitIntentToRoleHolder(\n            Intent intent, String role, UserHandle userHandle) {\n        String packageName = getRoleHolderPackageNameOnUser(mContext, role, userHandle);\n        if (packageName == null) {\n            return;\n        }\n        broadcastExplicitIntentToPackage(intent, packageName, userHandle);\n    }\n\n    private void broadcastExplicitIntentToPackage(\n            Intent intent, String packageName, UserHandle userHandle) {\n        int userId = userHandle.getIdentifier();\n        if (packageName == null) {\n            return;\n        }\n        Intent packageIntent = new Intent(intent)\n                .setPackage(packageName);\n        List<ResolveInfo> receivers = mContext.getPackageManager().queryBroadcastReceiversAsUser(\n                packageIntent,\n                PackageManager.ResolveInfoFlags.of(PackageManager.GET_RECEIVERS),\n                userId);\n        if (receivers.isEmpty()) {\n            Slog.i(LOG_TAG, \"Found no receivers to handle intent \" + intent\n                    + \" in package \" + packageName);\n            return;\n        }\n        for (ResolveInfo receiver : receivers) {\n            Intent componentIntent = new Intent(packageIntent)\n                    .setComponent(receiver.getComponentInfo().getComponentName())\n                    .addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n            mContext.sendBroadcastAsUser(componentIntent, userHandle);\n        }\n    }\n\n    @Override\n    public List<UserHandle> getPolicyManagedProfiles(@NonNull UserHandle user) {\n        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(\n                MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        int userId = user.getIdentifier();\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<UserInfo> userProfiles = mUserManager.getProfiles(userId);\n            List<UserHandle> result = new ArrayList<>();\n            for (int i = 0; i < userProfiles.size(); i++) {\n                UserInfo userInfo = userProfiles.get(i);\n                if (userInfo.isManagedProfile() && hasProfileOwner(userInfo.id)) {\n                    result.add(new UserHandle(userInfo.id));\n                }\n            }\n            return result;\n        });\n    }\n\n    // Permission that will need to be created in V.\n    private static final String MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL =\n            \"manage_device_policy_block_uninstall\";\n    private static final String MANAGE_DEVICE_POLICY_CAMERA_TOGGLE =\n            \"manage_device_policy_camera_toggle\";\n    private static final String MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE =\n            \"manage_device_policy_microphone_toggle\";\n\n    // DPC types\n    private static final int NOT_A_DPC = -1;\n    private static final int DEFAULT_DEVICE_OWNER = 0;\n    private static final int FINANCED_DEVICE_OWNER = 1;\n    private static final int PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE = 2;\n    private static final int PROFILE_OWNER_ON_USER_0 = 3;\n    private static final int PROFILE_OWNER = 4;\n    private static final int PROFILE_OWNER_ON_USER = 5;\n    private static final int AFFILIATED_PROFILE_OWNER_ON_USER = 6;\n    // DPC types\n    @IntDef(value = {\n            NOT_A_DPC,\n            DEFAULT_DEVICE_OWNER,\n            FINANCED_DEVICE_OWNER,\n            PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,\n            PROFILE_OWNER_ON_USER_0,\n            PROFILE_OWNER,\n            PROFILE_OWNER_ON_USER,\n            AFFILIATED_PROFILE_OWNER_ON_USER\n    })\n    private @interface DpcType {}\n\n    // Permissions of existing DPC types.\n    private static final List<String> DEFAULT_DEVICE_OWNER_PERMISSIONS = List.of(\n            MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n            MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n            MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n            MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n            MANAGE_DEVICE_POLICY_AUTOFILL,\n            MANAGE_DEVICE_POLICY_BLUETOOTH,\n            MANAGE_DEVICE_POLICY_CALLS,\n            MANAGE_DEVICE_POLICY_CAMERA,\n            MANAGE_DEVICE_POLICY_CERTIFICATES,\n            MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n            MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n            MANAGE_DEVICE_POLICY_DISPLAY,\n            MANAGE_DEVICE_POLICY_FACTORY_RESET,\n            MANAGE_DEVICE_POLICY_FUN,\n            MANAGE_DEVICE_POLICY_INPUT_METHODS,\n            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n            MANAGE_DEVICE_POLICY_KEYGUARD,\n            MANAGE_DEVICE_POLICY_LOCALE,\n            MANAGE_DEVICE_POLICY_LOCATION,\n            MANAGE_DEVICE_POLICY_LOCK,\n            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n            MANAGE_DEVICE_POLICY_LOCK_TASK,\n            MANAGE_DEVICE_POLICY_MICROPHONE,\n            MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n            MANAGE_DEVICE_POLICY_MODIFY_USERS,\n            MANAGE_DEVICE_POLICY_MTE,\n            MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n            MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n            MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n            MANAGE_DEVICE_POLICY_PRINTING,\n            MANAGE_DEVICE_POLICY_PROFILES,\n            MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n            MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n            MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n            MANAGE_DEVICE_POLICY_SAFE_BOOT,\n            MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n            MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n            MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n            MANAGE_DEVICE_POLICY_SMS,\n            MANAGE_DEVICE_POLICY_STATUS_BAR,\n            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n            MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n            MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,\n            MANAGE_DEVICE_POLICY_TIME,\n            MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n            MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n            MANAGE_DEVICE_POLICY_VPN,\n            MANAGE_DEVICE_POLICY_WALLPAPER,\n            MANAGE_DEVICE_POLICY_WIFI,\n            MANAGE_DEVICE_POLICY_WINDOWS,\n            MANAGE_DEVICE_POLICY_WIPE_DATA,\n            SET_TIME,\n            SET_TIME_ZONE\n    );\n    private static final List<String> FINANCED_DEVICE_OWNER_PERMISSIONS = List.of(\n            MANAGE_DEVICE_POLICY_ACROSS_USERS,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,\n            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n            MANAGE_DEVICE_POLICY_APPS_CONTROL,\n            MANAGE_DEVICE_POLICY_CALLS,\n            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n            MANAGE_DEVICE_POLICY_FACTORY_RESET,\n            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n            MANAGE_DEVICE_POLICY_KEYGUARD,\n            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n            MANAGE_DEVICE_POLICY_LOCK_TASK,\n            MANAGE_DEVICE_POLICY_MODIFY_USERS,\n            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n            MANAGE_DEVICE_POLICY_SAFE_BOOT,\n            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n            MANAGE_DEVICE_POLICY_TIME,\n            MANAGE_DEVICE_POLICY_WIPE_DATA\n    );\n\n    /**\n     * All the permissions granted to a profile owner.\n     */\n    private static final List<String> PROFILE_OWNER_PERMISSIONS  =\n            List.of(\n                    MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                    MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n                    MANAGE_DEVICE_POLICY_AUTOFILL,\n                    MANAGE_DEVICE_POLICY_BLUETOOTH,\n                    MANAGE_DEVICE_POLICY_CALLS,\n                    MANAGE_DEVICE_POLICY_CAMERA,\n                    MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n                    MANAGE_DEVICE_POLICY_DISPLAY,\n                    MANAGE_DEVICE_POLICY_FACTORY_RESET,\n                    MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                    MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n                    MANAGE_DEVICE_POLICY_KEYGUARD,\n                    MANAGE_DEVICE_POLICY_LOCALE,\n                    MANAGE_DEVICE_POLICY_LOCATION,\n                    MANAGE_DEVICE_POLICY_LOCK,\n                    MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    MANAGE_DEVICE_POLICY_CERTIFICATES,\n                    MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                    MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                    MANAGE_DEVICE_POLICY_PRINTING,\n                    MANAGE_DEVICE_POLICY_PROFILES,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                    MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                    MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n                    MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n                    MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                    MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                    MANAGE_DEVICE_POLICY_TIME,\n                    MANAGE_DEVICE_POLICY_VPN,\n                    MANAGE_DEVICE_POLICY_WIPE_DATA\n            );\n\n    /**\n     * All the additional permissions granted to an organisation owned profile owner.\n     */\n    private static final List<String>\n            ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_ACROSS_USERS,\n                    MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                    MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                    MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                    MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                    MANAGE_DEVICE_POLICY_LOCALE,\n                    MANAGE_DEVICE_POLICY_MICROPHONE,\n                    MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                    MANAGE_DEVICE_POLICY_MTE,\n                    MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                    MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                    MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n                    MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                    MANAGE_DEVICE_POLICY_SECURITY_LOGGING,\n                    MANAGE_DEVICE_POLICY_SMS,\n                    MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,\n                    MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,\n                    MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                    MANAGE_DEVICE_POLICY_WIFI,\n                    SET_TIME,\n                    SET_TIME_ZONE\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on user 0.\n     */\n    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                    MANAGE_DEVICE_POLICY_DISPLAY,\n                    MANAGE_DEVICE_POLICY_FUN,\n                    MANAGE_DEVICE_POLICY_LOCK_TASK,\n                    MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                    MANAGE_DEVICE_POLICY_MODIFY_USERS,\n                    MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                    MANAGE_DEVICE_POLICY_PRINTING,\n                    MANAGE_DEVICE_POLICY_PROFILES,\n                    MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                    MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                    MANAGE_DEVICE_POLICY_SMS,\n                    MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                    MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                    MANAGE_DEVICE_POLICY_WINDOWS,\n                    SET_TIME,\n                    SET_TIME_ZONE\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on an unaffiliated user.\n     */\n    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_LOCK_TASK\n            );\n\n    /**\n     * All the additional permissions granted to a Profile Owner on an affiliated user.\n     */\n    private static final List<String> ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            List.of(\n                    MANAGE_DEVICE_POLICY_STATUS_BAR\n            );\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_ON_USER_0_PERMISSIONS  =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_AFFILIATED_PROFIL_OWNER_ON_USER_PERMISSIONS}.\n     */\n    private static final List<String> AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =\n            new ArrayList();\n\n    /**\n     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and\n     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS}.\n     */\n    private static final List<String> PROFILE_OWNER_ON_USER_PERMISSIONS =\n            new ArrayList();\n\n\n    private static final HashMap<Integer, List<String>> DPC_PERMISSIONS = new HashMap<>();\n    {\n        // Organisation owned profile owners have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(\n                ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);\n        // Profile owners on user 0 have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS);\n        // Profile owners on users have all the permission of a profile owner plus\n        // some extra permissions.\n        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);\n        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(\n                ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS);\n        // Profile owners on affiliated users have all the permission of a profile owner on a user\n        // plus some extra permissions.\n        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_ON_USER_PERMISSIONS);\n        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(\n                ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);\n\n        DPC_PERMISSIONS.put(DEFAULT_DEVICE_OWNER, DEFAULT_DEVICE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(FINANCED_DEVICE_OWNER, FINANCED_DEVICE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,\n                PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER_0, PROFILE_OWNER_ON_USER_0_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER, PROFILE_OWNER_PERMISSIONS);\n        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER, PROFILE_OWNER_ON_USER_PERMISSIONS);\n        DPC_PERMISSIONS.put(AFFILIATED_PROFILE_OWNER_ON_USER,\n                AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);\n    }\n    //Map of Permission to Delegate Scope.\n    private static final HashMap<String, String> DELEGATE_SCOPES = new HashMap<>();\n    {\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS, DELEGATION_APP_RESTRICTIONS);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL, DELEGATION_BLOCK_UNINSTALL);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_CERTIFICATES, DELEGATION_CERT_INSTALL);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE, DELEGATION_PACKAGE_ACCESS);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, DELEGATION_PERMISSION_GRANT);\n        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, DELEGATION_SECURITY_LOGGING);\n    }\n\n    private static final HashMap<String, String> CROSS_USER_PERMISSIONS =\n            new HashMap<>();\n    {\n        // The permissions are all intrinsically global and therefore have no cross-user permission.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FACTORY_RESET, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MTE, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_STATUS_BAR, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, null);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING, null);\n        CROSS_USER_PERMISSIONS.put(SET_TIME, null);\n        CROSS_USER_PERMISSIONS.put(SET_TIME_ZONE, null);\n\n        // The permissions are all critical for securing data within the current user and\n        // therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL for\n        // cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_KEYGUARD,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);\n\n        // These permissions are required for securing device ownership without accessing user data\n        // and therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS for cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AIRPLANE_MODE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLUETOOTH,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CALLS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEFAULT_SMS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INPUT_METHODS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MOBILE_NETWORK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SMS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SAFE_BOOT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_TIME,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIFI,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIPE_DATA,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS);\n\n        // These permissions may grant access to user data and therefore must be protected with\n        // MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL for cross-user calls.\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APPS_CONTROL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUTOFILL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA_TOGGLE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DISPLAY,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FUN,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCALE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCATION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_TASK,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MODIFY_USERS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILES,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PRINTING,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESET_PASSWORD,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CONTENT,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_VPN,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WALLPAPER,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WINDOWS,\n                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permissions an array of permission names to be checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionsAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String[] permissions, String callerPackageName, int targetUserId) {\n        enforcePermissions(permissions, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, String callerPackageName, int targetUserId) {\n        enforcePermission(permission, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param deviceAdminPolicy The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, int deviceAdminPolicy, String callerPackageName, int targetUserId) {\n        enforcePermission(permission, deviceAdminPolicy, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.  Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exist and the target user is different to the calling user.\n     * Returns an {@link EnforcingAdmin} for the caller.\n     *\n     * @param admin the component name of the admin.\n     * @param callerPackageName The package name of the calling application.\n     * @param permissions The names of the permissions being checked.\n     * @param deviceAdminPolicy The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforcePermissionsAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String[] permissions, int deviceAdminPolicy, String callerPackageName,\n            int targetUserId) {\n        enforcePermissions(permissions, deviceAdminPolicy, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    /**\n     * Checks whether the calling process has been granted permission to query a device policy on\n     * a specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private EnforcingAdmin enforceCanQueryAndGetEnforcingAdmin(@Nullable ComponentName admin,\n            String permission, String callerPackageName, int targetUserId) {\n        enforceCanQuery(permission, callerPackageName, targetUserId);\n        return getEnforcingAdminForCaller(admin, callerPackageName);\n    }\n\n    private static final HashMap<String, String> POLICY_IDENTIFIER_TO_PERMISSION = new HashMap<>();\n    {\n        POLICY_IDENTIFIER_TO_PERMISSION.put(AUTO_TIMEZONE_POLICY, SET_TIME_ZONE);\n    }\n\n    private static final HashMap<String, Integer> POLICY_IDENTIFIER_TO_ACTIVE_ADMIN_POLICY =\n            new HashMap<>();\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, String callerPackageName)\n            throws SecurityException {\n        if (!hasPermission(permission, callerPackageName)) {\n            throw new SecurityException(\"Caller does not have the required permissions for \"\n                    + \"this user. Permission required: \"\n                    + permission\n                    + \".\");\n        }\n    }\n\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one permission provided in the list needs to be granted to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permissions The names of the permissions being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, String callerPackageName, int targetUserId)\n            throws SecurityException {\n        enforcePermission(permission, callerPackageName);\n        if (targetUserId != getCallerIdentity(callerPackageName).getUserId()) {\n            enforcePermission(CROSS_USER_PERMISSIONS.get(permission), callerPackageName);\n        }\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user. Only one of the given permissions will be required to be held to pass this\n     * check.\n     * The given permissions will be checked along with their associated cross-user permissions if\n     * they exist and the target user is different to the calling user.\n     *\n     * @param permissions An array of the names of the permissions being checked.\n     * @param callerPackageName The package name  of the calling application.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermissions(String[] permissions, String callerPackageName,\n            int targetUserId) throws SecurityException {\n        String heldPermission = \"\";\n        for (String permission : permissions) {\n            if (hasPermission(permission, callerPackageName)) {\n                heldPermission = permission;\n                break;\n            }\n        }\n        if (heldPermission.isEmpty()) {\n            throw new SecurityException(\"Caller does not have the required permissions for \"\n                    + \"this user. One of the following permission required: \"\n                    + Arrays.toString(permissions));\n        }\n        enforcePermission(heldPermission, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param adminPolicy The admin policy that should grant holders permission.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermission(String permission, int adminPolicy,\n            String callerPackageName, int targetUserId) throws SecurityException {\n        if (hasAdminPolicy(adminPolicy, callerPackageName)) {\n            return;\n        }\n        enforcePermission(permission, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks if the calling process has been granted permission to apply a device policy on a\n     * specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param adminPolicy The admin policy that should grant holders permission.\n     * @param permissions The names of the permissions being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user.\n     */\n    private void enforcePermissions(String[] permissions, int adminPolicy,\n            String callerPackageName, int targetUserId) throws SecurityException {\n        if (hasAdminPolicy(adminPolicy, callerPackageName)\n                && mInjector.userHandleGetCallingUserId() == targetUserId) {\n            return;\n        }\n        enforcePermissions(permissions, callerPackageName, targetUserId);\n    }\n\n    /**\n     * Checks whether the calling process has been granted permission to query a device policy on\n     * a specific user.\n     * The given permission will be checked along with its associated cross-user permission if it\n     * exists and the target user is different to the calling user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     * @throws SecurityException if the caller has not been granted the given permission,\n     * the associated cross-user permission if the caller's user is different to the target user\n     * and if the user has not been granted {@link QUERY_ADMIN_POLICY}.\n     */\n    private void enforceCanQuery(String permission, String callerPackageName, int targetUserId)\n            throws SecurityException {\n        if (hasPermission(QUERY_ADMIN_POLICY, callerPackageName)) {\n            return;\n        }\n        enforcePermission(permission, callerPackageName, targetUserId);\n    }\n\n    private boolean hasAdminPolicy(int adminPolicy, String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        ActiveAdmin deviceAdmin = getActiveAdminWithPolicyForUidLocked(\n                null, adminPolicy, caller.getUid());\n        return deviceAdmin != null;\n    }\n\n    /**\n     * Return whether the calling process has been granted permission to apply a device policy on\n     * a specific user.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     * @param targetUserId The userId of the user which the caller needs permission to act on.\n     */\n    private boolean hasPermission(String permission, String callerPackageName, int targetUserId) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        boolean hasPermissionOnOwnUser = hasPermission(permission, caller.getPackageName());\n        boolean hasPermissionOnTargetUser = true;\n        if (hasPermissionOnOwnUser && caller.getUserId() != targetUserId) {\n            hasPermissionOnTargetUser = hasPermissionOnTargetUser\n                    && hasPermission(CROSS_USER_PERMISSIONS.get(permission),\n                        caller.getPackageName());\n        }\n\n        return hasPermissionOnOwnUser && hasPermissionOnTargetUser;\n    }\n\n    /**\n     * Return whether the calling process has been granted the given permission.\n     *\n     * @param callerPackageName The package name  of the calling application.\n     * @param permission The name of the permission being checked.\n     */\n    private boolean hasPermission(String permission, @NonNull String callerPackageName) {\n        Objects.requireNonNull(callerPackageName, \"callerPackageName is null\");\n        if (permission == null) {\n            return true;\n        }\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n\n        // Check if the caller holds the permission\n        if (mContext.checkCallingOrSelfPermission(permission) == PERMISSION_GRANTED) {\n            return true;\n        }\n        int dpcType = getDpcType(caller);\n        if (dpcType != NOT_A_DPC) {\n            return DPC_PERMISSIONS.get(dpcType).contains(permission);\n        }\n        // Check the permission for the role-holder\n        if (isCallerDevicePolicyManagementRoleHolder(caller)) {\n            return anyDpcHasPermission(permission, caller.getUserId());\n        }\n        if (DELEGATE_SCOPES.containsKey(permission)) {\n            return isCallerDelegate(caller, DELEGATE_SCOPES.get(permission));\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether there is a DPC on the given user that has been granted the given permission.\n     *\n     * @param permission The name of the permission being checked.\n     * @param userId The id of the user to check.\n     */\n    private boolean anyDpcHasPermission(String permission, int userId) {\n        if (mOwners.isDefaultDeviceOwnerUserId(userId)) {\n            return DPC_PERMISSIONS.get(DEFAULT_DEVICE_OWNER).contains(permission);\n        }\n        if (mOwners.isFinancedDeviceOwnerUserId(userId)) {\n            return DPC_PERMISSIONS.get(FINANCED_DEVICE_OWNER).contains(permission);\n        }\n        if (mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE).contains(\n                    permission);\n        }\n        if (userId == 0 && mOwners.hasProfileOwner(0)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER_ON_USER_0).contains(permission);\n        }\n        if (mOwners.hasProfileOwner(userId)) {\n            return DPC_PERMISSIONS.get(PROFILE_OWNER).contains(permission);\n        }\n        return false;\n    }\n\n    private EnforcingAdmin getEnforcingAdminForCaller(@Nullable ComponentName who,\n            String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n        int userId = caller.getUserId();\n        ActiveAdmin admin;\n        if (isDeviceOwner(caller) || isProfileOwner(caller) || isCallerDelegate(caller)) {\n            ComponentName component;\n            synchronized (getLockObject()) {\n                if (who != null) {\n                    admin = getActiveAdminUncheckedLocked(who, userId);\n                    component = who;\n                } else {\n                    admin = getDeviceOrProfileOwnerAdminLocked(userId);\n                    component = admin.info.getComponent();\n                }\n            }\n            return EnforcingAdmin.createEnterpriseEnforcingAdmin(component, userId, admin);\n        }\n        // Check for non-DPC active admins.\n        admin = getActiveAdminForCaller(who, caller);\n        if (admin != null) {\n            return EnforcingAdmin.createDeviceAdminEnforcingAdmin(admin.info.getComponent(), userId,\n                    admin);\n        }\n        admin = getUserData(userId).createOrGetPermissionBasedAdmin(userId);\n        return  EnforcingAdmin.createEnforcingAdmin(caller.getPackageName(), userId, admin);\n    }\n\n    private EnforcingAdmin getEnforcingAdminForPackage(@Nullable ComponentName who,\n            String packageName, int userId) {\n        ActiveAdmin admin;\n        if (who != null) {\n            if (isDeviceOwner(who, userId) || isProfileOwner(who, userId)) {\n                synchronized (getLockObject()) {\n                    admin = getActiveAdminUncheckedLocked(who, userId);\n                }\n                if (admin != null) {\n                    return EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userId, admin);\n                }\n            } else {\n                // Check for non-DPC active admins.\n                admin = getActiveAdminUncheckedLocked(who, userId);\n                if (admin != null) {\n                    return EnforcingAdmin.createDeviceAdminEnforcingAdmin(who, userId, admin);\n                }\n            }\n        }\n\n        admin = getUserData(userId).createOrGetPermissionBasedAdmin(userId);\n        return  EnforcingAdmin.createEnforcingAdmin(packageName, userId, admin);\n    }\n\n    private int getAffectedUser(boolean calledOnParent) {\n        int callingUserId = mInjector.userHandleGetCallingUserId();\n        return calledOnParent ? getProfileParentId(callingUserId) : callingUserId;\n    }\n\n    /**\n     * Return the DPC type of the given caller.\n     */\n    private @DpcType int getDpcType(CallerIdentity caller) {\n        // Check the permissions of DPCs\n        if (isDefaultDeviceOwner(caller)) {\n            return DEFAULT_DEVICE_OWNER;\n        }\n        if (isFinancedDeviceOwner(caller)) {\n            return FINANCED_DEVICE_OWNER;\n        }\n        if (isProfileOwner(caller)) {\n            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {\n                return PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n            }\n            if (isManagedProfile(caller.getUserId())) {\n                return PROFILE_OWNER;\n            }\n            if (isProfileOwnerOnUser0(caller)) {\n                return PROFILE_OWNER_ON_USER_0;\n            }\n            if (isUserAffiliatedWithDevice(caller.getUserId())) {\n                return AFFILIATED_PROFILE_OWNER_ON_USER;\n            }\n            return PROFILE_OWNER_ON_USER;\n        }\n        return NOT_A_DPC;\n    }\n\n    private boolean isPermissionCheckFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                PERMISSION_BASED_ACCESS_EXPERIMENT_FLAG,\n                DEFAULT_VALUE_PERMISSION_BASED_ACCESS_FLAG);\n    }\n\n    static boolean isPolicyEngineForFinanceFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG,\n                DEFAULT_ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG);\n    }\n\n    private static boolean isKeepProfilesRunningFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                KEEP_PROFILES_RUNNING_FLAG,\n                DEFAULT_KEEP_PROFILES_RUNNING_FLAG);\n    }\n\n    private boolean isUnicornFlagEnabled() {\n        return false;\n    }\n\n    private void setKeepProfileRunningEnabledUnchecked(boolean keepProfileRunning) {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserDataUnchecked(UserHandle.USER_SYSTEM);\n            if (policyData.mEffectiveKeepProfilesRunning == keepProfileRunning) {\n                return;\n            }\n            policyData.mEffectiveKeepProfilesRunning = keepProfileRunning;\n            saveSettingsLocked(UserHandle.USER_SYSTEM);\n        }\n        suspendAppsForQuietProfiles(keepProfileRunning);\n    }\n\n    @Override\n    public void setOverrideKeepProfilesRunning(boolean enabled) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        setKeepProfileRunningEnabledUnchecked(enabled);\n        Slog.i(LOG_TAG, \"Keep profiles running overridden to: \" + enabled);\n    }\n\n    public void setMtePolicy(int flags, String callerPackageName) {\n        final Set<Integer> allowedModes =\n                Set.of(\n                        DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY,\n                        DevicePolicyManager.MTE_DISABLED,\n                        DevicePolicyManager.MTE_ENABLED);\n        Preconditions.checkArgument(\n                allowedModes.contains(flags), \"Provided mode is not one of the allowed values.\");\n        // In general, this API should be available when \"bootctl_settings_toggle\" is set, which\n        // signals that there is a control for MTE in the user settings and this API fundamentally\n        // is a way for the device admin to override that setting.\n        // Allow bootctl_device_policy_manager as an override, e.g. to offer the\n        // DevicePolicyManager only without a visible user setting.\n        if (!mInjector.systemPropertiesGetBoolean(\n                \"ro.arm64.memtag.bootctl_device_policy_manager\",\n                mInjector.systemPropertiesGetBoolean(\n                        \"ro.arm64.memtag.bootctl_settings_toggle\", false))) {\n            throw new UnsupportedOperationException(\"device does not support MTE\");\n        }\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        // For now we continue to restrict the DISABLED setting to device owner - we might need\n        // another permission for this in future.\n        if (flags == DevicePolicyManager.MTE_DISABLED) {\n            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));\n        }\n\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller));\n        }\n        synchronized (getLockObject()) {\n            // TODO(b/261999445): Remove\n            ActiveAdmin admin;\n            if (isHeadlessFlagEnabled()) {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                                UserHandle.USER_SYSTEM);\n            }\n\n            if (admin != null) {\n                final String memtagProperty = \"arm64.memtag.bootctl\";\n                if (flags == DevicePolicyManager.MTE_ENABLED) {\n                    mInjector.systemPropertiesSet(memtagProperty, \"memtag\");\n                } else if (flags == DevicePolicyManager.MTE_DISABLED) {\n                    mInjector.systemPropertiesSet(memtagProperty, \"memtag-off\");\n                }\n                admin.mtePolicy = flags;\n                saveSettingsLocked(caller.getUserId());\n\n                DevicePolicyEventLogger.createEvent(DevicePolicyEnums.SET_MTE_POLICY)\n                        .setInt(flags)\n                        .setAdmin(caller.getPackageName())\n                        .write();\n            }\n        }\n    }\n\n    @Override\n    public int getMtePolicy(String callerPackageName) {\n        final CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (isPermissionCheckFlagEnabled()) {\n            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),\n                    UserHandle.USER_ALL);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller)\n                            || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                            || isSystemUid(caller));\n        }\n        synchronized (getLockObject()) {\n            // TODO(b/261999445): Remove\n            ActiveAdmin admin;\n            if (isHeadlessFlagEnabled()) {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            } else {\n                admin =\n                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(\n                                UserHandle.USER_SYSTEM);\n            }\n            return admin != null\n                    ? admin.mtePolicy\n                    : DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY;\n        }\n    }\n\n    private boolean isHeadlessFlagEnabled() {\n        return DeviceConfig.getBoolean(\n                NAMESPACE_DEVICE_POLICY_MANAGER,\n                HEADLESS_FLAG,\n                DEFAULT_HEADLESS_FLAG);\n    }\n\n    @Override\n    public ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy() {\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getProfileOwnerOfOrganizationOwnedDeviceLocked();\n            if (admin != null && admin.mManagedSubscriptionsPolicy != null) {\n                return admin.mManagedSubscriptionsPolicy;\n            }\n        }\n        return new ManagedSubscriptionsPolicy(\n                ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS);\n    }\n\n    @Override\n    public void setManagedSubscriptionsPolicy(ManagedSubscriptionsPolicy policy) {\n        CallerIdentity caller = getCallerIdentity();\n\n        if (!isCallerDevicePolicyManagementRoleHolder(caller)\n                && !Objects.equals(mInjector.settingsGlobalGetString(\n                        Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS), \"1\")) {\n            throw new UnsupportedOperationException(\"This api is not enabled\");\n        }\n\n        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller),\n                \"This policy can only be set by a profile owner on an organization-owned \"\n                        + \"device.\");\n\n        int parentUserId = getProfileParentId(caller.getUserId());\n        synchronized (getLockObject()) {\n            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());\n            if (hasUserSetupCompleted(parentUserId) && !isAdminTestOnlyLocked(\n                    admin.info.getComponent(), caller.getUserId())) {\n                throw new IllegalStateException(\"Not allowed to apply this policy after setup\");\n            }\n            boolean changed = false;\n            if (!Objects.equals(policy, admin.mManagedSubscriptionsPolicy)) {\n                admin.mManagedSubscriptionsPolicy = policy;\n                changed = true;\n            }\n            if (changed) {\n                saveSettingsLocked(caller.getUserId());\n            } else {\n                return;\n            }\n        }\n\n        applyManagedSubscriptionsPolicyIfRequired();\n\n        int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n        final long id = mInjector.binderClearCallingIdentity();\n        try {\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                installOemDefaultDialerAndSmsApp(caller.getUserId());\n                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), true);\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), false);\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(id);\n        }\n    }\n\n    private void installOemDefaultDialerAndSmsApp(int targetUserId) {\n        try {\n            String defaultDialerPackageName = getOemDefaultDialerPackage();\n            String defaultSmsPackageName = getOemDefaultSmsPackage();\n\n            if (defaultDialerPackageName != null) {\n                mIPackageManager.installExistingPackageAsUser(defaultDialerPackageName,\n                        targetUserId, PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null);\n            } else {\n                Slogf.w(LOG_TAG, \"Couldn't install dialer app, dialer app package is null\");\n            }\n\n            if (defaultSmsPackageName != null) {\n                mIPackageManager.installExistingPackageAsUser(defaultSmsPackageName, targetUserId,\n                        PackageManager.INSTALL_ALL_WHITELIST_RESTRICTED_PERMISSIONS,\n                        PackageManager.INSTALL_REASON_POLICY, null);\n            } else {\n                Slogf.w(LOG_TAG, \"Couldn't install sms app, sms app package is null\");\n            }\n\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        } catch (RemoteException re) {\n            // shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Failed to install dialer/sms app\", re);\n        }\n    }\n\n    private String getOemDefaultDialerPackage() {\n        TelecomManager telecomManager = mContext.getSystemService(TelecomManager.class);\n        return telecomManager.getSystemDialerPackage();\n    }\n\n    private String getOemDefaultSmsPackage() {\n        return mContext.getString(R.string.config_defaultSms);\n    }\n\n    private void updateDialerAndSmsManagedShortcutsOverrideCache() {\n        ArrayMap<String, String> shortcutOverrides = new ArrayMap<>();\n        int managedUserId = getManagedUserId();\n        List<String> dialerRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_DIALER,\n                UserHandle.of(managedUserId));\n        List<String> smsRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS,\n                UserHandle.of(managedUserId));\n\n        String dialerPackageToOverride = getOemDefaultDialerPackage();\n        String smsPackageToOverride = getOemDefaultSmsPackage();\n\n        // To get the default app, we can get all the role holders and get the first element.\n        if (dialerPackageToOverride != null) {\n            shortcutOverrides.put(dialerPackageToOverride,\n                    dialerRoleHolders.isEmpty() ? dialerPackageToOverride\n                            : dialerRoleHolders.get(0));\n        }\n        if (smsPackageToOverride != null) {\n            shortcutOverrides.put(smsPackageToOverride,\n                    smsRoleHolders.isEmpty() ? smsPackageToOverride : smsRoleHolders.get(0));\n        }\n\n        mPolicyCache.setLauncherShortcutOverrides(shortcutOverrides);\n    }\n\n    private void registerListenerToAssignSubscriptionsToUser(int userId) {\n        synchronized (mSubscriptionsChangedListenerLock) {\n            if (mSubscriptionsChangedListener != null) {\n                return;\n            }\n            SubscriptionManager subscriptionManager = mContext.getSystemService(\n                    SubscriptionManager.class);\n            // Listener to assign all current and future subs to managed profile.\n            mSubscriptionsChangedListener = new SubscriptionManager.OnSubscriptionsChangedListener(\n                    mHandler.getLooper()) {\n                @Override\n                public void onSubscriptionsChanged() {\n                    final long id = mInjector.binderClearCallingIdentity();\n                    try {\n                        int[] subscriptionIds = subscriptionManager.getActiveSubscriptionIdList(\n                                false);\n                        for (int subId : subscriptionIds) {\n                            UserHandle associatedUserHandle =\n                                    subscriptionManager.getSubscriptionUserHandle(subId);\n                            if (associatedUserHandle == null\n                                    || associatedUserHandle.getIdentifier() != userId) {\n                                subscriptionManager.setSubscriptionUserHandle(subId,\n                                        UserHandle.of(userId));\n                            }\n                        }\n                    } finally {\n                        mInjector.binderRestoreCallingIdentity(id);\n                    }\n                }\n            };\n\n            final long id = mInjector.binderClearCallingIdentity();\n            try {\n                // When listener is added onSubscriptionsChanged gets called immediately for once\n                // (even if subscriptions are not changed) and later on when subscriptions changes.\n                subscriptionManager.addOnSubscriptionsChangedListener(\n                        mSubscriptionsChangedListener.getHandlerExecutor(),\n                        mSubscriptionsChangedListener);\n            } finally {\n                mInjector.binderRestoreCallingIdentity(id);\n            }\n        }\n    }\n\n    private void unregisterOnSubscriptionsChangedListener() {\n        synchronized (mSubscriptionsChangedListenerLock) {\n            if (mSubscriptionsChangedListener != null) {\n                SubscriptionManager subscriptionManager = mContext.getSystemService(\n                        SubscriptionManager.class);\n                subscriptionManager.removeOnSubscriptionsChangedListener(\n                        mSubscriptionsChangedListener);\n                mSubscriptionsChangedListener = null;\n            }\n        }\n    }\n\n    @Override\n    public DevicePolicyState getDevicePolicyState() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n\n        return mInjector.binderWithCleanCallingIdentity(mDevicePolicyEngine::getDevicePolicyState);\n    }\n\n    @Override\n    public boolean triggerDevicePolicyEngineMigration(boolean forceMigration) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            synchronized (getLockObject()) {\n                boolean canForceMigration = forceMigration && !hasNonTestOnlyActiveAdmins();\n                if (!canForceMigration && !shouldMigrateToDevicePolicyEngine()) {\n                    return false;\n                }\n                boolean migrated = migratePoliciesToDevicePolicyEngine();\n                migrated &= migratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                return migrated;\n            }\n        });\n    }\n\n    private boolean hasNonTestOnlyActiveAdmins() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                synchronized (getLockObject()) {\n                    List<ComponentName> activeAdmins = getActiveAdmins(userInfo.id);\n                    if (activeAdmins == null) {\n                        continue;\n                    }\n                    for (ComponentName admin : activeAdmins) {\n                        if (!isAdminTestOnlyLocked(admin, userInfo.id)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        });\n    }\n\n    private boolean shouldMigrateToDevicePolicyEngine() {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled())\n                        && !mOwners.isMigratedToPolicyEngine());\n    }\n\n    /**\n     * [b/318497672] Migrate policies that weren't migrated properly in the initial migration on\n     * update from Android T to Android U\n     */\n    private void maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked() {\n        if (!mOwners.isMigratedToPolicyEngine() || mOwners.isMigratedPostUpdate()) {\n            return;\n        }\n        migratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n        mOwners.markPostUpgradeMigration();\n    }\n\n    private boolean migratePoliciesPostUpgradeToDevicePolicyEngineLocked() {\n        try {\n            migrateScreenCapturePolicyLocked();\n            migrateLockTaskPolicyLocked();\n            migrateUserRestrictionsLocked();\n            return true;\n        } catch (Exception e) {\n            Slogf.e(LOG_TAG, e, \"Error occurred during post upgrade migration to the device \"\n                    + \"policy engine.\");\n            return false;\n        }\n    }\n\n    /**\n     * @return {@code true} if policies were migrated successfully, {@code false} otherwise.\n     */\n    private boolean migratePoliciesToDevicePolicyEngine() {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                synchronized (getLockObject()) {\n                    Slogf.i(LOG_TAG,\n                            \"Started device policies migration to the device policy engine.\");\n                    if (isUnicornFlagEnabled()) {\n                        migrateAutoTimezonePolicy();\n                        migratePermissionGrantStatePolicies();\n                    }\n                    migratePermittedInputMethodsPolicyLocked();\n                    migrateAccountManagementDisabledPolicyLocked();\n                    migrateUserControlDisabledPackagesLocked();\n\n                    mOwners.markMigrationToPolicyEngine();\n                    return true;\n                }\n            } catch (Exception e) {\n                mDevicePolicyEngine.clearAllPolicies();\n                Slogf.e(LOG_TAG, e, \"Error occurred during device policy migration, will \"\n                        + \"reattempt on the next system server restart.\");\n                return false;\n            }\n        });\n    }\n\n    private void migrateAutoTimezonePolicy() {\n        Slogf.i(LOG_TAG, \"Skipping Migration of AUTO_TIMEZONE policy to device policy engine,\"\n                + \"as no way to identify if the value was set by the admin or the user.\");\n    }\n\n    private void migratePermissionGrantStatePolicies() {\n        Slogf.i(LOG_TAG, \"Migrating PERMISSION_GRANT policy to device policy engine.\");\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            ActiveAdmin admin = getMostProbableDPCAdminForLocalPolicy(userInfo.id);\n            if (admin == null) {\n                Slogf.i(LOG_TAG, \"No admin found that can set permission grant state on user \"\n                        + userInfo.id);\n                continue;\n            }\n            for (PackageInfo packageInfo : getInstalledPackagesOnUser(userInfo.id)) {\n                if (packageInfo.requestedPermissions == null) {\n                    continue;\n                }\n                for (String permission : packageInfo.requestedPermissions) {\n                    if (!isRuntimePermission(permission)) {\n                        continue;\n                    }\n                    int grantState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\n                    try {\n                        grantState = getPermissionGrantStateForUser(\n                                packageInfo.packageName, permission,\n                                new CallerIdentity(\n                                        mInjector.binderGetCallingUid(),\n                                        admin.info.getComponent().getPackageName(),\n                                        admin.info.getComponent()),\n                                userInfo.id);\n                    } catch (RemoteException e) {\n                        Slogf.e(LOG_TAG, e, \"Error retrieving permission grant state for %s \"\n                                        + \"and %s\", packageInfo.packageName, permission);\n                    }\n                    if (grantState == DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT) {\n                        // Not Controlled by a policy\n                        continue;\n                    }\n\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.PERMISSION_GRANT(packageInfo.packageName,\n                                    permission),\n                            EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                    admin.info.getComponent(),\n                                    admin.getUserHandle().getIdentifier()),\n                            new IntegerPolicyValue(grantState),\n                            userInfo.id,\n                            /* skipEnforcePolicy= */ true);\n                }\n            }\n        }\n    }\n\n    private void migrateScreenCapturePolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            ActiveAdmin admin = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();\n            if (admin != null\n                    && ((isDeviceOwner(admin) && admin.disableScreenCapture)\n                    || (admin.getParentActiveAdmin() != null\n                    && admin.getParentActiveAdmin().disableScreenCapture))) {\n\n                EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(),\n                        admin.getUserHandle().getIdentifier(),\n                        admin);\n                mDevicePolicyEngine.setGlobalPolicy(\n                        PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                        enforcingAdmin,\n                        new BooleanPolicyValue(true));\n            }\n\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null && profileOwner.disableScreenCapture) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            profileOwner.info.getComponent(),\n                            profileOwner.getUserHandle().getIdentifier(),\n                            profileOwner);\n                    mDevicePolicyEngine.setLocalPolicy(\n                            PolicyDefinition.SCREEN_CAPTURE_DISABLED,\n                            enforcingAdmin,\n                            new BooleanPolicyValue(true),\n                            profileOwner.getUserHandle().getIdentifier());\n                }\n            }\n        });\n    }\n\n    private void migrateLockTaskPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                int doUserId = deviceOwner.getUserHandle().getIdentifier();\n                DevicePolicyData policies = getUserData(doUserId);\n                List<String> packages = policies.mLockTaskPackages;\n                int features = policies.mLockTaskFeatures;\n                // TODO: find out about persistent preferred activities\n                if (!packages.isEmpty()) {\n                    setLockTaskPolicyInPolicyEngine(deviceOwner, doUserId, packages, features);\n                }\n            }\n\n            for (int userId : mUserManagerInternal.getUserIds()) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userId);\n                if (profileOwner != null && canDPCManagedUserUseLockTaskLocked(userId)) {\n                    DevicePolicyData policies = getUserData(userId);\n                    List<String> packages = policies.mLockTaskPackages;\n                    int features = policies.mLockTaskFeatures;\n                    if (!packages.isEmpty()) {\n                        setLockTaskPolicyInPolicyEngine(profileOwner, userId, packages, features);\n                    }\n                }\n            }\n        });\n    }\n\n    private void setLockTaskPolicyInPolicyEngine(\n            ActiveAdmin admin, int userId, List<String> packages, int features) {\n        EnforcingAdmin enforcingAdmin =\n                EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        admin.info.getComponent(),\n                        userId,\n                        admin);\n        mDevicePolicyEngine.setLocalPolicy(\n                PolicyDefinition.LOCK_TASK,\n                enforcingAdmin,\n                new LockTaskPolicy(new HashSet<>(packages), features),\n                userId);\n    }\n\n    private void migratePermittedInputMethodsPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier(),\n                            admin);\n                    if (admin.permittedInputMethods != null) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.PERMITTED_INPUT_METHODS,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(\n                                        new HashSet<>(admin.permittedInputMethods)),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                    if (admin.getParentActiveAdmin() != null\n                            && admin.getParentActiveAdmin().permittedInputMethods != null) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.PERMITTED_INPUT_METHODS,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(\n                                        new HashSet<>(admin.getParentActiveAdmin()\n                                                .permittedInputMethods)),\n                                getProfileParentId(admin.getUserHandle().getIdentifier()));\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateAccountManagementDisabledPolicyLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier(),\n                            admin);\n                    for (String accountType : admin.accountTypesWithManagementDisabled) {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                                enforcingAdmin,\n                                new BooleanPolicyValue(true),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                    if (admin.getParentActiveAdmin() != null) {\n                        for (String accountType : admin.getParentActiveAdmin()\n                                .accountTypesWithManagementDisabled) {\n                            mDevicePolicyEngine.setLocalPolicy(\n                                    PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType),\n                                    enforcingAdmin,\n                                    new BooleanPolicyValue(true),\n                                    getProfileParentId(admin.getUserHandle().getIdentifier()));\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateUserControlDisabledPackagesLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin != null && admin.protectedPackages != null) {\n                    EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier(),\n                            admin);\n                    if (isDeviceOwner(admin)) {\n                        mDevicePolicyEngine.setGlobalPolicy(\n                                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(new HashSet<>(admin.protectedPackages)));\n                    } else {\n                        mDevicePolicyEngine.setLocalPolicy(\n                                PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES,\n                                enforcingAdmin,\n                                new StringSetPolicyValue(new HashSet<>(admin.protectedPackages)),\n                                admin.getUserHandle().getIdentifier());\n                    }\n                }\n            }\n        });\n    }\n\n    private void migrateUserRestrictionsLocked() {\n        Binder.withCleanCallingIdentity(() -> {\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(userInfo.id);\n                if (admin == null) continue;\n                ComponentName adminComponent = admin.info.getComponent();\n                int userId = userInfo.id;\n                EnforcingAdmin enforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                        adminComponent,\n                        userId,\n                        admin);\n                int ownerType;\n                if (isDeviceOwner(admin)) {\n                    ownerType = OWNER_TYPE_DEVICE_OWNER;\n                } else if (isProfileOwnerOfOrganizationOwnedDevice(adminComponent, userId)) {\n                    ownerType = OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n                } else if (isProfileOwner(adminComponent, userId)) {\n                    ownerType = OWNER_TYPE_PROFILE_OWNER;\n                } else {\n                    throw new IllegalStateException(\"Invalid DO/PO state\");\n                }\n\n                for (final String restriction : admin.ensureUserRestrictions().keySet()) {\n                    setBackwardCompatibleUserRestrictionLocked(ownerType, enforcingAdmin, userId,\n                            restriction, /* enabled */ true, /* parent */ false);\n                }\n                for (final String restriction : admin.getParentActiveAdmin()\n                        .ensureUserRestrictions().keySet()) {\n                    setBackwardCompatibleUserRestrictionLocked(ownerType, enforcingAdmin, userId,\n                            restriction, /* enabled */ true, /* parent */ true);\n                }\n            }\n        });\n    }\n\n    private List<PackageInfo> getInstalledPackagesOnUser(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.getPackageManager().getInstalledPackagesAsUser(\n                        PackageManager.PackageInfoFlags.of(\n                                PackageManager.GET_PERMISSIONS), userId));\n    }\n\n    /**\n     * Returns the most probable admin to have set a global policy according to the following\n     * heuristics:\n     *\n     * <ul>\n     * <li>The device owner on any user</li>\n     * <li>The org owned profile owner on any user</li>\n     * <li>The profile owner on any user</li>\n     * </ul>\n     */\n    @Nullable\n    // TODO(b/266928216): Check what the admin capabilities are when deciding which admin to return.\n    private ActiveAdmin getMostProbableDPCAdminForGlobalPolicy() {\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                return deviceOwner;\n            }\n\n            List<UserInfo> users = mUserManager.getUsers();\n            for (UserInfo userInfo : users) {\n                if (isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {\n                    return getProfileOwnerAdminLocked(userInfo.id);\n                }\n            }\n\n            for (UserInfo userInfo : users) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null) {\n                    return profileOwner;\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Returns the most probable admin to have set a policy on the given {@code userId} according\n     * to the following heuristics:\n     *\n     * <ul>\n     * <li>The device owner on the given userId</li>\n     * <li>The profile owner on the given userId</li>\n     * <li>The org owned profile owner of which the given userId is its parent</li>\n     * <li>The profile owner of which the given userId is its parent</li>\n     * <li>The device owner on any user</li>\n     * <li>The profile owner on any user</li>\n     * </ul>\n     */\n    @Nullable\n    // TODO(b/266928216): Check what the admin capabilities are when deciding which admin to return.\n    private ActiveAdmin getMostProbableDPCAdminForLocalPolicy(int userId) {\n        synchronized (getLockObject()) {\n            ActiveAdmin localDeviceOwner = getDeviceOwnerLocked(userId);\n            if (localDeviceOwner != null) {\n                return localDeviceOwner;\n            }\n\n            ActiveAdmin localProfileOwner = getProfileOwnerLocked(userId);\n            if (localProfileOwner != null) {\n                return localProfileOwner;\n            }\n\n            int[] profileIds = mUserManager.getProfileIds(userId, /* enabledOnly= */ false);\n            for (int id : profileIds) {\n                if (id == userId) {\n                    continue;\n                }\n                if (isProfileOwnerOfOrganizationOwnedDevice(id)) {\n                    return getProfileOwnerAdminLocked(id);\n                }\n            }\n\n            for (int id : profileIds) {\n                if (id == userId) {\n                    continue;\n                }\n                if (isManagedProfile(id)) {\n                    return getProfileOwnerAdminLocked(id);\n                }\n            }\n\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                return deviceOwner;\n            }\n\n            for (UserInfo userInfo : mUserManager.getUsers()) {\n                ActiveAdmin profileOwner = getProfileOwnerLocked(userInfo.id);\n                if (profileOwner != null) {\n                    return profileOwner;\n                }\n            }\n            return null;\n        }\n    }\n\n    // We need to add a mapping of policyId to permission in POLICY_IDENTIFIER_TO_PERMISSION\n    // for each migrated permission.\n    private List<ActiveAdmin> getNonDPCActiveAdminsForPolicyLocked(String policyIdentifier) {\n        Integer activeAdminPolicy = POLICY_IDENTIFIER_TO_ACTIVE_ADMIN_POLICY.get(policyIdentifier);\n        if (activeAdminPolicy == null) {\n            Slogf.e(LOG_TAG,\n                    \"Can't find a active admin policy for %s in POLICY_IDENTIFIER_TO_PERMISSION\",\n                    policyIdentifier);\n            return new ArrayList<>();\n        }\n\n        List<ActiveAdmin> admins = new ArrayList<>();\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            List<ComponentName> activeAdmins = getActiveAdmins(userInfo.id);\n            for (ComponentName admin : activeAdmins) {\n                if (isDeviceOwner(admin, userInfo.id) || isProfileOwner(admin, userInfo.id)) {\n                    continue;\n                }\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (isActiveAdminWithPolicyForUserLocked(\n                        policy.mAdminMap.get(admin), activeAdminPolicy,\n                        userInfo.id)) {\n                    admins.add(policy.mAdminMap.get(admin));\n                }\n            }\n        }\n        return admins;\n    }\n\n    // TODO: this can actually accept an EnforcingAdmin that gets created in the permission\n    //  check method.\n    private boolean isCallerActiveAdminOrDelegate(\n            CallerIdentity caller, @Nullable String delegateScope) {\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            List<ComponentName> activeAdmins = getActiveAdmins(caller.getUserId());\n            if (activeAdmins != null) {\n                for (ComponentName admin : activeAdmins) {\n                    if (admin.getPackageName().equals(caller.getPackageName())) {\n                        return true;\n                    }\n                }\n            }\n            return delegateScope != null && isCallerDelegate(caller, delegateScope);\n        });\n    }\n\n    /**\n     * Truncates char sequence to maximum length, nulls are ignored.\n     */\n    private static CharSequence truncateIfLonger(CharSequence input, int maxLength) {\n        return input == null || input.length() <= maxLength\n                ? input\n                : input.subSequence(0, maxLength);\n    }\n\n    /**\n     * Throw if string argument is too long to be serialized.\n     */\n    private static void enforceMaxStringLength(String str, String argName) {\n        Preconditions.checkArgument(\n                str.length() <= MAX_POLICY_STRING_LENGTH, argName + \" loo long\");\n    }\n\n    private static void enforceMaxPackageNameLength(String pkg) {\n        Preconditions.checkArgument(\n                pkg.length() <= MAX_PACKAGE_NAME_LENGTH, \"Package name too long\");\n    }\n\n    /**\n     * Throw if persistable bundle contains any string that we can't serialize.\n     */\n    private static void enforceMaxStringLength(PersistableBundle bundle, String argName) {\n        // Persistable bundles can have other persistable bundles as values, traverse with a queue.\n        Queue<PersistableBundle> queue = new ArrayDeque<>();\n        queue.add(bundle);\n        while (!queue.isEmpty()) {\n            PersistableBundle current = queue.remove();\n            for (String key : current.keySet()) {\n                enforceMaxStringLength(key, \"key in \" + argName);\n                Object value = current.get(key);\n                if (value instanceof String) {\n                    enforceMaxStringLength((String) value, \"string value in \" + argName);\n                } else if (value instanceof String[]) {\n                    for (String str : (String[]) value) {\n                        enforceMaxStringLength(str, \"string value in \" + argName);\n                    }\n                } else if (value instanceof PersistableBundle) {\n                    queue.add((PersistableBundle) value);\n                }\n            }\n        }\n    }\n\n    private ActiveAdmin getActiveAdminForCaller(@Nullable ComponentName who,\n            CallerIdentity caller) {\n        synchronized (getLockObject()) {\n            if (who != null) {\n                return getActiveAdminUncheckedLocked(who, caller.getUserId());\n            }\n            return mInjector.binderWithCleanCallingIdentity(() -> {\n                List<ComponentName> activeAdmins = getActiveAdmins(caller.getUserId());\n                if (activeAdmins != null) {\n                    for (ComponentName admin : activeAdmins) {\n                        if (admin.getPackageName().equals(caller.getPackageName())) {\n                            return getActiveAdminUncheckedLocked(admin, caller.getUserId());\n                        }\n                    }\n                }\n                return null;\n            });\n        }\n    }\n\n    @Override\n    public boolean isDeviceFinanced(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        Preconditions.checkCallAuthorization(isDeviceOwner(caller)\n                || isProfileOwnerOfOrganizationOwnedDevice(caller)\n                || isProfileOwnerOnUser0(caller)\n                || isCallerDevicePolicyManagementRoleHolder(caller)\n                || isCallerSystemSupervisionRoleHolder(caller));\n        return getFinancedDeviceKioskRoleHolderOnAnyUser() != null;\n    };\n\n    @Override\n    public String getFinancedDeviceKioskRoleHolder(String callerPackageName) {\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        enforcePermission(MANAGE_PROFILE_AND_DEVICE_OWNERS, caller.getPackageName(),\n                caller.getUserId());\n        return getFinancedDeviceKioskRoleHolderOnAnyUser();\n    }\n\n    private String getFinancedDeviceKioskRoleHolderOnAnyUser() {\n        return getRoleHolderPackageNameOnUser(\n                RoleManager.ROLE_FINANCED_DEVICE_KIOSK, UserHandle.USER_ALL);\n    }\n}",
        "llm_patched_codebase": "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.devicepolicy;\n\nimport static android.Manifest.permission.BIND_DEVICE_ADMIN;\nimport static android.Manifest.permission.LOCK_DEVICE;\nimport static android.Manifest.permission.MANAGE_CA_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;\nimport static android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS;\nimport static android.Manifest.permission.MASTER_CLEAR;\nimport static android.Manifest.permission.QUERY_ADMIN_POLICY;\nimport static android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY;\nimport static android.Manifest.permission.SET_TIME;\nimport static android.Manifest.permission.SET_TIME_ZONE;\nimport static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK;\nimport static android.accounts.AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_FORCE_LOCK;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_WIPE_DATA;\nimport static android.app.admin.DeviceAdminReceiver.ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED;\nimport static android.app.admin.DeviceAdminReceiver.EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE;\nimport static android.app.admin.DevicePolicyIdentifiers.AUTO_TIMEZONE_POLICY;\nimport static android.app.admin.DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_FINANCING_STATE_CHANGED;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_RESOURCE_UPDATED;\nimport static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_USER;\nimport static android.app.admin.DevicePolicyManager.ACTION_SYSTEM_UPDATE_POLICY_CHANGED;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_INSTALL_EXISTING_PACKAGE;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_KEEP_UNINSTALLED_PACKAGES;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_FINANCED;\nimport static android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_HIBERNATION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_IDS;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_DRAWABLE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_STRING;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_BASE_INFO;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_IMEI;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_INDIVIDUAL_ATTESTATION;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_MEID;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_SERIAL;\nimport static android.app.admin.DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;\nimport static android.app.admin.DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_LOW;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_MANAGED;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_NOT_SUSPENDED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_EXPLICITLY;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OFF;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OPPORTUNISTIC;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_UNKNOWN;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR;\nimport static android.app.admin.DevicePolicyManager.PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_SETUP_FINALIZED;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_UNMANAGED;\nimport static android.app.admin.DevicePolicyManager.STATUS_ACCOUNTS_NOT_EMPTY;\nimport static android.app.admin.DevicePolicyManager.STATUS_CANNOT_ADD_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_DEVICE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_PAIRED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_MANAGED_USERS_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_NONSYSTEM_USER_EXISTS;\nimport static android.app.admin.DevicePolicyManager.STATUS_NOT_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_OK;\nimport static android.app.admin.DevicePolicyManager.STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\nimport static android.app.admin.DevicePolicyManager.STATUS_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_HAS_PROFILE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_NOT_RUNNING;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_SETUP_COMPLETED;\nimport static android.app.admin.DevicePolicyManager.WIPE_EUICC;\nimport static android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE;\nimport static android.app.admin.DevicePolicyManager.WIPE_RESET_PROTECTION_DATA;\nimport static android.app.admin.DevicePolicyManager.WIPE_SILENTLY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PRINTING_DISABLED_NAMED_ADMIN;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_GENERIC_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_BODY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON;\nimport static android.app.admin.ProvisioningException.ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PRE_CONDITION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PROFILE_CREATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_REMOVE_NON_REQUIRED_APPS_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SETTING_PROFILE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SET_DEVICE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_STARTING_PROFILE_FAILED;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_AVAILABLE;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.PackageManager.GET_META_DATA;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\nimport static android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_DEFAULT;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK;\nimport static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;\nimport static android.provider.DeviceConfig.NAMESPACE_DEVICE_POLICY_MANAGER;\nimport static android.provider.Settings.Global.PRIVATE_DNS_SPECIFIER;\nimport static android.provider.Settings.Secure.MANAGED_PROVISIONING_DPC_DOWNLOADED;\nimport static android.provider.Settings.Secure.USER_SETUP_COMPLETE;\nimport static android.provider.Telephony.Carriers.DPC_URI;\nimport static android.provider.Telephony.Carriers.ENFORCE_KEY;\nimport static android.provider.Telephony.Carriers.ENFORCE_MANAGED_URI;\nimport static android.provider.Telephony.Carriers.INVALID_APN_ID;\nimport static android.security.keystore.AttestationUtils.USE_INDIVIDUAL_ATTESTATION;\nimport static com.android.internal.logging.nano.MetricsProto.MetricsEvent.PROVISIONING_ENTRY_POINT_ADB;\nimport static com.android.internal.widget.LockPatternUtils.CREDENTIAL_TYPE_NONE;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW;\nimport static com.android.server.SystemTimeZone.TIME_ZONE_CONFIDENCE_HIGH;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_DEVICE_OWNER;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_DEVICE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n\nimport android.Manifest;\nimport android.Manifest.permission;\nimport android.accessibilityservice.AccessibilityServiceInfo;\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.Mode;\nimport android.app.BroadcastOptions;\nimport android.app.IActivityManager;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.StatusBarManager;\nimport android.app.admin.AccountTypePolicyKey;\nimport android.app.admin.BooleanPolicyValue;\nimport android.app.admin.BundlePolicyValue;\nimport android.app.admin.ComponentNamePolicyValue;\nimport android.app.admin.DeviceAdminInfo;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.admin.DevicePolicyDrawableResource;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManager.DeviceOwnerType;\nimport android.app.admin.DevicePolicyManager.DevicePolicyOperation;\nimport android.app.admin.DevicePolicyManager.OperationSafetyReason;\nimport android.app.admin.DevicePolicyManager.PasswordComplexity;\nimport android.app.admin.DevicePolicyManager.PersonalAppsSuspensionReason;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerLiteInternal;\nimport android.app.admin.DevicePolicySafetyChecker;\nimport android.app.admin.DevicePolicyState;\nimport android.app.admin.DevicePolicyStringResource;\nimport android.app.admin.DeviceStateCache;\nimport android.app.admin.FactoryResetProtectionPolicy;\nimport android.app.admin.FullyManagedDeviceProvisioningParams;\nimport android.app.admin.IDevicePolicyManager;\nimport android.app.admin.IntegerPolicyValue;\nimport android.app.admin.IntentFilterPolicyKey;\nimport android.app.admin.LockTaskPolicy;\nimport android.app.admin.LongPolicyValue;\nimport android.app.admin.ManagedProfileProvisioningParams;\nimport android.app.admin.ManagedSubscriptionsPolicy;\nimport android.app.admin.NetworkEvent;\nimport android.app.admin.PackagePolicy;\nimport android.app.admin.ParcelableGranteeMap;\nimport android.app.admin.ParcelableResource;\nimport android.app.admin.PasswordMetrics;\nimport android.app.admin.PasswordPolicy;\nimport android.app.admin.PolicyKey;\nimport android.app.admin.PolicyValue;\nimport android.app.admin.PreferentialNetworkServiceConfig;\nimport android.app.admin.SecurityLog;\nimport android.app.admin.SecurityLog.SecurityEvent;\nimport android.app.admin.StartInstallingUpdateCallback;\nimport android.app.admin.StringSetPolicyValue;\nimport android.app.admin.SystemUpdateInfo;\nimport android.app.admin.SystemUpdatePolicy;\nimport android.app.admin.UnsafeStateException;\nimport android.app.admin.UserRestrictionPolicyKey;\nimport android.app.admin.WifiSsidPolicy;\nimport android.app.backup.IBackupManager;\nimport android.app.compat.CompatChanges;\nimport android.app.role.OnRoleHoldersChangedListener;\nimport android.app.role.RoleManager;\nimport android.app.trust.TrustManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.PermissionChecker;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.CrossProfileApps;\nimport android.content.pm.CrossProfileAppsInternal;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.StringParceledListSlice;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.pm.parsing.FrameworkParsingPackageUtils;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.hardware.usb.UsbManager;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.media.AudioManager;\nimport android.media.IAudioService;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivitySettingsManager;\nimport android.net.IIpConnectivityMetrics;\nimport android.net.ProfileNetworkPreference;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport android.net.VpnManager;\nimport android.net.metrics.IpConnectivityLog;\nimport android.net.wifi.WifiManager;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ServiceSpecificException;\nimport android.os.ShellCallback;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.UserManager.EnforcingUser;\nimport android.os.UserManager.UserRestrictionSource;\nimport android.os.storage.StorageManager;\nimport android.permission.AdminPermissionControlParams;\nimport android.permission.IPermissionManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.CalendarContract;\nimport android.provider.ContactsContract.QuickContact;\nimport android.provider.ContactsInternal;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.provider.Settings.Global;\nimport android.provider.Telephony;\nimport android.security.AppUriAuthenticationPolicy;\nimport android.security.IKeyChainAliasCallback;\nimport android.security.IKeyChainService;\nimport android.security.KeyChain;\nimport android.security.KeyChain.KeyChainConnection;\nimport android.security.KeyStore;\nimport android.security.keymaster.KeymasterCertificateChain;\nimport android.security.keystore.AttestationUtils;\nimport android.security.keystore.KeyGenParameterSpec;\nimport android.security.keystore.ParcelableKeyGenParameterSpec;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.telecom.TelecomManager;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.DebugUtils;\nimport android.util.IndentingPrintWriter;\nimport android.util.IntArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.Xml;\nimport android.view.IWindowManager;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.accessibility.IAccessibilityManager;\nimport android.view.inputmethod.InputMethodInfo;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.LocalePicker;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.net.NetworkUtilsInternal;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.statusbar.IStatusBarService;\nimport com.android.internal.telephony.SmsApplication;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.FunctionalUtils.ThrowingRunnable;\nimport com.android.internal.util.FunctionalUtils.ThrowingSupplier;\nimport com.android.internal.util.JournaledFile;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.StatLogger;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.internal.widget.LockSettingsInternal;\nimport com.android.internal.widget.LockscreenCredential;\nimport com.android.internal.widget.PasswordValidationError;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.net.module.util.ProxyUtils;\nimport com.android.server.AlarmManagerInternal;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.PersistentDataBlockManagerInternal;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.devicepolicy.ActiveAdmin.TrustAgentInfo;\nimport com.android.server.inputmethod.InputMethodManagerInternal;\nimport com.android.server.net.NetworkPolicyManagerInternal;\nimport com.android.server.pm.DefaultCrossProfileIntentFilter;\nimport com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.RestrictionsSet;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.UserManagerInternal.UserRestrictionsListener;\nimport com.android.server.pm.UserRestrictionsUtils;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.storage.DeviceStorageMonitorInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.utils.Slogf",
        "metrics": {
            "relative_line_count_similarity": 0.0223,
            "normalized_edit_similarity": "skipped",
            "token_level_edit_distance": 44651,
            "codebert_score": {
                "precision": 0.9932,
                "recall": 0.753,
                "f1": 0.8566,
                "f3": 0.7717
            },
            "token_count_ground_truth": 76096,
            "token_count_llm_output": 1307,
            "token_count_total": 77403,
            "cosine_similarity_openai": "skipped_max_tokens"
        },
        "metrics_status": "computed"
    }
]