[
    {
        "cve_id": "ASB-A-296915500",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.flags.Flags;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364027949",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_id trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364025411",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-340480881",
        "downstream_version": "14",
        "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-369103643",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                // operations so we don't end up splitting effects between the WM\n                // pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                        & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter it. Instead, send a signal to request PIP\n                // mode to the app if they wish to support it below in #applyTaskChanges.\n                return effects;\n            }\n\n            final int prevMode = container.getRequestedOverrideWindowingMode();\n            container.setWindowingMode(windowingMode);\n            if (prevMode != container.getWindowingMode()) {\n                // The activity in the container may become focusable or non-focusable due to\n                // windowing modes changes (such as entering or leaving pinned windowing mode),\n                // so also apply the lifecycle effects to this transaction.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        return effects;\n    }\n\n    private int applyTaskChanges(Task tr, WindowContainerTransaction.Change c) {\n        int effects = applyChanges(tr, c);\n        final SurfaceControl.Transaction t = c.getBoundsChangeTransaction();\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n            if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                effects = TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_FORCE_TRANSLUCENT) != 0) {\n            tr.setForceTranslucent(c.getForceTranslucent());\n            effects = TRANSACT_EFFECTS_LIFECYCLE;\n        }\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_DRAG_RESIZING) != 0) {\n            tr.setDragResizing(c.getDragResizing());\n        }\n\n        final int childWindowingMode = c.getActivityWindowingMode();\n        if (childWindowingMode > -1) {\n            tr.forAllActivities(a -> { a.setWindowingMode(childWindowingMode); });\n        }\n\n        if (t != null) {\n            tr.setMainWindowSizeChangeTransaction(t);\n        }\n\n        Rect enterPipBounds = c.getEnterPipBounds();\n        if (enterPipBounds != null) {\n            tr.mDisplayContent.mPinnedTaskController.setEnterPipBounds(enterPipBounds);\n        }\n\n        if (c.getWindowingMode() == WindowConfiguration.WINDOWING_MODE_PINNED\n                && !tr.inPinnedWindowingMode()) {\n            final ActivityRecord activity = tr.getTopNonFinishingActivity();\n            if (activity != null) {\n                final boolean lastSupportsEnterPipOnTaskSwitch =\n                        activity.supportsEnterPipOnTaskSwitch;\n                // Temporarily force enable enter PIP on task switch so that PIP is requested\n                // regardless of whether the activity is resumed or paused.\n                activity.supportsEnterPipOnTaskSwitch = true;\n                boolean canEnterPip = activity.checkEnterPictureInPictureState(\n                        \"applyTaskChanges\", true /* beforeStopping */);\n                if (canEnterPip) {\n                    canEnterPip = mService.mActivityClientController\n                            .requestPictureInPictureMode(activity);\n                }\n                if (!canEnterPip) {\n                    // Restore the flag to its previous state when the activity cannot enter PIP.\n                    activity.supportsEnterPipOnTaskSwitch = lastSupportsEnterPipOnTaskSwitch;\n                }\n            }\n        }\n\n        return effects;\n    }\n\n    private int applyDisplayAreaChanges(DisplayArea displayArea,\n            WindowContainerTransaction.Change c) {\n        final int[] effects = new int[1];\n        effects[0] = applyChanges(displayArea, c);\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_IGNORE_ORIENTATION_REQUEST) != 0) {\n            if (displayArea.setIgnoreOrientationRequest(c.getIgnoreOrientationRequest())) {\n                effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        displayArea.forAllTasks(task -> {\n            Task tr = (Task) task;\n            if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n                if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                    effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n        });\n\n        return effects[0];\n    }\n\n    private int applyTaskFragmentChanges(@NonNull TaskFragment taskFragment,\n            @NonNull WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        if (taskFragment.isEmbeddedTaskFragmentInPip()) {\n            // No override from organizer for embedded TaskFragment in a PIP Task.\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        // When the TaskFragment is resized, we may want to create a change transition for it, for\n        // which we want to defer the surface update until we determine whether or not to start\n        // change transition.\n        mTmpBounds0.set(taskFragment.getBounds());\n        mTmpBounds1.set(taskFragment.getRelativeEmbeddedBounds());\n        taskFragment.deferOrganizedTaskFragmentSurfaceUpdate();\n        final Rect relBounds = c.getRelativeBounds();\n        if (relBounds != null) {\n            // Make sure the requested bounds satisfied the min dimensions requirement.\n            adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(taskFragment, relBounds,\n                    errorCallbackToken);\n\n            // For embedded TaskFragment, the organizer set the bounds in parent coordinate to\n            // prevent flicker in case there is a racing condition between the parent bounds changed\n            // and the organizer request.\n            final Rect parentBounds = taskFragment.getParent().getBounds();\n            // Convert relative bounds to screen space.\n            final Rect absBounds = taskFragment.translateRelativeBoundsToAbsoluteBounds(relBounds,\n                    parentBounds);\n            c.getConfiguration().windowConfiguration.setBounds(absBounds);\n            taskFragment.setRelativeEmbeddedBounds(relBounds);\n        }\n        final int effects = applyChanges(taskFragment, c);\n        if (taskFragment.shouldStartChangeTransition(mTmpBounds0, mTmpBounds1)) {\n            taskFragment.initializeChangeTransition(mTmpBounds0);\n        }\n        taskFragment.continueOrganizedTaskFragmentSurfaceUpdate();\n        return effects;\n    }\n\n    /**\n     * Adjusts the requested relative bounds on {@link TaskFragment} to make sure it satisfies the\n     * activity min dimensions.\n     */\n    private void adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(\n            @NonNull TaskFragment taskFragment, @NonNull Rect inOutRelativeBounds,\n            @Nullable IBinder errorCallbackToken) {\n        if (inOutRelativeBounds.isEmpty()) {\n            return;\n        }\n        final Point minDimensions = taskFragment.calculateMinDimension();\n        if (inOutRelativeBounds.width() < minDimensions.x\n                || inOutRelativeBounds.height() < minDimensions.y) {\n            // Notify organizer about the request failure.\n            final Throwable exception = new SecurityException(\"The requested relative bounds:\"\n                    + inOutRelativeBounds + \" does not satisfy minimum dimensions:\"\n                    + minDimensions);\n            sendTaskFragmentOperationFailure(taskFragment.getTaskFragmentOrganizer(),\n                    errorCallbackToken, taskFragment, OP_TYPE_SET_RELATIVE_BOUNDS, exception);\n\n            // Reset to match parent bounds.\n            inOutRelativeBounds.setEmpty();\n        }\n    }\n\n    private int applyHierarchyOp(WindowContainerTransaction.HierarchyOp hop, int effects,\n            int syncId, @Nullable Transition transition, boolean isInLockTaskMode,\n            @NonNull CallerInfo caller, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable Transition finishTransition) {\n        final int type = hop.getType();\n        switch (type) {\n            case HIERARCHY_OP_TYPE_REMOVE_TASK: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || wc.asTask() == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to remove invalid task: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                task.remove(true, \"Applying remove task Hierarchy Op\");\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch root to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (task.getTaskDisplayArea() == null) {\n                    throw new IllegalArgumentException(\"Cannot set a task without display area as \"\n                            + \"launch root: \" + wc);\n                } else {\n                    task.getDisplayArea().setLaunchRootTask(task,\n                            hop.getWindowingModes(), hop.getActivityTypes());\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch adjacent to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                final boolean clearRoot = hop.getToTop();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-organized task as adjacent flag root: \" + wc);\n                } else if (task.getAdjacentTaskFragment() == null && !clearRoot) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-adjacent task as adjacent flag root: \" + wc);\n                }\n\n                task.getDisplayArea().setLaunchAdjacentFlagRootTask(clearRoot ? null : task);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS: {\n                effects |= setAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS: {\n                effects |= clearAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT: {\n                effects |= reparentChildrenTasksHierarchyOp(hop, transition, syncId,\n                        isInLockTaskMode);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_FINISH_ACTIVITY: {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(hop.getContainer());\n                if (activity == null || activity.finishing) {\n                    break;\n                }\n                if (activity.isVisible() || activity.isVisibleRequested()) {\n                    // Prevent the transition from being executed too early if the activity is\n                    // visible.\n                    activity.finishIfPossible(\"finish-activity-op\", false /* oomAdj */);\n                } else {\n                    activity.destroyIfPossible(\"finish-activity-op\");\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_LAUNCH_TASK: {\n                mService.mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                        \"launchTask HierarchyOp\");\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final int taskId = launchOpts.getInt(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                launchOpts.remove(WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(launchOpts, caller.mPid, caller.mUid);\n                waitAsyncStart(() -> mService.mTaskSupervisor.startActivityFromRecents(\n                        caller.mPid, caller.mUid, taskId, safeOptions));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REORDER:\n            case HIERARCHY_OP_TYPE_REPARENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    break;\n                }\n                // There is no use case to ask the reparent operation in lock-task mode now, so keep\n                // skipping this operation as usual.\n                if (isInLockTaskMode && type == HIERARCHY_OP_TYPE_REPARENT) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    break;\n                }\n                if (isLockTaskModeViolation(wc.getParent(), wc.asTask(), isInLockTaskMode)) {\n                    break;\n                }\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) {\n                    transition.collect(wc);\n                    if (hop.isReparent()) {\n                        if (wc.getParent() != null) {\n                            // Collect the current parent. It's visibility may change as\n                            // a result of this reparenting.\n                            transition.collect(wc.getParent());\n                        }\n                        if (hop.getNewParent() != null) {\n                            final WindowContainer parentWc =\n                                    WindowContainer.fromBinder(hop.getNewParent());\n                            if (parentWc == null) {\n                                Slog.e(TAG, \"Can't resolve parent window from token\");\n                                break;\n                            }\n                            transition.collect(parentWc);\n                        }\n                    }\n                }\n                effects |= sanitizeAndApplyHierarchyOp(wc, hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION: {\n                effects |= applyTaskFragmentOperation(hop, transition, isInLockTaskMode, caller,\n                        errorCallbackToken, organizer);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_PENDING_INTENT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                ActivityOptions activityOptions = launchOpts != null\n                        ? new ActivityOptions(launchOpts) : null;\n                if (activityOptions != null && activityOptions.getTransientLaunch()\n                        && mService.isCallerRecents(hop.getPendingIntent().getCreatorUid())) {\n                    if (mService.getActivityStartController().startExistingRecentsIfPossible(\n                            hop.getActivityIntent(), activityOptions)) {\n                        // Start recents successfully.\n                        break;\n                    }\n                }\n\n                String resolvedType = hop.getActivityIntent() != null\n                        ? hop.getActivityIntent().resolveTypeIfNeeded(\n                        mService.mContext.getContentResolver())\n                        : null;\n\n                if (hop.getPendingIntent().isActivity()) {\n                    // Set the context display id as preferred for this activity launches, so that\n                    // it can land on caller's display. Or just brought the task to front at the\n                    // display where it was on since it has higher preference.\n                    if (activityOptions == null) {\n                        activityOptions = ActivityOptions.makeBasic();\n                    }\n                    activityOptions.setCallerDisplayId(DEFAULT_DISPLAY);\n                }\n                final Bundle options = activityOptions != null ? activityOptions.toBundle() : null;\n                int res = waitAsyncStart(() -> mService.mAmInternal.sendIntentSender(\n                        hop.getPendingIntent().getTarget(),\n                        hop.getPendingIntent().getWhitelistToken(), 0 /* code */,\n                        hop.getActivityIntent(), resolvedType, null /* finishReceiver */,\n                        null /* requiredPermission */, options));\n                if (ActivityManager.isStartResultSuccessful(res)) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            default: {\n                // The other operations may change task order so they are skipped while in lock\n                // task mode. The above operations are still allowed because they don't move\n                // tasks. And it may be necessary such as clearing launch root after entering\n                // lock task mode.\n                if (isInLockTaskMode) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    return effects;\n                }\n            }\n        }\n\n        switch (type) {\n            case HIERARCHY_OP_TYPE_START_SHORTCUT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final String callingPackage = launchOpts.getString(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n                launchOpts.remove(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n\n                final LauncherAppsServiceInternal launcherApps = LocalServices.getService(\n                        LauncherAppsServiceInternal.class);\n\n                final boolean success = launcherApps.startShortcut(caller.mUid, caller.mPid,\n                        callingPackage, hop.getShortcutInfo().getPackage(), null /* featureId */,\n                        hop.getShortcutInfo().getId(), null /* sourceBounds */, launchOpts,\n                        hop.getShortcutInfo().getUserId());\n                if (success) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER: {\n                if (finishTransition == null) break;\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) break;\n                final Task thisTask = container.asActivityRecord() != null\n                        ? container.asActivityRecord().getTask() : container.asTask();\n                if (thisTask == null) break;\n                final Task restoreAt = finishTransition.getTransientLaunchRestoreTarget(container);\n                if (restoreAt == null) break;\n                final TaskDisplayArea taskDisplayArea = thisTask.getTaskDisplayArea();\n                taskDisplayArea.moveRootTaskBehindRootTask(thisTask.getRootTask(), restoreAt);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to add local insets source provider on unknown: \"\n                            + container);\n                    break;\n                }\n                container.addLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to remove local insets source provider from unknown: \"\n                                    + container);\n                    break;\n                }\n                container.removeLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null || container.asDisplayArea() == null\n                        || !container.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached display area: \"\n                            + container);\n                    break;\n                }\n                container.setAlwaysOnTop(hop.isAlwaysOnTop());\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = container != null ? container.asTask() : null;\n                if (task == null || !task.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \"\n                            + container);\n                    break;\n                }\n                if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-organized task : \" + task);\n                }\n                if (!task.isRootTask()) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-root task : \" + task);\n                }\n                task.setReparentLeafTaskIfRelaunch(hop.isReparentLeafTaskIfRelaunch());\n                break;\n            }\n        }\n        return effects;\n    }\n\n    /**\n     * Applies change set through {@link WindowContainerTransaction#addTaskFragmentOperation}.\n     * @return an int to represent the transaction effects, such as {@link #TRANSACT_EFFECTS_NONE},\n     *         {@link #TRANSACT_EFFECTS_LIFECYCLE} or {@link #TRANSACT_EFFECTS_CLIENT_CONFIG}.\n     */\n    private int applyTaskFragmentOperation(@NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, boolean isInLockTaskMode, @NonNull CallerInfo caller,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        if (!validateTaskFragmentOperation(hop, errorCallbackToken, organizer)) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final int opType = operation.getOpType();\n\n        int effects = TRANSACT_EFFECTS_NONE;\n        switch (opType) {\n            case OP_TYPE_CREATE_TASK_FRAGMENT: {\n                final TaskFragmentCreationParams taskFragmentCreationParams =\n                        operation.getTaskFragmentCreationParams();\n                if (taskFragmentCreationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentCreationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                createTaskFragment(taskFragmentCreationParams, errorCallbackToken, caller,\n                        transition);\n                break;\n            }\n            case OP_TYPE_DELETE_TASK_FRAGMENT: {\n                if (isInLockTaskMode) {\n                    final ActivityRecord bottomActivity = taskFragment.getActivity(\n                            a -> !a.finishing, false /* traverseTopToBottom */);\n                    if (bottomActivity != null\n                            && mService.getLockTaskController().activityBlockedFromFinish(\n                            bottomActivity)) {\n                        Slog.w(TAG, \"Skip removing TaskFragment due in lock task mode.\");\n                        sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                                taskFragment, opType, new IllegalStateException(\n                                        \"Not allow to delete task fragment in lock task mode.\"));\n                        break;\n                    }\n                }\n                effects |= deleteTaskFragment(taskFragment, transition);\n                break;\n            }\n            case OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT: {\n                final IBinder callerActivityToken = operation.getActivityToken();\n                final Intent activityIntent = operation.getActivityIntent();\n                final Bundle activityOptions = operation.getBundle();\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                callerActivityToken, caller.mUid, caller.mPid,\n                                errorCallbackToken));\n                if (!isStartResultSuccessful(result)) {\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, convertStartFailureToThrowable(result, activityIntent));\n                } else {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT: {\n                final IBinder activityToken = operation.getActivityToken();\n                ActivityRecord activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    // The token may be a temporary token if the activity doesn't belong to\n                    // the organizer process.\n                    activity = mTaskFragmentOrganizerController\n                            .getReparentActivityFromTemporaryToken(organizer, activityToken);\n                }\n                if (activity == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED) {\n                    final Throwable exception = new SecurityException(\n                            \"The task fragment is not allowed to embed the given activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getTask() != activity.getTask()) {\n                    final Throwable exception = new SecurityException(\"The reparented activity is\"\n                            + \" not in the same Task as the target TaskFragment.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (transition != null) {\n                    transition.collect(activity);\n                    if (activity.getParent() != null) {\n                        // Collect the current parent. Its visibility may change as a result of\n                        // this reparenting.\n                        transition.collect(activity.getParent());\n                    }\n                    transition.collect(taskFragment);\n                }\n                activity.reparent(taskFragment, POSITION_TOP);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS: {\n                final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment secondaryTaskFragment =\n                        mLaunchTaskFragments.get(secondaryFragmentToken);\n                if (secondaryTaskFragment == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"SecondaryFragmentToken must be set for setAdjacentTaskFragments.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getAdjacentTaskFragment() != secondaryTaskFragment) {\n                    // Only have lifecycle effect if the adjacent changed.\n                    taskFragment.setAdjacentTaskFragment(secondaryTaskFragment);\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n\n                final Bundle bundle = hop.getLaunchOptions();\n                final WindowContainerTransaction.TaskFragmentAdjacentParams adjacentParams =\n                        bundle != null\n                                ? new WindowContainerTransaction.TaskFragmentAdjacentParams(bundle)\n                                : null;\n                taskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelayPrimaryLastActivityRemoval());\n                secondaryTaskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelaySecondaryLastActivityRemoval());\n                break;\n            }\n            case OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS: {\n                final TaskFragment adjacentTaskFragment = taskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFragment == null) {\n                    break;\n                }\n                taskFragment.resetAdjacentTaskFragment();\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n\n                // Clear the focused app if the focused app is no longer visible after reset the\n                // adjacent TaskFragments.\n                final ActivityRecord focusedApp = taskFragment.getDisplayContent().mFocusedApp;\n                final TaskFragment focusedTaskFragment = focusedApp != null\n                        ? focusedApp.getTaskFragment()\n                        : null;\n                if ((focusedTaskFragment == taskFragment\n                        || focusedTaskFragment == adjacentTaskFragment)\n                        && !focusedTaskFragment.shouldBeVisible(null /* starting */)) {\n                    focusedTaskFragment.getDisplayContent().setFocusedApp(null /* newFocus */);\n                }\n                break;\n            }\n            case OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT: {\n                final ActivityRecord curFocus = taskFragment.getDisplayContent().mFocusedApp;\n                if (curFocus != null && curFocus.getTaskFragment() == taskFragment) {\n                    Slog.d(TAG, \"The requested TaskFragment already has the focus.\");\n                    break;\n                }\n                if (curFocus != null && curFocus.getTask() != taskFragment.getTask()) {\n                    Slog.d(TAG, \"The Task of the requested TaskFragment doesn't have focus.\");\n                    break;\n                }\n                final ActivityRecord targetFocus = taskFragment.getTopResumedActivity();\n                if (targetFocus == null) {\n                    Slog.d(TAG, \"There is no resumed activity in the requested TaskFragment.\");\n                    break;\n                }\n                taskFragment.getDisplayContent().setFocusedApp(targetFocus);\n                break;\n            }\n            case OP_TYPE_SET_COMPANION_TASK_FRAGMENT: {\n                final IBinder companionFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment companionTaskFragment = companionFragmentToken != null\n                        ? mLaunchTaskFragments.get(companionFragmentToken)\n                        : null;\n                taskFragment.setCompanionTaskFragment(companionTaskFragment);\n                break;\n            }\n            case OP_TYPE_SET_ANIMATION_PARAMS: {\n                final TaskFragmentAnimationParams animationParams = operation.getAnimationParams();\n                if (animationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentAnimationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                taskFragment.setAnimationParams(animationParams);\n                break;\n            }\n        }\n        return effects;\n    }\n\n    private boolean validateTaskFragmentOperation(\n            @NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        if (operation == null) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"TaskFragmentOperation must be non-null\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    OP_TYPE_UNKNOWN, exception);\n            return false;\n        }\n        final int opType = operation.getOpType();\n        if (opType == OP_TYPE_CREATE_TASK_FRAGMENT) {\n            // No need to check TaskFragment.\n            return true;\n        }\n\n        if (!validateTaskFragment(taskFragment, opType, errorCallbackToken, organizer)) {\n            return false;\n        }\n\n        final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n        return secondaryFragmentToken == null\n                || validateTaskFragment(mLaunchTaskFragments.get(secondaryFragmentToken), opType,\n                errorCallbackToken, organizer);\n    }\n\n    private boolean validateTaskFragment(@Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer) {\n        if (taskFragment == null || !taskFragment.isAttached()) {\n            // TaskFragment doesn't exist.\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on invalid fragment tokens opType=\" + opType);\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        if (taskFragment.isEmbeddedTaskFragmentInPip()\n                && (opType != OP_TYPE_DELETE_TASK_FRAGMENT\n                // When the Task enters PiP before the organizer removes the empty TaskFragment, we\n                // should allow it to delete the TaskFragment for cleanup.\n                || taskFragment.getTopNonFinishingActivity() != null)) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on PIP TaskFragment\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Post and wait for the result of the activity start to prevent potential deadlock against\n     * {@link WindowManagerGlobalLock}.\n     */\n    private int waitAsyncStart(IntSupplier startActivity) {\n        final Integer[] starterResult = {null};\n        final Handler handler = (Looper.myLooper() == mService.mH.getLooper())\n                // uncommon case where a queued transaction is trying to start an activity. We can't\n                // post to our own thread and wait (otherwise we deadlock), so use anim thread\n                // instead (which is 1 higher priority).\n                ? mService.mWindowManager.mAnimationHandler\n                // Otherwise just put it on main handler\n                : mService.mH;\n        handler.post(() -> {\n            try {\n                starterResult[0] = startActivity.getAsInt();\n            } catch (Throwable t) {\n                starterResult[0] = ActivityManager.START_CANCELED;\n                Slog.w(TAG, t);\n            }\n            synchronized (mGlobalLock) {\n                mGlobalLock.notifyAll();\n            }\n        });\n        while (starterResult[0] == null) {\n            try {\n                mGlobalLock.wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        return starterResult[0];\n    }\n\n    private int sanitizeAndApplyHierarchyOp(WindowContainer container,\n            WindowContainerTransaction.HierarchyOp hop) {\n        final Task task = container.asTask();\n        if (task == null) {\n            throw new IllegalArgumentException(\"Invalid container in hierarchy op\");\n        }\n        final DisplayContent dc = task.getDisplayContent();\n        if (dc == null) {\n            Slog.w(TAG, \"Container is no longer attached: \" + task);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final Task as = task;\n\n        if (hop.isReparent()) {\n            final boolean isNonOrganizedRootableTask =\n                    task.isRootTask() || task.getParent().asTask().mCreatedByOrganizer;\n            if (isNonOrganizedRootableTask) {\n                WindowContainer newParent = hop.getNewParent() == null\n                        ? dc.getDefaultTaskDisplayArea()\n                        : WindowContainer.fromBinder(hop.getNewParent());\n                if (newParent == null) {\n                    Slog.e(TAG, \"Can't resolve parent window from token\");\n                    return TRANSACT_EFFECTS_NONE;\n                }\n                if (task.getParent() != newParent) {\n                    if (newParent.asTaskDisplayArea() != null) {\n                        // For now, reparenting to displayarea is different from other reparents...\n                        as.reparent(newParent.asTaskDisplayArea(), hop.getToTop());\n                    } else if (newParent.asTask() != null) {\n                        if (newParent.inMultiWindowMode() && task.isLeafTask()) {\n                            if (newParent.inPinnedWindowingMode()) {\n                                Slog.w(TAG, \"Can't support moving a task to another PIP window...\"\n                                        + \" newParent=\" + newParent + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                            if (!task.supportsMultiWindowInDisplayArea(\n                                    newParent.asTask().getDisplayArea())) {\n                                Slog.w(TAG, \"Can't support task that doesn't support multi-window\"\n                                        + \" mode in multi-window mode... newParent=\" + newParent\n                                        + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                        }\n                        task.reparent((Task) newParent,\n                                hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                                false /*moveParents*/, \"sanitizeAndApplyHierarchyOp\");\n                    } else {\n                        throw new RuntimeException(\"Can only reparent task to another task or\"\n                                + \" taskDisplayArea, but not \" + newParent);\n                    }\n                } else {\n                    final Task rootTask = (Task) (\n                            (newParent != null && !(newParent instanceof TaskDisplayArea))\n                                    ? newParent : task.getRootTask());\n                    as.getDisplayArea().positionChildAt(\n                            hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM, rootTask,\n                            false /* includingParents */);\n                }\n            } else {\n                throw new RuntimeException(\"Reparenting leaf Tasks is not supported now. \" + task);\n            }\n        } else {\n            task.getParent().positionChildAt(\n                    hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                    task, false /* includingParents */);\n        }\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private boolean isLockTaskModeViolation(WindowContainer parent, Task task,\n            boolean isInLockTaskMode) {\n        if (!isInLockTaskMode || parent == null || task == null) {\n            return false;\n        }\n        final LockTaskController lockTaskController = mService.getLockTaskController();\n        boolean taskViolation = lockTaskController.isLockTaskModeViolation(task);\n        if (!taskViolation && parent.asTask() != null) {\n            taskViolation = lockTaskController.isLockTaskModeViolation(parent.asTask());\n        }\n        if (taskViolation) {\n            Slog.w(TAG, \"Can't support the operation since in lock task mode violation. \"\n                    + \" Task: \" + task + \" Parent : \" + parent);\n        }\n        return taskViolation;\n    }\n\n    private int reparentChildrenTasksHierarchyOp(WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, int syncId, boolean isInLockTaskMode) {\n        WindowContainer<?> currentParent = hop.getContainer() != null\n                ? WindowContainer.fromBinder(hop.getContainer()) : null;\n        WindowContainer newParent = hop.getNewParent() != null\n                ? WindowContainer.fromBinder(hop.getNewParent()) : null;\n        if (currentParent == null && newParent == null) {\n            throw new IllegalArgumentException(\"reparentChildrenTasksHierarchyOp: \" + hop);\n        } else if (currentParent == null) {\n            currentParent = newParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        } else if (newParent == null) {\n            newParent = currentParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        }\n\n        if (currentParent == newParent) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp parent not changing: \" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!currentParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp currentParent detached=\"\n                    + currentParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!newParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent detached=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (newParent.inPinnedWindowingMode()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent in PIP=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        final boolean newParentInMultiWindow = newParent.inMultiWindowMode();\n        final TaskDisplayArea newParentTda = newParent.asTask() != null\n                ? newParent.asTask().getDisplayArea()\n                : newParent.asTaskDisplayArea();\n        final WindowContainer finalCurrentParent = currentParent;\n        final WindowContainer finalNewParent = newParent;\n        Slog.i(TAG, \"reparentChildrenTasksHierarchyOp\"\n                + \" currentParent=\" + currentParent + \" newParent=\" + newParent + \" hop=\" + hop);\n\n        // We want to collect the tasks first before re-parenting to avoid array shifting on us.\n        final ArrayList<Task> tasksToReparent = new ArrayList<>();\n\n        currentParent.forAllTasks(task -> {\n            Slog.i(TAG, \" Processing task=\" + task);\n            final boolean reparent;\n            if (task.mCreatedByOrganizer || task.getParent() != finalCurrentParent) {\n                // We only care about non-organized task that are direct children of the thing we\n                // are reparenting from.\n                return false;\n            }\n            if (newParentInMultiWindow && !task.supportsMultiWindowInDisplayArea(newParentTda)) {\n                Slog.e(TAG, \"reparentChildrenTasksHierarchyOp non-resizeable task to multi window,\"\n                        + \" task=\" + task);\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getActivityTypes())\n                    && !ArrayUtils.contains(hop.getActivityTypes(), task.getActivityType())) {\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getWindowingModes())\n                    && !ArrayUtils.contains(hop.getWindowingModes(), task.getWindowingMode())) {\n                return false;\n            }\n            if (isLockTaskModeViolation(finalNewParent, task, isInLockTaskMode)) {\n                return false;\n            }\n\n            if (hop.getToTop()) {\n                tasksToReparent.add(0, task);\n            } else {\n                tasksToReparent.add(task);\n            }\n            return hop.getReparentTopOnly() && tasksToReparent.size() == 1;\n        });\n\n        final int count = tasksToReparent.size();\n        for (int i = 0; i < count; ++i) {\n            final Task task = tasksToReparent.get(i);\n            if (syncId >= 0) {\n                addToSyncSet(syncId, task);\n            }\n            if (transition != null) transition.collect(task);\n\n            if (newParent instanceof TaskDisplayArea) {\n                // For now, reparenting to display area is different from other reparents...\n                task.reparent((TaskDisplayArea) newParent, hop.getToTop());\n            } else {\n                task.reparent((Task) newParent,\n                        hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                        false /*moveParents*/, \"processChildrenTaskReparentHierarchyOp\");\n            }\n        }\n\n        if (transition != null) transition.collect(newParent);\n\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int setAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root1 = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        final TaskFragment root2 =\n                WindowContainer.fromBinder(hop.getAdjacentRoot()).asTaskFragment();\n        if (!root1.mCreatedByOrganizer || !root2.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"setAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root1=\" + root1 + \" root2=\" + root2);\n        }\n        if (root1.getAdjacentTaskFragment() == root2) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root1.setAdjacentTaskFragment(root2);\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int clearAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        if (!root.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"clearAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root=\" + root);\n        }\n        if (root.getAdjacentTaskFragment() == null) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root.resetAdjacentTaskFragment();\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private void sanitizeWindowContainer(WindowContainer wc) {\n        if (!(wc instanceof TaskFragment) && !(wc instanceof DisplayArea)) {\n            throw new RuntimeException(\"Invalid token in task fragment or displayArea transaction\");\n        }\n    }\n\n    private int applyWindowContainerChange(WindowContainer wc,\n            WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        sanitizeWindowContainer(wc);\n        if (wc.asDisplayArea() != null) {\n            return applyDisplayAreaChanges(wc.asDisplayArea(), c);\n        } else if (wc.asTask() != null) {\n            return applyTaskChanges(wc.asTask(), c);\n        } else if (wc.asTaskFragment() != null && wc.asTaskFragment().isEmbedded()) {\n            return applyTaskFragmentChanges(wc.asTaskFragment(), c, errorCallbackToken);\n        } else {\n            return applyChanges(wc, c);\n        }\n    }\n\n    @Override\n    public ITaskOrganizerController getTaskOrganizerController() {\n        enforceTaskPermission(\"getTaskOrganizerController()\");\n        return mTaskOrganizerController;\n    }\n\n    @Override\n    public IDisplayAreaOrganizerController getDisplayAreaOrganizerController() {\n        enforceTaskPermission(\"getDisplayAreaOrganizerController()\");\n        return mDisplayAreaOrganizerController;\n    }\n\n    @Override\n    public ITaskFragmentOrganizerController getTaskFragmentOrganizerController() {\n        return mTaskFragmentOrganizerController;\n    }\n\n    /**\n     * This will prepare a {@link BLASTSyncEngine.SyncGroup} for the organizer to track, but the\n     * {@link BLASTSyncEngine.SyncGroup} may not be active until the {@link BLASTSyncEngine} is\n     * free.\n     */\n    private BLASTSyncEngine.SyncGroup prepareSyncWithOrganizer(\n            IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = mService.mWindowManager.mSyncEngine\n                .prepareSyncSet(this, \"Organizer\");\n        mTransactionCallbacksByPendingSyncId.put(s.mSyncId, callback);\n        return s;\n    }\n\n    @VisibleForTesting\n    int startSyncWithOrganizer(IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = prepareSyncWithOrganizer(callback);\n        mService.mWindowManager.mSyncEngine.startSyncSet(s);\n        return s.mSyncId;\n    }\n\n    @VisibleForTesting\n    void setSyncReady(int id) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Set sync ready, syncId=%d\", id);\n        mService.mWindowManager.mSyncEngine.setReady(id);\n    }\n\n    @VisibleForTesting\n    void addToSyncSet(int syncId, WindowContainer wc) {\n        mService.mWindowManager.mSyncEngine.addToSyncSet(syncId, wc);\n    }\n\n    @Override\n    public void onTransactionReady(int syncId, SurfaceControl.Transaction t) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Transaction ready, syncId=%d\", syncId);\n        final IWindowContainerTransactionCallback callback =\n                mTransactionCallbacksByPendingSyncId.get(syncId);\n\n        try {\n            callback.onTransactionReady(syncId, t);\n        } catch (RemoteException e) {\n            // If there's an exception when trying to send the mergedTransaction to the client, we\n            // should immediately apply it here so the transactions aren't lost.\n            t.apply();\n        }\n\n        mTransactionCallbacksByPendingSyncId.remove(syncId);\n    }\n\n    @Override\n    public void registerTransitionPlayer(ITransitionPlayer player) {\n        enforceTaskPermission(\"registerTransitionPlayer()\");\n        final int callerPid = Binder.getCallingPid();\n        final int callerUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final WindowProcessController wpc =\n                        mService.getProcessController(callerPid, callerUid);\n                mTransitionController.registerTransitionPlayer(player, wpc);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ITransitionMetricsReporter getTransitionMetricsReporter() {\n        return mTransitionController.mTransitionMetricsReporter;\n    }\n\n    @Override\n    public IBinder getApplyToken() {\n        enforceTaskPermission(\"getApplyToken()\");\n        return SurfaceControl.Transaction.getDefaultApplyToken();\n    }\n\n    /** Whether the configuration changes are important to report back to an organizer. */\n    static boolean configurationsAreEqualForOrganizer(\n            Configuration newConfig, @Nullable Configuration oldConfig) {\n        if (oldConfig == null) {\n            return false;\n        }\n        int cfgChanges = newConfig.diff(oldConfig);\n        final int winCfgChanges = (cfgChanges & ActivityInfo.CONFIG_WINDOW_CONFIGURATION) != 0\n                ? (int) newConfig.windowConfiguration.diff(oldConfig.windowConfiguration,\n                true /* compareUndefined */) : 0;\n        if ((winCfgChanges & CONTROLLABLE_WINDOW_CONFIGS) == 0) {\n            cfgChanges &= ~ActivityInfo.CONFIG_WINDOW_CONFIGURATION;\n        }\n        return (cfgChanges & CONTROLLABLE_CONFIGS) == 0;\n    }\n\n    /**\n     * Makes sure that the transaction only contains operations that are allowed for the\n     * {@link WindowContainerTransaction#getTaskFragmentOrganizer()}.\n     */\n    private void enforceTaskFragmentOrganizerPermission(@NonNull String func,\n            @NonNull ITaskFragmentOrganizer organizer, @NonNull WindowContainerTransaction t) {\n        // Configuration changes\n        final Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                t.getChanges().entrySet().iterator();\n        while (entries.hasNext()) {\n            final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n            final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n            enforceTaskFragmentConfigChangeAllowed(func, wc, entry.getValue(), organizer);\n        }\n\n        // Hierarchy changes\n        final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n        for (int i = hops.size() - 1; i >= 0; i--) {\n            final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n            final int type = hop.getType();\n            // Check for each type of the operations that are allowed for TaskFragmentOrganizer.\n            switch (type) {\n                case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION:\n                    enforceTaskFragmentOrganized(func, hop.getContainer(), organizer);\n                    if (hop.getTaskFragmentOperation() != null\n                            && hop.getTaskFragmentOperation().getSecondaryFragmentToken() != null) {\n                        enforceTaskFragmentOrganized(func,\n                                hop.getTaskFragmentOperation().getSecondaryFragmentToken(),\n                                organizer);\n                    }\n                    break;\n                case HIERARCHY_OP_TYPE_FINISH_ACTIVITY:\n                    // Allow finish activity if it has the activity token.\n                    break;\n                default:\n                    // Other types of hierarchy changes are not allowed.\n                    String msg = \"Permission Denial: \" + func + \" from pid=\"\n                            + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                            + \" trying to apply a hierarchy change that is not allowed for\"\n                            + \" TaskFragmentOrganizer=\" + organizer;\n                    Slog.w(TAG, msg);\n                    throw new SecurityException(msg);\n            }\n        }\n    }\n\n    /**\n     * Makes sure that the {@link TaskFragment} of the given fragment token is created and organized\n     * by the given {@link ITaskFragmentOrganizer}.\n     */\n    private void enforceTaskFragmentOrganized(@NonNull String func,\n            @NonNull IBinder fragmentToken, @NonNull ITaskFragmentOrganizer organizer) {\n        Objects.requireNonNull(fragmentToken);\n        final TaskFragment tf = mLaunchTaskFragments.get(fragmentToken);\n        // When the TaskFragment is {@code null}, it means that the TaskFragment will be created\n        // later in the same transaction, in which case it will always be organized by the given\n        // organizer.\n        if (tf != null && !tf.hasTaskFragmentOrganizer(organizer)) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify TaskFragment not\"\n                    + \" belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    /**\n     * For config change on {@link TaskFragment}, we only support the following operations:\n     * {@link WindowContainerTransaction#setRelativeBounds(WindowContainerToken, Rect)},\n     * {@link WindowContainerTransaction#setWindowingMode(WindowContainerToken, int)}.\n     */\n    private void enforceTaskFragmentConfigChangeAllowed(@NonNull String func,\n            @Nullable WindowContainer wc, @NonNull WindowContainerTransaction.Change change,\n            @NonNull ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on task fragment that no longer exists\");\n            return;\n        }\n        final TaskFragment tf = wc.asTaskFragment();\n        if (tf == null || !tf.hasTaskFragmentOrganizer(organizer)) {\n            // Only allow to apply changes to TaskFragment that is organized by this organizer.\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify window container\"\n                    + \" not belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n\n        final int changeMask = change.getChangeMask();\n        final int configSetMask = change.getConfigSetMask();\n        final int windowSetMask = change.getWindowSetMask();\n        if (changeMask == 0 && configSetMask == 0 && windowSetMask == 0\n                && change.getWindowingMode() >= 0) {\n            // The change contains only setWindowingMode, which is allowed.\n            return;\n        }\n        if (changeMask != CHANGE_RELATIVE_BOUNDS\n                || configSetMask != ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n                || windowSetMask != WindowConfiguration.WINDOW_CONFIG_BOUNDS) {\n            // None of the change should be requested from a TaskFragment organizer except\n            // setRelativeBounds and setWindowingMode.\n            // For setRelativeBounds, we don't need to check whether it is outside of the Task\n            // bounds, because it is possible that the Task is also resizing, for which we don't\n            // want to throw an exception. The bounds will be adjusted in\n            // TaskFragment#translateRelativeBoundsToAbsoluteBounds.\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply changes of changeMask=\" + changeMask\n                    + \" configSetMask=\" + configSetMask + \" windowSetMask=\" + windowSetMask\n                    + \" to TaskFragment=\" + tf + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private void createTaskFragment(@NonNull TaskFragmentCreationParams creationParams,\n            @Nullable IBinder errorCallbackToken, @NonNull CallerInfo caller,\n            @Nullable Transition transition) {\n        final ActivityRecord ownerActivity =\n                ActivityRecord.forTokenLocked(creationParams.getOwnerToken());\n        final ITaskFragmentOrganizer organizer = ITaskFragmentOrganizer.Stub.asInterface(\n                creationParams.getOrganizer().asBinder());\n\n        if (mLaunchTaskFragments.containsKey(creationParams.getFragmentToken())) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"TaskFragment token must be unique\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerActivity == null || ownerActivity.getTask() == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid ownerToken\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (!ownerActivity.isResizeable()) {\n            final IllegalArgumentException exception = new IllegalArgumentException(\"Not allowed\"\n                    + \" to operate with non-resizable owner Activity\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        // The ownerActivity has to belong to the same app as the target Task.\n        final Task ownerTask = ownerActivity.getTask();\n        if (ownerTask.effectiveUid != ownerActivity.getUid()\n                || ownerTask.effectiveUid != caller.mUid) {\n            final Throwable exception =\n                    new SecurityException(\"Not allowed to operate with the ownerToken while \"\n                            + \"the root activity of the target task belong to the different app\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerTask.inPinnedWindowingMode()) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to create TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        final TaskFragment taskFragment = new TaskFragment(mService,\n                creationParams.getFragmentToken(), true /* createdByOrganizer */);\n        // Set task fragment organizer immediately, since it might have to be notified about further\n        // actions.\n        taskFragment.setTaskFragmentOrganizer(creationParams.getOrganizer(),\n                ownerActivity.getUid(), ownerActivity.info.processName);\n        final int position;\n        if (creationParams.getPairedPrimaryFragmentToken() != null) {\n            // When there is a paired primary TaskFragment, we want to place the new TaskFragment\n            // right above the paired one to make sure there is no other window in between.\n            final TaskFragment pairedPrimaryTaskFragment = getTaskFragment(\n                    creationParams.getPairedPrimaryFragmentToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedPrimaryTaskFragment);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else if (creationParams.getPairedActivityToken() != null) {\n            // When there is a paired Activity, we want to place the new TaskFragment right above\n            // the paired Activity to make sure the Activity position is not changed after reparent.\n            final ActivityRecord pairedActivity = ActivityRecord.forTokenLocked(\n                    creationParams.getPairedActivityToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedActivity);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else {\n            position = POSITION_TOP;\n        }\n        ownerTask.addChild(taskFragment, position);\n        taskFragment.setWindowingMode(creationParams.getWindowingMode());\n        if (!creationParams.getInitialRelativeBounds().isEmpty()) {\n            // Set relative bounds instead of using setBounds. This will avoid unnecessary update in\n            // case the parent has resized since the last time parent info is sent to the organizer.\n            taskFragment.setRelativeEmbeddedBounds(creationParams.getInitialRelativeBounds());\n            // Recompute configuration as the bounds will be calculated based on relative bounds in\n            // TaskFragment#resolveOverrideConfiguration.\n            taskFragment.recomputeConfiguration();\n        }\n        mLaunchTaskFragments.put(creationParams.getFragmentToken(), taskFragment);\n\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n    }\n\n    private int deleteTaskFragment(@NonNull TaskFragment taskFragment,\n            @Nullable Transition transition) {\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n        taskFragment.remove(true /* withTransition */, \"deleteTaskFragment\");\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    @Nullable\n    TaskFragment getTaskFragment(IBinder tfToken) {\n        return mLaunchTaskFragments.get(tfToken);\n    }\n\n    void cleanUpEmbeddedTaskFragment(TaskFragment taskFragment) {\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n    }\n\n    static class CallerInfo {\n        final int mPid;\n        final int mUid;\n\n        CallerInfo() {\n            mPid = Binder.getCallingPid();\n            mUid = Binder.getCallingUid();\n        }\n    }\n\n    void sendTaskFragmentOperationFailure(@NonNull ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken, @Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @NonNull Throwable exception) {\n        if (organizer == null) {\n            throw new IllegalArgumentException(\"Not allowed to operate with invalid organizer\");\n        }\n        mService.mTaskFragmentOrganizerController\n                .onTaskFragmentError(organizer, errorCallbackToken, taskFragment, opType,\n                        exception);\n    }\n\n    private Throwable convertStartFailureToThrowable(int result, Intent intent) {\n        switch (result) {\n            case ActivityManager.START_INTENT_NOT_RESOLVED:\n            case ActivityManager.START_CLASS_NOT_FOUND:\n                return new ActivityNotFoundException(\"No Activity found to handle \" + intent);\n            case ActivityManager.START_PERMISSION_DENIED:\n                return new SecurityException(\"Permission denied and not allowed to start activity \"\n                        + intent);\n            case ActivityManager.START_CANCELED:\n                return new AndroidRuntimeException(\"Activity could not be started for \" + intent\n                        + \" with error code : \" + result);\n            default:\n                return new AndroidRuntimeException(\"Start activity failed with error code : \"\n                        + result + \" when starting \" + intent);\n        }\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364026473",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-364027038",
        "downstream_version": "14",
        "file_name": "system/stack/gatt/gatt_sr.cc",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-352542820",
        "downstream_version": "14",
        "file_name": "src/com/android/settings/users/UserSettings.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    UserManager.isMultipleAdminEnabled(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(UserHandle.USER_SYSTEM);\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to system user\");\n                switchToUserId(UserHandle.USER_SYSTEM);\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (mUserCaps.mUserSwitcherEnabled) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            // Only current user will be displayed in case of multi-user switch is disabled\n            users = List.of(mUserManager.getUserInfo(context.getUserId()));\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n                if (user.isAdmin()) {\n                    pref.setSummary(R.string.user_admin);\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (mUserCaps.mUserSwitcherEnabled) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser && !mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.clear();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-289375038",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Update bond state for a device\n     *\n     * @param device     remote device of interest\n     * @param fromState  old bond state\n     * @param toState    new bond state\n     */\n    public void handleBondStateChanged(\n            BluetoothDevice device, int fromState, int toState) {\n        // The BondStateMachine also gets the Bond State Changed event.\n        // The BondStateMachine is responsible for sending ACTION_BOND_STATE_CHANGED intents.\n        // Avoid duplicate events.\n        mBondStateMachine.processBondStateChange(device, fromState, toState);\n        mRemoteDevices.setBondState(device, toState);\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mCsipSetCoordinatorService != null) {\n            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n        }\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-289811388",
        "downstream_version": "14",
        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    void handleBondStateChanged(BluetoothDevice device, int fromState, int toState) {\n        if (mBondStateMachine != null) {\n            mBondStateMachine.onBondStateChanged(device, fromState, toState);\n        }\n        if (mA2dpService != null) {\n            mA2dpService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mA2dpSinkService != null) {\n            mA2dpSinkService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHeadsetService != null) {\n            mHeadsetService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHeadsetClientService != null) {\n            mHeadsetClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mMapClientService != null) {\n            mMapClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHidHostService != null) {\n            mHidHostService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHearingAidService != null) {\n            mHearingAidService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHapClientService != null) {\n            mHapClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mVolumeControlService != null) {\n            mVolumeControlService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mLeAudioService != null) {\n            mLeAudioService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mCsipSetCoordinatorService != null) {\n            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n        }\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-375623125",
        "downstream_version": "14",
        "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    @VisibleForTesting\n    public AppOpsService(File recentAccessesFile, File storageFile, Handler handler,\n            Context context) {\n        mContext = context;\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n        mAppOpsCheckingService = new AppOpsCheckingServiceTracingDecorator(\n                new AppOpsCheckingServiceImpl(\n                        storageFile, this, handler, context,  mSwitchedOps));\n        //mAppOpsCheckingService = new AppOpsCheckingServiceLoggingDecorator(\n        //        LocalServices.getService(AppOpsCheckingServiceInterface.class));\n        mAppOpsRestrictions = new AppOpsRestrictionsImpl(context, handler, mAppOpsCheckingService);\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mStorageFile = new AtomicFile(storageFile, \"appops_legacy\");\n        mRecentAccessesFile = new AtomicFile(recentAccessesFile, \"appops_accesses\");\n\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        // To migrate storageFile to recentAccessesFile, these reads must be called in this order.\n        readRecentAccesses();\n        mAppOpsCheckingService.readState();\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n        LocalManagerRegistry.addManager(AppOpsManagerLocal.class, new AppOpsManagerLocalImpl());\n    }\n\n    /** Handler for work when packages are updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mAppOpsCheckingService.systemReady();\n        initializeUidStates();\n\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        getUserManagerInternal().addUserLifecycleListener(\n                new UserManagerInternal.UserLifecycleListener() {\n                    @Override\n                    public void onUserCreated(UserInfo user, Object token) {\n                        initializeUserUidStates(user.id);\n                    }\n\n                    // onUserRemoved handled by #removeUser\n                });\n\n        getPackageManagerInternal().getPackageList(\n                new PackageManagerInternal.PackageListObserver() {\n                    @Override\n                    public void onPackageAdded(String packageName, int appId) {\n                        PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                                PackageManager.GET_PERMISSIONS, Process.myUid(),\n                                mContext.getUserId());\n                        boolean isSamplingTarget = isSamplingTarget(pi);\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            if (isSamplingTarget) {\n                                mRarelyUsedPackages.add(packageName);\n                            }\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                UidState uidState = getUidStateLocked(uid, true);\n                                if (!uidState.pkgOps.containsKey(packageName)) {\n                                    uidState.pkgOps.put(packageName,\n                                            new Ops(packageName, uidState));\n                                }\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onPackageRemoved(String packageName, int appId) {\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                packageRemovedLocked(uid, packageName);\n                            }\n                        }\n                    }\n                });\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<OnOpModeChangedListener> onModeChangedListeners;\n                    synchronized (AppOpsService.this) {\n                        onModeChangedListeners =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (onModeChangedListeners == null) {\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(onModeChangedListeners, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Initialize uid state objects for state contained in the checking service.\n     */\n    @VisibleForTesting\n    void initializeUidStates() {\n        UserManagerInternal umi = getUserManagerInternal();\n        synchronized (this) {\n            int[] userIds = umi.getUserIds();\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                         getPackageManagerLocal().withUnfilteredSnapshot()) {\n                Map<String, PackageState> packageStates = snapshot.getPackageStates();\n                for (int i = 0; i < userIds.length; i++) {\n                    int userId = userIds[i];\n                    initializeUserUidStatesLocked(userId, packageStates);\n                }\n            }\n        }\n    }\n\n    private void initializeUserUidStates(int userId) {\n        synchronized (this) {\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                    getPackageManagerLocal().withUnfilteredSnapshot()) {\n                initializeUserUidStatesLocked(userId, snapshot.getPackageStates());\n            }\n        }\n    }\n\n    private void initializeUserUidStatesLocked(int userId, Map<String,\n            PackageState> packageStates) {\n        for (Map.Entry<String, PackageState> entry : packageStates.entrySet()) {\n            int appId = entry.getValue().getAppId();\n            String packageName = entry.getKey();\n\n            initializePackageUidStateLocked(userId, appId, packageName);\n        }\n    }\n\n    /*\n      Be careful not to clear any existing data; only want to add objects that don't already exist.\n     */\n    private void initializePackageUidStateLocked(int userId, int appId, String packageName) {\n        int uid = UserHandle.getUid(userId, appId);\n        UidState uidState = getUidStateLocked(uid, true);\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        SparseIntArray packageModes =\n                mAppOpsCheckingService.getNonDefaultPackageModes(packageName, userId);\n        for (int k = 0; k < packageModes.size(); k++) {\n            int code = packageModes.keyAt(k);\n\n            if (ops.indexOfKey(code) < 0) {\n                ops.put(code, new Op(uidState, packageName, code, uid));\n            }\n        }\n\n        uidState.evalForegroundOps();\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    @VisibleForTesting\n    void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            packageRemovedLocked(uid, packageName);\n        }\n    }\n\n    @GuardedBy(\"this\")\n    private void packageRemovedLocked(int uid, String packageName) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        Ops removedOps = null;\n\n        // Remove any package state if such.\n        removedOps = uidState.pkgOps.remove(packageName);\n        mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n\n        if (removedOps != null) {\n            scheduleFastWriteLocked();\n\n            final int numOps = removedOps.size();\n            for (int opNum = 0; opNum < numOps; opNum++) {\n                final Op op = removedOps.valueAt(opNum);\n\n                final int numAttributions = op.mAttributions.size();\n                for (int attributionNum = 0; attributionNum < numAttributions;\n                        attributionNum++) {\n                    AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                    while (attributedOp.isRunning()) {\n                        attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                    }\n                    while (attributedOp.isPaused()) {\n                        attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.get(uid).clear();\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    // The callback method from AppOpsUidStateTracker\n    private void onUidStateChanged(int uid, int state, boolean foregroundModeMayChange) {\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, true);\n\n            if (uidState != null && foregroundModeMayChange && uidState.hasForegroundWatchers) {\n                for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                    if (!uidState.foregroundOps.valueAt(fgi)) {\n                        continue;\n                    }\n                    final int code = uidState.foregroundOps.keyAt(fgi);\n\n                    if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)\n                            && uidState.getUidMode(code) == AppOpsManager.MODE_FOREGROUND) {\n                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                AppOpsService::notifyOpChangedForAllPkgsInUid,\n                                this, code, uidState.uid, true, null));\n                    } else if (!uidState.pkgOps.isEmpty()) {\n                        final ArraySet<OnOpModeChangedListener> listenerSet =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (listenerSet != null) {\n                            for (int cbi = listenerSet.size() - 1; cbi >= 0; cbi--) {\n                                final OnOpModeChangedListener listener = listenerSet.valueAt(cbi);\n                                if ((listener.getFlags()\n                                        & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                        || !listener.isWatchingUid(uidState.uid)) {\n                                    continue;\n                                }\n                                for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                    final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                    if (op == null) {\n                                        continue;\n                                    }\n                                    if (op.getMode() == AppOpsManager.MODE_FOREGROUND) {\n                                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                                AppOpsService::notifyOpChanged,\n                                                this, listenerSet.valueAt(cbi), code, uidState.uid,\n                                                uidState.pkgOps.keyAt(pkgi)));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (uidState != null) {\n                int numPkgs = uidState.pkgOps.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = 0; attributionNum < numAttributions;\n                                attributionNum++) {\n                            AttributedOp attributedOp = op.mAttributions.valueAt(\n                                    attributionNum);\n\n                            attributedOp.onUidStateChanged(state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify the proc state or capability has changed for a certain UID.\n     */\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            getUidStateTracker().updateUidProcState(uid, procState, capability);\n            if (!mUidStates.contains(uid)) {\n                UidState uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n                onUidStateChanged(uid,\n                        AppOpsUidStateTracker.processStateToUidState(procState), false);\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeRecentAccesses();\n        }\n        mAppOpsCheckingService.shutdown();\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid())\n                == PackageManager.PERMISSION_GRANTED;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j = 0; j < pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                    continue;\n                }\n                resOps.add(getOpEntryForResult(curOp));\n            }\n        } else {\n            for (int j = 0; j < ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                        continue;\n                    }\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n        if (opModes == null) {\n            return null;\n        }\n\n        int opModeCount = opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = opModes.keyAt(i);\n                resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        // We get to access everything\n        final int callingPid = Binder.getCallingPid();\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        final int callingUid = Binder.getCallingUid();\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, callingPid,\n                callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        mAppOpsCheckingService.writeState();\n        mAppOpsCheckingService.readState();\n    }\n\n    @VisibleForTesting\n    void readState() {\n        mAppOpsCheckingService.readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                op.setMode(AppOpsManager.opToDefaultMode(op.op));\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        mAppOpsCheckingService.removePackage(ops.packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n            }\n            if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                previousMode = uidState.getUidMode(code);\n            } else {\n                // doesn't look right but is legacy behavior.\n                previousMode = MODE_DEFAULT;\n            }\n\n            if (!uidState.setUidMode(code, mode)) {\n                return;\n            }\n            uidState.evalForegroundOps();\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        ModeCallback listenerToIgnore = callbackToIgnore != null\n                ? mModeWatchers.get(callbackToIgnore.asBinder()) : null;\n        mAppOpsCheckingService.notifyOpChangedForAllPkgsInUid(code, uid, onlyForeground,\n                listenerToIgnore);\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        ArraySet<OnOpModeChangedListener> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot setMode: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot setMode\", e);\n            }\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.getMode() != mode) {\n                    previousMode = op.getMode();\n                    op.setMode(mode);\n\n                    if (uidState != null) {\n                        uidState.evalForegroundOps();\n                    }\n                    ArraySet<OnOpModeChangedListener> cbs =\n                            mAppOpsCheckingService.getOpModeChangedListeners(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mAppOpsCheckingService.getPackageModeChangedListeners(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<OnOpModeChangedListener> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final OnOpModeChangedListener callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(OnOpModeChangedListener callback, int code,\n            int uid, String packageName) {\n        mAppOpsCheckingService.notifyOpChanged(callback, code, uid, packageName);\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode,\n            ArraySet<OnOpModeChangedListener> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            OnOpModeChangedListener cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            int newMode = isUidOpGrantedByRole(uidState.uid, code) ? MODE_ALLOWED :\n                                    AppOpsManager.opToDefaultMode(code);\n                            uidState.setUidMode(code, newMode);\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode,\n                                        mAppOpsCheckingService.getOpModeChangedListeners(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mAppOpsCheckingService\n                                                .getPackageModeChangedListeners(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)) {\n                            int previousMode = curOp.getMode();\n                            int newMode = isPackageOpGrantedByRole(packageName, uidState.uid,\n                                    curOp.op) ? MODE_ALLOWED : AppOpsManager.opToDefaultMode(\n                                    curOp.op);\n                            if (previousMode == newMode) {\n                                continue;\n                            }\n                            curOp.setMode(newMode);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode,\n                                    mAppOpsCheckingService.getOpModeChangedListeners(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mAppOpsCheckingService\n                                            .getPackageModeChangedListeners(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                        mAppOpsCheckingService.removePackage(packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps();\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<OnOpModeChangedListener, ArrayList<ChangeRec>> ent\n                    : callbacks.entrySet()) {\n                OnOpModeChangedListener cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean isUidOpGrantedByRole(int uid, int code) {\n        if (!AppOpsManager.opIsUidAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            // Permissions are managed by UIDs, but unfortunately a package name is required in API.\n            String packageName = ArrayUtils.firstOrNull(packageManager.getPackagesForUid(uid));\n            if (packageName == null) {\n                return false;\n            }\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean isPackageOpGrantedByRole(@NonNull String packageName, int uid, int code) {\n        if (!AppOpsManager.opIsPackageAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName = packageName != null\n                && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(callingUid));\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                mAppOpsCheckingService.startWatchingOpModeChanged(cb, switchOp);\n            }\n            if (mayWatchPackageName) {\n                mAppOpsCheckingService.startWatchingPackageModeChanged(cb, packageName);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                mAppOpsCheckingService.removeListener(cb);\n            }\n\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot checkOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot checkOperation\", e);\n            }\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null\n                    && uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                final int rawMode = uidState.getUidMode(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.getMode() : op.uidState.evalMode(op.op, op.getMode());\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveNonAppUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return getPackageManagerInternal().getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, userId);\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))\n                || !isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot noteOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot noteOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.getState(), flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState.getState(),\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, OP_RECEIVE_AMBIENT_TRIGGER_AUDIO and\n        // OP_RECORD_AUDIO_SANDBOXED which we use only for attribution purposes and not as a check,\n        // also make sure that the caller is allowed to access the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        int result = MODE_DEFAULT;\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO\n                || code == OP_RECORD_AUDIO_SANDBOXED) {\n            result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        // As a special case for OP_CAMERA_SANDBOXED.\n        if (code == OP_CAMERA_SANDBOXED) {\n            result = checkOperation(OP_CAMERA, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot startOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot startOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return null;\n        }\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot finishOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot finishOperation\", e);\n            }\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        if (AppOpsManager.shouldForceCollectNoteForOp(opCode)) {\n            return true;\n        }\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private boolean isIncomingPackageValid(@Nullable String packageName, @UserIdInt int userId) {\n        final int callingUid = Binder.getCallingUid();\n        // Handle the special UIDs that don't have actual packages (audioserver, cameraserver, etc).\n        if (packageName == null || isSpecialPackage(callingUid, packageName)) {\n            return true;\n        }\n\n        // If the package doesn't exist, #verifyAndGetBypass would throw a SecurityException in\n        // the end. Although that exception would be caught and return, we could make it return\n        // early.\n        if (!isPackageExisted(packageName)) {\n            return false;\n        }\n\n        if (getPackageManagerInternal().filterAppAccess(packageName, callingUid, userId)) {\n            Slog.w(TAG, packageName + \" not found from \" + callingUid);\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            // if there is a next attribution source, it must be trusted, as well.\n            if (attributionSource.getNext() == null\n                    || attributionSource.getNext().isTrusted(mContext)) {\n                return true;\n            }\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        }\n\n        return uidState;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            getUidStateTracker().updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        if (mPackageManagerInternal == null) {\n            throw new IllegalStateException(\"PackageManagerInternal not loaded\");\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * @return {@link PackageManagerLocal}\n     */\n    private @NonNull PackageManagerLocal getPackageManagerLocal() {\n        if (mPackageManagerLocal == null) {\n            mPackageManagerLocal = LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n        if (mPackageManagerLocal == null) {\n            throw new IllegalStateException(\"PackageManagerLocal not loaded\");\n        }\n\n        return mPackageManagerLocal;\n    }\n\n    /**\n     * @return {@link UserManagerInternal}\n     */\n    private @NonNull UserManagerInternal getUserManagerInternal() {\n        if (mUserManagerInternal == null) {\n            mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);\n        }\n        if (mUserManagerInternal == null) {\n            throw new IllegalStateException(\"UserManagerInternal not loaded\");\n        }\n\n        return mUserManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull PackageState packageState) {\n        return new RestrictionBypass(packageState.getAppId() == Process.SYSTEM_UID,\n                packageState.isPrivileged(), mContext.checkPermission(\n                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1,\n                packageState.getAppId()) == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n                false);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    uid = pm.getPackageUidAsUser(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0), UserHandle.getUserId(uid));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && !uidState.pkgOps.isEmpty()) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable, non-app uids\n        int nonAppUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            nonAppUid = Process.SHELL_UID;\n        } else {\n            nonAppUid = resolveNonAppUid(packageName);\n        }\n        if (nonAppUid != Process.INVALID_UID) {\n            if (nonAppUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                                + \".\");\n                }\n                String otherUidMessage =\n                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName\n                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            // We only allow bypassing the attribution tag verification if the proxy is a\n            // system app (or is null), in order to prevent abusive apps clogging the appops\n            // system with unlimited attribution tags via proxy calls.\n            boolean proxyIsSystemAppOrNull = true;\n            if (proxyPackageName != null) {\n                int proxyAppId = UserHandle.getAppId(proxyUid);\n                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n                    proxyIsSystemAppOrNull =\n                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                }\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        int pkgUid = nonAppUid;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            var pkgState = pmInt.getPackageStateInternal(packageName);\n            var pkg = pkgState == null ? null : pkgState.getAndroidPackage();\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, pkgState.getAppId());\n                bypass = getBypassforPackage(pkgState);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            if (!suppressErrorLogs) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            }\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Read recent accesses from persistence (mRecentAccessesFile).\n     * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n     * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n     * If neither file exists, there's nothing to migrate.\n     */\n    private void readRecentAccesses() {\n        if (!mRecentAccessesFile.exists()) {\n            readRecentAccesses(mStorageFile);\n        } else {\n            readRecentAccesses(mRecentAccessesFile);\n        }\n    }\n\n    private void readRecentAccesses(AtomicFile file) {\n        synchronized (file) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = file.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + file.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                mAppOpsCheckingService.clearAllModes();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        // Parse next until we reach the start or end\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            // uid tag may be present during migration, don't print warning.\n                            XmlUtils.skipCurrentTag(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                        mAppOpsCheckingService.clearAllModes();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    @VisibleForTesting\n    void writeRecentAccesses() {\n        synchronized (mRecentAccessesFile) {\n            FileOutputStream stream;\n            try {\n                stream = mRecentAccessesFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mRecentAccessesFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mRecentAccessesFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveNonAppUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n        pw.println(\"  --uid-state-changes\");\n        pw.println(\"    Include logs about uid state changes.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                AttributedOp.InProgressStartOpEvent event =\n                        attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.mNumUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        boolean dumpUidStateChangeLogs = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n        boolean dumpAll = false;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                    dumpAll = true;\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else if (\"--uid-state-changes\".equals(arg)) {\n                    dumpUidStateChangeLogs = true;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n\n            if (!dumpHistory) {\n                needSep |= mAppOpsCheckingService.dumpListeners(dumpOp, dumpUid, dumpPackage, pw);\n            }\n\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i = 0; i < mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.getWatchingUid())) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (opModes != null\n                            && opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).getMode() == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                uidState.dump(pw, nowElapsed);\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.getMode()) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.getMode()));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj == null\n                                    ? AppOpsManager.opToDefaultMode(switchOp) : switchObj.getMode();\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            boolean showUserRestrictions = !(dumpMode < 0 && !dumpWatchers && !dumpHistory);\n            mAppOpsRestrictions.dumpRestrictions(pw, dumpOp, dumpPackage, showUserRestrictions);\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n\n            if (dumpAll || dumpUidStateChangeLogs) {\n                pw.println();\n                pw.println(\"Uid State Changes Event Log:\");\n                getUidStateTracker().dumpEvents(pw);\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.getMode() != MODE_ALLOWED && op.getMode() != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n                            .bypass;\n                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n                            Context.DEVICE_ID_DEFAULT, bypass, false)) {\n                        // Only resume if there are no other restrictions remaining on this op\n                        attrOp.resume();\n                    }\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<OnOpModeChangedListener> modeChangedListenerSet;\n        synchronized (this) {\n            modeChangedListenerSet = mAppOpsCheckingService.getOpModeChangedListeners(code);\n            if (modeChangedListenerSet == null) {\n                return;\n            }\n        }\n\n        notifyOpChanged(modeChangedListenerSet,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return false;\n        }\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeatureId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"this\")\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.valueAt(i).clear();\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveNonAppUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return Process.INVALID_UID;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n                    restricted, excludedPackageTags);\n        }\n\n        public boolean hasRestriction(int code, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n                    attributionTag, isCheckOp);\n        }\n\n        public void removeUser(int userId) {\n            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n        }\n\n        public boolean isDefault() {\n            return !mAppOpsRestrictions.hasUserRestrictions(token);\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mAppOpsRestrictions.clearUserRestrictions(token);\n                mOpUserRestrictions.remove(token);\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n        }\n\n        boolean hasRestriction(int code) {\n            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n        }\n\n        boolean isDefault() {\n            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n        }\n\n        @Override\n        public void binderDied() {\n            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n            mOpGlobalRestrictions.remove(mToken);\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n        @Override\n        public boolean isUidInForeground(int uid) {\n            synchronized (AppOpsService.this) {\n                return mUidStateTracker.isUidInForeground(uid);\n            }\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-353240784",
        "downstream_version": "14",
        "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    // See {@link Provider#pendingDeletedWidgetIds}.\n    private static final String PENDING_DELETED_IDS_ATTR = \"pending_deleted_ids\";\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    // Handles user and package related broadcasts.\n    // See {@link #registerBroadcastReceiver}\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        if (DEBUG) {\n            Slog.i(TAG, \"addWidgetLocked() \" + widget);\n        }\n        ensureWidgetCountBeforeAddLocked(widget);\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Ensures that the widget count for the widget's host is not greater than the maximum\n     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n     * from the host until the count is less than or equal to the maximum.\n     */\n    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n        if (widget.host == null || widget.host.id == null) {\n            return;\n        }\n        final List<Widget> widgetsInSameHost = new ArrayList<>();\n        for (Widget w : mWidgets) {\n            if (w.host != null && widget.host.id.equals(w.host.id)) {\n                widgetsInSameHost.add(w);\n            }\n        }\n        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n            removeWidgetLocked(widgetsInSameHost.remove(0));\n        }\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        if (provider != null) {\n                           provider.widgets.remove(widget);\n                        }\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    },
    {
        "cve_id": "ASB-A-382064697",
        "downstream_version": "14",
        "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
        "ground_truth_codebase": "",
        "llm_patched_codebase": "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.devicepolicy;\n\nimport static android.Manifest.permission.BIND_DEVICE_ADMIN;\nimport static android.Manifest.permission.LOCK_DEVICE;\nimport static android.Manifest.permission.MANAGE_CA_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;\nimport static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;\nimport static android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS;\nimport static android.Manifest.permission.MASTER_CLEAR;\nimport static android.Manifest.permission.QUERY_ADMIN_POLICY;\nimport static android.Manifest.permission.REQUEST_PASSWORD_COMPLEXITY;\nimport static android.Manifest.permission.SET_TIME;\nimport static android.Manifest.permission.SET_TIME_ZONE;\nimport static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_ALL_MASK;\nimport static android.accounts.AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION;\nimport static android.app.ActivityManager.LOCK_TASK_MODE_NONE;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.AppOpsManager.OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DeviceAdminInfo.HEADLESS_DEVICE_OWNER_MODE_AFFILIATED;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_FORCE_LOCK;\nimport static android.app.admin.DeviceAdminInfo.USES_POLICY_WIPE_DATA;\nimport static android.app.admin.DeviceAdminReceiver.ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED;\nimport static android.app.admin.DeviceAdminReceiver.EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE;\nimport static android.app.admin.DevicePolicyIdentifiers.AUTO_TIMEZONE_POLICY;\nimport static android.app.admin.DevicePolicyManager.ACTION_CHECK_POLICY_COMPLIANCE;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_FINANCING_STATE_CHANGED;\nimport static android.app.admin.DevicePolicyManager.ACTION_DEVICE_POLICY_RESOURCE_UPDATED;\nimport static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_USER;\nimport static android.app.admin.DevicePolicyManager.ACTION_SYSTEM_UPDATE_POLICY_CHANGED;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_CERT_SELECTION;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_ENABLE_SYSTEM_APP;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_INSTALL_EXISTING_PACKAGE;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_KEEP_UNINSTALLED_PACKAGES;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_NETWORK_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;\nimport static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.DEVICE_OWNER_TYPE_FINANCED;\nimport static android.app.admin.DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_HIBERNATION;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_POWER_RESTRICTIONS;\nimport static android.app.admin.DevicePolicyManager.EXEMPT_FROM_SUSPENSION;\nimport static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_IDS;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_DRAWABLE;\nimport static android.app.admin.DevicePolicyManager.EXTRA_RESOURCE_TYPE_STRING;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_BASE_INFO;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_IMEI;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_INDIVIDUAL_ATTESTATION;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_MEID;\nimport static android.app.admin.DevicePolicyManager.ID_TYPE_SERIAL;\nimport static android.app.admin.DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;\nimport static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;\nimport static android.app.admin.DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;\nimport static android.app.admin.DevicePolicyManager.NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_LOW;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_COMPLEXITY_NONE;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_MANAGED;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;\nimport static android.app.admin.DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;\nimport static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_NOT_SUSPENDED;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_EXPLICITLY;\nimport static android.app.admin.DevicePolicyManager.PERSONAL_APPS_SUSPENDED_PROFILE_TIMEOUT;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OFF;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_OPPORTUNISTIC;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_MODE_UNKNOWN;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;\nimport static android.app.admin.DevicePolicyManager.PRIVATE_DNS_SET_NO_ERROR;\nimport static android.app.admin.DevicePolicyManager.PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_SETUP_FINALIZED;\nimport static android.app.admin.DevicePolicyManager.STATE_USER_UNMANAGED;\nimport static android.app.admin.DevicePolicyManager.STATUS_ACCOUNTS_NOT_EMPTY;\nimport static android.app.admin.DevicePolicyManager.STATUS_CANNOT_ADD_MANAGED_PROFILE;\nimport static android.app.admin.DevicePolicyManager.STATUS_DEVICE_ADMIN_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_DEVICE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_HAS_PAIRED;\nimport static android.app.admin.DevicePolicyManager.STATUS_HEADLESS_SYSTEM_USER_MODE_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_MANAGED_USERS_NOT_SUPPORTED;\nimport static android.app.admin.DevicePolicyManager.STATUS_NONSYSTEM_USER_EXISTS;\nimport static android.app.admin.DevicePolicyManager.STATUS_NOT_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_OK;\nimport static android.app.admin.DevicePolicyManager.STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;\nimport static android.app.admin.DevicePolicyManager.STATUS_SYSTEM_USER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_HAS_PROFILE_OWNER;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_NOT_RUNNING;\nimport static android.app.admin.DevicePolicyManager.STATUS_USER_SETUP_COMPLETED;\nimport static android.app.admin.DevicePolicyManager.WIPE_EUICC;\nimport static android.app.admin.DevicePolicyManager.WIPE_EXTERNAL_STORAGE;\nimport static android.app.admin.DevicePolicyManager.WIPE_RESET_PROTECTION_DATA;\nimport static android.app.admin.DevicePolicyManager.WIPE_SILENTLY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.LOCATION_CHANGED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NETWORK_LOGGING_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.PRINTING_DISABLED_NAMED_ADMIN;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_GENERIC_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_ORG_OWNED_MESSAGE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_DELETED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_BODY;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TITLE;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.WORK_PROFILE_TELEPHONY_PAUSED_TURN_ON_BUTTON;\nimport static android.app.admin.ProvisioningException.ERROR_ADMIN_PACKAGE_INSTALLATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PRE_CONDITION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_PROFILE_CREATION_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_REMOVE_NON_REQUIRED_APPS_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SETTING_PROFILE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_SET_DEVICE_OWNER_FAILED;\nimport static android.app.admin.ProvisioningException.ERROR_STARTING_PROFILE_FAILED;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_AVAILABLE;\nimport static android.content.Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.pm.PackageManager.GET_META_DATA;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE;\nimport static android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\nimport static android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES;\nimport static android.content.pm.PackageManager.PERMISSION_GRANTED;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_DEFAULT;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_BLOCKING;\nimport static android.net.ConnectivityManager.PROFILE_NETWORK_PREFERENCE_ENTERPRISE_NO_FALLBACK;\nimport static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;\nimport static android.provider.DeviceConfig.NAMESPACE_DEVICE_POLICY_MANAGER;\nimport static android.provider.Settings.Global.PRIVATE_DNS_SPECIFIER;\nimport static android.provider.Settings.Secure.MANAGED_PROVISIONING_DPC_DOWNLOADED;\nimport static android.provider.Settings.Secure.USER_SETUP_COMPLETE;\nimport static android.provider.Telephony.Carriers.DPC_URI;\nimport static android.provider.Telephony.Carriers.ENFORCE_KEY;\nimport static android.provider.Telephony.Carriers.ENFORCE_MANAGED_URI;\nimport static android.provider.Telephony.Carriers.INVALID_APN_ID;\nimport static android.security.keystore.AttestationUtils.USE_INDIVIDUAL_ATTESTATION;\nimport static com.android.internal.logging.nano.MetricsProto.MetricsEvent.PROVISIONING_ENTRY_POINT_ADB;\nimport static com.android.internal.widget.LockPatternUtils.CREDENTIAL_TYPE_NONE;\nimport static com.android.internal.widget.LockPatternUtils.StrongAuthTracker.STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW;\nimport static com.android.server.SystemTimeZone.TIME_ZONE_CONFIDENCE_HIGH;\nimport static com.android.server.am.ActivityManagerService.STOCK_PM_FLAGS;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_DEVICE_OWNER;\nimport static com.android.server.devicepolicy.TransferOwnershipMetadataManager.ADMIN_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_DEVICE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER;\nimport static com.android.server.pm.UserManagerInternal.OWNER_TYPE_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;\n\nimport android.Manifest;\nimport android.Manifest.permission;\nimport android.accessibilityservice.AccessibilityServiceInfo;\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.ActivityTaskManager;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.Mode;\nimport android.app.BroadcastOptions;\nimport android.app.IActivityManager;\nimport android.app.IActivityTaskManager;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.StatusBarManager;\nimport android.app.admin.AccountTypePolicyKey;\nimport android.app.admin.BooleanPolicyValue;\nimport android.app.admin.BundlePolicyValue;\nimport android.app.admin.ComponentNamePolicyValue;\nimport android.app.admin.DeviceAdminInfo;\nimport android.app.admin.DeviceAdminReceiver;\nimport android.app.admin.DevicePolicyCache;\nimport android.app.admin.DevicePolicyDrawableResource;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManager.DeviceOwnerType;\nimport android.app.admin.DevicePolicyManager.DevicePolicyOperation;\nimport android.app.admin.DevicePolicyManager.OperationSafetyReason;\nimport android.app.admin.DevicePolicyManager.PasswordComplexity;\nimport android.app.admin.DevicePolicyManager.PersonalAppsSuspensionReason;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerLiteInternal;\nimport android.app.admin.DevicePolicySafetyChecker;\nimport android.app.admin.DevicePolicyState;\nimport android.app.admin.DevicePolicyStringResource;\nimport android.app.admin.DeviceStateCache;\nimport android.app.admin.FactoryResetProtectionPolicy;\nimport android.app.admin.FullyManagedDeviceProvisioningParams;\nimport android.app.admin.IDevicePolicyManager;\nimport android.app.admin.IntegerPolicyValue;\nimport android.app.admin.IntentFilterPolicyKey;\nimport android.app.admin.LockTaskPolicy;\nimport android.app.admin.LongPolicyValue;\nimport android.app.admin.ManagedProfileProvisioningParams;\nimport android.app.admin.ManagedSubscriptionsPolicy;\nimport android.app.admin.NetworkEvent;\nimport android.app.admin.PackagePolicy;\nimport android.app.admin.ParcelableGranteeMap;\nimport android.app.admin.ParcelableResource;\nimport android.app.admin.PasswordMetrics;\nimport android.app.admin.PasswordPolicy;\nimport android.app.admin.PolicyKey;\nimport android.app.admin.PolicyValue;\nimport android.app.admin.PreferentialNetworkServiceConfig;\nimport android.app.admin.SecurityLog;\nimport android.app.admin.SecurityLog.SecurityEvent;\nimport android.app.admin.StartInstallingUpdateCallback;\nimport android.app.admin.StringSetPolicyValue;\nimport android.app.admin.SystemUpdateInfo;\nimport android.app.admin.SystemUpdatePolicy;\nimport android.app.admin.UnsafeStateException;\nimport android.app.admin.UserRestrictionPolicyKey;\nimport android.app.admin.WifiSsidPolicy;\nimport android.app.backup.IBackupManager;\nimport android.app.compat.CompatChanges;\nimport android.app.role.OnRoleHoldersChangedListener;\nimport android.app.role.RoleManager;\nimport android.app.trust.TrustManager;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.PermissionChecker;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.CrossProfileApps;\nimport android.content.pm.CrossProfileAppsInternal;\nimport android.content.pm.IPackageDataObserver;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageInstaller;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.StringParceledListSlice;\nimport android.content.pm.UserInfo;\nimport android.content.pm.UserPackage;\nimport android.content.pm.parsing.FrameworkParsingPackageUtils;\nimport android.content.res.Resources;\nimport android.database.ContentObserver;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.hardware.usb.UsbManager;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.media.AudioManager;\nimport android.media.IAudioService;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivitySettingsManager;\nimport android.net.IIpConnectivityMetrics;\nimport android.net.ProfileNetworkPreference;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport android.net.VpnManager;\nimport android.net.metrics.IpConnectivityLog;\nimport android.net.wifi.WifiManager;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PersistableBundle;\nimport android.os.PowerManager;\nimport android.os.PowerManagerInternal;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ServiceSpecificException;\nimport android.os.ShellCallback;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.UserManager.EnforcingUser;\nimport android.os.UserManager.UserRestrictionSource;\nimport android.os.storage.StorageManager;\nimport android.permission.AdminPermissionControlParams;\nimport android.permission.IPermissionManager;\nimport android.permission.PermissionControllerManager;\nimport android.provider.CalendarContract;\nimport android.provider.ContactsContract.QuickContact;\nimport android.provider.ContactsInternal;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.provider.Settings.Global;\nimport android.provider.Telephony;\nimport android.security.AppUriAuthenticationPolicy;\nimport android.security.IKeyChainAliasCallback;\nimport android.security.IKeyChainService;\nimport android.security.KeyChain;\nimport android.security.KeyChain.KeyChainConnection;\nimport android.security.KeyStore;\nimport android.security.keymaster.KeymasterCertificateChain;\nimport android.security.keystore.AttestationUtils;\nimport android.security.keystore.KeyGenParameterSpec;\nimport android.security.keystore.ParcelableKeyGenParameterSpec;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.telecom.TelecomManager;\nimport android.telephony.SubscriptionManager;\nimport android.telephony.TelephonyManager;\nimport android.telephony.data.ApnSetting;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.DebugUtils;\nimport android.util.IndentingPrintWriter;\nimport android.util.IntArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.Xml;\nimport android.view.IWindowManager;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.accessibility.IAccessibilityManager;\nimport android.view.inputmethod.InputMethodInfo;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.LocalePicker;\nimport com.android.internal.infra.AndroidFuture;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.net.NetworkUtilsInternal;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.statusbar.IStatusBarService;\nimport com.android.internal.telephony.SmsApplication;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.FunctionalUtils.ThrowingRunnable;\nimport com.android.internal.util.FunctionalUtils.ThrowingSupplier;\nimport com.android.internal.util.JournaledFile;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.StatLogger;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.internal.widget.LockSettingsInternal;\nimport com.android.internal.widget.LockscreenCredential;\nimport com.android.internal.widget.PasswordValidationError;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.net.module.util.ProxyUtils;\nimport com.android.server.AlarmManagerInternal;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.PersistentDataBlockManagerInternal;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemService;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.devicepolicy.ActiveAdmin.TrustAgentInfo;\nimport com.android.server.inputmethod.InputMethodManagerInternal;\nimport com.android.server.net.NetworkPolicyManagerInternal;\nimport com.android.server.pm.DefaultCrossProfileIntentFilter;\nimport com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.RestrictionsSet;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.UserManagerInternal.UserRestrictionsListener;\nimport com.android.server.pm.UserRestrictionsUtils;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.storage.DeviceStorageMonitorInternal;\nimport com.android.server.uri.NeededUriGrants;\nimport com.android.server.uri.UriGrantsManagerInternal;\nimport com.android.server.utils.Slogf;\nimport com.android.server.wm.ActivityTaskManagerInternal;\n\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.text.DateFormat;\nimport java.time.LocalDate;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\n/**\n * Implementation of the device policy APIs.\n */\npublic class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n\n    protected static final String LOG_TAG = \"DevicePolicyManager\";\n\n    private static final String ATTRIBUTION_TAG = \"DevicePolicyManagerService\";\n\n    static final boolean VERBOSE_LOG = false; // DO NOT SUBMIT WITH TRUE\n\n    static final String DEVICE_POLICIES_XML = \"device_policies.xml\";\n\n    static final String POLICIES_VERSION_XML = \"device_policies_version\";\n\n    private static final String TRANSFER_OWNERSHIP_PARAMETERS_XML =\n            \"transfer-ownership-parameters.xml\";\n\n    private static final String TAG_TRANSFER_OWNERSHIP_BUNDLE = \"transfer-ownership-bundle\";\n\n    private static final int REQUEST_EXPIRE_PASSWORD = 5571;\n\n    private static final int REQUEST_PROFILE_OFF_DEADLINE = 5572;\n\n    // Binary XML serializer doesn't support longer strings\n    private static final int MAX_POLICY_STRING_LENGTH = 65535;\n    // FrameworkParsingPackageUtils#MAX_FILE_NAME_SIZE, Android packages are used in dir names.\n    private static final int MAX_PACKAGE_NAME_LENGTH = 223;\n\n    private static final int MAX_PROFILE_NAME_LENGTH = 200;\n    private static final int MAX_LONG_SUPPORT_MESSAGE_LENGTH = 20000;\n    private static final int MAX_SHORT_SUPPORT_MESSAGE_LENGTH = 200;\n    private static final int MAX_ORG_NAME_LENGTH = 200;\n\n    private static final long MS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n\n    private static final long EXPIRATION_GRACE_PERIOD_MS = 5 * MS_PER_DAY; // 5 days, in ms\n    private static final long MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD = 3 * MS_PER_DAY;\n    /** When to warn the user about the approaching work profile off deadline: 1 day before */\n    private static final long MANAGED_PROFILE_OFF_WARNING_PERIOD = 1 * MS_PER_DAY;\n\n    private static final String ACTION_EXPIRED_PASSWORD_NOTIFICATION =\n            \"com.android.server.ACTION_EXPIRED_PASSWORD_NOTIFICATION\";\n\n    /** Broadcast action invoked when the user taps a notification to turn the profile on. */\n    @VisibleForTesting\n    static final String ACTION_TURN_PROFILE_ON_NOTIFICATION =\n            \"com.android.server.ACTION_TURN_PROFILE_ON_NOTIFICATION\";\n\n    /** Broadcast action for tracking managed profile maximum time off. */\n    @VisibleForTesting\n    static final String ACTION_PROFILE_OFF_DEADLINE =\n            \"com.android.server.ACTION_PROFILE_OFF_DEADLINE\";\n\n    private static final String CALLED_FROM_PARENT = \"calledFromParent\";\n    private static final String NOT_CALLED_FROM_PARENT = \"notCalledFromParent\";\n\n    private static final String CREDENTIAL_MANAGEMENT_APP = \"credentialManagementApp\";\n    private static final String NOT_CREDENTIAL_MANAGEMENT_APP = \"notCredentialManagementApp\";\n\n    private static final String NULL_STRING_ARRAY = \"nullStringArray\";\n\n    private static final String ALLOW_USER_PROVISIONING_KEY = \"ro.config.allowuserprovisioning\";\n\n    // Comprehensive list of delegations.\n    private static final String DELEGATIONS[] = {\n        DELEGATION_CERT_INSTALL,\n        DELEGATION_APP_RESTRICTIONS,\n        DELEGATION_BLOCK_UNINSTALL,\n        DELEGATION_ENABLE_SYSTEM_APP,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_PACKAGE_ACCESS,\n        DELEGATION_PERMISSION_GRANT,\n        DELEGATION_INSTALL_EXISTING_PACKAGE,\n        DELEGATION_KEEP_UNINSTALLED_PACKAGES,\n        DELEGATION_NETWORK_LOGGING,\n        DELEGATION_SECURITY_LOGGING,\n        DELEGATION_CERT_SELECTION,\n    };\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of a\n    // managed profile.\n    private static final List<String> DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_NETWORK_LOGGING,\n            });\n\n    // Subset of delegations that can only be delegated by Device Owner or Profile Owner of an\n    // organization-owned and managed profile.\n    private static final List<String>\n            DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS =\n            Arrays.asList(new String[]{\n                    DELEGATION_SECURITY_LOGGING,\n            });\n\n    // Subset of delegations that only one single package within a given user can hold\n    private static final List<String> EXCLUSIVE_DELEGATIONS = Arrays.asList(new String[] {\n            DELEGATION_NETWORK_LOGGING,\n            DELEGATION_SECURITY_LOGGING,\n            DELEGATION_CERT_SELECTION,\n    });\n\n    /**\n     * System property whose value indicates whether the device is fully owned by an organization:\n     * it can be either a device owner device, or a device with an organization-owned managed\n     * profile.\n     *\n     * <p>The state is stored as a Boolean string.\n     */\n    private static final String PROPERTY_ORGANIZATION_OWNED = \"ro.organization_owned\";\n\n    private static final int STATUS_BAR_DISABLE_MASK =\n            StatusBarManager.DISABLE_EXPAND |\n            StatusBarManager.DISABLE_NOTIFICATION_ICONS |\n            StatusBarManager.DISABLE_NOTIFICATION_ALERTS |\n            StatusBarManager.DISABLE_SEARCH;\n\n    private static final int STATUS_BAR_DISABLE2_MASK =\n            StatusBarManager.DISABLE2_QUICK_SETTINGS;\n\n    private static final Set<String> SECURE_SETTINGS_ALLOWLIST;\n    private static final Set<String> SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_ALLOWLIST;\n    private static final Set<String> GLOBAL_SETTINGS_DEPRECATED;\n    private static final Set<String> SYSTEM_SETTINGS_ALLOWLIST;\n    private static final Set<Integer> DA_DISALLOWED_POLICIES;\n    private static final String AB_DEVICE_KEY = \"ro.build.ab_update\";\n    // The version of the current DevicePolicyManagerService data. This version is used\n    // to decide whether an existing policy in the {@link #DEVICE_POLICIES_XML} needs to\n    // be upgraded. See {@link PolicyVersionUpgrader} on instructions how to add an upgrade\n    // step.\n    static final int DPMS_VERSION = 5;\n\n    static {\n        SECURE_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.DEFAULT_INPUT_METHOD);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.SKIP_FIRST_USE_HINTS);\n        SECURE_SETTINGS_ALLOWLIST.add(Settings.Secure.INSTALL_NON_MARKET_APPS);\n\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST = new ArraySet<>();\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.addAll(SECURE_SETTINGS_ALLOWLIST);\n        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST.add(Settings.Secure.LOCATION_MODE);\n\n        GLOBAL_SETTINGS_ALLOWLIST = new ArraySet<>();\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.ADB_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.ADB_WIFI_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.AUTO_TIME);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.AUTO_TIME_ZONE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.DATA_ROAMING);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.USB_MASS_STORAGE_ENABLED);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.WIFI_SLEEP_POLICY);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.STAY_ON_WHILE_PLUGGED_IN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.PRIVATE_DNS_MODE);\n        GLOBAL_SETTINGS_ALLOWLIST.add(Settings.Global.PRIVATE_DNS_SPECIFIER);\n\n        GLOBAL_SETTINGS_DEPRECATED = new ArraySet<>();\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.BLUETOOTH_ON);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.DEVELOPMENT_SETTINGS_ENABLED);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.MODE_RINGER);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.NETWORK_PREFERENCE);\n        GLOBAL_SETTINGS_DEPRECATED.add(Settings.Global.WIFI_ON);\n\n        SYSTEM_SETTINGS_ALLOWLIST = new ArraySet<>();\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_FLOAT);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_BRIGHTNESS_MODE);\n        SYSTEM_SETTINGS_ALLOWLIST.add(Settings.System.SCREEN_OFF_TIMEOUT);\n\n        DA_DISALLOWED_POLICIES = new ArraySet<>();\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD);\n        DA_DISALLOWED_POLICIES.add(DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD);\n    }\n\n    /**\n     * Keyguard features that when set on a profile affect the profile content or challenge only.\n     * These cannot be set on the managed profile's parent DPM instance\n     */\n    private static final int PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY =\n            DevicePolicyManager.KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS;\n\n    /** Keyguard features that are allowed to be set on a managed profile */\n    private static final int PROFILE_KEYGUARD_FEATURES =\n            NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER\n                    | PROFILE_KEYGUARD_FEATURES_PROFILE_ONLY;\n\n    private static final int DEVICE_ADMIN_DEACTIVATE_TIMEOUT = 10000;\n\n    /**\n     * Minimum timeout in milliseconds after which unlocking with weak auth times out,\n     * i.e. the user has to use a strong authentication method like password, PIN or pattern.\n     */\n    private static final long MINIMUM_STRONG_AUTH_TIMEOUT_MS = TimeUnit.HOURS.toMillis(1);\n\n    /**\n     * The amount of ms that a managed kiosk must go without user interaction to be considered\n     * unattended.\n     */\n    private static final int UNATTENDED_MANAGED_KIOSK_MS = 30000;\n\n    /**\n     * Strings logged with {@link\n     * com.android.internal.logging.nano.MetricsProto.MetricsEvent#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#PROVISIONING_ENTRY_POINT_ADB},\n     * {@link DevicePolicyEnums#SET_NETWORK_LOGGING_ENABLED} and\n     * {@link DevicePolicyEnums#RETRIEVE_NETWORK_LOGS}.\n     */\n    private static final String LOG_TAG_PROFILE_OWNER = \"profile-owner\";\n    private static final String LOG_TAG_DEVICE_OWNER = \"device-owner\";\n\n    /**\n     * For admin apps targeting R+, throw when the app sets password requirement\n     * that is not taken into account at given quality. For example when quality is set\n     * to {@link android.app.admin.DevicePolicyManager#PASSWORD_QUALITY_UNSPECIFIED}, it doesn't\n     * make sense to require certain password length. If the intent is to require a password of\n     * certain length having at least NUMERIC quality, the admin should first call\n     * {@link android.app.admin.DevicePolicyManager#setPasswordQuality} and only then call\n     * {@link android.app.admin.DevicePolicyManager#setPasswordMinimumLength}.\n     *\n     * <p>Conversely when an admin app targeting R+ lowers password quality, those\n     * requirements that stop making sense are reset to default values.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long ADMIN_APP_PASSWORD_COMPLEXITY = 123562444L;\n\n    /**\n     * Admin apps targeting Android R+ may not use\n     * {@link android.app.admin.DevicePolicyManager#setSecureSetting} to change the deprecated\n     * {@link android.provider.Settings.Secure#LOCATION_MODE} setting. Instead they should use\n     * {@link android.app.admin.DevicePolicyManager#setLocationEnabled}.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.Q)\n    private static final long USE_SET_LOCATION_ENABLED = 117835097L;\n\n    /**\n     * Forces wipeDataNoLock to attempt removing the user or throw an error as\n     * opposed to trying to factory reset the device first and only then falling back to user\n     * removal.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long EXPLICIT_WIPE_BEHAVIOUR = 242193913L;\n\n    /**\n     * Apps targetting U+ should now expect that attempts to grant sensor permissions without\n     * authorisation will result in a security exception.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long THROW_SECURITY_EXCEPTION_FOR_SENSOR_PERMISSIONS = 277035314L;\n\n    // Only add to the end of the list. Do not change or rearrange these values, that will break\n    // historical data. Do not use negative numbers or zero, logger only handles positive\n    // integers.\n    private static final int COPY_ACCOUNT_SUCCEEDED = 1;\n    private static final int COPY_ACCOUNT_FAILED = 2;\n    private static final int COPY_ACCOUNT_TIMED_OUT = 3;\n    private static final int COPY_ACCOUNT_EXCEPTION = 4;\n\n    @IntDef({\n            COPY_ACCOUNT_SUCCEEDED,\n            COPY_ACCOUNT_FAILED,\n            COPY_ACCOUNT_TIMED_OUT,\n            COPY_ACCOUNT_EXCEPTION})\n    private @interface CopyAccountStatus {}\n\n    /**\n     * Mapping of {@link android.app.admin.DevicePolicyManager.ApplicationExemptionConstants} to\n     * corresponding app-ops.\n     */\n    private static final Map<Integer, String> APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS =\n            new ArrayMap<>();\n    static {\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_SUSPENSION, OPSTR_SYSTEM_EXEMPT_FROM_SUSPENSION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS,\n                OPSTR_SYSTEM_EXEMPT_FROM_DISMISSIBLE_NOTIFICATIONS);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION,\n                OPSTR_SYSTEM_EXEMPT_FROM_ACTIVITY_BG_START_RESTRICTION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_HIBERNATION, OPSTR_SYSTEM_EXEMPT_FROM_HIBERNATION);\n        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS.put(\n                EXEMPT_FROM_POWER_RESTRICTIONS, OPSTR_SYSTEM_EXEMPT_FROM_POWER_RESTRICTIONS);\n    }\n\n    /**\n     * Admin apps targeting Android S+ may not use\n     * {@link android.app.admin.DevicePolicyManager#setPasswordQuality} to set password quality\n     * on the {@code DevicePolicyManager} instance obtained by calling\n     * {@link android.app.admin.DevicePolicyManager#getParentProfileInstance}.\n     * Instead, they should use\n     * {@link android.app.admin.DevicePolicyManager#setRequiredPasswordComplexity} to set\n     * coarse-grained password requirements device-wide.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.S)\n    private static final long PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT = 165573442L;\n\n    /**\n     * For Admin Apps targeting U+\n     * If {@link android.security.IKeyChainService#setGrant} is called with an alias with no\n     * existing key, throw IllegalArgumentException.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    private static final long THROW_EXCEPTION_WHEN_KEY_MISSING = 175101461L;\n\n    private static final String CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG =\n            \"The alias provided must be contained in the aliases specified in the credential \"\n                    + \"management app's authentication policy\";\n    private static final String NOT_SYSTEM_CALLER_MSG = \"Only the system can %s\";\n\n    private static final String PERMISSION_BASED_ACCESS_EXPERIMENT_FLAG =\n            \"enable_permission_based_access\";\n    private static final boolean DEFAULT_VALUE_PERMISSION_BASED_ACCESS_FLAG = false;\n\n    private static final String ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG =\n            \"enable_device_policy_engine\";\n    private static final boolean DEFAULT_ENABLE_DEVICE_POLICY_ENGINE_FOR_FINANCE_FLAG = true;\n\n    // TODO(b/265683382) remove the flag after rollout.\n    private static final String KEEP_PROFILES_RUNNING_FLAG = \"enable_keep_profiles_running\";\n    public static final boolean DEFAULT_KEEP_PROFILES_RUNNING_FLAG = true;\n\n    // TODO(b/261999445) remove the flag after rollout.\n    private static final String HEADLESS_FLAG = \"headless\";\n    private static final boolean DEFAULT_HEADLESS_FLAG = true;\n\n    // TODO(b/266831522) remove the flag after rollout.\n    private static final String APPLICATION_EXEMPTIONS_FLAG = \"application_exemptions\";\n    private static final boolean DEFAULT_APPLICATION_EXEMPTIONS_FLAG = true;\n\n    /**\n     * For apps targeting U+\n     * Enable multiple admins to coexist on the same device.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    static final long ENABLE_COEXISTENCE_CHANGE = 260560985L;\n\n    final Context mContext;\n    final Injector mInjector;\n    final PolicyPathProvider mPathProvider;\n    final IPackageManager mIPackageManager;\n    final IPermissionManager mIPermissionManager;\n    final UserManager mUserManager;\n    final UserManagerInternal mUserManagerInternal;\n    final UsageStatsManagerInternal mUsageStatsManagerInternal;\n    final TelephonyManager mTelephonyManager;\n    final RoleManager mRoleManager;\n    private final LockPatternUtils mLockPatternUtils;\n    private final LockSettingsInternal mLockSettingsInternal;\n    private final DeviceAdminServiceController mDeviceAdminServiceController;\n    private final OverlayPackagesProvider mOverlayPackagesProvider;\n\n    private final DevicePolicyCacheImpl mPolicyCache = new DevicePolicyCacheImpl();\n    private final DeviceStateCacheImpl mStateCache = new DeviceStateCacheImpl();\n    private final Object mESIDInitilizationLock = new Object();\n    private EnterpriseSpecificIdCalculator mEsidCalculator;\n    private final Object mSubscriptionsChangedListenerLock = new Object();\n    @GuardedBy(\"mSubscriptionsChangedListenerLock\")\n    private SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedListener;\n\n    /**\n     * Contains the list of OEM Default Role Holders for Contact-related roles\n     * (DIALER, SMS, SYSTEM_CONTACTS)\n     */\n    private final Set<String> mContactSystemRoleHolders;\n\n    /**\n     * Contains (package-user) pairs to remove. An entry (p, u) implies that removal of package p\n     * is requested for user u.\n     */\n    private final Set<UserPackage> mPackagesToRemove = new ArraySet<>();\n\n    final LocalService mLocalService;\n\n    // Stores and loads state on device and profile owners.\n    @VisibleForTesting\n    final Owners mOwners;\n\n    private final Binder mToken = new Binder();\n\n    /**\n     * Whether or not device admin feature is supported. If it isn't return defaults for all\n     * public methods, unless the caller has the appropriate permission for a particular method.\n     */\n    final boolean mHasFeature;\n\n    /**\n     * Whether or not this device is a watch.\n     */\n    final boolean mIsWatch;\n\n    /**\n     * Whether or not this device is an automotive.\n     */\n    private final boolean mIsAutomotive;\n\n    /**\n     * Whether this device has the telephony feature.\n     */\n    final boolean mHasTelephonyFeature;\n\n    private final CertificateMonitor mCertificateMonitor;\n    private final SecurityLogMonitor mSecurityLogMonitor;\n    private final RemoteBugreportManager mBugreportCollectionManager;\n\n    @GuardedBy(\"getLockObject()\")\n    private NetworkLogger mNetworkLogger;\n\n    private final SetupContentObserver mSetupContentObserver;\n    private final DevicePolicyConstantsObserver mConstantsObserver;\n\n    private DevicePolicyConstants mConstants;\n\n    /**\n     * User to be switched to on {@code logoutUser()}.\n     *\n     * <p>Only used on devices with headless system user mode\n     */\n    @GuardedBy(\"getLockObject()\")\n    private @UserIdInt int mLogoutUserId = UserHandle.USER_NULL;\n\n    /**\n     * User the network logging notification was sent to.\n     */\n    // Guarded by mHandler\n    private @UserIdInt int mNetworkLoggingNotificationUserId = UserHandle.USER_NULL;\n\n    private final DeviceManagementResourcesProvider mDeviceManagementResourcesProvider;\n    private final DevicePolicyManagementRoleObserver mDevicePolicyManagementRoleObserver;\n\n    private final DevicePolicyEngine mDevicePolicyEngine;\n\n    private static final boolean ENABLE_LOCK_GUARD = true;\n\n    interface Stats {\n        int LOCK_GUARD_GUARD = 0;\n\n        int COUNT = LOCK_GUARD_GUARD + 1;\n    }\n\n    private final StatLogger mStatLogger = new StatLogger(new String[] {\n            \"LockGuard.guard()\",\n    });\n\n    private final Object mLockDoNoUseDirectly = LockGuard.installNewLock(\n            LockGuard.INDEX_DPMS, /* doWtf=*/ true);\n\n    final Object getLockObject() {\n        if (ENABLE_LOCK_GUARD) {\n            final long start = mStatLogger.getTime();\n            LockGuard.guard(LockGuard.INDEX_DPMS);\n            mStatLogger.logDurationStat(Stats.LOCK_GUARD_GUARD, start);\n        }\n        return mLockDoNoUseDirectly;\n    }\n\n    /**\n     * Check if the current thread holds the DPMS lock, and if not, do a WTF.\n     *\n     * (Doing this check too much may be costly, so don't call it in a hot path.)\n     */\n    final void ensureLocked() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            return;\n        }\n        Slogf.wtfStack(LOG_TAG, \"Not holding DPMS lock.\");\n    }\n\n    /**\n     * Calls wtfStack() if called with the DPMS lock held.\n     */\n    private void wtfIfInLock() {\n        if (Thread.holdsLock(mLockDoNoUseDirectly)) {\n            Slogf.wtfStack(LOG_TAG, \"Shouldn't be called with DPMS lock held\");\n        }\n    }\n\n    @VisibleForTesting\n    final TransferOwnershipMetadataManager mTransferOwnershipMetadataManager;\n\n    @Nullable\n    private DevicePolicySafetyChecker mSafetyChecker;\n\n    @GuardedBy(\"getLockObject()\")\n    private final ArrayList<Object> mPendingUserCreatedCallbackTokens = new ArrayList<>();\n\n    public static final class Lifecycle extends SystemService {\n        private DevicePolicyManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n            String dpmsClassName = context.getResources()\n                    .getString(R.string.config_deviceSpecificDevicePolicyManagerService);\n            if (TextUtils.isEmpty(dpmsClassName)) {\n                mService = new DevicePolicyManagerService(context);\n            } else {\n                try {\n                    Class<?> serviceClass = Class.forName(dpmsClassName);\n                    Constructor<?> constructor = serviceClass.getConstructor(Context.class);\n                    mService = (DevicePolicyManagerService) constructor.newInstance(context);\n                } catch (Exception e) {\n                    throw new IllegalStateException(\n                        \"Failed to instantiate DevicePolicyManagerService with class name: \"\n                        + dpmsClassName, e);\n                }\n            }\n        }\n\n        /** Sets the {@link DevicePolicySafetyChecker}. */\n        public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mService.setDevicePolicySafetyChecker(safetyChecker);\n        }\n\n        @Override\n        public void onStart() {\n            publishBinderService(Context.DEVICE_POLICY_SERVICE, mService);\n        }\n\n        @Override\n        public void onBootPhase(int phase) {\n            mService.systemReady(phase);\n        }\n\n        @Override\n        public void onUserStarting(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStartUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleStopUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserUnlocked(@NonNull TargetUser user) {\n            if (user.isPreCreated()) return;\n            mService.handleOnUserUnlocked(user.getUserIdentifier());\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    final SparseArray<DevicePolicyData> mUserData;\n\n    final Handler mHandler;\n    final Handler mBackgroundHandler;\n\n    /** Listens only if mHasFeature == true. */\n    final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE,\n                    getSendingUserId());\n\n            /*\n             * Network logging would ideally be started in setDeviceOwnerSystemPropertyLocked(),\n             * however it's too early in the boot process to register with IIpConnectivityMetrics\n             * to listen for events.\n             */\n            if (Intent.ACTION_USER_STARTED.equals(action) && userHandle == UserHandle.USER_SYSTEM) {\n                synchronized (getLockObject()) {\n                    if (isNetworkLoggingEnabledInternalLocked()) {\n                        setNetworkLoggingActiveInternal(true);\n                    }\n                }\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    && userHandle == mOwners.getDeviceOwnerUserId()) {\n                mBugreportCollectionManager.checkForPendingBugreportAfterBoot();\n\n            }\n            if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                    || ACTION_EXPIRED_PASSWORD_NOTIFICATION.equals(action)) {\n                if (VERBOSE_LOG) {\n                    Slogf.v(LOG_TAG, \"Sending password expiration notifications for action \"\n                            + action + \" for user \" + userHandle);\n                }\n                mHandler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        handlePasswordExpirationNotification(userHandle);\n                    }\n                });\n            }\n\n            if (Intent.ACTION_USER_ADDED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_ADDED, userHandle);\n                synchronized (getLockObject()) {\n                    // It might take a while for the user to become affiliated. Make security\n                    // and network logging unavailable in the meantime.\n                    maybePauseDeviceWideLoggingLocked();\n                }\n            } else if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_REMOVED, userHandle);\n                synchronized (getLockObject()) {\n                    // Check whether the user is affiliated, *before* removing its data.\n                    boolean isRemovedUserAffiliated = isUserAffiliatedWithDeviceLocked(userHandle);\n                    removeUserData(userHandle);\n                    if (!isRemovedUserAffiliated) {\n                        // We discard the logs when unaffiliated users are deleted (so that the\n                        // device owner cannot retrieve data about that user after it's gone).\n                        discardDeviceWideLogsLocked();\n                        // Resume logging if all remaining users are affiliated.\n                        maybeResumeDeviceWideLoggingLocked();\n                    }\n                }\n                if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                    mDevicePolicyEngine.handleUserRemoved(userHandle);\n                }\n            } else if (Intent.ACTION_USER_STARTED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STARTED, userHandle);\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                    // Reset the policy data\n                    mUserData.remove(userHandle);\n                }\n                handlePackagesChanged(null /* check all admins */, userHandle);\n                updatePersonalAppsSuspensionOnUserStart(userHandle);\n            } else if (Intent.ACTION_USER_STOPPED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_STOPPED, userHandle);\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile was stopped\");\n                    updatePersonalAppsSuspension(userHandle);\n                }\n            } else if (Intent.ACTION_USER_SWITCHED.equals(action)) {\n                sendDeviceOwnerUserCommand(DeviceAdminReceiver.ACTION_USER_SWITCHED, userHandle);\n            } else if (Intent.ACTION_USER_UNLOCKED.equals(action)) {\n                synchronized (getLockObject()) {\n                    maybeSendAdminEnabledBroadcastLocked(userHandle);\n                }\n                if (isManagedProfile(userHandle)) {\n                    Slogf.d(LOG_TAG, \"Managed profile became unlocked\");\n                    final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                    triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n                }\n            } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {\n                handlePackagesChanged(null /* check all admins */, userHandle);\n            } else if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n            } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {\n                if (intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                } else {\n                    handleNewPackageInstalled(intent.getData().getSchemeSpecificPart(), userHandle);\n                }\n            } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)\n                    && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                handlePackagesChanged(intent.getData().getSchemeSpecificPart(), userHandle);\n                removeCredentialManagementApp(intent.getData().getSchemeSpecificPart());\n            } else if (Intent.ACTION_MANAGED_PROFILE_ADDED.equals(action)) {\n                clearWipeProfileNotification();\n            } else if (Intent.ACTION_DATE_CHANGED.equals(action)\n                    || Intent.ACTION_TIME_CHANGED.equals(action)) {\n                // Update freeze period record when clock naturally progresses to the next day\n                // (ACTION_DATE_CHANGED), or when manual clock adjustment is made\n                // (ACTION_TIME_CHANGED)\n                updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                }\n            } else if (ACTION_PROFILE_OFF_DEADLINE.equals(action)) {\n                Slogf.i(LOG_TAG, \"Profile off deadline alarm was triggered\");\n                final int userId = getManagedUserId(getMainUserId());\n                if (userId >= 0) {\n                    updatePersonalAppsSuspension(userId);\n                } else {\n                    Slogf.wtf(LOG_TAG, \"Got deadline alarm for nonexistent profile\");\n                }\n            } else if (ACTION_TURN_PROFILE_ON_NOTIFICATION.equals(action)) {\n                Slogf.i(LOG_TAG, \"requesting to turn on the profile: \" + userHandle);\n                mUserManager.requestQuietModeEnabled(false, UserHandle.of(userHandle));\n            } else if (ACTION_MANAGED_PROFILE_UNAVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ false);\n                updatePersonalAppsSuspension(userHandle);\n            } else if (ACTION_MANAGED_PROFILE_AVAILABLE.equals(action)) {\n                notifyIfManagedSubscriptionsAreUnavailable(\n                        UserHandle.of(userHandle), /* managedProfileAvailable= */ true);\n                final boolean suspended = updatePersonalAppsSuspension(userHandle);\n                triggerPolicyComplianceCheckIfNeeded(userHandle, suspended);\n            } else if (LOGIN_ACCOUNTS_CHANGED_ACTION.equals(action)) {\n                calculateHasIncompatibleAccounts();\n            }\n        }\n\n        private void sendDeviceOwnerUserCommand(String action, int userHandle) {\n            synchronized (getLockObject()) {\n                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n                if (deviceOwner != null) {\n                    Bundle extras = new Bundle();\n                    extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n                    sendAdminCommandLocked(deviceOwner, action, extras, /* result */ null,\n                            /* inForeground */ true);\n                }\n            }\n        }\n    };\n\n    protected static class RestrictionsListener implements UserRestrictionsListener {\n        private final Context mContext;\n        private final UserManagerInternal mUserManagerInternal;\n        private final DevicePolicyManagerService mDpms;\n\n        public RestrictionsListener(\n                Context context,\n                UserManagerInternal userManagerInternal,\n                DevicePolicyManagerService dpms) {\n            mContext = context;\n            mUserManagerInternal = userManagerInternal;\n            mDpms = dpms;\n        }\n\n        @Override\n        public void onUserRestrictionsChanged(int userId, Bundle newRestrictions,\n                Bundle prevRestrictions) {\n            resetCrossProfileIntentFiltersIfNeeded(userId, newRestrictions, prevRestrictions);\n            resetUserVpnIfNeeded(userId, newRestrictions, prevRestrictions);\n        }\n\n        private void resetUserVpnIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            final boolean newlyEnforced =\n                    !prevRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN)\n                    && newRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_VPN);\n            if (newlyEnforced) {\n                mDpms.clearUserConfiguredVpns(userId);\n            }\n        }\n\n        private void resetCrossProfileIntentFiltersIfNeeded(\n                int userId, Bundle newRestrictions, Bundle prevRestrictions) {\n            if (UserRestrictionsUtils.restrictionsChanged(prevRestrictions, newRestrictions,\n                    UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE)) {\n                final int parentId = mUserManagerInternal.getProfileParentId(userId);\n                if (parentId == userId) {\n                    return;\n                }\n\n                // Always reset filters on the parent user, which handles cross profile intent\n                // filters between the parent and its profiles.\n                Slogf.i(LOG_TAG, \"Resetting cross-profile intent filters on restriction \"\n                        + \"change\");\n                mDpms.resetDefaultCrossProfileIntentFilters(parentId);\n                mContext.sendBroadcastAsUser(\n                        new Intent(DevicePolicyManager.ACTION_DATA_SHARING_RESTRICTION_APPLIED),\n                        UserHandle.of(userId));\n            }\n        }\n    }\n\n    private void clearUserConfiguredVpns(int userId) {\n        final String adminConfiguredVpnPkg;\n        synchronized (getLockObject()) {\n            final ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            if (owner == null) {\n                Slogf.wtf(LOG_TAG, \"Admin not found\");\n                return;\n            }\n            adminConfiguredVpnPkg = owner.mAlwaysOnVpnPackage;\n        }\n\n        // Clear always-on configuration if it wasn't set by the admin.\n        if (adminConfiguredVpnPkg == null) {\n            mInjector.getVpnManager().setAlwaysOnVpnPackageForUser(userId, null, false, null);\n        }\n\n        // Clear app authorizations to establish VPNs. When DISALLOW_CONFIG_VPN is enforced apps\n        // won't be able to get those authorizations unless it is configured by an admin.\n        final List<AppOpsManager.PackageOps> allVpnOps = mInjector.getAppOpsManager()\n                .getPackagesForOps(new int[] {AppOpsManager.OP_ACTIVATE_VPN});\n        if (allVpnOps == null) {\n            return;\n        }\n        for (AppOpsManager.PackageOps pkgOps : allVpnOps) {\n            if (UserHandle.getUserId(pkgOps.getUid()) != userId\n                    || pkgOps.getPackageName().equals(adminConfiguredVpnPkg)) {\n                continue;\n            }\n            if (pkgOps.getOps().size() != 1) {\n                Slogf.wtf(LOG_TAG, \"Unexpected number of ops returned\");\n                continue;\n            }\n            final @Mode int mode = pkgOps.getOps().get(0).getMode();\n            if (mode == MODE_ALLOWED) {\n                Slogf.i(LOG_TAG, String.format(\"Revoking VPN authorization for package %s uid %d\",\n                        pkgOps.getPackageName(), pkgOps.getUid()));\n                mInjector.getAppOpsManager().setMode(AppOpsManager.OP_ACTIVATE_VPN, pkgOps.getUid(),\n                        pkgOps.getPackageName(), MODE_DEFAULT);\n            }\n        }\n    }\n\n    private final class UserLifecycleListener implements UserManagerInternal.UserLifecycleListener {\n\n        @Override\n        public void onUserCreated(UserInfo user, Object token) {\n            mHandler.post(() -> handleNewUserCreated(user, token));\n        }\n    }\n\n    private void handlePackagesChanged(@Nullable String packageName, int userHandle) {\n        boolean removedAdmin = false;\n        String removedAdminPackage = null;\n        if (VERBOSE_LOG) {\n            Slogf.d(LOG_TAG, \"Handling package changes package \" + packageName\n                    + \" for user \" + userHandle);\n        }\n        DevicePolicyData policy = getUserData(userHandle);\n        synchronized (getLockObject()) {\n            for (int i = policy.mAdminList.size() - 1; i >= 0; i--) {\n                ActiveAdmin aa = policy.mAdminList.get(i);\n                try {\n                    // If we're checking all packages or if the specific one we're checking matches,\n                    // then check if the package and receiver still exist.\n                    final String adminPackage = aa.info.getPackageName();\n                    if (packageName == null || packageName.equals(adminPackage)) {\n                        if (mIPackageManager.getPackageInfo(adminPackage, 0, userHandle) == null\n                                || mIPackageManager.getReceiverInfo(aa.info.getComponent(),\n                                PackageManager.MATCH_DIRECT_BOOT_AWARE\n                                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n                                userHandle) == null) {\n                            Slogf.e(LOG_TAG, String.format(\n                                    \"Admin package %s not found for user %d, removing active admin\",\n                                    packageName, userHandle));\n                            removedAdmin = true;\n                            removedAdminPackage = adminPackage;\n                            policy.mAdminList.remove(i);\n                            policy.mAdminMap.remove(aa.info.getComponent());\n                            pushActiveAdminPackagesLocked(userHandle);\n                            pushMeteredDisabledPackages(userHandle);\n                        }\n                    }\n                } catch (RemoteException re) {\n                    // Shouldn't happen.\n                    Slogf.wtf(LOG_TAG, \"Error handling package changes\", re);\n                }\n            }\n            if (removedAdmin) {\n                policy.validatePasswordOwner();\n            }\n\n            boolean removedDelegate = false;\n\n            // Check if a delegate was removed.\n            for (int i = policy.mDelegationMap.size() - 1; i >= 0; i--) {\n                final String delegatePackage = policy.mDelegationMap.keyAt(i);\n                if (isRemovedPackage(packageName, delegatePackage, userHandle)) {\n                    policy.mDelegationMap.removeAt(i);\n                    removedDelegate = true;\n                }\n            }\n\n            // If it's an owner package, we may need to refresh the bound connection.\n            final ComponentName owner = getOwnerComponent(userHandle);\n            if ((packageName != null) && (owner != null)\n                    && (owner.getPackageName().equals(packageName))) {\n                startOwnerService(userHandle, \"package-broadcast\");\n            }\n            if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                mDevicePolicyEngine.handlePackageChanged(\n                        packageName, userHandle, removedAdminPackage);\n            }\n            // Persist updates if the removed package was an admin or delegate.\n            if (removedAdmin || removedDelegate) {\n                saveSettingsLocked(policy.mUserId);\n            }\n        }\n        if (removedAdmin) {\n            // The removed admin might have disabled camera, so update user restrictions.\n            pushUserRestrictions(userHandle);\n        }\n    }\n\n    private void removeCredentialManagementApp(String packageName) {\n        mBackgroundHandler.post(() -> {\n            try (KeyChainConnection connection = mInjector.keyChainBind()) {\n                IKeyChainService service = connection.getService();\n                if (service.hasCredentialManagementApp()\n                        && packageName.equals(service.getCredentialManagementAppPackageName())) {\n                    service.removeCredentialManagementApp();\n                }\n            } catch (RemoteException | InterruptedException | IllegalStateException\n                    | AssertionError e) {\n                Slogf.e(LOG_TAG, \"Unable to remove the credential management app\", e);\n            }\n        });\n    }\n\n    private boolean isRemovedPackage(String changedPackage, String targetPackage, int userHandle) {\n        try {\n            return targetPackage != null\n                    && (changedPackage == null || changedPackage.equals(targetPackage))\n                    && mIPackageManager.getPackageInfo(targetPackage, 0, userHandle) == null;\n        } catch (RemoteException e) {\n            // Shouldn't happen\n            Slogf.wtf(LOG_TAG, \"Error checking isRemovedPackage\", e);\n        }\n\n        return false;\n    }\n\n    private void handleNewPackageInstalled(String packageName, int userHandle) {\n        // If personal apps were suspended by the admin, suspend the newly installed one.\n        if (!getUserData(userHandle).mAppsSuspended) {\n            return;\n        }\n        final String[] packagesToSuspend = { packageName };\n        // Check if package is considered not suspendable?\n        if (mInjector.getPackageManager(userHandle)\n                .getUnsuspendablePackages(packagesToSuspend).length != 0) {\n            Slogf.i(LOG_TAG, \"Newly installed package is unsuspendable: \" + packageName);\n            return;\n        }\n        mInjector.getPackageManagerInternal()\n                .setPackagesSuspendedByAdmin(userHandle, packagesToSuspend, true /*suspend*/);\n    }\n\n    public void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n        CallerIdentity callerIdentity = getCallerIdentity();\n        Preconditions.checkCallAuthorization(mIsAutomotive || isAdb(callerIdentity), \"can only set \"\n                + \"DevicePolicySafetyChecker on automotive builds or from ADB (but caller is %s)\",\n                callerIdentity);\n        setDevicePolicySafetyCheckerUnchecked(safetyChecker);\n    }\n\n    /**\n     * Used by {@code setDevicePolicySafetyChecker()} above and {@link OneTimeSafetyChecker}.\n     */\n    void setDevicePolicySafetyCheckerUnchecked(DevicePolicySafetyChecker safetyChecker) {\n        Slogf.i(LOG_TAG, \"Setting DevicePolicySafetyChecker as %s\", safetyChecker);\n        mSafetyChecker = safetyChecker;\n        mInjector.setDevicePolicySafetyChecker(safetyChecker);\n    }\n\n    /**\n     * Used by {@link OneTimeSafetyChecker} only.\n     */\n    DevicePolicySafetyChecker getDevicePolicySafetyChecker() {\n        return mSafetyChecker;\n    }\n\n    /**\n     * Checks if it's safe to execute the given {@code operation}.\n     *\n     * @throws UnsafeStateException if it's not safe to execute the operation.\n     */\n    private void checkCanExecuteOrThrowUnsafe(@DevicePolicyOperation int operation) {\n        int reason = getUnsafeOperationReason(operation);\n        if (reason == OPERATION_SAFETY_REASON_NONE) return;\n\n        if (mSafetyChecker == null) {\n            // Happens on CTS after it's set just once (by OneTimeSafetyChecker)\n            throw new UnsafeStateException(operation, reason);\n        }\n        // Let mSafetyChecker customize it (for example, by explaining how to retry)\n        throw mSafetyChecker.newUnsafeStateException(operation, reason);\n    }\n\n    /**\n     * Returns whether it's safe to execute the given {@code operation}, and why.\n     */\n    @OperationSafetyReason\n    int getUnsafeOperationReason(@DevicePolicyOperation int operation) {\n        return mSafetyChecker == null ? OPERATION_SAFETY_REASON_NONE\n                : mSafetyChecker.getUnsafeOperationReason(operation);\n    }\n\n    @Override\n    public void setNextOperationSafety(@DevicePolicyOperation int operation,\n            @OperationSafetyReason int reason) {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Slogf.i(LOG_TAG, \"setNextOperationSafety(%s, %s)\",\n                DevicePolicyManager.operationToString(operation),\n                DevicePolicyManager.operationSafetyReasonToString(reason));\n        mSafetyChecker = new OneTimeSafetyChecker(this, operation, reason);\n    }\n\n    @Override\n    public boolean isSafeOperation(@OperationSafetyReason int reason) {\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"checking isSafeOperation(%s) using mSafetyChecker %s\",\n                    DevicePolicyManager.operationSafetyReasonToString(reason), mSafetyChecker);\n        }\n        return mSafetyChecker == null ? true : mSafetyChecker.isSafeOperation(reason);\n    }\n\n    // Used by DevicePolicyManagerServiceShellCommand\n    List<OwnerShellData> listAllOwners() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        return mInjector.binderWithCleanCallingIdentity(() -> {\n            SparseArray<DevicePolicyData> userData;\n\n            // Gets the owners of \"full users\" first (device owner and profile owners)\n            List<OwnerShellData> owners = mOwners.listAllOwners();\n            synchronized (getLockObject()) {\n                for (int i = 0; i < owners.size(); i++) {\n                    OwnerShellData owner = owners.get(i);\n                    owner.isAffiliated = isUserAffiliatedWithDeviceLocked(owner.userId);\n                }\n                userData = mUserData;\n            }\n\n            // Then the owners of profile users (managed profiles)\n            for (int i = 0; i < userData.size(); i++) {\n                DevicePolicyData policyData = mUserData.valueAt(i);\n                int userId = userData.keyAt(i);\n                int parentUserId = mUserManagerInternal.getProfileParentId(userId);\n                boolean isProfile = parentUserId != userId;\n                if (!isProfile) continue;\n                for (int j = 0; j < policyData.mAdminList.size(); j++) {\n                    ActiveAdmin admin = policyData.mAdminList.get(j);\n                    OwnerShellData owner = OwnerShellData.forManagedProfileOwner(userId,\n                            parentUserId, admin.info.getComponent());\n                    owners.add(owner);\n                }\n            }\n\n            return owners;\n        });\n    }\n\n    /**\n     * Unit test will subclass it to inject mocks.\n     */\n    @VisibleForTesting\n    static class Injector {\n\n        public final Context mContext;\n\n        @Nullable private DevicePolicySafetyChecker mSafetyChecker;\n\n        Injector(Context context) {\n            mContext = context;\n        }\n\n        public boolean hasFeature() {\n            return getPackageManager().hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN);\n        }\n\n        Context createContextAsUser(UserHandle user) throws PackageManager.NameNotFoundException {\n            final String packageName = mContext.getPackageName();\n            return mContext.createPackageContextAsUser(packageName, 0, user);\n        }\n\n        Resources getResources() {\n            return mContext.getResources();\n        }\n\n        UserManager getUserManager() {\n            return UserManager.get(mContext);\n        }\n\n        UserManagerInternal getUserManagerInternal() {\n            return LocalServices.getService(UserManagerInternal.class);\n        }\n\n        PackageManagerInternal getPackageManagerInternal() {\n            return LocalServices.getService(PackageManagerInternal.class);\n        }\n\n        PackageManagerLocal getPackageManagerLocal() {\n            return LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n\n        ActivityTaskManagerInternal getActivityTaskManagerInternal() {\n            return LocalServices.getService(ActivityTaskManagerInternal.class);\n        }\n\n        @NonNull PermissionControllerManager getPermissionControllerManager(\n                @NonNull UserHandle user) {\n            if (user.equals(mContext.getUser())) {\n                return mContext.getSystemService(PermissionControllerManager.class);\n            } else {\n                try {\n                    return mContext.createPackageContextAsUser(mContext.getPackageName(), 0,\n                            user).getSystemService(PermissionControllerManager.class);\n                } catch (NameNotFoundException notPossible) {\n                    // not possible\n                    throw new IllegalStateException(notPossible);\n                }\n            }\n        }\n\n        UsageStatsManagerInternal getUsageStatsManagerInternal() {\n            return LocalServices.getService(UsageStatsManagerInternal.class);\n        }\n\n        NetworkPolicyManagerInternal getNetworkPolicyManagerInternal() {\n            return LocalServices.getService(NetworkPolicyManagerInternal.class);\n        }\n\n        NotificationManager getNotificationManager() {\n            return mContext.getSystemService(NotificationManager.class);\n        }\n\n        IIpConnectivityMetrics getIIpConnectivityMetrics() {\n            return (IIpConnectivityMetrics) IIpConnectivityMetrics.Stub.asInterface(\n                ServiceManager.getService(IpConnectivityLog.SERVICE_NAME));\n        }\n\n        PackageManager getPackageManager() {\n            return mContext.getPackageManager();\n        }\n\n        PackageManager getPackageManager(int userId) {\n            try {\n                return createContextAsUser(UserHandle.of(userId)).getPackageManager();\n            } catch (NameNotFoundException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        PowerManagerInternal getPowerManagerInternal() {\n            return LocalServices.getService(PowerManagerInternal.class);\n        }\n\n        TelephonyManager getTelephonyManager() {\n            return mContext.getSystemService(TelephonyManager.class);\n        }\n\n        RoleManager getRoleManager() {\n            return mContext.getSystemService(RoleManager.class);\n        }\n\n        TrustManager getTrustManager() {\n            return (TrustManager) mContext.getSystemService(Context.TRUST_SERVICE);\n        }\n\n        AlarmManager getAlarmManager() {\n            return mContext.getSystemService(AlarmManager.class);\n        }\n\n        AlarmManagerInternal getAlarmManagerInternal() {\n            return LocalServices.getService(AlarmManagerInternal.class);\n        }\n\n        ConnectivityManager getConnectivityManager() {\n            return mContext.getSystemService(ConnectivityManager.class);\n        }\n\n        VpnManager getVpnManager() {\n            return mContext.getSystemService(VpnManager.class);\n        }\n\n        LocationManager getLocationManager() {\n            return mContext.getSystemService(LocationManager.class);\n        }\n\n        IWindowManager getIWindowManager() {\n            return IWindowManager.Stub\n                    .asInterface(ServiceManager.getService(Context.WINDOW_SERVICE));\n        }\n\n        IActivityManager getIActivityManager() {\n            return ActivityManager.getService();\n        }\n\n        IActivityTaskManager getIActivityTaskManager() {\n            return ActivityTaskManager.getService();\n        }\n\n        ActivityManagerInternal getActivityManagerInternal() {\n            return LocalServices.getService(ActivityManagerInternal.class);\n        }\n\n        IPackageManager getIPackageManager() {\n            return AppGlobals.getPackageManager();\n        }\n\n        IPermissionManager getIPermissionManager() {\n            return AppGlobals.getPermissionManager();\n        }\n\n        IBackupManager getIBackupManager() {\n            return IBackupManager.Stub.asInterface(\n                    ServiceManager.getService(Context.BACKUP_SERVICE));\n        }\n\n        IAudioService getIAudioService() {\n            return IAudioService.Stub.asInterface(ServiceManager.getService(Context.AUDIO_SERVICE));\n        }\n\n        PersistentDataBlockManagerInternal getPersistentDataBlockManagerInternal() {\n            return LocalServices.getService(PersistentDataBlockManagerInternal.class);\n        }\n\n        AppOpsManager getAppOpsManager() {\n            return mContext.getSystemService(AppOpsManager.class);\n        }\n\n        LockSettingsInternal getLockSettingsInternal() {\n            return LocalServices.getService(LockSettingsInternal.class);\n        }\n\n        CrossProfileApps getCrossProfileApps(@UserIdInt int userId) {\n            return mContext.createContextAsUser(UserHandle.of(userId), /* flags= */ 0)\n                    .getSystemService(CrossProfileApps.class);\n        }\n\n        boolean hasUserSetupCompleted(DevicePolicyData userData) {\n            return userData.mUserSetupComplete;\n        }\n\n        boolean isBuildDebuggable() {\n            return Build.IS_DEBUGGABLE;\n        }\n\n        LockPatternUtils newLockPatternUtils() {\n            return new LockPatternUtils(mContext);\n        }\n\n        EnterpriseSpecificIdCalculator newEnterpriseSpecificIdCalculator() {\n            return new EnterpriseSpecificIdCalculator(mContext);\n        }\n\n        boolean storageManagerIsFileBasedEncryptionEnabled() {\n            return StorageManager.isFileEncrypted();\n        }\n\n        Looper getMyLooper() {\n            return Looper.myLooper();\n        }\n\n        WifiManager getWifiManager() {\n            return mContext.getSystemService(WifiManager.class);\n        }\n\n        UsbManager getUsbManager() {\n            return mContext.getSystemService(UsbManager.class);\n        }\n\n        @SuppressWarnings(\"ResultOfClearIdentityCallNotStoredInVariable\")\n        long binderClearCallingIdentity() {\n            return Binder.clearCallingIdentity();\n        }\n\n        void binderRestoreCallingIdentity(long token) {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        int binderGetCallingUid() {\n            return Binder.getCallingUid();\n        }\n\n        int binderGetCallingPid() {\n            return Binder.getCallingPid();\n        }\n\n        UserHandle binderGetCallingUserHandle() {\n            return Binder.getCallingUserHandle();\n        }\n\n        boolean binderIsCallingUidMyUid() {\n            return getCallingUid() == Process.myUid();\n        }\n\n        void binderWithCleanCallingIdentity(@NonNull ThrowingRunnable action) {\n             Binder.withCleanCallingIdentity(action);\n        }\n\n        final <T> T binderWithCleanCallingIdentity(@NonNull ThrowingSupplier<T> action) {\n            return Binder.withCleanCallingIdentity(action);\n        }\n\n        final int userHandleGetCallingUserId() {\n            return UserHandle.getUserId(binderGetCallingUid());\n        }\n\n        void powerManagerGoToSleep(long time, int reason, int flags) {\n            mContext.getSystemService(PowerManager.class).goToSleep(time, reason, flags);\n        }\n\n        void powerManagerReboot(String reason) {\n            mContext.getSystemService(PowerManager.class).reboot(reason);\n        }\n\n        boolean recoverySystemRebootWipeUserData(boolean shutdown, String reason, boolean force,\n                boolean wipeEuicc, boolean wipeExtRequested, boolean wipeResetProtectionData)\n                        throws IOException {\n            return FactoryResetter.newBuilder(mContext).setSafetyChecker(mSafetyChecker)\n                    .setReason(reason).setShutdown(shutdown).setForce(force).setWipeEuicc(wipeEuicc)\n                    .setWipeAdoptableStorage(wipeExtRequested)\n                    .setWipeFactoryResetProtection(wipeResetProtectionData)\n                    .build().factoryReset();\n        }\n\n        boolean systemPropertiesGetBoolean(String key, boolean def) {\n            return SystemProperties.getBoolean(key, def);\n        }\n\n        long systemPropertiesGetLong(String key, long def) {\n            return SystemProperties.getLong(key, def);\n        }\n\n        String systemPropertiesGet(String key, String def) {\n            return SystemProperties.get(key, def);\n        }\n\n        String systemPropertiesGet(String key) {\n            return SystemProperties.get(key);\n        }\n\n        void systemPropertiesSet(String key, String value) {\n            SystemProperties.set(key, value);\n        }\n\n        boolean userManagerIsHeadlessSystemUserMode() {\n            return UserManager.isHeadlessSystemUserMode();\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetActivityAsUser(Context context, int requestCode,\n                @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n            return PendingIntent.getActivityAsUser(\n                    context, requestCode, intent, flags, options, user);\n        }\n\n        @SuppressWarnings(\"AndroidFrameworkPendingIntentMutability\")\n        PendingIntent pendingIntentGetBroadcast(\n                Context context, int requestCode, Intent intent, int flags) {\n            return PendingIntent.getBroadcast(context, requestCode, intent, flags);\n        }\n\n        void registerContentObserver(Uri uri, boolean notifyForDescendents,\n                ContentObserver observer, int userHandle) {\n            mContext.getContentResolver().registerContentObserver(uri, notifyForDescendents,\n                    observer, userHandle);\n        }\n\n        int settingsSecureGetIntForUser(String name, int def, int userHandle) {\n            return Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                    name, def, userHandle);\n        }\n\n        String settingsSecureGetStringForUser(String name, int userHandle) {\n            return Settings.Secure.getStringForUser(mContext.getContentResolver(), name,\n                    userHandle);\n        }\n\n        void settingsSecurePutIntForUser(String name, int value, int userHandle) {\n            Settings.Secure.putIntForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutStringForUser(String name, String value, int userHandle) {\n            Settings.Secure.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsGlobalPutStringForUser(String name, String value, int userHandle) {\n            Settings.Global.putStringForUser(mContext.getContentResolver(),\n                    name, value, userHandle);\n        }\n\n        void settingsSecurePutInt(String name, int value) {\n            Settings.Secure.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        int settingsGlobalGetInt(String name, int def) {\n            return Settings.Global.getInt(mContext.getContentResolver(), name, def);\n        }\n\n        @Nullable\n        String settingsGlobalGetString(String name) {\n            return Settings.Global.getString(mContext.getContentResolver(), name);\n        }\n\n        void settingsGlobalPutInt(String name, int value) {\n            Settings.Global.putInt(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSecurePutString(String name, String value) {\n            Settings.Secure.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsGlobalPutString(String name, String value) {\n            Settings.Global.putString(mContext.getContentResolver(), name, value);\n        }\n\n        void settingsSystemPutStringForUser(String name, String value, int userId) {\n          Settings.System.putStringForUser(\n              mContext.getContentResolver(), name, value, userId);\n        }\n\n        void securityLogSetLoggingEnabledProperty(boolean enabled) {\n            SecurityLog.setLoggingEnabledProperty(enabled);\n        }\n\n        boolean securityLogGetLoggingEnabledProperty() {\n            return SecurityLog.getLoggingEnabledProperty();\n        }\n\n        boolean securityLogIsLoggingEnabled() {\n            return SecurityLog.isLoggingEnabled();\n        }\n\n        KeyChainConnection keyChainBind() throws InterruptedException {\n            return KeyChain.bind(mContext);\n        }\n\n        KeyChainConnection keyChainBindAsUser(UserHandle user) throws InterruptedException {\n            return KeyChain.bindAsUser(mContext, user);\n        }\n\n        void postOnSystemServerInitThreadPool(Runnable runnable) {\n            SystemServerInitThreadPool.submit(runnable, LOG_TAG);\n        }\n\n        public TransferOwnershipMetadataManager newTransferOwnershipMetadataManager() {\n            return new TransferOwnershipMetadataManager();\n        }\n\n        public void runCryptoSelfTest() {\n            CryptoTestHelper.runAndLogSelfTest();\n        }\n\n        public String[] getPersonalAppsForSuspension(@UserIdInt int userId) {\n            return PersonalAppsSuspensionHelper.forUser(mContext, userId)\n                    .getPersonalAppsForSuspension();\n        }\n\n        public long systemCurrentTimeMillis() {\n            return System.currentTimeMillis();\n        }\n\n        public boolean isChangeEnabled(long changeId, String packageName, int userId) {\n            return CompatChanges.isChangeEnabled(changeId, packageName, UserHandle.of(userId));\n        }\n\n        void setDevicePolicySafetyChecker(DevicePolicySafetyChecker safetyChecker) {\n            mSafetyChecker = safetyChecker;\n        }\n\n        DeviceManagementResourcesProvider getDeviceManagementResourcesProvider() {\n            return new DeviceManagementResourcesProvider();\n        }\n    }\n\n    /**\n     * Instantiates the service.\n     */\n    public DevicePolicyManagerService(Context context) {\n        this(new Injector(\n                context.createAttributionContext(ATTRIBUTION_TAG)), new PolicyPathProvider() {});\n    }\n\n    @VisibleForTesting\n    DevicePolicyManagerService(Injector injector, PolicyPathProvider pathProvider) {\n        DevicePolicyManager.disableLocalCaches();\n\n        mInjector = injector;\n        mPathProvider = pathProvider;\n        mContext = Objects.requireNonNull(injector.mContext);\n        mHandler = new Handler(Objects.requireNonNull(injector.getMyLooper()));\n\n        mConstantsObserver = new DevicePolicyConstantsObserver(mHandler);\n        mConstantsObserver.register();\n        mConstants = loadConstants();\n\n        mUserManager = Objects.requireNonNull(injector.getUserManager());\n        mUserManagerInternal = Objects.requireNonNull(injector.getUserManagerInternal());\n        mUsageStatsManagerInternal = Objects.requireNonNull(\n                injector.getUsageStatsManagerInternal());\n        mIPackageManager = Objects.requireNonNull(injector.getIPackageManager());\n        mIPermissionManager = Objects.requireNonNull(injector.getIPermissionManager());\n        mTelephonyManager = Objects.requireNonNull(injector.getTelephonyManager());\n        mRoleManager = Objects.requireNonNull(injector.getRoleManager());\n\n        mLocalService = new LocalService();\n        mLockPatternUtils = injector.newLockPatternUtils();\n        mLockSettingsInternal = injector.getLockSettingsInternal();\n        // TODO: why does SecurityLogMonitor need to be created even when mHasFeature == false?\n        mSecurityLogMonitor = new SecurityLogMonitor(this);\n\n        mHasFeature = mInjector.hasFeature();\n        mIsWatch = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_WATCH);\n        mHasTelephonyFeature = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY);\n        mIsAutomotive = mInjector.getPackageManager()\n                .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n        mBackgroundHandler = BackgroundThread.getHandler();\n\n        // Needed when mHasFeature == false, because it controls the certificate warning text.\n        mCertificateMonitor = new CertificateMonitor(this, mInjector, mBackgroundHandler);\n\n        mDeviceAdminServiceController = new DeviceAdminServiceController(this, mConstants);\n        mOverlayPackagesProvider = new OverlayPackagesProvider(mContext);\n        mTransferOwnershipMetadataManager = mInjector.newTransferOwnershipMetadataManager();\n        mBugreportCollectionManager = new RemoteBugreportManager(this, mInjector);\n\n        mDeviceManagementResourcesProvider = mInjector.getDeviceManagementResourcesProvider();\n        mDevicePolicyManagementRoleObserver = new DevicePolicyManagementRoleObserver(mContext);\n        mDevicePolicyManagementRoleObserver.register();\n\n        // \"Lite\" interface is available even when the device doesn't have the feature\n        LocalServices.addService(DevicePolicyManagerLiteInternal.class, mLocalService);\n\n        // Policy version upgrade must not depend on either mOwners or mUserData, so they are\n        // initialized only after performing the upgrade.\n        if (mHasFeature) {\n            performPolicyVersionUpgrade();\n        }\n\n        mUserData = new SparseArray<>();\n        mOwners = makeOwners(injector, pathProvider);\n\n        mDevicePolicyEngine = new DevicePolicyEngine(\n                mContext, mDeviceAdminServiceController, getLockObject());\n\n        if (!mHasFeature) {\n            // Skip the rest of the initialization\n            mSetupContentObserver = null;\n            mContactSystemRoleHolders = Collections.emptySet();\n            return;\n        }\n\n        loadOwners();\n\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_BOOT_COMPLETED);\n        filter.addAction(ACTION_EXPIRED_PASSWORD_NOTIFICATION);\n        filter.addAction(ACTION_TURN_PROFILE_ON_NOTIFICATION);\n        filter.addAction(ACTION_PROFILE_OFF_DEADLINE);\n        filter.addAction(Intent.ACTION_USER_ADDED);\n        filter.addAction(Intent.ACTION_USER_REMOVED);\n        filter.addAction(Intent.ACTION_USER_STARTED);\n        filter.addAction(Intent.ACTION_USER_STOPPED);\n        filter.addAction(Intent.ACTION_USER_SWITCHED);\n        filter.addAction(Intent.ACTION_USER_UNLOCKED);\n        filter.addAction(LOGIN_ACCOUNTS_CHANGED_ACTION);\n        filter.addAction(ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        filter.addAction(ACTION_MANAGED_PROFILE_AVAILABLE);\n        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        filter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        filter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        filter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n        filter = new IntentFilter();\n        filter.addAction(Intent.ACTION_MANAGED_PROFILE_ADDED);\n        filter.addAction(Intent.ACTION_TIME_CHANGED);\n        filter.addAction(Intent.ACTION_DATE_CHANGED);\n        mContext.registerReceiverAsUser(mReceiver, UserHandle.ALL, filter, null, mHandler);\n\n        LocalServices.addService(DevicePolicyManagerInternal.class, mLocalService);\n\n        mSetupContentObserver = new SetupContentObserver(mHandler);\n\n        mUserManagerInternal.addUserRestrictionsListener(\n                new RestrictionsListener(mContext, mUserManagerInternal, this));\n        mUserManagerInternal.addUserLifecycleListener(new UserLifecycleListener());\n\n        mDeviceManagementResourcesProvider.load();\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.load();\n        }\n\n        mContactSystemRoleHolders = fetchOemSystemHolders(/* roleResIds...= */\n                com.android.internal.R.string.config_defaultSms,\n                com.android.internal.R.string.config_defaultDialer,\n                com.android.internal.R.string.config_systemContacts\n        );\n\n        // The binder caches are not enabled until the first invalidation.\n        invalidateBinderCaches();\n    }\n\n    /**\n     * Fetch the OEM System Holders for the supplied roleNames\n     *\n     * @param roleResIds the list of resource ids whose role holders are needed\n     * @return the set of packageNames that handle the requested roles\n     */\n    private @NonNull Set<String> fetchOemSystemHolders(int... roleResIds) {\n        Set<String> packageNames = new ArraySet<>();\n\n        for (int roleResId : roleResIds) {\n            String packageName = getDefaultRoleHolderPackageName(roleResId);\n            if (packageName != null) {\n                packageNames.add(packageName);\n            }\n        }\n\n        return Collections.unmodifiableSet(packageNames);\n    }\n\n\n    private @Nullable String getDefaultRoleHolderPackageName(int resId) {\n        String packageNameAndSignature = mContext.getString(resId);\n\n        if (TextUtils.isEmpty(packageNameAndSignature)) {\n            return null;\n        }\n\n        if (packageNameAndSignature.contains(\":\")) {\n            return packageNameAndSignature.split(\":\")[0];\n        }\n\n        return packageNameAndSignature;\n    }\n\n    private void suspendAppsForQuietProfiles(boolean toSuspend) {\n        PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        List<UserInfo> users = mUserManager.getUsers(true /* excludeDying */);\n        for (UserInfo user : users) {\n            if (user.isManagedProfile() && user.isQuietModeEnabled()) {\n                pmi.setPackagesSuspendedForQuietMode(user.id, toSuspend);\n            }\n        }\n    }\n\n    private Owners makeOwners(Injector injector, PolicyPathProvider pathProvider) {\n        return new Owners(\n                injector.getUserManager(), injector.getUserManagerInternal(),\n                injector.getPackageManagerInternal(),\n                injector.getActivityTaskManagerInternal(),\n                injector.getActivityManagerInternal(), mStateCache, pathProvider);\n    }\n\n    /**\n     * Invalidate the binder API caches. The invalidation itself does not require any\n     * locking, but this specific call should be protected by getLockObject() to ensure\n     * that the invalidation is synchronous with cached queries, for those queries that\n     * are served under getLockObject().\n     */\n    static void invalidateBinderCaches() {\n        DevicePolicyManager.invalidateBinderCaches();\n    }\n\n    /**\n     * Creates and loads the policy data from xml.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    @NonNull\n    DevicePolicyData getUserData(int userHandle) {\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy == null) {\n                policy = new DevicePolicyData(userHandle);\n                mUserData.append(userHandle, policy);\n                loadSettingsLocked(policy, userHandle);\n                if (userHandle == UserHandle.USER_SYSTEM) {\n                    mStateCache.setDeviceProvisioned(policy.mUserSetupComplete);\n                }\n            }\n            return policy;\n        }\n    }\n\n    /**\n     * Creates and loads the policy data from xml for data that is shared between\n     * various profiles of a user. In contrast to {@link #getUserData(int)}\n     * it allows access to data of users other than the calling user.\n     *\n     * This function should only be used for shared data, e.g. everything regarding\n     * passwords and should be removed once multiple screen locks are present.\n     * @param userHandle the user for whom to load the policy data\n     * @return\n     */\n    DevicePolicyData getUserDataUnchecked(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() -> getUserData(userHandle));\n    }\n\n    void removeUserData(int userHandle) {\n        final boolean isOrgOwned;\n        synchronized (getLockObject()) {\n            if (userHandle == UserHandle.USER_SYSTEM) {\n                Slogf.w(LOG_TAG, \"Tried to remove device policy file for user 0! Ignoring.\");\n                return;\n            }\n            updatePasswordQualityCacheForUserGroup(userHandle);\n            mPolicyCache.onUserRemoved(userHandle);\n\n            if (isManagedProfile(userHandle)) {\n                clearManagedProfileApnUnchecked();\n            }\n            isOrgOwned = mOwners.isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n\n            // Clear any restrictions set by the a profile owner and the parent admin.\n            final ActiveAdmin admin = getProfileOwnerLocked(userHandle);\n            if (admin != null) {\n                admin.userRestrictions = null;\n                final ActiveAdmin parentAdmin = admin.getParentActiveAdmin();\n                if (parentAdmin != null) {\n                    parentAdmin.userRestrictions = null;\n                }\n                pushUserRestrictions(userHandle);\n            }\n            mOwners.removeProfileOwner(userHandle);\n            mOwners.writeProfileOwner(userHandle);\n            pushScreenCapturePolicy(userHandle);\n\n            DevicePolicyData policy = mUserData.get(userHandle);\n            if (policy != null) {\n                mUserData.remove(userHandle);\n            }\n\n            File policyFile =\n                    new File(mPathProvider.getUserSystemDirectory(userHandle), DEVICE_POLICIES_XML);\n            policyFile.delete();\n            Slogf.i(LOG_TAG, \"Removed device policy file \" + policyFile.getAbsolutePath());\n        }\n        if (isOrgOwned) {\n            final UserInfo primaryUser = mUserManager.getPrimaryUser();\n            if (primaryUser != null) {\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(primaryUser.id);\n            } else {\n                Slogf.wtf(LOG_TAG, \"Was unable to get primary user.\");\n            }\n        }\n    }\n\n    /**\n     * Load information about device and profile owners of the device, populating mOwners and\n     * pushing owner info to other system services. This is called at a fairly early stage of\n     * system server initialiation (via DevicePolicyManagerService's ctor), so care should to\n     * be taken to not interact with system services that are initialiated after DPMS.\n     * onLockSettingsReady() is a safer place to do initialization work not critical during\n     * the first boot stage.\n     * Note this only loads the list of owners, and not their actual policy (DevicePolicyData).\n     * The policy is normally loaded lazily when it's first accessed. In several occasions\n     * the list of owners is necessary for providing callers with aggregated policies across\n     * multiple owners, hence the owner list is loaded as part of DPMS's construction here.\n     */\n    void loadOwners() {\n        synchronized (getLockObject()) {\n            mOwners.load();\n            setDeviceOwnershipSystemPropertyLocked();\n            if (mOwners.hasDeviceOwner()) {\n                setGlobalSettingDeviceOwnerType(\n                        mOwners.getDeviceOwnerType(mOwners.getDeviceOwnerPackageName()));\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity() {\n        return getCallerIdentity(null, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     */\n    private CallerIdentity getCallerIdentity(@Nullable String callerPackage) {\n        return getCallerIdentity(null, callerPackage);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * The component name should be an active admin for the calling user.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent) {\n        return getCallerIdentity(adminComponent, null);\n    }\n\n    /**\n     * Creates a new {@link CallerIdentity} object to represent the caller's identity.\n     * If {@code adminComponent} is provided, it's validated against the list of known\n     * active admins and caller uid. If {@code callerPackage} is provided, it's validated\n     * against the caller uid. If a valid {@code adminComponent} is provided but not\n     * {@code callerPackage}, the package name of the {@code adminComponent} is used instead.\n     */\n    @VisibleForTesting\n    CallerIdentity getCallerIdentity(@Nullable ComponentName adminComponent,\n            @Nullable String callerPackage) {\n        final int callerUid = mInjector.binderGetCallingUid();\n\n        if (callerPackage != null) {\n            if (!isCallingFromPackage(callerPackage, callerUid)) {\n                throw new SecurityException(\n                        String.format(\"Caller with uid %d is not %s\", callerUid, callerPackage));\n            }\n        }\n\n        if (adminComponent != null) {\n            final DevicePolicyData policy = getUserData(UserHandle.getUserId(callerUid));\n            ActiveAdmin admin = policy.mAdminMap.get(adminComponent);\n\n            // Throwing combined exception message for both the cases here, because from different\n            // security exceptions it could be deduced if particular package is admin package.\n            if (admin == null || admin.getUid() != callerUid) {\n                throw new SecurityException(String.format(\n                        \"Admin %s does not exist or is not owned by uid %d\", adminComponent,\n                        callerUid));\n            }\n            if (callerPackage != null) {\n                Preconditions.checkArgument(callerPackage.equals(adminComponent.getPackageName()));\n            } else {\n                callerPackage = adminComponent.getPackageName();\n            }\n        }\n\n        return new CallerIdentity(callerUid, callerPackage, adminComponent);\n    }\n\n    /**\n     * Checks if the device is in COMP mode, and if so migrates it to managed profile on a\n     * corporate owned device.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void migrateToProfileOnOrganizationOwnedDeviceIfCompLocked() {\n        if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Checking whether we need to migrate COMP \");\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping migration.\");\n            return;\n        }\n\n        final List<UserInfo> profiles = mUserManager.getProfiles(doUserId);\n        if (profiles.size() != 2) {\n            if (profiles.size() == 1) {\n                if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"Profile not found, skipping migration.\");\n            } else {\n                Slogf.wtf(LOG_TAG, \"Found \" + profiles.size() + \" profiles, skipping migration\");\n            }\n            return;\n        }\n\n        final int poUserId = getManagedUserId(doUserId);\n        if (poUserId < 0) {\n            Slogf.wtf(LOG_TAG, \"Found DO and a profile, but it is not managed, skipping migration\");\n            return;\n        }\n\n        final ActiveAdmin doAdmin = getDeviceOwnerAdminLocked();\n        final ActiveAdmin poAdmin = getProfileOwnerAdminLocked(poUserId);\n        if (doAdmin == null || poAdmin == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get either PO or DO admin, aborting migration.\");\n            return;\n        }\n\n        final ComponentName doAdminComponent = mOwners.getDeviceOwnerComponent();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(poUserId);\n        if (doAdminComponent == null || poAdminComponent == null) {\n            Slogf.wtf(LOG_TAG, \"Cannot find PO or DO component name, aborting migration.\");\n            return;\n        }\n        if (!doAdminComponent.getPackageName().equals(poAdminComponent.getPackageName())) {\n            Slogf.e(LOG_TAG, \"DO and PO are different packages, aborting migration.\");\n            return;\n        }\n\n        Slogf.i(LOG_TAG, \"Migrating COMP to PO on a corp owned device; primary user: %d; \"\n                + \"profile: %d\", doUserId, poUserId);\n\n        Slogf.i(LOG_TAG, \"Giving the PO additional power...\");\n        setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(poAdminComponent, poUserId, true);\n        Slogf.i(LOG_TAG, \"Migrating DO policies to PO...\");\n        moveDoPoliciesToProfileParentAdminLocked(doAdmin, poAdmin.getParentActiveAdmin());\n        migratePersonalAppSuspensionLocked(doUserId, poUserId, poAdmin);\n        saveSettingsLocked(poUserId);\n        Slogf.i(LOG_TAG, \"Clearing the DO...\");\n        final ComponentName doAdminReceiver = doAdmin.info.getComponent();\n        clearDeviceOwnerLocked(doAdmin, doUserId);\n        Slogf.i(LOG_TAG, \"Removing admin artifacts...\");\n        removeAdminArtifacts(doAdminReceiver, doUserId);\n        Slogf.i(LOG_TAG, \"Uninstalling the DO...\");\n        uninstallOrDisablePackage(doAdminComponent.getPackageName(), doUserId);\n        Slogf.i(LOG_TAG, \"Migration complete.\");\n\n        // Note: KeyChain keys are not removed and will remain accessible for the apps that have\n        // been given grants to use them.\n\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.COMP_TO_ORG_OWNED_PO_MIGRATED)\n                .setAdmin(poAdminComponent)\n                .write();\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void migratePersonalAppSuspensionLocked(\n            int doUserId, int poUserId, ActiveAdmin poAdmin) {\n        final PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n        if (!pmi.isSuspendingAnyPackages(PLATFORM_PACKAGE_NAME, doUserId)) {\n            Slogf.i(LOG_TAG, \"DO is not suspending any apps.\");\n            return;\n        }\n\n        if (getTargetSdk(poAdmin.info.getPackageName(), poUserId) >= Build.VERSION_CODES.R) {\n            Slogf.i(LOG_TAG, \"PO is targeting R+, keeping personal apps suspended.\");\n            getUserData(doUserId).mAppsSuspended = true;\n            poAdmin.mSuspendPersonalApps = true;\n        } else {\n            Slogf.i(LOG_TAG, \"PO isn't targeting R+, unsuspending personal apps.\");\n            pmi.unsuspendForSuspendingPackage(PLATFORM_PACKAGE_NAME, doUserId);\n        }\n    }\n\n    private void uninstallOrDisablePackage(String packageName, @UserIdInt int userId) {\n        final ApplicationInfo appInfo;\n        try {\n            appInfo = mIPackageManager.getApplicationInfo(\n                    packageName, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, userId);\n        } catch (RemoteException e) {\n            // Shouldn't happen.\n            Slogf.wtf(LOG_TAG, \"Error getting application info\", e);\n            return;\n        }\n        if (appInfo == null) {\n            Slogf.wtf(LOG_TAG, \"Failed to get package info for \" + packageName);\n            return;\n        }\n        if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n            Slogf.i(LOG_TAG, \"Package %s is pre-installed, marking disabled until used\",\n                    packageName);\n            mContext.getPackageManager().setApplicationEnabledSetting(packageName,\n                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED, /* flags= */ 0);\n            return;\n        }\n\n        final IIntentSender.Stub mLocalSender = new IIntentSender.Stub() {\n            @Override\n            public void send(int code, Intent intent, String resolvedType, IBinder allowlistToken,\n                    IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {\n                final int status = intent.getIntExtra(\n                        PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);\n                if (status == PackageInstaller.STATUS_SUCCESS) {\n                    Slogf.i(LOG_TAG, \"Package %s uninstalled for user %d\", packageName, userId);\n                } else {\n                    Slogf.e(LOG_TAG, \"Failed to uninstall %s; status: %d\", packageName, status);\n                }\n            }\n        };\n\n        final PackageInstaller pi = mInjector.getPackageManager(userId).getPackageInstaller();\n        pi.uninstall(packageName, /* flags= */ 0, new IntentSender((IIntentSender) mLocalSender));\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void moveDoPoliciesToProfileParentAdminLocked(\n            ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        // The following policies can be already controlled via parent instance, skip if so.\n        if (parentAdmin.mPasswordPolicy.quality == PASSWORD_QUALITY_UNSPECIFIED) {\n            parentAdmin.mPasswordPolicy = doAdmin.mPasswordPolicy;\n        }\n        if (parentAdmin.passwordHistoryLength == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordHistoryLength = doAdmin.passwordHistoryLength;\n        }\n        if (parentAdmin.passwordExpirationTimeout == ActiveAdmin.DEF_PASSWORD_HISTORY_LENGTH) {\n            parentAdmin.passwordExpirationTimeout = doAdmin.passwordExpirationTimeout;\n        }\n        if (parentAdmin.maximumFailedPasswordsForWipe\n                == ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n            parentAdmin.maximumFailedPasswordsForWipe = doAdmin.maximumFailedPasswordsForWipe;\n        }\n        if (parentAdmin.maximumTimeToUnlock == ActiveAdmin.DEF_MAXIMUM_TIME_TO_UNLOCK) {\n            parentAdmin.maximumTimeToUnlock = doAdmin.maximumTimeToUnlock;\n        }\n        if (parentAdmin.strongAuthUnlockTimeout\n                == DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            parentAdmin.strongAuthUnlockTimeout = doAdmin.strongAuthUnlockTimeout;\n        }\n        parentAdmin.disabledKeyguardFeatures |=\n                doAdmin.disabledKeyguardFeatures & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;\n\n        parentAdmin.trustAgentInfos.putAll(doAdmin.trustAgentInfos);\n\n        // The following policies weren't available to PO, but will be available after migration.\n        parentAdmin.disableCamera = doAdmin.disableCamera;\n        parentAdmin.disableScreenCapture = doAdmin.disableScreenCapture;\n        parentAdmin.accountTypesWithManagementDisabled.addAll(\n                doAdmin.accountTypesWithManagementDisabled);\n\n        moveDoUserRestrictionsToCopeParent(doAdmin, parentAdmin);\n\n        // From Android 11, {@link setAutoTimeRequired} is no longer used. The user restriction\n        // {@link UserManager#DISALLOW_CONFIG_DATE_TIME} should be used to enforce auto time\n        // settings instead.\n        if (doAdmin.requireAutoTime) {\n            parentAdmin.ensureUserRestrictions().putBoolean(\n                    UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n        }\n    }\n\n    private void moveDoUserRestrictionsToCopeParent(ActiveAdmin doAdmin, ActiveAdmin parentAdmin) {\n        if (doAdmin.userRestrictions == null) {\n            return;\n        }\n        for (final String restriction : doAdmin.userRestrictions.keySet()) {\n            if (UserRestrictionsUtils.canProfileOwnerOfOrganizationOwnedDeviceChange(restriction)) {\n                parentAdmin.ensureUserRestrictions().putBoolean(\n                        restriction, doAdmin.userRestrictions.getBoolean(restriction));\n            }\n        }\n    }\n\n    /**\n     * If the device is in Device Owner mode, apply the restriction on adding\n     * a managed profile.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void applyProfileRestrictionsIfDeviceOwnerLocked() {\n        final int doUserId = mOwners.getDeviceOwnerUserId();\n        if (doUserId == UserHandle.USER_NULL) {\n            if (VERBOSE_LOG) Slogf.d(LOG_TAG, \"No DO found, skipping application of restriction.\");\n            return;\n        }\n\n        for (UserInfo userInfo : mUserManager.getUsers()) {\n            UserHandle userHandle = userInfo.getUserHandle();\n            // Based on  CDD : https://source.android.com/compatibility/12/android-12-cdd#95_multi-user_support,\n            // creation of clone profile is not allowed in case device owner is set.\n            // Enforcing this restriction on setting up of device owner.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_CLONE_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, true,\n                        userHandle);\n            }\n            // Creation of managed profile is restricted in case device owner is set, enforcing this\n            // restriction by setting user level restriction at time of device owner setup.\n            if (!mUserManager.hasUserRestriction(\n                    UserManager.DISALLOW_ADD_MANAGED_PROFILE, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE, true,\n                        userHandle);\n            }\n        }\n    }\n\n    /** Apply default restrictions that haven't been applied to profile owners yet. */\n    private void maybeSetDefaultProfileOwnerUserRestrictions() {\n        synchronized (getLockObject()) {\n            for (final int userId : mOwners.getProfileOwnerKeys()) {\n                final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(userId);\n                // The following restrictions used to be applied to managed profiles by different\n                // means (via Settings or by disabling components). Now they are proper user\n                // restrictions so we apply them to managed profile owners. Non-managed secondary\n                // users didn't have those restrictions so we skip them to keep existing behavior.\n                if (profileOwner == null || !mUserManager.isManagedProfile(userId)) {\n                    continue;\n                }\n                maybeSetDefaultRestrictionsForAdminLocked(userId, profileOwner);\n                ensureUnknownSourcesRestrictionForProfileOwnerLocked(\n                        userId, profileOwner, false /* newOwner */);\n            }\n        }\n    }\n\n    /**\n     * Checks whether {@link UserManager#DISALLOW_INSTALL_UNKNOWN_SOURCES} should be added to the\n     * set of restrictions for this profile owner.\n     */\n    private void ensureUnknownSourcesRestrictionForProfileOwnerLocked(int userId,\n            ActiveAdmin profileOwner, boolean newOwner) {\n        if (newOwner || mInjector.settingsSecureGetIntForUser(\n                Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId) != 0) {\n            if (isPolicyEngineForFinanceFlagEnabled()) {\n                mDevicePolicyEngine.setLocalPolicy(\n                        PolicyDefinition.getPolicyDefinitionForUserRestriction(\n                                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES),\n                        EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                                profileOwner.info.getComponent(),\n                                profileOwner.getUserHandle().getIdentifier()),\n                        new BooleanPolicyValue(true),\n                        userId);\n            } else {\n                profileOwner.ensureUserRestrictions().putBoolean(\n                        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, true);\n                saveUserRestrictionsLocked(userId);\n            }\n            mInjector.settingsSecurePutIntForUser(\n                    Settings.Secure.UNKNOWN_SOURCES_DEFAULT_REVERSED, 0, userId);\n        }\n    }\n\n    /** Apply default restrictions that haven't been applied to a given admin yet. */\n    private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n        Set<String> newDefaultRestrictions = new HashSet(\n            UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n        newDefaultRestrictions.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n        if (newDefaultRestrictions.isEmpty()) {\n            return; // The same set of default restrictions has been already applied.\n        }\n\n        for (String restriction : newDefaultRestrictions) {\n            mDevicePolicyEngine.setLocalPolicy(\n                    PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            admin.info.getComponent(),\n                            admin.getUserHandle().getIdentifier()),\n                    new BooleanPolicyValue(true),\n                    userId);\n            admin.defaultEnabledRestrictionsAlreadySet.add(restriction);\n            Slogf.i(LOG_TAG, \"Enabled the following restriction by default: \" + restriction);\n        }\n    }\n\n    private void setDeviceOwnershipSystemPropertyLocked() {\n        final boolean deviceProvisioned =\n                mInjector.settingsGlobalGetInt(Settings.Global.DEVICE_PROVISIONED, 0) != 0;\n        final boolean hasDeviceOwner = mOwners.hasDeviceOwner();\n        final boolean hasOrgOwnedProfile = isOrganizationOwnedDeviceWithManagedProfile();\n        // If the device is not provisioned and there is currently no management, do not set the\n        // read-only system property yet, since device owner / org-owned profile may still be\n        // provisioned.\n        if (!hasDeviceOwner && !hasOrgOwnedProfile && !deviceProvisioned) {\n            return;\n        }\n        final String value = Boolean.toString(hasDeviceOwner || hasOrgOwnedProfile);\n        final String currentVal = mInjector.systemPropertiesGet(PROPERTY_ORGANIZATION_OWNED, null);\n        if (TextUtils.isEmpty(currentVal)) {\n            Slogf.i(LOG_TAG, \"Set ro.organization_owned property to \" + value);\n            mInjector.systemPropertiesSet(PROPERTY_ORGANIZATION_OWNED, value);\n        } else if (!value.equals(currentVal)) {\n            Slogf.w(LOG_TAG, \"Cannot change existing ro.organization_owned to \" + value);\n        }\n    }\n\n    private void maybeStartSecurityLogMonitorOnActivityManagerReady() {\n        synchronized (getLockObject()) {\n            if (mInjector.securityLogIsLoggingEnabled()) {\n                mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());\n                mInjector.runCryptoSelfTest();\n                maybePauseDeviceWideLoggingLocked();\n            }\n        }\n    }\n\n    /**\n     * Fix left-over restrictions and auto-time policy during COMP -> COPE migration.\n     *\n     * When a COMP device with requireAutoTime policy set was migrated to an\n     * organization-owned profile, a DISALLOW_CONFIG_DATE_TIME restriction is set\n     * on user 0 from the DO user, which becomes unremovable by the organization-owned\n     * profile owner. Fix this by force removing that restriction. Also revert the\n     * parentAdmin.requireAutoTime bit (since the COPE PO cannot unset this bit)\n     * and replace it with DISALLOW_CONFIG_DATE_TIME on the correct\n     * admin, in line with the deprecation recommendation of setAutoTimeRequired().\n     */\n    private void fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration() {\n        for (UserInfo ui : mUserManager.getUsers()) {\n            final int userId = ui.id;\n            if (isProfileOwnerOfOrganizationOwnedDevice(userId)) {\n                final ActiveAdmin parent = getProfileOwnerAdminLocked(userId).parentAdmin;\n                if (parent != null && parent.requireAutoTime) {\n                    // Remove deprecated requireAutoTime\n                    parent.requireAutoTime = false;\n                    saveSettingsLocked(userId);\n\n                    // Remove user restrictions set by the device owner before the upgrade to\n                    // Android 11.\n                    mUserManagerInternal.setDevicePolicyUserRestrictions(UserHandle.USER_SYSTEM,\n                            new Bundle(), new RestrictionsSet(), /* isDeviceOwner */ false);\n\n                    // Apply user restriction to parent active admin instead\n                    parent.ensureUserRestrictions().putBoolean(\n                            UserManager.DISALLOW_CONFIG_DATE_TIME, true);\n                    pushUserRestrictions(userId);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set an alarm for an upcoming event - expiration warning, expiration, or post-expiration\n     * reminders.  Clears alarm if no expirations are configured.\n     */\n    private void setExpirationAlarmCheckLocked(Context context, int userHandle, boolean parent) {\n        final long expiration = getPasswordExpirationLocked(null, userHandle, parent);\n        final long now = System.currentTimeMillis();\n        final long timeToExpire = expiration - now;\n        final long alarmTime;\n        if (expiration == 0) {\n            // No expirations are currently configured:  Cancel alarm.\n            alarmTime = 0;\n        } else if (timeToExpire <= 0) {\n            // The password has already expired:  Repeat every 24 hours.\n            alarmTime = now + MS_PER_DAY;\n        } else {\n            // Selecting the next alarm time:  Roll forward to the next 24 hour multiple before\n            // the expiration time.\n            long alarmInterval = timeToExpire % MS_PER_DAY;\n            if (alarmInterval == 0) {\n                alarmInterval = MS_PER_DAY;\n            }\n            alarmTime = now + alarmInterval;\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            int affectedUserHandle = parent ? getProfileParentId(userHandle) : userHandle;\n            AlarmManager am = mInjector.getAlarmManager();\n            // Broadcast alarms sent by system are immutable\n            PendingIntent pi = PendingIntent.getBroadcastAsUser(context, REQUEST_EXPIRE_PASSWORD,\n                    new Intent(ACTION_EXPIRED_PASSWORD_NOTIFICATION),\n                    PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT\n                            | PendingIntent.FLAG_IMMUTABLE,\n                    UserHandle.of(affectedUserHandle));\n            am.cancel(pi);\n            if (alarmTime != 0) {\n                am.set(AlarmManager.RTC, alarmTime, pi);\n            }\n        });\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle) {\n        ensureLocked();\n        ActiveAdmin admin = getUserData(userHandle).mAdminMap.get(who);\n        if (admin != null\n                && who.getPackageName().equals(admin.info.getActivityInfo().packageName)\n                && who.getClassName().equals(admin.info.getActivityInfo().name)) {\n            return admin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getActiveAdminUncheckedLocked(ComponentName who, int userHandle, boolean parent) {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallAuthorization(isManagedProfile(userHandle),\n                    \"You can not call APIs on the parent profile outside a managed profile, \"\n                            + \"userId = %d\", userHandle);\n        }\n        ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        if (admin != null && parent) {\n            admin = admin.getParentActiveAdmin();\n        }\n        return admin;\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(ComponentName who, int reqPolicy)\n            throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(who,\n                reqPolicy, /* permission= */ null);\n    }\n\n    ActiveAdmin getDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n        return doAdmin;\n    }\n\n    ActiveAdmin getDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        ComponentName doComponent = mOwners.getDeviceOwnerComponent();\n        if (mOwners.getDeviceOwnerType(doComponent.getPackageName()) == DEFAULT_DEVICE_OWNER) {\n            ActiveAdmin doAdmin = getUserData(userId).mAdminMap.get(doComponent);\n            return doAdmin;\n        }\n        return null;\n    }\n\n    ActiveAdmin getProfileOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n        ActiveAdmin poAdmin = getUserData(userId).mAdminMap.get(poAdminComponent);\n        return poAdmin;\n    }\n\n    @NonNull ActiveAdmin getOrganizationOwnedProfileOwnerLocked(final CallerIdentity caller) {\n        Preconditions.checkCallAuthorization(\n                mOwners.isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()),\n                \"Caller %s is not an admin of an org-owned device\",\n                caller.getComponentName());\n        final ActiveAdmin profileOwner = getProfileOwnerLocked(caller.getUserId());\n\n        return profileOwner;\n    }\n\n    ActiveAdmin getProfileOwnerOrDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDeviceOwnerLocked(userId);\n    }\n\n    ActiveAdmin getProfileOwnerOrDefaultDeviceOwnerLocked(@UserIdInt int userId) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);\n\n        if (poAdminComponent != null) {\n            return getProfileOwnerLocked(userId);\n        }\n\n        return getDefaultDeviceOwnerLocked(userId);\n    }\n\n    @NonNull ActiveAdmin getParentOfAdminIfRequired(ActiveAdmin admin, boolean parent) {\n        Objects.requireNonNull(admin);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permissions} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * one of {@code permissions} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            ComponentName who,\n            int reqPolicy,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        final CallerIdentity caller = getCallerIdentity();\n\n        ActiveAdmin result = getActiveAdminWithPolicyForUidLocked(who, reqPolicy, caller.getUid());\n        if (result != null) {\n            return result;\n        } else {\n            for (String permission : permissions) {\n                if (hasCallingPermission(permission)) {\n                    return null;\n                }\n            }\n        }\n\n        // Code for handling failure from getActiveAdminWithPolicyForUidLocked to find an admin\n        // that satisfies the required policy.\n        // Throws a security exception with the right error message.\n        if (who != null) {\n            final DevicePolicyData policy = getUserData(caller.getUserId());\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            final boolean isDeviceOwner = isDeviceOwner(admin.info.getComponent(),\n                    caller.getUserId());\n            final boolean isProfileOwner = isProfileOwner(admin.info.getComponent(),\n                    caller.getUserId());\n\n            if (DA_DISALLOWED_POLICIES.contains(reqPolicy) && !isDeviceOwner && !isProfileOwner) {\n                throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                        + \" is not a device owner or profile owner, so may not use policy: \"\n                        + admin.info.getTagForPolicy(reqPolicy));\n            }\n            throw new SecurityException(\"Admin \" + admin.info.getComponent()\n                    + \" did not specify uses-policy for: \"\n                    + admin.info.getTagForPolicy(reqPolicy));\n        } else {\n            throw new SecurityException(\"No active admin owned by uid \"\n                    + caller.getUid() + \" for policy #\" + reqPolicy + (permissions.isEmpty() ? \"\"\n                    : \", which doesn't have \" + permissions));\n        }\n    }\n\n    ActiveAdmin getActiveAdminForCallerLocked(@Nullable ComponentName who, int reqPolicy,\n            boolean parent) throws SecurityException {\n        return getActiveAdminOrCheckPermissionForCallerLocked(\n                who, reqPolicy, parent, /* permission= */ null);\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            @Nullable String permission) throws SecurityException {\n        return getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, parent, permission == null ? Set.of() : Set.of(permission));\n    }\n\n    /**\n     * Finds an active admin for the caller then checks {@code permission} if admin check failed.\n     *\n     * @return an active admin or {@code null} if there is no active admin but\n     * {@code permission} is granted\n     * @throws SecurityException if caller neither has an active admin nor {@code permission}\n     */\n    @Nullable\n    ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(\n            @Nullable ComponentName who,\n            int reqPolicy,\n            boolean parent,\n            Set<String> permissions) throws SecurityException {\n        ensureLocked();\n        if (parent) {\n            Preconditions.checkCallingUser(isManagedProfile(getCallerIdentity().getUserId()));\n        }\n        ActiveAdmin admin = getActiveAdminOrCheckPermissionsForCallerLocked(\n                who, reqPolicy, permissions);\n        return parent ? admin.getParentActiveAdmin() : admin;\n    }\n\n    /**\n     * Find the admin for the component and userId bit of the uid, then check\n     * the admin's uid matches the uid.\n     */\n    private ActiveAdmin getActiveAdminForUidLocked(ComponentName who, int uid) {\n        ensureLocked();\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        ActiveAdmin admin = policy.mAdminMap.get(who);\n        if (admin == null) {\n            throw new SecurityException(\"No active admin \" + who + \" for UID \" + uid);\n        }\n        if (admin.getUid() != uid) {\n            throw new SecurityException(\"Admin \" + who + \" is not owned by uid \" + uid);\n        }\n        return admin;\n    }\n\n    /**\n     * Returns the active admin for the user of the caller as denoted by uid, which implements\n     * the {@code reqPolicy}.\n     *\n     * The {@code who} parameter is used as a hint:\n     * If provided, it must be the component name of the active admin for that user and the caller\n     * uid must match the uid of the admin.\n     * If not provided, iterate over all of the active admins in the DevicePolicyData for that user\n     * and return the one with the uid specified as parameter, and has the policy specified.\n     */\n    @Nullable\n    private ActiveAdmin getActiveAdminWithPolicyForUidLocked(ComponentName who, int reqPolicy,\n            int uid) {\n        ensureLocked();\n        // Try to find an admin which can use reqPolicy\n        final int userId = UserHandle.getUserId(uid);\n        final DevicePolicyData policy = getUserData(userId);\n        if (who != null) {\n            ActiveAdmin admin = policy.mAdminMap.get(who);\n            if (admin == null || admin.getUid() != uid) {\n                throw new SecurityException(\n                        \"Admin \" + who + \" is not active or not owned by uid \" + uid);\n            }\n            if (isActiveAdminWithPolicyForUserLocked(admin, reqPolicy, userId)) {\n                return admin;\n            }\n        } else {\n            for (ActiveAdmin admin : policy.mAdminList) {\n                if (admin.getUid() == uid && isActiveAdminWithPolicyForUserLocked(admin, reqPolicy,\n                        userId)) {\n                    return admin;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    @VisibleForTesting\n    boolean isActiveAdminWithPolicyForUserLocked(ActiveAdmin admin, int reqPolicy,\n            int userId) {\n        ensureLocked();\n        final boolean ownsDevice = isDeviceOwner(admin.info.getComponent(), userId);\n        final boolean ownsProfile = isProfileOwner(admin.info.getComponent(), userId);\n\n        boolean allowedToUsePolicy = ownsDevice || ownsProfile\n                || !DA_DISALLOWED_POLICIES.contains(reqPolicy)\n                || getTargetSdk(admin.info.getPackageName(), userId) < Build.VERSION_CODES.Q;\n        return allowedToUsePolicy && admin.info.usesPolicy(reqPolicy);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action) {\n        sendAdminCommandLocked(admin, action, null);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, null, result);\n    }\n\n    void sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result) {\n        sendAdminCommandLocked(admin, action, adminExtras, result, false);\n    }\n\n    /**\n     * Send an update to one specific admin, get notified when that admin returns a result.\n     *\n     * @return whether the broadcast was successfully sent\n     */\n    boolean sendAdminCommandLocked(ActiveAdmin admin, String action, Bundle adminExtras,\n            BroadcastReceiver result, boolean inForeground) {\n        Intent intent = new Intent(action);\n        intent.setComponent(admin.info.getComponent());\n        if (UserManager.isDeviceInDemoMode(mContext)) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (action.equals(DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING)) {\n            intent.putExtra(\"expiration\", admin.passwordExpirationDate);\n        }\n        if (inForeground) {\n            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        }\n        if (adminExtras != null) {\n            intent.putExtras(adminExtras);\n        }\n        if (mInjector.getPackageManager().queryBroadcastReceiversAsUser(\n                intent,\n                PackageManager.MATCH_DEBUG_TRIAGED_MISSING,\n                admin.getUserHandle()).isEmpty()) {\n            return false;\n        }\n\n        final BroadcastOptions options = BroadcastOptions.makeBasic();\n        options.setBackgroundActivityStartsAllowed(true);\n\n        if (result != null) {\n            mContext.sendOrderedBroadcastAsUser(intent, admin.getUserHandle(),\n                    null, AppOpsManager.OP_NONE, options.toBundle(),\n                    result, mHandler, Activity.RESULT_OK, null, null);\n        } else {\n            mContext.sendBroadcastAsUser(intent, admin.getUserHandle(), null, options.toBundle());\n        }\n\n        return true;\n    }\n\n    /**\n     * Send an update to all admins of a user that enforce a specified policy.\n     */\n    void sendAdminCommandLocked(String action, int reqPolicy, int userHandle, Bundle adminExtras) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        final int count = policy.mAdminList.size();\n        for (int i = 0; i < count; i++) {\n            final ActiveAdmin admin = policy.mAdminList.get(i);\n            if (admin.info.usesPolicy(reqPolicy)) {\n                sendAdminCommandLocked(admin, action, adminExtras, null);\n            }\n        }\n    }\n\n    /**\n     * Send an update intent to all admins of a user and its profiles. Only send to admins that\n     * enforce a specified policy.\n     */\n    private void sendAdminCommandToSelfAndProfilesLocked(String action, int reqPolicy,\n            int userHandle, Bundle adminExtras) {\n        int[] profileIds = mUserManager.getProfileIdsWithDisabled(userHandle);\n        for (int profileId : profileIds) {\n            sendAdminCommandLocked(action, reqPolicy, profileId, adminExtras);\n        }\n    }\n\n    /**\n     * Sends a broadcast to each profile that share the password unlock with the given user id.\n     */\n    private void sendAdminCommandForLockscreenPoliciesLocked(\n            String action, int reqPolicy, int userHandle) {\n        final Bundle extras = new Bundle();\n        extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n            sendAdminCommandLocked(action, reqPolicy, userHandle, extras);\n        } else {\n            sendAdminCommandToSelfAndProfilesLocked(action, reqPolicy, userHandle, extras);\n        }\n    }\n\n    void removeActiveAdminLocked(final ComponentName adminReceiver, final int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n        DevicePolicyData policy = getUserData(userHandle);\n        if (admin != null && !policy.mRemovingAdmins.contains(adminReceiver)) {\n            policy.mRemovingAdmins.add(adminReceiver);\n            sendAdminCommandLocked(admin,\n                    DeviceAdminReceiver.ACTION_DEVICE_ADMIN_DISABLED,\n                    new BroadcastReceiver() {\n                        @Override\n                        public void onReceive(Context context, Intent intent) {\n                            removeAdminArtifacts(adminReceiver, userHandle);\n                            removePackageIfRequired(adminReceiver.getPackageName(), userHandle);\n                        }\n                    });\n        }\n    }\n\n    private DeviceAdminInfo findAdmin(final ComponentName adminName, final int userHandle,\n            boolean throwForMissingPermission) {\n        final ActivityInfo ai = mInjector.binderWithCleanCallingIdentity(() -> {\n            try {\n                return mIPackageManager.getReceiverInfo(adminName,\n                        GET_META_DATA\n                        | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS\n                        | PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, userHandle);\n            } catch (RemoteException e) {\n                // shouldn't happen.\n                Slogf.wtf(LOG_TAG, \"Error getting receiver info\", e);\n                return null;\n            }\n        });\n        if (ai == null) {\n            throw new IllegalArgumentException(\"Unknown admin: \" + adminName);\n        }\n\n        if (!permission.BIND_DEVICE_ADMIN.equals(ai.permission)) {\n            final String message = \"DeviceAdminReceiver \" + adminName + \" must be protected with \"\n                    + permission.BIND_DEVICE_ADMIN;\n            Slogf.w(LOG_TAG, message);\n            if (throwForMissingPermission &&\n                    ai.applicationInfo.targetSdkVersion > Build.VERSION_CODES.M) {\n                throw new IllegalArgumentException(message);\n            }\n        }\n\n        try {\n            return new DeviceAdminInfo(mContext, ai);\n        } catch (XmlPullParserException | IOException e) {\n            Slogf.w(LOG_TAG, \"Bad device admin requested for user=\" + userHandle + \": \" + adminName,\n                    e);\n            return null;\n        }\n    }\n\n    private File getPolicyFileDirectory(@UserIdInt int userId) {\n        return userId == UserHandle.USER_SYSTEM\n                ? mPathProvider.getDataSystemDirectory()\n                : mPathProvider.getUserSystemDirectory(userId);\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId, String fileName) {\n        final String base = new File(getPolicyFileDirectory(userId), fileName)\n                .getAbsolutePath();\n        if (VERBOSE_LOG) Slogf.v(LOG_TAG, \"Opening %s\", base);\n        return new JournaledFile(new File(base), new File(base + \".tmp\"));\n    }\n\n    private JournaledFile makeJournaledFile(@UserIdInt int userId) {\n        return makeJournaledFile(userId, DEVICE_POLICIES_XML);\n    }\n\n    /**\n     * Persist modified values to disk by calling {@link #saveSettingsLocked} for each\n     * affected user ID.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private void saveSettingsForUsersLocked(Set<Integer> affectedUserIds) {\n        for (int userId : affectedUserIds) {\n            saveSettingsLocked(userId);\n        }\n    }\n\n    private void saveSettingsLocked(int userHandle) {\n        if (DevicePolicyData.store(getUserData(userHandle), makeJournaledFile(userHandle))) {\n            sendChangedNotification(userHandle);\n        }\n        invalidateBinderCaches();\n    }\n\n    private void sendChangedNotification(int userHandle) {\n        Intent intent = new Intent(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        Bundle options = new BroadcastOptions()\n                .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n                .setDeferralPolicy(BroadcastOptions.DEFERRAL_POLICY_UNTIL_ACTIVE)\n                .toBundle();\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mContext.sendBroadcastAsUser(intent, new UserHandle(userHandle), null, options));\n    }\n\n    private void loadSettingsLocked(DevicePolicyData policy, int userHandle) {\n        DevicePolicyData.load(policy,\n                makeJournaledFile(userHandle),\n                component -> findAdmin(\n                        component, userHandle, /* throwForMissingPermission= */ false),\n                getOwnerComponent(userHandle));\n\n        policy.validatePasswordOwner();\n        updateMaximumTimeToLockLocked(userHandle);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            updateLockTaskPackagesLocked(mContext, policy.mLockTaskPackages, userHandle);\n            updateLockTaskFeaturesLocked(policy.mLockTaskFeatures, userHandle);\n        }\n        if (policy.mStatusBarDisabled) {\n            setStatusBarDisabledInternal(policy.mStatusBarDisabled, userHandle);\n        }\n    }\n\n    static void updateLockTaskPackagesLocked(Context context, List<String> packages, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n\n            String[] packagesArray = null;\n            if (!packages.isEmpty()) {\n                // When adding packages, we need to include the exempt apps so they can still be\n                // launched (ideally we should use a different AM API as these apps don't need to\n                // use lock-task mode).\n                // They're not added when the packages is empty though, as in that case we're\n                // disabling lock-task mode.\n                List<String> exemptApps = listPolicyExemptAppsUnchecked(context);\n                if (!exemptApps.isEmpty()) {\n                    // TODO(b/175377361): add unit test to verify it (cannot be CTS because the\n                    //  policy-exempt apps are provided by OEM and the test would have no control\n                    //  over it) once tests are migrated to the new infra-structure\n                    HashSet<String> updatedPackages = new HashSet<>(packages);\n                    updatedPackages.addAll(exemptApps);\n                    if (VERBOSE_LOG) {\n                        Slogf.v(LOG_TAG, \"added %d policy-exempt apps to %d lock task \"\n                                + \"packages. Final list: %s\",\n                                exemptApps.size(), packages.size(), updatedPackages);\n                    }\n                    packagesArray = updatedPackages.toArray(new String[updatedPackages.size()]);\n                }\n            }\n\n            if (packagesArray == null) {\n                packagesArray = packages.toArray(new String[packages.size()]);\n            }\n            try {\n                ActivityManager.getService().updateLockTaskPackages(userId, packagesArray);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void updateLockTaskFeaturesLocked(int flags, int userId) {\n        Binder.withCleanCallingIdentity(() -> {\n            try {\n                ActivityTaskManager.getService().updateLockTaskFeatures(userId, flags);\n            } catch (RemoteException e) {\n                // Shouldn't happen.\n                Slog.wtf(LOG_TAG, \"Remote Exception: \", e);\n            }\n        });\n    }\n\n    static void validateQualityConstant(int quality) {\n        switch (quality) {\n            case PASSWORD_QUALITY_UNSPECIFIED:\n            case PASSWORD_QUALITY_BIOMETRIC_WEAK:\n            case PASSWORD_QUALITY_SOMETHING:\n            case PASSWORD_QUALITY_NUMERIC:\n            case PASSWORD_QUALITY_NUMERIC_COMPLEX:\n            case PASSWORD_QUALITY_ALPHABETIC:\n            case PASSWORD_QUALITY_ALPHANUMERIC:\n            case PASSWORD_QUALITY_COMPLEX:\n            case PASSWORD_QUALITY_MANAGED:\n                return;\n        }\n        throw new IllegalArgumentException(\"Invalid quality constant: 0x\"\n                + Integer.toHexString(quality));\n    }\n\n    @VisibleForTesting\n    void systemReady(int phase) {\n        if (!mHasFeature) {\n            return;\n        }\n        switch (phase) {\n            case SystemService.PHASE_LOCK_SETTINGS_READY:\n                onLockSettingsReady();\n                loadAdminDataAsync();\n                mOwners.systemReady();\n                applyManagedSubscriptionsPolicyIfRequired();\n                break;\n            case SystemService.PHASE_ACTIVITY_MANAGER_READY:\n                synchronized (getLockObject()) {\n                    migrateToProfileOnOrganizationOwnedDeviceIfCompLocked();\n                    applyProfileRestrictionsIfDeviceOwnerLocked();\n\n                    // TODO: Is this the right place to trigger the migration?\n                    if (shouldMigrateToDevicePolicyEngine()) {\n                        migratePoliciesToDevicePolicyEngine();\n                    }\n\n                    maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked();\n                }\n                maybeStartSecurityLogMonitorOnActivityManagerReady();\n                break;\n            case SystemService.PHASE_BOOT_COMPLETED:\n                // Ideally it should be done earlier, but currently it relies on RecoverySystem,\n                // which would hang on earlier phases\n                factoryResetIfDelayedEarlier();\n\n                ensureDeviceOwnerUserStarted(); // TODO Consider better place to do this.\n                break;\n        }\n    }\n\n    private void applyManagedSubscriptionsPolicyIfRequired() {\n        int copeProfileUserId = getOrganizationOwnedProfileUserId();\n        // This policy is relevant only for COPE devices.\n        if (copeProfileUserId != UserHandle.USER_NULL) {\n            unregisterOnSubscriptionsChangedListener();\n            int policyType = getManagedSubscriptionsPolicy().getPolicyType();\n            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {\n                clearManagedSubscriptionsPolicy();\n            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n                // Add listener to assign all current and future subs to managed profile.\n                registerListenerToAssignSubscriptionsToUser(copeProfileUserId);\n            }\n        }\n    }\n\n    private void updatePersonalAppsSuspensionOnUserStart(int userHandle) {\n        final int profileUserHandle = getManagedUserId(userHandle);\n        if (profileUserHandle >= 0) {\n            // Given that the parent user has just started, profile should be locked.\n            updatePersonalAppsSuspension(profileUserHandle);\n        } else {\n            suspendPersonalAppsInternal(userHandle, profileUserHandle, false);\n        }\n    }\n\n    private void onLockSettingsReady() {\n        synchronized (getLockObject()) {\n            fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration();\n        }\n        getUserData(UserHandle.USER_SYSTEM);\n        cleanUpOldUsers();\n        maybeSetDefaultProfileOwnerUserRestrictions();\n        handleStartUser(UserHandle.USER_SYSTEM);\n        maybeLogStart();\n\n        // Register an observer for watching for user setup complete and settings changes.\n        mSetupContentObserver.register();\n        // Initialize the user setup state, to handle the upgrade case.\n        updateUserSetupCompleteAndPaired();\n\n        List<String> packageList;\n        synchronized (getLockObject()) {\n            packageList = getKeepUninstalledPackagesLocked();\n        }\n        if (packageList != null) {\n            mInjector.getPackageManagerInternal().setKeepUninstalledPackages(packageList);\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();\n            if (deviceOwner != null) {\n                // Push the force-ephemeral-users policy to the user manager.\n                mUserManagerInternal.setForceEphemeralUsers(deviceOwner.forceEphemeralUsers);\n\n                // Update user switcher message to activity manager.\n                ActivityManagerInternal activityManagerInternal =\n                        mInjector.getActivityManagerInternal();\n                activityManagerInternal.setSwitchingFromSystemUserMessage(\n                        deviceOwner.startUserSessionMessage);\n                activityManagerInternal.setSwitchingToSystemUserMessage(\n                        deviceOwner.endUserSessionMessage);\n            }\n\n            revertTransferOwnershipIfNecessaryLocked();\n        }\n        updateUsbDataSignal();\n\n        // In case flag value has changed, we apply it during boot to avoid doing it concurrently\n        // with user toggling quiet mode.\n        setKeepProfileRunningEnabledUnchecked(isKeepProfilesRunningFlagEnabled());\n    }\n\n    // TODO(b/230841522) Make it static.\n    private class DpmsUpgradeDataProvider implements PolicyUpgraderDataProvider {\n        @Override\n        public JournaledFile makeDevicePoliciesJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, DEVICE_POLICIES_XML);\n        }\n\n        @Override\n        public JournaledFile makePoliciesVersionJournaledFile(int userId) {\n            return DevicePolicyManagerService.this.makeJournaledFile(userId, POLICIES_VERSION_XML);\n        }\n\n        @Override\n        public Function<ComponentName, DeviceAdminInfo> getAdminInfoSupplier(int userId) {\n            return component ->\n                    findAdmin(component, userId, /* throwForMissingPermission= */ false);\n        }\n\n        @Override\n        public int[] getUsersForUpgrade() {\n            List<UserInfo> allUsers = mUserManager.getUsers();\n            return allUsers.stream().mapToInt(u -> u.id).toArray();\n        }\n\n        @Override\n        public List<String> getPlatformSuspendedPackages(int userId) {\n            PackageManagerInternal pmi = mInjector.getPackageManagerInternal();\n            return mInjector.getPackageManager(userId)\n                    .getInstalledPackages(PackageManager.PackageInfoFlags.of(\n                            MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE))\n                    .stream()\n                    .map(packageInfo -> packageInfo.packageName)\n                    .filter(pkg ->\n                            PLATFORM_PACKAGE_NAME.equals(pmi.getSuspendingPackage(pkg, userId))\n                    )\n                    .collect(Collectors.toList());\n        }\n    }\n\n    private void performPolicyVersionUpgrade() {\n        PolicyVersionUpgrader upgrader = new PolicyVersionUpgrader(\n                new DpmsUpgradeDataProvider(), mPathProvider);\n        upgrader.upgradePolicy(DPMS_VERSION);\n    }\n\n    private void revertTransferOwnershipIfNecessaryLocked() {\n        if (!mTransferOwnershipMetadataManager.metadataFileExists()) {\n            return;\n        }\n        Slogf.e(LOG_TAG, \"Owner transfer metadata file exists! Reverting transfer.\");\n        final TransferOwnershipMetadataManager.Metadata metadata =\n                mTransferOwnershipMetadataManager.loadMetadataFile();\n        // Revert transfer\n        if (metadata.adminType.equals(ADMIN_TYPE_PROFILE_OWNER)) {\n            transferProfileOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        } else if (metadata.adminType.equals(ADMIN_TYPE_DEVICE_OWNER)) {\n            transferDeviceOwnershipLocked(metadata.targetComponent, metadata.sourceComponent,\n                    metadata.userId);\n            deleteTransferOwnershipMetadataFileLocked();\n            deleteTransferOwnershipBundleLocked(metadata.userId);\n        }\n        updateSystemUpdateFreezePeriodsRecord(/* saveIfChanged */ true);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            pushUserControlDisabledPackagesLocked(metadata.userId);\n        }\n    }\n\n    private void maybeLogStart() {\n        if (!SecurityLog.isLoggingEnabled()) {\n            return;\n        }\n        final String verifiedBootState =\n                mInjector.systemPropertiesGet(\"ro.boot.verifiedbootstate\");\n        final String verityMode = mInjector.systemPropertiesGet(\"ro.boot.veritymode\");\n        SecurityLog.writeEvent(SecurityLog.TAG_OS_STARTUP, verifiedBootState, verityMode);\n    }\n\n    private void ensureDeviceOwnerUserStarted() {\n        final int userId;\n        synchronized (getLockObject()) {\n            if (!mOwners.hasDeviceOwner()) {\n                return;\n            }\n            userId = mOwners.getDeviceOwnerUserId();\n        }\n        if (VERBOSE_LOG) {\n            Slogf.v(LOG_TAG, \"Starting non-system DO user: \" + userId);\n        }\n        if (userId != UserHandle.USER_SYSTEM) {\n            try {\n                mInjector.getIActivityManager().startUserInBackground(userId);\n\n                // STOPSHIP Prevent the DO user from being killed.\n\n            } catch (RemoteException e) {\n                Slogf.w(LOG_TAG, \"Exception starting user\", e);\n            }\n        }\n    }\n\n    void handleStartUser(int userId) {\n        synchronized (getLockObject()) {\n            pushScreenCapturePolicy(userId);\n            if (!isPolicyEngineForFinanceFlagEnabled()) {\n                pushUserControlDisabledPackagesLocked(userId);\n            }\n        }\n        pushUserRestrictions(userId);\n        // When system user is started (device boot), load cache for all users.\n        // This is to mitigate the potential race between loading the cache and keyguard\n        // reading the value during user switch, due to onStartUser() being asynchronous.\n        updatePasswordQualityCacheForUserGroup(\n                userId == UserHandle.USER_SYSTEM ? UserHandle.USER_ALL : userId);\n        updatePermissionPolicyCache(userId);\n        updateAdminCanGrantSensorsPermissionCache(userId);\n\n        final List<PreferentialNetworkServiceConfig> preferentialNetworkServiceConfigs;\n        synchronized (getLockObject()) {\n            ActiveAdmin owner = getDeviceOrProfileOwnerAdminLocked(userId);\n            preferentialNetworkServiceConfigs = owner != null\n                    ? owner.mPreferentialNetworkServiceConfigs\n                    : List.of(PreferentialNetworkServiceConfig.DEFAULT);\n        }\n        updateNetworkPreferenceForUser(userId, preferentialNetworkServiceConfigs);\n\n        if (isProfileOwnerOfOrganizationOwnedDevice(userId)\n                && getManagedSubscriptionsPolicy().getPolicyType()\n                == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {\n            updateDialerAndSmsManagedShortcutsOverrideCache();\n        }\n\n        startOwnerService(userId, \"start-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleStartUser(userId);\n        }\n    }\n\n    void pushUserControlDisabledPackagesLocked(int userId) {\n        final int targetUserId;\n        final ActiveAdmin owner;\n        if (getDeviceOwnerUserIdUncheckedLocked() == userId) {\n            owner = getDeviceOwnerAdminLocked();\n            targetUserId = UserHandle.USER_ALL;\n        } else {\n            owner = getProfileOwnerAdminLocked(userId);\n            targetUserId = userId;\n        }\n\n        List<String> protectedPackages = (owner == null || owner.protectedPackages == null)\n                ? null : owner.protectedPackages;\n        mInjector.binderWithCleanCallingIdentity(() ->\n                mInjector.getPackageManagerInternal().setOwnerProtectedPackages(\n                        targetUserId, protectedPackages));\n        mUsageStatsManagerInternal.setAdminProtectedPackages(new ArraySet(protectedPackages),\n                targetUserId);\n    }\n\n    void handleUnlockUser(int userId) {\n        startOwnerService(userId, \"unlock-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleUnlockUser(userId);\n        }\n    }\n\n    void handleOnUserUnlocked(int userId) {\n        showNewUserDisclaimerIfNecessary(userId);\n    }\n\n    void handleStopUser(int userId) {\n        updateNetworkPreferenceForUser(userId, List.of(PreferentialNetworkServiceConfig.DEFAULT));\n        mDeviceAdminServiceController.stopServicesForUser(userId, /* actionForLog= */ \"stop-user\");\n        if (isPermissionCheckFlagEnabled() || isPolicyEngineForFinanceFlagEnabled()) {\n            mDevicePolicyEngine.handleStopUser(userId);\n        }\n    }\n\n    private void startOwnerService(int userId, String actionForLog) {\n        final ComponentName owner = getOwnerComponent(userId);\n        if (owner != null) {\n            mDeviceAdminServiceController.startServiceForAdmin(\n                    owner.getPackageName(), userId, actionForLog);\n            invalidateBinderCaches();\n        }\n    }\n\n    private void cleanUpOldUsers() {\n        // This is needed in case the broadcast {@link Intent.ACTION_USER_REMOVED} was not handled\n        // before reboot\n        Set<Integer> usersWithProfileOwners;\n        Set<Integer> usersWithData;\n        synchronized (getLockObject()) {\n            usersWithProfileOwners = mOwners.getProfileOwnerKeys();\n            usersWithData = new ArraySet<>();\n            for (int i = 0; i < mUserData.size(); i++) {\n                usersWithData.add(mUserData.keyAt(i));\n            }\n        }\n        List<UserInfo> allUsers = mUserManager.getUsers();\n\n        Set<Integer> deletedUsers = new ArraySet<>();\n        deletedUsers.addAll(usersWithProfileOwners);\n        deletedUsers.addAll(usersWithData);\n        for (UserInfo userInfo : allUsers) {\n            deletedUsers.remove(userInfo.id);\n        }\n        for (Integer userId : deletedUsers) {\n            removeUserData(userId);\n            if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n                mDevicePolicyEngine.handleUserRemoved(userId);\n            }\n        }\n    }\n\n    private void handlePasswordExpirationNotification(int userHandle) {\n        final Bundle adminExtras = new Bundle();\n        adminExtras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));\n\n        synchronized (getLockObject()) {\n            final long now = System.currentTimeMillis();\n\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if ((admin.isPermissionBased || admin.info.usesPolicy(DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD))\n                        && admin.passwordExpirationTimeout > 0L\n                        && now >= admin.passwordExpirationDate - EXPIRATION_GRACE_PERIOD_MS\n                        && admin.passwordExpirationDate > 0L) {\n                    sendAdminCommandLocked(admin,\n                            DeviceAdminReceiver.ACTION_PASSWORD_EXPIRING, adminExtras, null);\n                }\n            }\n            setExpirationAlarmCheckLocked(mContext, userHandle, /* parent */ false);\n        }\n    }\n\n    /**\n     * Clean up internal state when the set of installed trusted CA certificates changes.\n     *\n     * @param userHandle user to check for. This must be a real user and not, for example,\n     *        {@link UserHandle#ALL}.\n     * @param installedCertificates the full set of certificate authorities currently installed for\n     *        {@param userHandle}. After calling this function, {@code mAcceptedCaCertificates} will\n     *        correspond to some subset of this.\n     */\n    protected void onInstalledCertificatesChanged(final UserHandle userHandle,\n            final @NonNull Collection<String> installedCertificates) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n\n            boolean changed = false;\n            changed |= policy.mAcceptedCaCertificates.retainAll(installedCertificates);\n            changed |= policy.mOwnerInstalledCaCerts.retainAll(installedCertificates);\n            if (changed) {\n                saveSettingsLocked(userHandle.getIdentifier());\n            }\n        }\n    }\n\n    /**\n     * Internal method used by {@link CertificateMonitor}.\n     */\n    protected Set<String> getAcceptedCaCertificates(final UserHandle userHandle) {\n        if (!mHasFeature) {\n            return Collections.<String> emptySet();\n        }\n        synchronized (getLockObject()) {\n            final DevicePolicyData policy = getUserData(userHandle.getIdentifier());\n            return policy.mAcceptedCaCertificates;\n        }\n    }\n\n    /**\n     * @param adminReceiver The admin to add\n     * @param refreshing true = update an active admin, no error\n     */\n    @Override\n    public void setActiveAdmin(\n            ComponentName adminReceiver, boolean refreshing, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS));\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        DevicePolicyData policy = getUserData(userHandle);\n        DeviceAdminInfo info = findAdmin(adminReceiver, userHandle,\n                /* throwForMissingPermission= */ true);\n        synchronized (getLockObject()) {\n            checkActiveAdminPrecondition(adminReceiver, info, policy);\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final ActiveAdmin existingAdmin\n                        = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n                if (!refreshing && existingAdmin != null) {\n                    throw new IllegalArgumentException(\"Admin is already added\");\n                }\n                ActiveAdmin newAdmin = new ActiveAdmin(info, /* parent */ false);\n                newAdmin.testOnlyAdmin =\n                        (existingAdmin != null) ? existingAdmin.testOnlyAdmin\n                                : isPackageTestOnly(adminReceiver.getPackageName(), userHandle);\n                policy.mAdminMap.put(adminReceiver, newAdmin);\n                int replaceIndex = -1;\n                final int N = policy.mAdminList.size();\n                for (int i=0; i < N; i++) {\n                    ActiveAdmin oldAdmin = policy.mAdminList.get(i);\n                    if (oldAdmin.info.getComponent().equals(adminReceiver)) {\n                        replaceIndex = i;\n                        break;\n                    }\n                }\n                if (replaceIndex == -1) {\n                    policy.mAdminList.add(newAdmin);\n                    enableIfNecessary(info.getPackageName(), userHandle);\n                    mUsageStatsManagerInternal.onActiveAdminAdded(\n                            adminReceiver.getPackageName(), userHandle);\n                } else {\n                    policy.mAdminList.set(replaceIndex, newAdmin);\n                }\n                saveSettingsLocked(userHandle);\n                sendAdminCommandLocked(newAdmin, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                        /* adminExtras= */ null, /* result= */ null);\n            });\n        }\n    }\n\n    private void loadAdminDataAsync() {\n        mInjector.postOnSystemServerInitThreadPool(() -> {\n            pushActiveAdminPackages();\n            mUsageStatsManagerInternal.onAdminDataAvailable();\n            pushAllMeteredRestrictedPackages();\n            mInjector.getNetworkPolicyManagerInternal().onAdminDataAvailable();\n        });\n    }\n\n    private void pushActiveAdminPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mUsageStatsManagerInternal.setActiveAdminApps(\n                        getActiveAdminPackagesLocked(userId), userId);\n            }\n        }\n    }\n\n    private void pushAllMeteredRestrictedPackages() {\n        synchronized (getLockObject()) {\n            final List<UserInfo> users = mUserManager.getUsers();\n            for (int i = users.size() - 1; i >= 0; --i) {\n                final int userId = users.get(i).id;\n                mInjector.getNetworkPolicyManagerInternal().setMeteredRestrictedPackagesAsync(\n                        getMeteredDisabledPackages(userId), userId);\n            }\n        }\n    }\n\n    private void pushActiveAdminPackagesLocked(int userId) {\n        mUsageStatsManagerInternal.setActiveAdminApps(\n                getActiveAdminPackagesLocked(userId), userId);\n    }\n\n    private Set<String> getActiveAdminPackagesLocked(int userId) {\n        final DevicePolicyData policy = getUserData(userId);\n        Set<String> adminPkgs = null;\n        for (int i = policy.mAdminList.size() - 1; i >= 0; --i) {\n            final String pkgName = policy.mAdminList.get(i).info.getPackageName();\n            if (adminPkgs == null) {\n                adminPkgs = new ArraySet<>();\n            }\n            adminPkgs.add(pkgName);\n        }\n        return adminPkgs;\n    }\n\n    private void transferActiveAdminUncheckedLocked(ComponentName incomingReceiver,\n            ComponentName outgoingReceiver, int userHandle) {\n        final DevicePolicyData policy = getUserData(userHandle);\n        if (!policy.mAdminMap.containsKey(outgoingReceiver)\n                && policy.mAdminMap.containsKey(incomingReceiver)) {\n            // Nothing to transfer - the incoming receiver is already the active admin.\n            return;\n        }\n        final DeviceAdminInfo incomingDeviceInfo = findAdmin(incomingReceiver, userHandle,\n            /* throwForMissingPermission= */ true);\n        final ActiveAdmin adminToTransfer = policy.mAdminMap.get(outgoingReceiver);\n        final int oldAdminUid = adminToTransfer.getUid();\n\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            EnforcingAdmin oldAdmin =\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            outgoingReceiver, userHandle, adminToTransfer);\n            EnforcingAdmin newAdmin =\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            incomingReceiver, userHandle, adminToTransfer);\n\n            mDevicePolicyEngine.transferPolicies(oldAdmin, newAdmin);\n        }\n\n        adminToTransfer.transfer(incomingDeviceInfo);\n        policy.mAdminMap.remove(outgoingReceiver);\n        policy.mAdminMap.put(incomingReceiver, adminToTransfer);\n        if (policy.mPasswordOwner == oldAdminUid) {\n            policy.mPasswordOwner = adminToTransfer.getUid();\n        }\n\n        saveSettingsLocked(userHandle);\n        sendAdminCommandLocked(adminToTransfer, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,\n                null, null);\n    }\n\n    private void checkActiveAdminPrecondition(ComponentName adminReceiver, DeviceAdminInfo info,\n            DevicePolicyData policy) {\n        if (info == null) {\n            throw new IllegalArgumentException(\"Bad admin: \" + adminReceiver);\n        }\n        if (!info.getActivityInfo().applicationInfo.isInternal()) {\n            throw new IllegalArgumentException(\"Only apps in internal storage can be active admin: \"\n                    + adminReceiver);\n        }\n        if (info.getActivityInfo().applicationInfo.isInstantApp()) {\n            throw new IllegalArgumentException(\"Instant apps cannot be device admins: \"\n                    + adminReceiver);\n        }\n        if (policy.mRemovingAdmins.contains(adminReceiver)) {\n            throw new IllegalArgumentException(\n                    \"Trying to set an admin which is being removed\");\n        }\n    }\n\n    private void checkAllUsersAreAffiliatedWithDevice() {\n        Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(),\n                \"operation not allowed when device has unaffiliated users\");\n    }\n\n    @Override\n    public boolean isAdminActive(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getActiveAdminUncheckedLocked(adminReceiver, userHandle) != null;\n        }\n    }\n\n    @Override\n    public boolean isRemovingAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(userHandle);\n            return policyData.mRemovingAdmins.contains(adminReceiver);\n        }\n    }\n\n    @Override\n    public boolean hasGrantedPolicy(ComponentName adminReceiver, int policyId, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(\n                isCallingFromPackage(adminReceiver.getPackageName(), caller.getUid())\n                        || isSystemUid(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin administrator = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (administrator == null) {\n                throw new SecurityException(\"No active admin \" + adminReceiver);\n            }\n            return administrator.info.usesPolicy(policyId);\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<ComponentName> getActiveAdmins(int userHandle) {\n        if (!mHasFeature) {\n            return Collections.EMPTY_LIST;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            if (N <= 0) {\n                return null;\n            }\n            ArrayList<ComponentName> res = new ArrayList<ComponentName>(N);\n            for (int i=0; i<N; i++) {\n                res.add(policy.mAdminList.get(i).info.getComponent());\n            }\n            return res;\n        }\n    }\n\n    @Override\n    public boolean packageHasActiveAdmins(String packageName, int userHandle) {\n        if (!mHasFeature) {\n            return false;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            DevicePolicyData policy = getUserData(userHandle);\n            final int N = policy.mAdminList.size();\n            for (int i=0; i<N; i++) {\n                if (policy.mAdminList.get(i).info.getPackageName().equals(packageName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    @Override\n    public void forceRemoveActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Objects.requireNonNull(adminReceiver, \"ComponentName is null\");\n        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity())\n                        || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS),\n                \"Caller must be shell or hold MANAGE_PROFILE_AND_DEVICE_OWNERS to call \"\n                        + \"forceRemoveActiveAdmin\");\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            boolean isOrgOwnedProfile = false;\n            synchronized (getLockObject()) {\n                if (!isAdminTestOnlyLocked(adminReceiver, userHandle)) {\n                    throw new SecurityException(\"Attempt to remove non-test admin \"\n                            + adminReceiver + \" \" + userHandle);\n                }\n\n                // If admin is a device or profile owner tidy that up first.\n                if (isDeviceOwner(adminReceiver, userHandle)) {\n                    clearDeviceOwnerLocked(getDeviceOwnerAdminLocked(), userHandle);\n                }\n                if (isProfileOwner(adminReceiver, userHandle)) {\n                    isOrgOwnedProfile = isProfileOwnerOfOrganizationOwnedDevice(userHandle);\n                    final ActiveAdmin admin = getActiveAdminUncheckedLocked(adminReceiver,\n                            userHandle, /* parent */ false);\n                    clearProfileOwnerLocked(admin, userHandle);\n                }\n            }\n            // Remove the admin skipping sending the broadcast.\n            removeAdminArtifacts(adminReceiver, userHandle);\n\n            // In case of PO on org owned device, clean device-wide policies and restrictions.\n            if (isOrgOwnedProfile) {\n                final UserHandle parentUser = UserHandle.of(getProfileParentId(userHandle));\n                clearOrgOwnedProfileOwnerUserRestrictions(parentUser);\n                clearOrgOwnedProfileOwnerDeviceWidePolicies(parentUser.getIdentifier());\n            }\n\n            Slogf.i(LOG_TAG, \"Admin \" + adminReceiver + \" removed from user \" + userHandle);\n        });\n    }\n\n    private void clearOrgOwnedProfileOwnerUserRestrictions(UserHandle parentUserHandle) {\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_REMOVE_MANAGED_PROFILE, false, parentUserHandle);\n        mUserManager.setUserRestriction(\n                UserManager.DISALLOW_ADD_USER, false, parentUserHandle);\n    }\n\n    private void clearDeviceOwnerUserRestriction(UserHandle userHandle) {\n        if (isHeadlessFlagEnabled()) {\n            for (int userId : mUserManagerInternal.getUserIds()) {\n                UserHandle user = UserHandle.of(userId);\n                // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the\n                // original state\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER,\n                            false, user);\n                }\n                // When a device owner is set, the system automatically restricts adding a\n                // managed profile.\n                // Remove this restriction when the device owner is cleared.\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                            false,\n                            user);\n                }\n                // When a device owner is set, the system automatically restricts adding a\n                // clone profile.\n                // Remove this restriction when the device owner is cleared.\n                if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, user)) {\n                    mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                            false,\n                            user);\n                }\n            }\n        } else {\n            // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the original state\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER, false,\n                        userHandle);\n            }\n            // When a device owner is set, the system automatically restricts adding a\n            // managed profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                    userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE,\n                        false,\n                        userHandle);\n            }\n            // When a device owner is set, the system automatically restricts adding a clone\n            // profile.\n            // Remove this restriction when the device owner is cleared.\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                    userHandle)) {\n                mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE,\n                        false,\n                        userHandle);\n            }\n        }\n    }\n\n    /**\n     * Return if a given package has testOnly=\"true\", in which case we'll relax certain rules\n     * for CTS.\n     *\n     * DO NOT use this method except in {@link #setActiveAdmin}.  Use {@link #isAdminTestOnlyLocked}\n     * to check wehter an active admin is test-only or not.\n     *\n     * The system allows this flag to be changed when an app is updated, which is not good\n     * for us.  So we persist the flag in {@link ActiveAdmin} when an admin is first installed,\n     * and used the persisted version in actual checks. (See b/31382361 and b/28928996)\n     */\n    private boolean isPackageTestOnly(String packageName, int userHandle) {\n        final ApplicationInfo ai;\n        try {\n            ai = mInjector.getIPackageManager().getApplicationInfo(packageName,\n                    (PackageManager.MATCH_DIRECT_BOOT_AWARE\n                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE), userHandle);\n        } catch (RemoteException e) {\n            throw new IllegalStateException(e);\n        }\n        if (ai == null) {\n            throw new IllegalStateException(\"Couldn't find package: \"\n                    + packageName + \" on user \" + userHandle);\n        }\n        return (ai.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0;\n    }\n\n    /**\n     * See {@link #isPackageTestOnly}.\n     */\n    private boolean isAdminTestOnlyLocked(ComponentName who, int userHandle) {\n        final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle);\n        return (admin != null) && admin.testOnlyAdmin;\n    }\n\n    @Override\n    public void removeActiveAdmin(ComponentName adminReceiver, int userHandle) {\n        if (!mHasFeature) {\n            return;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)\n                ? getCallerIdentity() : getCallerIdentity(adminReceiver);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_REMOVE_ACTIVE_ADMIN);\n        enforceUserUnlocked(userHandle);\n\n        ActiveAdmin admin;\n        synchronized (getLockObject()) {\n            admin = getActiveAdminUncheckedLocked(adminReceiver, userHandle);\n            if (admin == null) {\n                return;\n            }\n            // Active device/profile owners must remain active admins.\n            if (isDeviceOwner(adminReceiver, userHandle)\n                    || isProfileOwner(adminReceiver, userHandle)) {\n                Slogf.e(LOG_TAG, \"Device/profile owner cannot be removed: component=\"\n                        + adminReceiver);\n                return;\n            }\n            mInjector.binderWithCleanCallingIdentity(() ->\n                    removeActiveAdminLocked(adminReceiver, userHandle));\n        }\n        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {\n            mDevicePolicyEngine.removePoliciesForAdmin(\n                    EnforcingAdmin.createEnterpriseEnforcingAdmin(\n                            adminReceiver, userHandle, admin));\n        }\n    }\n\n    private boolean canSetPasswordQualityOnParent(String packageName, final CallerIdentity caller) {\n        return !mInjector.isChangeEnabled(\n                PREVENT_SETTING_PASSWORD_QUALITY_ON_PARENT, packageName, caller.getUserId())\n            || isProfileOwnerOfOrganizationOwnedDevice(caller);\n    }\n\n    private boolean isPasswordLimitingAdminTargetingP(CallerIdentity caller) {\n        if (!caller.hasAdminComponent()) {\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            return getActiveAdminWithPolicyForUidLocked(\n                    caller.getComponentName(), DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD,\n                    caller.getUid()) != null;\n        }\n    }\n\n    private boolean notSupportedOnAutomotive(String method) {\n        if (mIsAutomotive) {\n            Slogf.i(LOG_TAG, \"%s is not supported on automotive builds\", method);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void setPasswordQuality(ComponentName who, int quality, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordQuality\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        validateQualityConstant(quality);\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(\n                isProfileOwner(caller) || isDefaultDeviceOwner(caller)\n                        || isSystemUid(caller) || isPasswordLimitingAdminTargetingP(caller));\n\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    canSetPasswordQualityOnParent(who.getPackageName(), caller),\n                    \"Profile Owner may not apply password quality requirements device-wide\");\n        }\n\n        final int userId = caller.getUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n\n            // If setPasswordQuality is called on the parent, ensure that\n            // the primary admin does not have password complexity state (this is an\n            // unsupported state).\n            if (parent) {\n                final ActiveAdmin primaryAdmin = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, false);\n                final boolean hasComplexitySet =\n                        primaryAdmin.mPasswordComplexity != PASSWORD_COMPLEXITY_NONE;\n                Preconditions.checkState(!hasComplexitySet,\n                        \"Cannot set password quality when complexity is set on the primary admin.\"\n                        + \" Set the primary admin's complexity to NONE first.\");\n            }\n            mInjector.binderWithCleanCallingIdentity(() -> {\n                final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n                if (passwordPolicy.quality != quality) {\n                    passwordPolicy.quality = quality;\n                    ap.mPasswordComplexity = PASSWORD_COMPLEXITY_NONE;\n                    resetInactivePasswordRequirementsIfRPlus(userId, ap);\n                    updatePasswordValidityCheckpointLocked(userId, parent);\n                    updatePasswordQualityCacheForUserGroup(userId);\n                    saveSettingsLocked(userId);\n                }\n                logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n            });\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_QUALITY)\n                .setAdmin(who)\n                .setInt(quality)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)\n                .write();\n    }\n\n    private boolean passwordQualityInvocationOrderCheckEnabled(String packageName, int userId) {\n        return mInjector.isChangeEnabled(ADMIN_APP_PASSWORD_COMPLEXITY, packageName, userId);\n    }\n\n    /**\n     * For admins targeting R+ reset various password constraints to default values when quality is\n     * set to a value that makes those constraints that have no effect.\n     */\n    private void resetInactivePasswordRequirementsIfRPlus(int userId, ActiveAdmin admin) {\n        if (passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(), userId)) {\n            final PasswordPolicy policy = admin.mPasswordPolicy;\n            if (policy.quality < PASSWORD_QUALITY_NUMERIC) {\n                policy.length = PasswordPolicy.DEF_MINIMUM_LENGTH;\n            }\n            if (policy.quality < PASSWORD_QUALITY_COMPLEX) {\n                policy.letters = PasswordPolicy.DEF_MINIMUM_LETTERS;\n                policy.upperCase = PasswordPolicy.DEF_MINIMUM_UPPER_CASE;\n                policy.lowerCase = PasswordPolicy.DEF_MINIMUM_LOWER_CASE;\n                policy.numeric = PasswordPolicy.DEF_MINIMUM_NUMERIC;\n                policy.symbols = PasswordPolicy.DEF_MINIMUM_SYMBOLS;\n                policy.nonLetter = PasswordPolicy.DEF_MINIMUM_NON_LETTER;\n            }\n        }\n    }\n\n    /**\n     * Updates a flag that tells us whether the user's password currently satisfies the\n     * requirements set by all of the user's active admins.\n     * This should be called whenever the password or the admin policies have changed. The caller\n     * is responsible for calling {@link #saveSettingsLocked} to persist the change.\n     *\n     * @return the set of user IDs that have been affected\n     */\n    @GuardedBy(\"getLockObject()\")\n    private Set<Integer> updatePasswordValidityCheckpointLocked(int userHandle, boolean parent) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        final int credentialOwner = getCredentialOwner(userHandle, parent);\n        DevicePolicyData policy = getUserData(credentialOwner);\n        PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n        // Update the checkpoint only if the user's password metrics is known\n        if (metrics != null) {\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            final boolean newCheckpoint = isPasswordSufficientForUserWithoutCheckpointLocked(\n                    metrics, userToCheck);\n            if (newCheckpoint != policy.mPasswordValidAtLastCheckpoint) {\n                policy.mPasswordValidAtLastCheckpoint = newCheckpoint;\n                affectedUserIds.add(credentialOwner);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    /**\n     * Update password quality values in policy cache for all users in the same user group as\n     * the given user. The cached password quality for user X is the aggregated quality among all\n     * admins who have influence of user X's screenlock, i.e. it's equivalent to the return value of\n     * getPasswordQuality(null, user X, false).\n     *\n     * Caches for all users in the same user group often need to be updated alltogether because a\n     * user's admin policy can affect another's aggregated password quality in some situation.\n     * For example a managed profile's policy will affect the parent user if the profile has unified\n     * challenge. A profile can also explicitly set a parent password quality which will affect the\n     * aggregated password quality of the parent user.\n     */\n    private void updatePasswordQualityCacheForUserGroup(@UserIdInt int userId) {\n        final List<UserInfo> users;\n        if (userId == UserHandle.USER_ALL) {\n            users = mUserManager.getUsers();\n        } else {\n            users = mUserManager.getProfiles(userId);\n        }\n        for (UserInfo userInfo : users) {\n            final int currentUserId = userInfo.id;\n            mPolicyCache.setPasswordQuality(currentUserId,\n                    getPasswordQuality(null, currentUserId, false));\n        }\n    }\n\n    @Override\n    public int getPasswordQuality(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return PASSWORD_QUALITY_UNSPECIFIED;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            int mode = PASSWORD_QUALITY_UNSPECIFIED;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.mPasswordPolicy.quality : mode;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (mode < admin.mPasswordPolicy.quality) {\n                    mode = admin.mPasswordPolicy.quality;\n                }\n            }\n            return mode;\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForLockscreenPoliciesLocked(int userHandle) {\n        if (isSeparateProfileChallengeEnabled(userHandle)) {\n\n            if (isPermissionCheckFlagEnabled()) {\n                return getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(userHandle);\n            }\n            // If this user has a separate challenge, only return its restrictions.\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        // If isSeparateProfileChallengeEnabled is false and userHandle points to a managed profile\n        // we need to query the parent user who owns the credential.\n        if (isPermissionCheckFlagEnabled()) {\n            return getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(getProfileParentId(userHandle),\n                    (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n        } else {\n            return getActiveAdminsForUserAndItsManagedProfilesLocked(getProfileParentId(userHandle),\n                    (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n        }\n\n    }\n\n    /**\n     * Get the list of active admins for an affected user:\n     * <ul>\n     * <li>The active admins associated with the userHandle itself</li>\n     * <li>The parent active admins for each managed profile associated with the userHandle</li>\n     * </ul>\n     *\n     * @param userHandle the affected user for whom to get the active admins\n     * @return the list of active admins for the affected user\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForAffectedUserLocked(int userHandle) {\n        if (isManagedProfile(userHandle)) {\n            return getUserDataUnchecked(userHandle).mAdminList;\n        }\n        return getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                /* shouldIncludeProfileAdmins */ (user) -> false);\n    }\n\n    /**\n     * Get the list of active admins for an affected user:\n     * <ul>\n     * <li>The active admins associated with the userHandle itself</li>\n     * <li>The parent active admins for each managed profile associated with the userHandle</li>\n     * <li>The permission based admin associated with the userHandle itself</li>\n     * </ul>\n     *\n     * @param userHandle the affected user for whom to get the active admins\n     * @return the list of active admins for the affected user\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForAffectedUserInclPermissionBasedAdminLocked(\n            int userHandle) {\n        List<ActiveAdmin> list;\n\n        if (isManagedProfile(userHandle)) {\n            list = getUserDataUnchecked(userHandle).mAdminList;\n        }\n        list = getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(userHandle,\n                /* shouldIncludeProfileAdmins */ (user) -> false);\n\n        if (getUserData(userHandle).mPermissionBasedAdmin != null) {\n            list.add(getUserData(userHandle).mPermissionBasedAdmin);\n        }\n        return list;\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    /**\n     * Returns the list of admins on the given user, as well as parent admins for each managed\n     * profile associated with the given user. Optionally also include the admin of each managed\n     * profile.\n     * <p> Should not be called on a profile user.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private List<ActiveAdmin> getActiveAdminsForUserAndItsManagedProfilesInclPermissionBasedAdminLocked(int userHandle,\n            Predicate<UserInfo> shouldIncludeProfileAdmins) {\n        ArrayList<ActiveAdmin> admins = new ArrayList<>();\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            for (UserInfo userInfo : mUserManager.getProfiles(userHandle)) {\n                DevicePolicyData policy = getUserDataUnchecked(userInfo.id);\n                if (userInfo.id == userHandle) {\n                    admins.addAll(policy.mAdminList);\n                    if (policy.mPermissionBasedAdmin != null) {\n                        admins.add(policy.mPermissionBasedAdmin);\n                    }\n                } else if (userInfo.isManagedProfile()) {\n                    for (int i = 0; i < policy.mAdminList.size(); i++) {\n                        ActiveAdmin admin = policy.mAdminList.get(i);\n                        if (admin.hasParentActiveAdmin()) {\n                            admins.add(admin.getParentActiveAdmin());\n                        }\n                        if (shouldIncludeProfileAdmins.test(userInfo)) {\n                            admins.add(admin);\n                        }\n                    }\n                    if (policy.mPermissionBasedAdmin != null\n                            && shouldIncludeProfileAdmins.test(userInfo)) {\n                        admins.add(policy.mPermissionBasedAdmin);\n                    }\n                }\n            }\n        });\n        return admins;\n    }\n\n    private boolean isSeparateProfileChallengeEnabled(int userHandle) {\n        return mInjector.binderWithCleanCallingIdentity(() ->\n                mLockPatternUtils.isSeparateProfileChallengeEnabled(userHandle));\n    }\n\n    @Override\n    public void setPasswordMinimumLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLength\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_NUMERIC, \"setPasswordMinimumLength\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.length != length) {\n                passwordPolicy.length = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LENGTH)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    private void ensureMinimumQuality(\n            int userId, ActiveAdmin admin, int minimumQuality, String operation) {\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // This check will also take care of the case where the password requirements\n            // are specified as complexity rather than quality: When a password complexity\n            // is set, the quality is reset to \"unspecified\" which will be below any value\n            // of minimumQuality.\n            if (admin.mPasswordPolicy.quality < minimumQuality\n                    && passwordQualityInvocationOrderCheckEnabled(admin.info.getPackageName(),\n                    userId)) {\n                throw new IllegalStateException(String.format(\n                        \"password quality should be at least %d for %s\",\n                        minimumQuality, operation));\n            }\n        });\n    }\n\n    @Override\n    public int getPasswordMinimumLength(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.length, PASSWORD_QUALITY_NUMERIC);\n    }\n\n    @Override\n    public void setPasswordHistoryLength(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            if (ap.passwordHistoryLength != length) {\n                ap.passwordHistoryLength = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_HISTORY_LENGTH_SET,\n                    who.getPackageName(), userId, affectedUserId, length);\n        }\n    }\n\n    @Override\n    public int getPasswordHistoryLength(ComponentName who, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.passwordHistoryLength, PASSWORD_QUALITY_UNSPECIFIED);\n    }\n\n    @Override\n    public void setPasswordExpirationTimeout(ComponentName who, String callerPackageName,\n            long timeout, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n        Preconditions.checkArgumentNonnegative(timeout, \"Timeout must be >= 0 ms\");\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUserId)\n                        .getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD, parent);\n            }\n            // Calling this API automatically bumps the expiration date\n            final long expiration = timeout > 0L ? (timeout + System.currentTimeMillis()) : 0L;\n            ap.passwordExpirationDate = expiration;\n            ap.passwordExpirationTimeout = timeout;\n            if (timeout > 0L) {\n                Slogf.w(LOG_TAG, \"setPasswordExpiration(): password will expire on \"\n                        + DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)\n                        .format(new Date(expiration)));\n            }\n            saveSettingsLocked(userHandle);\n\n            // in case this is the first one, set the alarm on the appropriate user.\n            setExpirationAlarmCheckLocked(mContext, userHandle, parent);\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_EXPIRATION_SET, callerPackageName,\n                    userHandle, affectedUserId, timeout);\n        }\n    }\n\n    /**\n     * Return a single admin's expiration cycle time, or the min of all cycle times.\n     * Returns 0 if not configured.\n     */\n    @Override\n    public long getPasswordExpirationTimeout(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            long timeout = 0L;\n\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.passwordExpirationTimeout : timeout;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                ActiveAdmin admin = admins.get(i);\n                if (timeout == 0L || (admin.passwordExpirationTimeout != 0L\n                        && timeout > admin.passwordExpirationTimeout)) {\n                    timeout = admin.passwordExpirationTimeout;\n                }\n            }\n            return timeout;\n        }\n    }\n\n    /**\n     * Return a single admin's expiration date/time, or the min (soonest) for all admins.\n     * Returns 0 if not configured.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private long getPasswordExpirationLocked(ComponentName who, int userHandle, boolean parent) {\n        long timeout = 0L;\n\n        if (who != null) {\n            ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n            return admin != null ? admin.passwordExpirationDate : timeout;\n        }\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (timeout == 0L || (admin.passwordExpirationDate != 0\n                    && timeout > admin.passwordExpirationDate)) {\n                timeout = admin.passwordExpirationDate;\n            }\n        }\n        return timeout;\n    }\n\n    @Override\n    public long getPasswordExpiration(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0L;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            return getPasswordExpirationLocked(who, userHandle, parent);\n        }\n    }\n\n    @Override\n    public void setPasswordMinimumUpperCase(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumUpperCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            final ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumUpperCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.upperCase != length) {\n                passwordPolicy.upperCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_UPPER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumUpperCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.upperCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLowerCase(ComponentName who, int length, boolean parent) {\n        if (notSupportedOnAutomotive(\"setPasswordMinimumLowerCase\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLowerCase\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.lowerCase != length) {\n                passwordPolicy.lowerCase = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LOWER_CASE)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLowerCase(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.lowerCase, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumLetters(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumLetters\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumLetters\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.letters != length) {\n                passwordPolicy.letters = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_LETTERS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumLetters(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.letters, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNumeric(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNumeric\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNumeric\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.numeric != length) {\n                passwordPolicy.numeric = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NUMERIC)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNumeric(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.numeric, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumSymbols(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumSymbols\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumSymbols\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.symbols != length) {\n                ap.mPasswordPolicy.symbols = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_SYMBOLS)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumSymbols(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.symbols, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    @Override\n    public void setPasswordMinimumNonLetter(ComponentName who, int length, boolean parent) {\n        if (!mHasFeature || notSupportedOnAutomotive(\"setPasswordMinimumNonLetter\")) {\n            return;\n        }\n        Objects.requireNonNull(who, \"ComponentName is null\");\n        final int userId = mInjector.userHandleGetCallingUserId();\n        synchronized (getLockObject()) {\n            ActiveAdmin ap = getActiveAdminForCallerLocked(\n                    who, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            ensureMinimumQuality(\n                    userId, ap, PASSWORD_QUALITY_COMPLEX, \"setPasswordMinimumNonLetter\");\n            final PasswordPolicy passwordPolicy = ap.mPasswordPolicy;\n            if (passwordPolicy.nonLetter != length) {\n                ap.mPasswordPolicy.nonLetter = length;\n                updatePasswordValidityCheckpointLocked(userId, parent);\n                saveSettingsLocked(userId);\n            }\n            logPasswordQualitySetIfSecurityLogEnabled(who, userId, parent, passwordPolicy);\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.SET_PASSWORD_MINIMUM_NON_LETTER)\n                .setAdmin(who)\n                .setInt(length)\n                .write();\n    }\n\n    @Override\n    public int getPasswordMinimumNonLetter(ComponentName who, int userHandle, boolean parent) {\n        return getStrictestPasswordRequirement(who, userHandle, parent,\n                admin -> admin.mPasswordPolicy.nonLetter, PASSWORD_QUALITY_COMPLEX);\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    private int getStrictestPasswordRequirement(ComponentName who, int userHandle,\n            boolean parent, Function<ActiveAdmin, Integer> getter, int minimumPasswordQuality) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity(who);\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? getter.apply(admin) : 0;\n            }\n\n            int maxValue = 0;\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final int N = admins.size();\n            for (int i = 0; i < N; i++) {\n                final ActiveAdmin admin = admins.get(i);\n                if (!isLimitPasswordAllowed(admin, minimumPasswordQuality)) {\n                    continue;\n                }\n                final Integer adminValue = getter.apply(admin);\n                if (adminValue > maxValue) {\n                    maxValue = adminValue;\n                }\n            }\n            return maxValue;\n        }\n    }\n\n    /**\n     * Calculates strictest (maximum) value for a given password property enforced by admin[s].\n     */\n    @Override\n    public PasswordMetrics getPasswordMinimumMetrics(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle)\n                && (isSystemUid(caller) || hasCallingOrSelfPermission(\n                permission.SET_INITIAL_LOCK)));\n        return getPasswordMinimumMetricsUnchecked(userHandle, deviceWideOnly);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId) {\n        return getPasswordMinimumMetricsUnchecked(userId, false);\n    }\n\n    private PasswordMetrics getPasswordMinimumMetricsUnchecked(@UserIdInt int userId,\n            boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            new PasswordMetrics(CREDENTIAL_TYPE_NONE);\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n        if (deviceWideOnly) {\n            Preconditions.checkArgument(!isManagedProfile(userId));\n        }\n\n        ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>();\n        final List<ActiveAdmin> admins;\n        synchronized (getLockObject()) {\n            if (deviceWideOnly) {\n                admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userId,\n                        /* shouldIncludeProfileAdmins */ (user) -> false);\n            } else {\n                admins = getActiveAdminsForLockscreenPoliciesLocked(userId);\n            }\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n            }\n        }\n        return PasswordMetrics.merge(adminMetrics);\n    }\n\n    @Override\n    public boolean isActivePasswordSufficient(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        enforceUserUnlocked(userHandle, parent);\n\n        synchronized (getLockObject()) {\n            if (isPermissionCheckFlagEnabled()) {\n                int affectedUser = parent ? getProfileParentId(userHandle) : userHandle;\n                enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        callerPackageName, affectedUser);\n            } else {\n                // This API can only be called by an active device admin,\n                // so try to retrieve it to check that the caller is one.\n                getActiveAdminForCallerLocked(\n                        null, DeviceAdminInfo.USES_POLICY_LIMIT_PASSWORD, parent);\n            }\n\n            int credentialOwner = getCredentialOwner(userHandle, parent);\n            DevicePolicyData policy = getUserDataUnchecked(credentialOwner);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            final int userToCheck = getProfileParentUserIfRequested(userHandle, parent);\n            boolean activePasswordSufficientForUserLocked = isActivePasswordSufficientForUserLocked(\n                    policy.mPasswordValidAtLastCheckpoint, metrics, userToCheck);\n            return activePasswordSufficientForUserLocked;\n        }\n    }\n\n    @Override\n    public boolean isActivePasswordSufficientForDeviceRequirement() {\n        if (!mHasFeature) {\n            return true;\n        }\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(isProfileOwner(caller));\n\n        final int profileUserId = caller.getUserId();\n        Preconditions.checkCallingUser(isManagedProfile(profileUserId));\n\n        // This method is always called on the parent DPM instance to check if its password (i.e.\n        // the device password) is sufficient for all explicit password requirement set on it\n        // So retrieve the parent user Id to which the device password belongs.\n        final int parentUser = getProfileParentId(profileUserId);\n        enforceUserUnlocked(parentUser);\n\n        final boolean isSufficient;\n        synchronized (getLockObject()) {\n\n            int complexity = getAggregatedPasswordComplexityLocked(parentUser, true);\n            PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(parentUser, true);\n\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(parentUser);\n            final List<PasswordValidationError> passwordValidationErrors =\n                    PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n            isSufficient = passwordValidationErrors.isEmpty();\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.IS_ACTIVE_PASSWORD_SUFFICIENT_FOR_DEVICE)\n                .setStrings(mOwners.getProfileOwnerComponent(caller.getUserId()).getPackageName())\n                .write();\n        return isSufficient;\n    }\n\n    @Override\n    public boolean isUsingUnifiedPassword(ComponentName admin) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Objects.requireNonNull(admin, \"ComponentName is null\");\n\n        final CallerIdentity caller = getCallerIdentity(admin);\n        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller));\n        Preconditions.checkCallingUser(isManagedProfile(caller.getUserId()));\n\n        return !isSeparateProfileChallengeEnabled(caller.getUserId());\n    }\n\n    @Override\n    public boolean isPasswordSufficientAfterProfileUnification(int userHandle, int profileUser) {\n        if (!mHasFeature) {\n            return true;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        Preconditions.checkCallAuthorization(!isManagedProfile(userHandle),\n                \"You can not check password sufficiency for a managed profile, userId = %d\",\n                userHandle);\n        enforceUserUnlocked(userHandle);\n\n        synchronized (getLockObject()) {\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(userHandle);\n\n            // Combine password policies across the user and its profiles. Profile admins are\n            // included if the profile is to be unified or currently has unified challenge\n            List<ActiveAdmin> admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> user.id == profileUser\n                    || !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));\n            ArrayList<PasswordMetrics> adminMetrics = new ArrayList<>(admins.size());\n            int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n            for (ActiveAdmin admin : admins) {\n                adminMetrics.add(admin.mPasswordPolicy.getMinMetrics());\n                maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n            }\n            return PasswordMetrics.validatePasswordMetrics(PasswordMetrics.merge(adminMetrics),\n                    maxRequiredComplexity, metrics).isEmpty();\n        }\n    }\n\n    private boolean isActivePasswordSufficientForUserLocked(\n            boolean passwordValidAtLastCheckpoint, @Nullable PasswordMetrics metrics,\n            int userHandle) {\n        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled() && (metrics == null)) {\n            // Before user enters their password for the first time after a reboot, return the\n            // value of this flag, which tells us whether the password was valid the last time\n            // settings were saved.  If DPC changes password requirements on boot so that the\n            // current password no longer meets the requirements, this value will be stale until\n            // the next time the password is entered.\n            return passwordValidAtLastCheckpoint;\n        }\n\n        if (metrics == null) {\n            // Called on a FBE device when the user password exists but its metrics is unknown.\n            // This shouldn't happen since we enforce the user to be unlocked (which would result\n            // in the metrics known to the framework on a FBE device) at all call sites.\n            throw new IllegalStateException(\"isActivePasswordSufficient called on FBE-locked user\");\n        }\n\n        return isPasswordSufficientForUserWithoutCheckpointLocked(metrics, userHandle);\n    }\n\n    /**\n     * Returns {@code true} if the password represented by the {@code metrics} argument\n     * sufficiently fulfills the password requirements for the user corresponding to\n     * {@code userId}.\n     */\n    private boolean isPasswordSufficientForUserWithoutCheckpointLocked(\n            @NonNull PasswordMetrics metrics, @UserIdInt int userId) {\n        final int complexity = getAggregatedPasswordComplexityLocked(userId);\n        PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userId);\n        final List<PasswordValidationError> passwordValidationErrors =\n                PasswordMetrics.validatePasswordMetrics(minMetrics, complexity, metrics);\n        return passwordValidationErrors.isEmpty();\n    }\n\n    @Override\n    @PasswordComplexity\n    public int getPasswordComplexity(boolean parent) {\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_USER_PASSWORD_COMPLEXITY_LEVEL)\n                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT,\n                        mInjector.getPackageManager().getPackagesForUid(Binder.getCallingUid()))\n                .write();\n        final CallerIdentity caller = getCallerIdentity();\n        enforceUserUnlocked(caller.getUserId());\n        if (parent) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller) || isSystemUid(caller),\n                    \"Only profile owner, device owner and system may call this method on parent.\");\n        } else {\n            if (isPermissionCheckFlagEnabled()) {\n                Preconditions.checkCallAuthorization(\n                        hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                                || hasCallingOrSelfPermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS)\n                                || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                        \"Must have \" + REQUEST_PASSWORD_COMPLEXITY + \" or \" +\n                                MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS\n                                + \" permissions, or be a profile owner or device owner.\");\n            } else {\n                Preconditions.checkCallAuthorization(\n                        hasCallingOrSelfPermission(REQUEST_PASSWORD_COMPLEXITY)\n                                || isDefaultDeviceOwner(caller) || isProfileOwner(caller),\n                        \"Must have \" + REQUEST_PASSWORD_COMPLEXITY\n                                + \" permission, or be a profile owner or device owner.\");\n            }\n        }\n\n        synchronized (getLockObject()) {\n            final int credentialOwner = getCredentialOwner(caller.getUserId(), parent);\n            PasswordMetrics metrics = mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);\n            return metrics == null ? PASSWORD_COMPLEXITY_NONE : metrics.determineComplexity();\n        }\n    }\n\n    @Override\n    public void setRequiredPasswordComplexity(\n            String callerPackageName, int passwordComplexity, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return;\n        }\n        final Set<Integer> allowedModes = Set.of(PASSWORD_COMPLEXITY_NONE, PASSWORD_COMPLEXITY_LOW,\n                PASSWORD_COMPLEXITY_MEDIUM, PASSWORD_COMPLEXITY_HIGH);\n        Preconditions.checkArgument(allowedModes.contains(passwordComplexity),\n                \"Provided complexity is not one of the allowed values.\");\n\n        CallerIdentity caller = getCallerIdentity(callerPackageName);\n        if (!isPolicyEngineForFinanceFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            if (isPermissionCheckFlagEnabled()) {\n                // TODO: Make sure this returns the parent of the fake admin\n                // TODO: Deal with null componentname\n                int affectedUser = calledOnParent\n                        ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n                admin = enforcePermissionAndGetEnforcingAdmin(\n                        null, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUser).getActiveAdmin();\n            } else {\n                admin = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), calledOnParent);\n            }\n\n            if (admin.mPasswordComplexity != passwordComplexity) {\n                // We require the caller to explicitly clear any password quality requirements set\n                // on the parent DPM instance, to avoid the case where password requirements are\n                // specified in the form of quality on the parent but complexity on the profile\n                // itself.\n                if (!calledOnParent) {\n                    final boolean hasQualityRequirementsOnParent = admin.hasParentActiveAdmin()\n                            && admin.getParentActiveAdmin().mPasswordPolicy.quality\n                            != PASSWORD_QUALITY_UNSPECIFIED;\n                    Preconditions.checkState(!hasQualityRequirementsOnParent,\n                            \"Password quality is set on the parent when attempting to set password\"\n                            + \"complexity. Clear the quality by setting the password quality \"\n                            + \"on the parent to PASSWORD_QUALITY_UNSPECIFIED first\");\n                }\n\n                mInjector.binderWithCleanCallingIdentity(() -> {\n                    admin.mPasswordComplexity = passwordComplexity;\n                    // Reset the password policy.\n                    admin.mPasswordPolicy = new PasswordPolicy();\n                    updatePasswordValidityCheckpointLocked(caller.getUserId(), calledOnParent);\n                    updatePasswordQualityCacheForUserGroup(caller.getUserId());\n                    saveSettingsLocked(caller.getUserId());\n                });\n\n\n                //TODO(b/276855301): caller.getPackageName() will be null when the coexistence flags are\n                // turned off. Change back to caller.getPackageName once this API is unflagged.\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.SET_PASSWORD_COMPLEXITY)\n                        .setAdmin(admin.info.getPackageName())\n                        .setInt(passwordComplexity)\n                        .setBoolean(calledOnParent)\n                        .write();\n            }\n            logPasswordComplexityRequiredIfSecurityLogEnabled(caller.getPackageName(),\n                    caller.getUserId(), calledOnParent, passwordComplexity);\n        }\n    }\n\n    private void logPasswordComplexityRequiredIfSecurityLogEnabled(String adminPackageName,\n            int userId,\n            boolean parent, int complexity) {\n        if (SecurityLog.isLoggingEnabled()) {\n            final int affectedUserId = parent ? getProfileParentId(userId) : userId;\n            SecurityLog.writeEvent(SecurityLog.TAG_PASSWORD_COMPLEXITY_REQUIRED,\n                    adminPackageName, userId, affectedUserId, complexity);\n        }\n    }\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle) {\n        return getAggregatedPasswordComplexityLocked(userHandle, false);\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle,\n            boolean deviceWideOnly) {\n        ensureLocked();\n        final List<ActiveAdmin> admins;\n        if (deviceWideOnly) {\n            admins = getActiveAdminsForUserAndItsManagedProfilesLocked(userHandle,\n                    /* shouldIncludeProfileAdmins */ (user) -> false);\n        } else {\n            admins = getActiveAdminsForLockscreenPoliciesLocked(userHandle);\n        }\n        int maxRequiredComplexity = PASSWORD_COMPLEXITY_NONE;\n        for (ActiveAdmin admin : admins) {\n            maxRequiredComplexity = Math.max(maxRequiredComplexity, admin.mPasswordComplexity);\n        }\n        return maxRequiredComplexity;\n    }\n\n    @Override\n    public int getRequiredPasswordComplexity(String callerPackageName, boolean calledOnParent) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n\n        if (isPermissionCheckFlagEnabled()) {\n            int affectedUser = calledOnParent ? getProfileParentId(caller.getUserId())\n                    : caller.getUserId();\n            enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                    callerPackageName, affectedUser);\n        } else {\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n\n            Preconditions.checkArgument(!calledOnParent || isProfileOwner(caller));\n        }\n\n        synchronized (getLockObject()) {\n            final ActiveAdmin requiredAdmin = getParentOfAdminIfRequired(\n                    getDeviceOrProfileOwnerAdminLocked(caller.getUserId()), calledOnParent);\n            return requiredAdmin.mPasswordComplexity;\n        }\n    }\n\n    @Override\n    public int getAggregatedPasswordComplexityForUser(int userId, boolean deviceWideOnly) {\n        if (!mHasFeature) {\n            return PASSWORD_COMPLEXITY_NONE;\n        }\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        synchronized (getLockObject()) {\n            return getAggregatedPasswordComplexityLocked(userId, deviceWideOnly);\n        }\n    }\n\n\n    @Override\n    public int getCurrentFailedPasswordAttempts(\n            String callerPackageName, int userHandle, boolean parent) {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            if (!isSystemUid(caller)) {\n                // This API can be called by an active device admin or by keyguard code.\n                if (!hasCallingPermission(permission.ACCESS_KEYGUARD_SECURE_STORAGE)) {\n                    if (isPermissionCheckFlagEnabled()) {\n                        int affectedUser = parent ? getProfileParentId(userHandle) : userHandle;\n                        enforcePermission(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                                callerPackageName, affectedUser);\n                    } else {\n                        getActiveAdminForCallerLocked(\n                                null, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n                    }\n                }\n            }\n\n            DevicePolicyData policy = getUserDataUnchecked(getCredentialOwner(userHandle, parent));\n\n            return policy.mFailedPasswordAttempts;\n        }\n    }\n\n    @Override\n    public void setMaximumFailedPasswordsForWipe(\n            ComponentName who, String callerPackageName, int num, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n\n\n        int userId = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userId) : userId;\n\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionsAndGetEnforcingAdmin(\n                        who,\n                        /*permission=*/ new String[]{MANAGE_DEVICE_POLICY_WIPE_DATA},\n                        /* adminPolicy=*/ DeviceAdminInfo.USES_POLICY_WIPE_DATA,\n                        caller.getPackageName(), affectedUserId).getActiveAdmin();\n            } else {\n                // This API can only be called by an active device admin,\n                // so try to retrieve it to check that the caller is one.\n                getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_WIPE_DATA, parent);\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_WATCH_LOGIN, parent);\n            }\n\n            if (ap.maximumFailedPasswordsForWipe != num) {\n                ap.maximumFailedPasswordsForWipe = num;\n                saveSettingsLocked(userId);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_PASSWORD_ATTEMPTS_SET, callerPackageName,\n                    userId, affectedUserId, num);\n        }\n    }\n\n    @Override\n    public int getMaximumFailedPasswordsForWipe(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = (who != null)\n                    ? getActiveAdminUncheckedLocked(who, userHandle, parent)\n                    : getAdminWithMinimumFailedPasswordsForWipeLocked(userHandle, parent);\n            return admin != null ? admin.maximumFailedPasswordsForWipe : 0;\n        }\n    }\n\n    @Override\n    public int getProfileWithMinimumFailedPasswordsForWipe(int userHandle, boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return UserHandle.USER_NULL;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n\n        synchronized (getLockObject()) {\n            ActiveAdmin admin = getAdminWithMinimumFailedPasswordsForWipeLocked(\n                    userHandle, parent);\n            return admin != null ? getUserIdToWipeForFailedPasswords(admin) : UserHandle.USER_NULL;\n        }\n    }\n\n    /**\n     * Returns the admin with the strictest policy on maximum failed passwords for:\n     * <ul>\n     *   <li>this user if it has a separate profile challenge, or\n     *   <li>this user and all profiles that don't have their own challenge otherwise.\n     * </ul>\n     * <p>If the policy for the primary and any other profile are equal, it returns the admin for\n     * the primary profile. Policy of a PO on an organization-owned device applies to the primary\n     * profile.\n     * Returns {@code null} if no participating admin has that policy set.\n     */\n    @GuardedBy(\"getLockObject()\")\n    private ActiveAdmin getAdminWithMinimumFailedPasswordsForWipeLocked(\n            int userHandle, boolean parent) {\n        int count = 0;\n        ActiveAdmin strictestAdmin = null;\n\n        // Return the strictest policy across all participating admins.\n        List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                getProfileParentUserIfRequested(userHandle, parent));\n        final int N = admins.size();\n        for (int i = 0; i < N; i++) {\n            ActiveAdmin admin = admins.get(i);\n            if (admin.maximumFailedPasswordsForWipe ==\n                    ActiveAdmin.DEF_MAXIMUM_FAILED_PASSWORDS_FOR_WIPE) {\n                continue;  // No max number of failed passwords policy set for this profile.\n            }\n\n            // We always favor the primary profile if several profiles have the same value set.\n            final int userId = getUserIdToWipeForFailedPasswords(admin);\n            if (count == 0 ||\n                    count > admin.maximumFailedPasswordsForWipe ||\n                    (count == admin.maximumFailedPasswordsForWipe &&\n                            getUserInfo(userId).isPrimary())) {\n                count = admin.maximumFailedPasswordsForWipe;\n                strictestAdmin = admin;\n            }\n        }\n        return strictestAdmin;\n    }\n\n    private UserInfo getUserInfo(@UserIdInt int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mUserManager.getUserInfo(userId));\n    }\n\n    private boolean setPasswordPrivileged(@NonNull String password, int flags,\n            CallerIdentity caller) {\n        // Only allow setting password on an unsecured user\n        if (isLockScreenSecureUnchecked(caller.getUserId())) {\n            throw new SecurityException(\"Cannot change current password\");\n        }\n        return resetPasswordInternal(password, 0, null, flags, caller);\n    }\n\n    @Override\n    public boolean resetPassword(@Nullable String password, int flags) throws RemoteException {\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            Slogf.w(LOG_TAG, \"Cannot reset password when the device has no lock screen\");\n            return false;\n        }\n        if (password == null) password = \"\";\n        final CallerIdentity caller = getCallerIdentity();\n        final int userHandle = caller.getUserId();\n\n        // As of R, only privileged caller holding RESET_PASSWORD can call resetPassword() to\n        // set password to an unsecured user.\n        if (hasCallingPermission(permission.RESET_PASSWORD)) {\n            final boolean result = setPasswordPrivileged(password, flags, caller);\n            if (result) {\n                DevicePolicyEventLogger\n                        .createEvent(DevicePolicyEnums.RESET_PASSWORD)\n                        .write();\n            }\n            return result;\n        }\n\n        // If caller has PO (or DO) throw or fail silently depending on its target SDK level.\n        if (isDefaultDeviceOwner(caller) || isProfileOwner(caller)) {\n            synchronized (getLockObject()) {\n                ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());\n                if (getTargetSdk(admin.info.getPackageName(), userHandle) < Build.VERSION_CODES.O) {\n                    Slogf.e(LOG_TAG, \"DPC can no longer call resetPassword()\");\n                    return false;\n                }\n                throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n            }\n        }\n\n        // Caller is not DO or PO, could either be unauthorized or Device Admin.\n        synchronized (getLockObject()) {\n            // Legacy device admin cannot call resetPassword either\n            ActiveAdmin admin = getActiveAdminForCallerLocked(\n                    null, DeviceAdminInfo.USES_POLICY_RESET_PASSWORD, false);\n            Preconditions.checkCallAuthorization(admin != null,\n                    \"Unauthorized caller cannot call resetPassword.\");\n            if (getTargetSdk(admin.info.getPackageName(),\n                    userHandle) <= android.os.Build.VERSION_CODES.M) {\n                Slogf.e(LOG_TAG, \"Device admin can no longer call resetPassword()\");\n                return false;\n            }\n            throw new SecurityException(\"Device admin can no longer call resetPassword()\");\n        }\n    }\n\n    private boolean resetPasswordInternal(String password, long tokenHandle, byte[] token,\n            int flags, CallerIdentity caller) {\n        final int callingUid = caller.getUid();\n        final int userHandle = UserHandle.getUserId(callingUid);\n        final boolean isPin = PasswordMetrics.isNumericOnly(password);\n        synchronized (getLockObject()) {\n            final PasswordMetrics minMetrics = getPasswordMinimumMetricsUnchecked(userHandle);\n            final List<PasswordValidationError> validationErrors;\n            final int complexity = getAggregatedPasswordComplexityLocked(userHandle);\n            // TODO: Consider changing validation API to take LockscreenCredential.\n            if (password.isEmpty()) {\n                validationErrors = PasswordMetrics.validatePasswordMetrics(\n                        minMetrics, complexity, new PasswordMetrics(CREDENTIAL_TYPE_NONE));\n            } else {\n                // TODO(b/120484642): remove getBytes() below\n                validationErrors = PasswordMetrics.validatePassword(\n                        minMetrics, complexity, isPin, password.getBytes());\n            }\n\n            if (!validationErrors.isEmpty()) {\n                Slogf.w(LOG_TAG, \"Failed to reset password due to constraint violation: %s\",\n                        validationErrors.get(0));\n                return false;\n            }\n        }\n\n        DevicePolicyData policy = getUserData(userHandle);\n        if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {\n            Slogf.w(LOG_TAG, \"resetPassword: already set by another uid and not entered by user\");\n            return false;\n        }\n\n        boolean callerIsDeviceOwnerAdmin = isDefaultDeviceOwner(caller);\n        boolean doNotAskCredentialsOnBoot =\n                (flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;\n        if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {\n            setDoNotAskCredentialsOnBoot();\n        }\n\n        // Don't do this with the lock held, because it is going to call\n        // back in to the service.\n        final long ident = mInjector.binderClearCallingIdentity();\n        final LockscreenCredential newCredential;\n        if (isPin) {\n            newCredential = LockscreenCredential.createPin(password);\n        } else {\n            newCredential = LockscreenCredential.createPasswordOrNone(password);\n        }\n        try {\n            if (tokenHandle == 0 || token == null) {\n                if (!mLockPatternUtils.setLockCredential(newCredential,\n                        LockscreenCredential.createNone(), userHandle)) {\n                    return false;\n                }\n            } else {\n                if (!mLockPatternUtils.setLockCredentialWithToken(newCredential, tokenHandle,\n                        token, userHandle)) {\n                    return false;\n                }\n            }\n            boolean requireEntry = (flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;\n            if (requireEntry) {\n                mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW,\n                        UserHandle.USER_ALL);\n            }\n            synchronized (getLockObject()) {\n                int newOwner = requireEntry ? callingUid : -1;\n                if (policy.mPasswordOwner != newOwner) {\n                    policy.mPasswordOwner = newOwner;\n                    saveSettingsLocked(userHandle);\n                }\n            }\n        } finally {\n            mInjector.binderRestoreCallingIdentity(ident);\n        }\n        return true;\n    }\n\n    private boolean isLockScreenSecureUnchecked(int userId) {\n        return mInjector.binderWithCleanCallingIdentity(() -> mLockPatternUtils.isSecure(userId));\n    }\n\n    private void setDoNotAskCredentialsOnBoot() {\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            if (!policyData.mDoNotAskCredentialsOnBoot) {\n                policyData.mDoNotAskCredentialsOnBoot = true;\n                saveSettingsLocked(UserHandle.USER_SYSTEM);\n            }\n        }\n    }\n\n    @Override\n    public boolean getDoNotAskCredentialsOnBoot() {\n        Preconditions.checkCallAuthorization(\n                hasCallingOrSelfPermission(permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT));\n        synchronized (getLockObject()) {\n            DevicePolicyData policyData = getUserData(UserHandle.USER_SYSTEM);\n            return policyData.mDoNotAskCredentialsOnBoot;\n        }\n    }\n\n    @Override\n    public void setMaximumTimeToLock(ComponentName who, String callerPackageName,\n            long timeMs, boolean parent) {\n        if (!mHasFeature) {\n            return;\n        }\n        if (!isPermissionCheckFlagEnabled()) {\n            Objects.requireNonNull(who, \"ComponentName is null\");\n        }\n        int userHandle = mInjector.userHandleGetCallingUserId();\n        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                CallerIdentity caller = getCallerIdentity(who, callerPackageName);\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who,\n                        /*permission=*/ MANAGE_DEVICE_POLICY_LOCK,\n                        /*AdminPolicy=*/DeviceAdminInfo.USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        affectedUserId).getActiveAdmin();\n            } else {\n                ap = getActiveAdminForCallerLocked(\n                        who, DeviceAdminInfo.USES_POLICY_FORCE_LOCK, parent);\n            }\n\n            if (ap.maximumTimeToUnlock != timeMs) {\n                ap.maximumTimeToUnlock = timeMs;\n                saveSettingsLocked(userHandle);\n                updateMaximumTimeToLockLocked(userHandle);\n            }\n        }\n        if (SecurityLog.isLoggingEnabled()) {\n            SecurityLog.writeEvent(SecurityLog.TAG_MAX_SCREEN_LOCK_TIMEOUT_SET,\n                    callerPackageName, userHandle, affectedUserId, timeMs);\n        }\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateMaximumTimeToLockLocked(@UserIdInt int userId) {\n        // Update the profile's timeout\n        if (isManagedProfile(userId)) {\n            updateProfileLockTimeoutLocked(userId);\n        }\n\n        mInjector.binderWithCleanCallingIdentity(() -> {\n            // Update the device timeout\n            final int parentId = getProfileParentId(userId);\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(parentId));\n\n            final DevicePolicyData policy = getUserDataUnchecked(parentId);\n            if (policy.mLastMaximumTimeToLock == timeMs) {\n                return;\n            }\n            policy.mLastMaximumTimeToLock = timeMs;\n\n            if (policy.mLastMaximumTimeToLock != Long.MAX_VALUE) {\n                // Make sure KEEP_SCREEN_ON is disabled, since that\n                // would allow bypassing of the maximum time to lock.\n                mInjector.settingsGlobalPutInt(Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0);\n            }\n            getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(parentId, timeMs);\n        });\n    }\n\n    @GuardedBy(\"getLockObject()\")\n    private void updateProfileLockTimeoutLocked(@UserIdInt int userId) {\n        final long timeMs;\n        if (isSeparateProfileChallengeEnabled(userId)) {\n            timeMs = getMaximumTimeToLockPolicyFromAdmins(\n                    getActiveAdminsForLockscreenPoliciesLocked(userId));\n        } else {\n            timeMs = Long.MAX_VALUE;\n        }\n\n        final DevicePolicyData policy = getUserDataUnchecked(userId);\n        if (policy.mLastMaximumTimeToLock == timeMs) {\n            return;\n        }\n        policy.mLastMaximumTimeToLock = timeMs;\n\n        mInjector.binderWithCleanCallingIdentity(() ->\n                getPowerManagerInternal().setMaximumScreenOffTimeoutFromDeviceAdmin(\n                        userId, policy.mLastMaximumTimeToLock));\n    }\n\n    @Override\n    public long getMaximumTimeToLock(ComponentName who, int userHandle, boolean parent) {\n        if (!mHasFeature) {\n            return 0;\n        }\n        Preconditions.checkArgumentNonnegative(userHandle, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));\n        // System caller can query policy for a particular admin.\n        Preconditions.checkCallAuthorization(\n                who == null || isCallingFromPackage(who.getPackageName(), caller.getUid())\n                        || canQueryAdminPolicy(caller));\n\n        synchronized (getLockObject()) {\n            if (who != null) {\n                final ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userHandle, parent);\n                return admin != null ? admin.maximumTimeToUnlock : 0;\n            }\n            // Return the strictest policy across all participating admins.\n            final List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userHandle, parent));\n            final long timeMs = getMaximumTimeToLockPolicyFromAdmins(admins);\n            return timeMs == Long.MAX_VALUE ? 0 : timeMs;\n        }\n    }\n\n    private long getMaximumTimeToLockPolicyFromAdmins(List<ActiveAdmin> admins) {\n        long time = Long.MAX_VALUE;\n        for (final ActiveAdmin admin : admins) {\n            if (admin.maximumTimeToUnlock > 0 && admin.maximumTimeToUnlock < time) {\n                time = admin.maximumTimeToUnlock;\n            }\n        }\n        return time;\n    }\n\n    @Override\n    public void setRequiredStrongAuthTimeout(ComponentName who, String callerPackageName, long timeoutMs,\n            boolean parent) {\n        if (!mHasFeature || !mLockPatternUtils.hasSecureLockScreen()) {\n            return;\n        }\n        Preconditions.checkArgument(timeoutMs >= 0, \"Timeout must not be a negative number.\");\n        CallerIdentity caller;\n        if (isPermissionCheckFlagEnabled()) {\n            caller = getCallerIdentity(who, callerPackageName);\n        } else {\n            caller = getCallerIdentity(who);\n            Objects.requireNonNull(who, \"ComponentName is null\");\n            Preconditions.checkCallAuthorization(\n                    isDefaultDeviceOwner(caller) || isProfileOwner(caller));\n        }\n        // timeoutMs with value 0 means that the admin doesn't participate\n        // timeoutMs is clamped to the interval in case the internal constants change in the future\n        final long minimumStrongAuthTimeout = getMinimumStrongAuthTimeoutMs();\n        if (timeoutMs != 0 && timeoutMs < minimumStrongAuthTimeout) {\n            timeoutMs = minimumStrongAuthTimeout;\n        }\n        if (timeoutMs > DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS) {\n            timeoutMs = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n\n        final int userHandle = caller.getUserId();\n        boolean changed = false;\n        synchronized (getLockObject()) {\n            ActiveAdmin ap;\n            if (isPermissionCheckFlagEnabled()) {\n                int affectedUser = parent\n                        ? getProfileParentId(caller.getUserId()) : caller.getUserId();\n                ap = enforcePermissionAndGetEnforcingAdmin(\n                        who, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,\n                        caller.getPackageName(), affectedUser).getActiveAdmin();\n            } else {\n                ap = getParentOfAdminIfRequired(\n                        getProfileOwnerOrDeviceOwnerLocked(caller.getUserId()), parent);\n            }\n            if (ap.strongAuthUnlockTimeout != timeoutMs) {\n                ap.strongAuthUnlockTimeout = timeoutMs;\n                saveSettingsLocked(userHandle);\n                changed = true;\n            }\n        }\n        if (changed) {\n            mLockSettingsInternal.refreshStrongAuthTimeout(userHandle);\n            // Refreshes the parent if profile has unified challenge, since the timeout would\n            // also affect the parent user in this case.\n            if (isManagedProfile(userHandle) && !isSeparateProfileChallengeEnabled(userHandle)) {\n                mLockSettingsInternal.refreshStrongAuthTimeout(getProfileParentId(userHandle));\n            }\n        }\n    }\n\n    /**\n     * Return a single admin's strong auth unlock timeout or minimum value (strictest) of all\n     * admins if who is null.\n     * Returns 0 if not configured for the provided admin.\n     */\n    @Override\n    public long getRequiredStrongAuthTimeout(ComponentName who, int userId, boolean parent) {\n        if (!mHasFeature) {\n            return DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n        }\n        Preconditions.checkArgumentNonnegative(userId, \"Invalid userId\");\n\n        final CallerIdentity caller = getCallerIdentity();\n        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userId));\n\n        if (!mLockPatternUtils.hasSecureLockScreen()) {\n            // No strong auth timeout on devices not supporting the\n            // {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature\n            return 0;\n        }\n        synchronized (getLockObject()) {\n            if (who != null) {\n                ActiveAdmin admin = getActiveAdminUncheckedLocked(who, userId, parent);\n                return admin != null ? admin.strongAuthUnlockTimeout : 0;\n            }\n\n            // Return the strictest policy across all participating admins.\n            List<ActiveAdmin> admins = getActiveAdminsForLockscreenPoliciesLocked(\n                    getProfileParentUserIfRequested(userId, parent));\n\n            long strongAuthUnlockTimeout = DevicePolicyManager.DEFAULT_STRONG_AUTH_TIMEOUT_MS;\n            for (int i = 0; i < admins.size(); i++) {\n                final long timeout = admins.get(i).strongAuthUnlockTimeout;\n                if (timeout != 0) { // take only participating admins into account\n                    strongAuthUnlockTimeout = Math.min(timeout, strongAuthUnlockTimeout);\n                }\n            }\n            return Math.max(strongAuthUnlockTimeout, getMinimumStrongAuthTimeoutMs());\n        }\n    }\n\n    private long getMinimumStrongAuthTimeoutMs() {\n        if (!mInjector.isBuildDebuggable()) {\n            return MINIMUM_STRONG_AUTH_TIMEOUT_MS;\n        }\n        // ideally the property was named persist.sys.min_strong_auth_timeout, but system property\n        // name cannot be longer than 31 characters\n        return Math.min(mInjector.systemPropertiesGetLong(\"persist.sys.min_str_auth_timeo\",\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS),\n                MINIMUM_STRONG_AUTH_TIMEOUT_MS);\n    }\n\n    @Override\n    public void lockNow(int flags, String callerPackageName, boolean parent) {\n        CallerIdentity caller;\n        if (isUnicornFlagEnabled()) {\n            caller = getCallerIdentity(callerPackageName);\n        } else {\n            caller = getCallerIdentity();\n        }\n\n        final int callingUserId = caller.getUserId();\n        ComponentName adminComponent = null;\n        synchronized (getLockObject()) {\n            ActiveAdmin admin;\n            // Make sure the caller has any active admin with the right policy or\n            // the required permission.\n            if (isUnicornFlagEnabled()) {\n                admin = enforcePermissionsAndGetEnforcingAdmin(\n                        /* admin= */ null,\n                        /* permission= */ new String[]{MANAGE_DEVICE_POLICY_LOCK},\n                        USES_POLICY_FORCE_LOCK,\n                        caller.getPackageName(),\n                        getAffectedUser(parent)\n                 ).getActiveAdmin();\n            } else {\n                admin = getActiveAdminOrCheckPermissionForCallerLocked(\n                        null,\n                        DeviceAdminInfo.USES_POLICY_FORCE_LOCK,\n                        parent,\n                        LOCK_DEVICE);\n            }\n            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_LOCK_NOW);\n            final long ident = mInjector.binderClearCallingIdentity();\n            try {\n                adminComponent = admin == null ? null : admin.info.getComponent();\n                if (adminComponent != null) {\n                    // For Profile Owners only, callers with only permission not allowed.\n                    if ((flags & DevicePolicyManager.FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY) != 0) {\n                        // Evict key\n                        Preconditions.checkCallingUser(isManagedProfile(callingUserId));\n                        Preconditions.checkArgument(!parent,\n                                \"Cannot set FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY for the parent\");\n                        if (!isProfileOwner(adminComponent, callingUserId)) {\n                            throw new SecurityException(\"Only profile owner admins can set \"\n                                    + \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY\");\n                        }\n                        if (!mInjector.storageManagerIsFileBasedEncryptionEnabled()) {\n                            throw new UnsupportedOperationException(\n                                    \"FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY only applies to FBE\"\n                                        + \" devices\");\n                        }\n                        mUserManager.evictCredentialEncryptionKey(callingUserId);\n                    }\n                }\n\n                // Lock all users unless this is a managed profile with a separate challenge\n                final int userToLock = (parent || !isSeparateProfileChallengeEnabled(callingUserId)\n                        ? UserHandle.USER_ALL : callingUserId);\n                mLockPatternUtils.requireStrongAuth(\n                        STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW, userToLock);\n\n                // Require authentication for the device or profile\n                if (userToLock == UserHandle.USER_ALL) {\n                    if (mIsAutomotive) {\n                        if (VERBOSE_LOG) {\n                            Slogf.v(LOG_TAG, \"lockNow(): not powering off display on automotive\"\n                                    + \" build\");\n                        }\n                    } else {\n                        // Power off the display\n                        mInjector.powerManagerGoToSleep(SystemClock.uptimeMillis(),\n                                PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN, 0);\n                    }\n                    mInjector.getIWindowManager().lockNow(null);\n                } else {\n                    mInjector.getTrustManager().setDeviceLockedForUser(userToLock, true);\n                }\n\n                if (SecurityLog.isLoggingEnabled() && adminComponent != null) {\n                    final int affectedUserId =\n                            parent ? getProfileParentId(callingUserId) : callingUserId;\n                    SecurityLog.writeEvent(SecurityLog.TAG_REMOTE_LOCK,\n                            adminComponent.getPackageName(), callingUserId, affectedUserId);\n                }\n            } catch (RemoteException e) {\n            } finally {\n                mInjector.binderRestoreCallingIdentity(ident);\n            }\n        }\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.LOCK_NOW)\n                .setAdmin(adminComponent)\n                .setInt(flags)\n                .write();\n    }\n\n    @Override\n    public void enforceCanManageCaCerts(ComponentName who, String callerPackage) {\n        final CallerIdentity caller = getCallerIdentity(who, callerPackage);\n        Preconditions.checkCallAuthorization(canManageCaCerts(caller));\n    }\n\n    private boolean canManageCaCerts(CallerIdentity caller) {\n        return (caller.hasAdminComponent() && (isDefaultDeviceOwner(caller)\n                || isProfileOwner(caller)))\n                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_CERT_INSTALL))\n                || hasCallingOrSelfPermission(MANAGE_CA_CERTIFICATES);\n    }\n\n    @Override\n    public boolean approveCaCert(String alias, int userId, boolean approval) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            Set<String> certs = getUserData(userId).mAcceptedCaCertificates;\n            boolean changed = (approval ? certs.add(alias) : certs.remove(alias));\n            if (!changed) {\n                return false;\n            }\n            saveSettingsLocked(userId);\n        }\n        mCertificateMonitor.onCertificateApprovalsChanged(userId);\n        return true;\n    }\n\n    @Override\n    public boolean isCaCertApproved(String alias, int userId) {\n        Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity()));\n\n        synchronized (getLockObject()) {\n            return getUserData(userId).mAcceptedCaCertificates.contains(alias);\n        }\n    }\n\n    private Set<Integer> removeCaApprovalsIfNeeded(int userId) {\n        final ArraySet<Integer> affectedUserIds = new ArraySet<>();\n        for (UserInfo userInfo : mUserManager.getProfiles(userId)) {\n            boolean isSecure = mLockPatternUtils.isSecure(userInfo.id);\n            if (userInfo.isManagedProfile()){\n                isSecure |= mLockPatternUtils.isSecure(getProfileParentId(userInfo.id));\n            }\n            if (!isSecure) {\n                synchronized (getLockObject()) {\n                    getUserData(userInfo.id).mAcceptedCaCertificates.clear();\n                    affectedUserIds.add(userInfo.id);\n                }\n                mCertificateMonitor.onCertificateApprovalsChanged(userId);\n            }\n        }\n        return affectedUserIds;\n    }\n\n    @Override\n    public boolean installCaCert(ComponentName admin, String callerPackage, byte[] certBuffer) {\n        if (!mHasFeature) {\n            return false;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        }  else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))\n                    || (caller.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));\n        }\n        if (isCredentialManagementApp) {\n            Preconditions.checkCallAuthorization(\n                    isAliasInCredentialManagementAppPolicy(caller, alias),\n                    CREDENTIAL_MANAGEMENT_APP_INVALID_ALIAS_MSG);\n        }\n        checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_INSTALL_CA_CERT);\n\n        final String alias = mInjector.binderWithCleanCallingIdentity(() -> {\n            String installedAlias = mCertificateMonitor.installCaCert(\n                    caller.getUserHandle(), certBuffer);\n            DevicePolicyEventLogger\n                    .createEvent(DevicePolicyEnums.INSTALL_CA_CERT)\n                    .setAdmin(caller.getPackageName())\n                    .setBoolean(/* isDelegate */ admin == null)\n                    .setStrings(isCredentialManagementApp\n                                ? CREDENTIAL_MANAGEMENT_APP : NOT_CREDENTIAL_MANAGEMENT_APP)\n                    .write();\n            return installedAlias;\n        });\n\n        if (alias == null) {\n            Slogf.w(LOG_TAG, \"Problem installing cert\");\n            return false;\n        }\n\n        synchronized (getLockObject()) {\n            getUserData(caller.getUserId()).mOwnerInstalledCaCerts.add(alias);\n            saveSettingsLocked(caller.getUserId());\n        }\n        return true;\n    }\n\n    @Override\n    public void uninstallCaCerts(ComponentName admin, String callerPackage, String[] aliases) {\n        if (!mHasFeature) {\n            return;\n        }\n        final CallerIdentity caller = getCallerIdentity(admin, callerPackage);\n        final boolean isCallerDelegate = isCallerDelegate(caller, DELEGATION_CERT_INSTALL);\n        final boolean isCredentialManagementApp = isCredentialManagementApp(caller);\n        if (isPermissionCheckFlagEnabled()) {\n            Preconditions.checkCallAuthorization(\n                    hasPermission(MANAGE_DEVICE_POLICY_CERTIFICATES,\n                            caller.getPackageName(), caller.getUserId())\n                            || isCredentialManagementApp);\n        }  else {\n            Preconditions.checkCallAuthorization((caller.hasAdminComponent()\n                    && (isProfileOwner(caller) ||",
        "metrics": {},
        "metrics_status": "Metrics not computed: 'downstream_file_content_ground_truth' is missing."
    }
]