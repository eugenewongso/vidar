[
  {
    "cve_id": "ASB-A-299441833",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-299441833",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-242996380",
    "downstream_version": "14",
    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-242996380",
    "downstream_version": "13",
    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-316891059",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 385.02,
    "ground_truth_diff": "diff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 6ba0338bfc9..504e2985742 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-317048495",
    "downstream_version": "13",
    "file_name": "packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java",
    "runtime_seconds": 398.28,
    "ground_truth_diff": "diff --git a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\nindex da602caac0dc..cdf58db58a15 100644\n--- a/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n+++ b/packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java\n@@ -25,6 +25,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -59,18 +60,21 @@ public class ClipboardListener extends CoreStartable\n     private final ClipboardOverlayControllerFactory mOverlayFactory;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlayController mClipboardOverlayController;\n \n     @Inject\n     public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n             ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n-            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n+            ClipboardToast clipboardToast, KeyguardManager keyguardManager,\n+            UiEventLogger uiEventLogger) {\n         super(context);\n         mDeviceConfig = deviceConfigProxy;\n         mOverlayFactory = overlayFactory;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -96,8 +100,11 @@ public class ClipboardListener extends CoreStartable\n             return;\n         }\n \n-        if (!isUserSetupComplete()) {\n-            // just show a toast, user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n+                || clipData == null // shouldn't happen, but just in case\n+                || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n                 mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                 mClipboardToast.showCopiedToast();",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -25,6 +25,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -59,18 +60,21 @@ public class ClipboardListener extends CoreStartable\n     private final ClipboardOverlayControllerFactory mOverlayFactory;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlayController mClipboardOverlayController;\n \n     @Inject\n     public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n             ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n-            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n+            ClipboardToast clipboardToast, KeyguardManager keyguardManager,\n+            UiEventLogger uiEventLogger) {\n         super(context);\n         mDeviceConfig = deviceConfigProxy;\n         mOverlayFactory = overlayFactory;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -96,8 +100,11 @@ public class ClipboardListener extends CoreStartable\n             return;\n         }\n \n-        if (!isUserSetupComplete()) {\n-            // just show a toast, user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n+                || clipData == null // shouldn't happen, but just in case\n+                || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n                 mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                 mClipboardToast.showCopiedToast();",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-299931761",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/wifi/WifiDialogActivity.java",
    "runtime_seconds": 351.75,
    "ground_truth_diff": "diff --git a/src/com/android/settings/wifi/WifiDialogActivity.java b/src/com/android/settings/wifi/WifiDialogActivity.java\nindex 67f291da49d..ca7d80f8999 100644\n--- a/src/com/android/settings/wifi/WifiDialogActivity.java\n+++ b/src/com/android/settings/wifi/WifiDialogActivity.java\n@@ -17,6 +17,8 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -31,6 +33,7 @@ import android.os.Looper;\n import android.os.Process;\n import android.os.SimpleClock;\n import android.os.SystemClock;\n+import android.os.UserManager;\n import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n@@ -115,6 +118,10 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n \n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n \n@@ -361,6 +368,29 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n     }\n \n+    @VisibleForTesting\n+    boolean isConfigWifiAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager == null) return true;\n+        final boolean isConfigWifiAllowed = !userManager.hasUserRestriction(DISALLOW_CONFIG_WIFI);\n+        if (!isConfigWifiAllowed) {\n+            Log.e(TAG, \"The user is not allowed to configure Wi-Fi.\");\n+            EventLog.writeEvent(0x534e4554, \"226133034\", getApplicationContext().getUserId(),\n+                    \"The user is not allowed to configure Wi-Fi.\");\n+        }\n+        return isConfigWifiAllowed;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isAddWifiConfigAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n+            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWifiManager() {\n         if (mWifiManager != null) return true;\n         mWifiManager = getSystemService(WifiManager.class);",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/wifi/WifiDialogActivity.java\n+++ b/src/com/android/settings/wifi/WifiDialogActivity.java\n@@ -18,4 +18,6 @@\n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n \n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -100,3 +102,7 @@\n         super.onCreate(savedInstanceState);\n \n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n```",
    "cleaned_ground_truth": "@@ -17,6 +17,8 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -31,6 +33,7 @@ import android.os.Looper;\n import android.os.Process;\n import android.os.SimpleClock;\n import android.os.SystemClock;\n+import android.os.UserManager;\n import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n@@ -115,6 +118,10 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n \n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n \n@@ -361,6 +368,29 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n     }\n \n+    @VisibleForTesting\n+    boolean isConfigWifiAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager == null) return true;\n+        final boolean isConfigWifiAllowed = !userManager.hasUserRestriction(DISALLOW_CONFIG_WIFI);\n+        if (!isConfigWifiAllowed) {\n+            Log.e(TAG, \"The user is not allowed to configure Wi-Fi.\");\n+            EventLog.writeEvent(0x534e4554, \"226133034\", getApplicationContext().getUserId(),\n+                    \"The user is not allowed to configure Wi-Fi.\");\n+        }\n+        return isConfigWifiAllowed;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isAddWifiConfigAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n+            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWifiManager() {\n         if (mWifiManager != null) return true;\n         mWifiManager = getSystemService(WifiManager.class);",
    "cleaned_upstream_plus_llm": "@@ -18,4 +18,6 @@\n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n \n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -100,3 +102,7 @@\n         super.onCreate(savedInstanceState);\n \n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n```"
  },
  {
    "cve_id": "ASB-A-283099444",
    "downstream_version": "11",
    "file_name": "media/codec2/sfplugin/utils/Codec2BufferUtils.cpp",
    "runtime_seconds": null,
    "ground_truth_diff": "diff --git a/media/codec2/sfplugin/utils/Codec2BufferUtils.cpp b/media/codec2/sfplugin/utils/Codec2BufferUtils.cpp\nindex bf2a07ee52..9bc8eb9c4c 100644\n--- a/media/codec2/sfplugin/utils/Codec2BufferUtils.cpp\n+++ b/media/codec2/sfplugin/utils/Codec2BufferUtils.cpp\n@@ -361,8 +361,8 @@ status_t ConvertRGBToPlanarYUV(\n     const uint8_t *pBlue  = src.data()[C2PlanarLayout::PLANE_B];\n \n #define CLIP3(x,y,z) (((z) < (x)) ? (x) : (((z) > (y)) ? (y) : (z)))\n-    for (size_t y = 0; y < src.height(); ++y) {\n-        for (size_t x = 0; x < src.width(); ++x) {\n+    for (size_t y = 0; y < src.crop().height; ++y) {\n+        for (size_t x = 0; x < src.crop().width; ++x) {\n             uint8_t red = *pRed;\n             uint8_t green = *pGreen;\n             uint8_t blue = *pBlue;",
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "@@ -361,8 +361,8 @@ status_t ConvertRGBToPlanarYUV(\n     const uint8_t *pBlue  = src.data()[C2PlanarLayout::PLANE_B];\n \n #define CLIP3(x,y,z) (((z) < (x)) ? (x) : (((z) > (y)) ? (y) : (z)))\n-    for (size_t y = 0; y < src.height(); ++y) {\n-        for (size_t x = 0; x < src.width(); ++x) {\n+    for (size_t y = 0; y < src.crop().height; ++y) {\n+        for (size_t x = 0; x < src.crop().width; ++x) {\n             uint8_t red = *pRed;\n             uint8_t green = *pGreen;\n             uint8_t blue = *pBlue;",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 343.93,
    "ground_truth_diff": "diff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 6ba0338bfc9..504e2985742 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 345.76,
    "ground_truth_diff": "diff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 8b041b67f87..6580c682fa1 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 526.89,
    "ground_truth_diff": "diff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex 8b041b67f87..6580c682fa1 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 566.62,
    "ground_truth_diff": "diff --git a/src/com/android/settings/search/SearchResultTrampoline.java b/src/com/android/settings/search/SearchResultTrampoline.java\nindex e9304739460..28030e81d87 100644\n--- a/src/com/android/settings/search/SearchResultTrampoline.java\n+++ b/src/com/android/settings/search/SearchResultTrampoline.java\n@@ -39,7 +39,7 @@ public class SearchResultTrampoline extends Activity {\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n+                .verifyLaunchSearchResultPageCaller(this, getLaunchedFromPackage());\n         // Didn't crash, proceed and launch the result as a subsetting.\n         final Intent intent = getIntent();",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -39,7 +39,7 @@ public class SearchResultTrampoline extends Activity {\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n+                .verifyLaunchSearchResultPageCaller(this, getLaunchedFromPackage());\n         // Didn't crash, proceed and launch the result as a subsetting.\n         final Intent intent = getIntent();",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-327749022",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/homepage/SettingsHomepageActivity.java",
    "runtime_seconds": 90.38,
    "ground_truth_diff": "diff --git a/src/com/android/settings/homepage/SettingsHomepageActivity.java b/src/com/android/settings/homepage/SettingsHomepageActivity.java\nindex 0311ea3fbe9..81556ef81f0 100644\n--- a/src/com/android/settings/homepage/SettingsHomepageActivity.java\n+++ b/src/com/android/settings/homepage/SettingsHomepageActivity.java\n@@ -154,6 +154,17 @@ public class SettingsHomepageActivity extends FragmentActivity implements\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n         mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this);\n         mIsTwoPaneLastTime = ActivityEmbeddingUtils.isTwoPaneResolution(this);",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/homepage/SettingsHomepageActivity.java\n+++ b/src/com/android/settings/homepage/SettingsHomepageActivity.java\n@@ -129,6 +129,16 @@\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n         setContentView(R.layout.settings_homepage_container);\n         mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this);\n         mIsTwoPaneLastTime = ActivityEmbeddingUtils.isTwoPaneResolution(this);\n\n```",
    "cleaned_ground_truth": "@@ -154,6 +154,17 @@ public class SettingsHomepageActivity extends FragmentActivity implements\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n         mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this);\n         mIsTwoPaneLastTime = ActivityEmbeddingUtils.isTwoPaneResolution(this);",
    "cleaned_upstream_plus_llm": "@@ -129,6 +129,16 @@\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n         setContentView(R.layout.settings_homepage_container);\n         mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this);\n         mIsTwoPaneLastTime = ActivityEmbeddingUtils.isTwoPaneResolution(this);\n\n```"
  },
  {
    "cve_id": "ASB-A-327749022",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/homepage/SettingsHomepageActivity.java",
    "runtime_seconds": 104.54,
    "ground_truth_diff": "diff --git a/src/com/android/settings/homepage/SettingsHomepageActivity.java b/src/com/android/settings/homepage/SettingsHomepageActivity.java\nindex 1d7b5dc14b9..f1c46dff44a 100644\n--- a/src/com/android/settings/homepage/SettingsHomepageActivity.java\n+++ b/src/com/android/settings/homepage/SettingsHomepageActivity.java\n@@ -74,6 +74,17 @@ public class SettingsHomepageActivity extends FragmentActivity implements\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n \n         final View appBar = findViewById(R.id.app_bar_container);",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/homepage/SettingsHomepageActivity.java\n+++ b/src/com/android/settings/homepage/SettingsHomepageActivity.java\n@@ -54,6 +54,16 @@\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n \n         final View appBar = findViewById(R.id.app_bar_container);\n```",
    "cleaned_ground_truth": "@@ -74,6 +74,17 @@ public class SettingsHomepageActivity extends FragmentActivity implements\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n \n         final View appBar = findViewById(R.id.app_bar_container);",
    "cleaned_upstream_plus_llm": "@@ -54,6 +54,16 @@\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n \n         final View appBar = findViewById(R.id.app_bar_container);\n```"
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "14",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 150.17,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n@@ -17,7 +17,8 @@\n import com.android.systemui.dagger.SysUISingleton;\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n-import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.MediaHost;\n import com.android.systemui.media.controls.ui.MediaHostStatesManager;\n@@ -37,6 +37,7 @@\n     String QUICK_QS_PANEL = \"media_quick_qs_panel\";\n     String KEYGUARD = \"media_keyguard\";\n     String DREAM = \"dream\";\n+    String COMMUNAL_HUB = \"media_communal_hub\";\n \n     /** */\n     @Provides\n@@ -81,3 +82,14 @@\n     }\n \n+    /** */\n+    @Provides\n+    @SysUISingleton\n+    @Named(COMMUNAL_HUB)\n+    static MediaHost providesCommunalMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n+            MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n+            MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n+        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,\n+                carouselController);\n+    }\n+\n     /** Provides a logging buffer related to the media tap-to-transfer chip on the sender device. */\n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -17,7 +17,8 @@\n import com.android.systemui.dagger.SysUISingleton;\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n-import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.MediaHost;\n import com.android.systemui.media.controls.ui.MediaHostStatesManager;\n@@ -37,6 +37,7 @@\n     String QUICK_QS_PANEL = \"media_quick_qs_panel\";\n     String KEYGUARD = \"media_keyguard\";\n     String DREAM = \"dream\";\n+    String COMMUNAL_HUB = \"media_communal_hub\";\n \n     /** */\n     @Provides\n@@ -81,3 +82,14 @@\n     }\n \n+    /** */\n+    @Provides\n+    @SysUISingleton\n+    @Named(COMMUNAL_HUB)\n+    static MediaHost providesCommunalMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n+            MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n+            MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n+        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,\n+                carouselController);\n+    }\n+\n     /** Provides a logging buffer related to the media tap-to-transfer chip on the sender device. */\n```"
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "13",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 517.87,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "12L",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 176.88,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n@@ -19,6 +19,7 @@\n import com.android.systemui.media.MediaHierarchyManager;\n import com.android.systemui.media.MediaHost;\n import com.android.systemui.media.MediaHostStatesManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n \n import javax.inject.Named;\n \n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -19,6 +19,7 @@\n import com.android.systemui.media.MediaHierarchyManager;\n import com.android.systemui.media.MediaHost;\n import com.android.systemui.media.MediaHostStatesManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n \n import javax.inject.Named;\n \n```"
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "12",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 120.41,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n+++ b/packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n@@ -19,6 +19,7 @@ import com.android.systemui.media.MediaDataManager;\n import com.android.systemui.media.MediaHierarchyManager;\n import com.android.systemui.media.MediaHost;\n import com.android.systemui.media.MediaHostStatesManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n \n import javax.inject.Named;\n \n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -19,6 +19,7 @@ import com.android.systemui.media.MediaDataManager;\n import com.android.systemui.media.MediaHierarchyManager;\n import com.android.systemui.media.MediaHost;\n import com.android.systemui.media.MediaHostStatesManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n \n import javax.inject.Named;\n \n```"
  },
  {
    "cve_id": "ASB-A-283103220",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/wm/ActivityClientController.java",
    "runtime_seconds": 253.72,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex e02e8671f211..c783630be113 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -73,6 +73,7 @@ import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -80,6 +81,9 @@ import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.pm.parsing.pkg.AndroidPackage;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -95,6 +99,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -691,6 +702,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -705,6 +717,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -738,6 +751,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -762,6 +788,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -1063,7 +1063,20 @@\n         if (!r.supportsPictureInPicture()) {\n             throw new IllegalStateException(caller\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n+\n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n \n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n```",
    "cleaned_ground_truth": "@@ -73,6 +73,7 @@ import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -80,6 +81,9 @@ import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.pm.parsing.pkg.AndroidPackage;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -95,6 +99,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -691,6 +702,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -705,6 +717,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -738,6 +751,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -762,6 +788,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {",
    "cleaned_upstream_plus_llm": "@@ -1063,7 +1063,20 @@\n         if (!r.supportsPictureInPicture()) {\n             throw new IllegalStateException(caller\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n+\n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n \n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n```"
  },
  {
    "cve_id": "ASB-A-283103220",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/wm/ActivityClientController.java",
    "runtime_seconds": 85.24,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/ActivityClientController.java b/services/core/java/com/android/server/wm/ActivityClientController.java\nindex 3a4faf73bfe1..1cad6b5db365 100644\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -64,17 +64,22 @@ import android.os.PersistableBundle;\n import android.os.RemoteException;\n import android.os.SystemClock;\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -90,6 +95,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -661,6 +673,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -675,6 +688,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -708,6 +722,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -732,6 +759,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/wm/ActivityClientController.java\n+++ b/services/core/java/com/android/server/wm/ActivityClientController.java\n@@ -51,4 +51,5 @@\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n@@ -688,4 +689,17 @@\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n\n```",
    "cleaned_ground_truth": "@@ -64,17 +64,22 @@ import android.os.PersistableBundle;\n import android.os.RemoteException;\n import android.os.SystemClock;\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -90,6 +95,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -661,6 +673,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -675,6 +688,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -708,6 +722,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -732,6 +759,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {",
    "cleaned_upstream_plus_llm": "@@ -51,4 +51,5 @@\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n@@ -688,4 +689,17 @@\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n\n```"
  },
  {
    "cve_id": "ASB-A-308414141",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 319.73,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-308414141",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 366.73,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -119,6 +119,9 @@\n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -342,6 +345,9 @@\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n\n```",
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "@@ -119,6 +119,9 @@\n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -342,6 +345,9 @@\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n\n```"
  },
  {
    "cve_id": "ASB-A-308414141",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 397.27,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-307948424",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 340.63,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -118,7 +118,10 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -369,6 +372,9 @@\n             }\n \n             if (groupSummaryKey != null) {\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n\n```",
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "@@ -118,7 +118,10 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -369,6 +372,9 @@\n             }\n \n             if (groupSummaryKey != null) {\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n\n```"
  },
  {
    "cve_id": "ASB-A-307948424",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 338.83,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-307948424",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 131.9,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/SnoozeHelper.java b/services/core/java/com/android/server/notification/SnoozeHelper.java\nindex f3b92eaf6473..966560359b39 100644\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/notification/SnoozeHelper.java\n+++ b/services/core/java/com/android/server/notification/SnoozeHelper.java\n@@ -154,9 +154,12 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                            + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                            > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n@@ -386,6 +389,9 @@\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n+                String trimmedGroupSummaryKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedGroupSummaryKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedGroupSummaryKey, userId, mPersistedSnoozedNotificationsWithContext);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n\n```",
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "@@ -154,9 +154,12 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                            + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                            > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n@@ -386,6 +389,9 @@\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n+                String trimmedGroupSummaryKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedGroupSummaryKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedGroupSummaryKey, userId, mPersistedSnoozedNotificationsWithContext);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n\n```"
  },
  {
    "cve_id": "ASB-A-328068777",
    "downstream_version": "14",
    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
    "runtime_seconds": 80.65,
    "ground_truth_diff": "diff --git a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\nindex 578db3397..9becd0c39 100644\n--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -798,6 +798,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 builder);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -816,6 +820,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        builder.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         builder.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -862,6 +874,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -815,8 +815,12 @@\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                         if (!isInForeground) {\n                             throwSecurityException(\n\n```",
    "cleaned_ground_truth": "@@ -798,6 +798,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 builder);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -816,6 +820,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        builder.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         builder.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -862,6 +874,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);",
    "cleaned_upstream_plus_llm": "@@ -815,8 +815,12 @@\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                         if (!isInForeground) {\n                             throwSecurityException(\n\n```"
  },
  {
    "cve_id": "ASB-A-300090204",
    "downstream_version": "12L",
    "file_name": "core/java/android/service/dreams/DreamService.java",
    "runtime_seconds": 415.99,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-300090204",
    "downstream_version": "11",
    "file_name": "core/java/android/service/dreams/DreamService.java",
    "runtime_seconds": 523.04,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-300090204",
    "downstream_version": "12",
    "file_name": "core/java/android/service/dreams/DreamService.java",
    "runtime_seconds": 558.56,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-321707289",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/notification/ManagedServices.java",
    "runtime_seconds": 275.12,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/ManagedServices.java b/services/core/java/com/android/server/notification/ManagedServices.java\nindex e6bc79679a8f..496e8c6a1a34 100644\n--- a/services/core/java/com/android/server/notification/ManagedServices.java\n+++ b/services/core/java/com/android/server/notification/ManagedServices.java\n@@ -901,6 +901,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -958,6 +975,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1083,8 +1101,7 @@ abstract public class ManagedServices {\n \n         synchronized (mMutex) {\n             if (enabled) {\n-                if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                        || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                     registerServiceLocked(component, userId);\n                 } else {\n                     Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1222,6 +1239,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1405,28 +1449,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1447,6 +1483,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1548,7 +1593,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1680,6 +1725,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -901,6 +901,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -958,6 +975,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1083,8 +1101,7 @@ abstract public class ManagedServices {\n \n         synchronized (mMutex) {\n             if (enabled) {\n-                if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                        || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                     registerServiceLocked(component, userId);\n                 } else {\n                     Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1222,6 +1239,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1405,28 +1449,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1447,6 +1483,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1548,7 +1593,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1680,6 +1725,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-321707289",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/notification/ManagedServices.java",
    "runtime_seconds": 150.79,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/ManagedServices.java b/services/core/java/com/android/server/notification/ManagedServices.java\nindex bccc52fe350a..fd73e8c4b16f 100644\n--- a/services/core/java/com/android/server/notification/ManagedServices.java\n+++ b/services/core/java/com/android/server/notification/ManagedServices.java\n@@ -155,7 +155,9 @@ abstract public class ManagedServices {\n     // List of approved packages or components (by user, then by primary/secondary) that are\n     // allowed to be bound as managed services. A package or component appearing in this list does\n     // not mean that we are currently bound to said package/component.\n-    protected ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved = new ArrayMap<>();\n+    @GuardedBy(\"mApproved\")\n+    protected final ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved =\n+            new ArrayMap<>();\n \n     // List of packages or components (by user) that are configured to be enabled/disabled\n     // explicitly by the user\n@@ -871,6 +873,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -928,6 +947,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1057,8 +1077,7 @@ abstract public class ManagedServices {\n             for (int i = 0; i < userIds.size(); i++) {\n                 final int userId = userIds.get(i);\n                 if (enabled) {\n-                    if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                            || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                    if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                         registerServiceLocked(component, userId);\n                     } else {\n                         Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1197,6 +1216,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1380,28 +1426,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1422,6 +1460,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1523,7 +1570,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1655,6 +1702,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/notification/ManagedServices.java\n+++ b/services/core/java/com/android/server/notification/ManagedServices.java\n@@ -1302,6 +1302,15 @@\n             Slog.e(TAG, \"Unable to bind \" + getCaption() + \" service: \" + intent, ex);\n         }\n     }\n+\n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n \n     boolean isBound(ComponentName cn, int userId) {\n         final Pair<ComponentName, Integer> servicesBindingTag = Pair.create(cn, userId);\n```",
    "cleaned_ground_truth": "@@ -155,7 +155,9 @@ abstract public class ManagedServices {\n     // List of approved packages or components (by user, then by primary/secondary) that are\n     // allowed to be bound as managed services. A package or component appearing in this list does\n     // not mean that we are currently bound to said package/component.\n-    protected ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved = new ArrayMap<>();\n+    @GuardedBy(\"mApproved\")\n+    protected final ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved =\n+            new ArrayMap<>();\n \n     // List of packages or components (by user) that are configured to be enabled/disabled\n     // explicitly by the user\n@@ -871,6 +873,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -928,6 +947,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1057,8 +1077,7 @@ abstract public class ManagedServices {\n             for (int i = 0; i < userIds.size(); i++) {\n                 final int userId = userIds.get(i);\n                 if (enabled) {\n-                    if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                            || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                    if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                         registerServiceLocked(component, userId);\n                     } else {\n                         Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1197,6 +1216,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1380,28 +1426,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1422,6 +1460,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1523,7 +1570,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1655,6 +1702,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "cleaned_upstream_plus_llm": "@@ -1302,6 +1302,15 @@\n             Slog.e(TAG, \"Unable to bind \" + getCaption() + \" service: \" + intent, ex);\n         }\n     }\n+\n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n \n     boolean isBound(ComponentName cn, int userId) {\n         final Pair<ComponentName, Integer> servicesBindingTag = Pair.create(cn, userId);\n```"
  },
  {
    "cve_id": "ASB-A-321707289",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/notification/ManagedServices.java",
    "runtime_seconds": 144.34,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/notification/ManagedServices.java b/services/core/java/com/android/server/notification/ManagedServices.java\nindex bccc52fe350a..fd73e8c4b16f 100644\n--- a/services/core/java/com/android/server/notification/ManagedServices.java\n+++ b/services/core/java/com/android/server/notification/ManagedServices.java\n@@ -155,7 +155,9 @@ abstract public class ManagedServices {\n     // List of approved packages or components (by user, then by primary/secondary) that are\n     // allowed to be bound as managed services. A package or component appearing in this list does\n     // not mean that we are currently bound to said package/component.\n-    protected ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved = new ArrayMap<>();\n+    @GuardedBy(\"mApproved\")\n+    protected final ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved =\n+            new ArrayMap<>();\n \n     // List of packages or components (by user) that are configured to be enabled/disabled\n     // explicitly by the user\n@@ -871,6 +873,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -928,6 +947,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1057,8 +1077,7 @@ abstract public class ManagedServices {\n             for (int i = 0; i < userIds.size(); i++) {\n                 final int userId = userIds.get(i);\n                 if (enabled) {\n-                    if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                            || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                    if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                         registerServiceLocked(component, userId);\n                     } else {\n                         Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1197,6 +1216,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1380,28 +1426,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1422,6 +1460,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1523,7 +1570,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1655,6 +1702,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/notification/ManagedServices.java\n+++ b/services/core/java/com/android/server/notification/ManagedServices.java\n@@ -1275,7 +1275,17 @@\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        // If rebinding a package that died, ensure it still has permission\n+                                        // after the rebind delay\n+                                        if (isPackageOrComponentAllowedWithPermission(name, userid)) {\n+                                            registerService(name, userid);\n+                                        } else {\n+                                            Slog.w(TAG, \"Not re-binding \" + name + \" for user \" + userid\n+                                                    + \" as it's no longer allowed or lacks permission.\");\n+                                            synchronized (mMutex) {\n+                                                mServicesRebinding.remove(Pair.create(name, userid));\n+                                            }\n+                                        }\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n```",
    "cleaned_ground_truth": "@@ -155,7 +155,9 @@ abstract public class ManagedServices {\n     // List of approved packages or components (by user, then by primary/secondary) that are\n     // allowed to be bound as managed services. A package or component appearing in this list does\n     // not mean that we are currently bound to said package/component.\n-    protected ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved = new ArrayMap<>();\n+    @GuardedBy(\"mApproved\")\n+    protected final ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved =\n+            new ArrayMap<>();\n \n     // List of packages or components (by user) that are configured to be enabled/disabled\n     // explicitly by the user\n@@ -871,6 +873,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -928,6 +947,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1057,8 +1077,7 @@ abstract public class ManagedServices {\n             for (int i = 0; i < userIds.size(); i++) {\n                 final int userId = userIds.get(i);\n                 if (enabled) {\n-                    if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                            || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                    if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                         registerServiceLocked(component, userId);\n                     } else {\n                         Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1197,6 +1216,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1380,28 +1426,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1422,6 +1460,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1523,7 +1570,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1655,6 +1702,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "cleaned_upstream_plus_llm": "@@ -1275,7 +1275,17 @@\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        // If rebinding a package that died, ensure it still has permission\n+                                        // after the rebind delay\n+                                        if (isPackageOrComponentAllowedWithPermission(name, userid)) {\n+                                            registerService(name, userid);\n+                                        } else {\n+                                            Slog.w(TAG, \"Not re-binding \" + name + \" for user \" + userid\n+                                                    + \" as it's no longer allowed or lacks permission.\");\n+                                            synchronized (mMutex) {\n+                                                mServicesRebinding.remove(Pair.create(name, userid));\n+                                            }\n+                                        }\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n```"
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "14",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 403.61,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "12L",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 360.04,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "12",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 187.2,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/ojluni/src/main/java/java/util/zip/ZipFile.java\n+++ b/ojluni/src/main/java/java/util/zip/ZipFile.java\n@@ -244,6 +244,16 @@\n         this.name = name;\n         this.total = getTotal(jzfile);\n         this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-added: do not accept files with invalid header\n+        // A valid ZIP file must start with a LOC header (locsig=true) or be an empty archive.\n+        // An empty archive (often just an EOCD record) would have locsig=false and total=0.\n+        // If locsig is false (does not start with LOCSIG) AND total is not 0 (not an empty zip),\n+        // then it's an invalid header.\n+        if (!this.locsig && this.total != 0) {\n+            throw new ZipException(\"ZIP file must start with LOC header or be an empty archive. \" +\n+                                   \"File: \" + this.name + \" starts with an invalid signature.\");\n+        }\n+        // END Android-added: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -244,6 +244,16 @@\n         this.name = name;\n         this.total = getTotal(jzfile);\n         this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-added: do not accept files with invalid header\n+        // A valid ZIP file must start with a LOC header (locsig=true) or be an empty archive.\n+        // An empty archive (often just an EOCD record) would have locsig=false and total=0.\n+        // If locsig is false (does not start with LOCSIG) AND total is not 0 (not an empty zip),\n+        // then it's an invalid header.\n+        if (!this.locsig && this.total != 0) {\n+            throw new ZipException(\"ZIP file must start with LOC header or be an empty archive. \" +\n+                                   \"File: \" + this.name + \" starts with an invalid signature.\");\n+        }\n+        // END Android-added: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n```"
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "13",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 174.81,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/ojluni/src/main/java/java/util/zip/ZipFile.java\n+++ b/ojluni/src/main/java/java/util/zip/ZipFile.java\n@@ -257,6 +257,14 @@\n         this.name = name;\n         this.total = getTotal(jzfile);\n         this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-changed: do not accept files with invalid header\n+        // Ensure that if a zip file has entries, it must start with LOCSIG.\n+        // A zip file can also be empty and start with ENDSIG (total=0, locsig=false).\n+        // This check addresses cases where a file doesn't start with LOCSIG but claims entries.\n+        if (!this.locsig && this.total > 0) {\n+            throw new ZipException(\"Zip file with entries must start with Local File Header.\");\n+        }\n+        // END Android-changed: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -257,6 +257,14 @@\n         this.name = name;\n         this.total = getTotal(jzfile);\n         this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-changed: do not accept files with invalid header\n+        // Ensure that if a zip file has entries, it must start with LOCSIG.\n+        // A zip file can also be empty and start with ENDSIG (total=0, locsig=false).\n+        // This check addresses cases where a file doesn't start with LOCSIG but claims entries.\n+        if (!this.locsig && this.total > 0) {\n+            throw new ZipException(\"Zip file with entries must start with Local File Header.\");\n+        }\n+        // END Android-changed: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n```"
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "14",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 264.89,
    "ground_truth_diff": "diff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 5c36a6b07392..2194a0863238 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -83,9 +83,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -931,13 +929,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferRequestStore, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -947,13 +947,14 @@\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```",
    "cleaned_ground_truth": "@@ -83,9 +83,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -931,13 +929,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferRequestStore, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": "@@ -947,13 +947,14 @@\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```"
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "12L",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 339.93,
    "ground_truth_diff": "diff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 5445b63a4e20..5e8f4ef18901 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -702,10 +701,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -702,10 +701,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "12",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 346.52,
    "ground_truth_diff": "diff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex eccfe2ecb0b2..f31ba03e3b5f 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -699,10 +698,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -699,10 +698,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "13",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 297.08,
    "ground_truth_diff": "diff --git a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\nindex 5f6211f158c2..1b50f2e535be 100644\n--- a/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ b/services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -72,12 +72,11 @@ import android.os.Environment;\n import android.os.Handler;\n import android.os.Message;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -750,16 +749,13 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            enforceCallerCanManageCompanionDevice(getContext(), \"onShellCommand\");\n-\n-            final CompanionDeviceShellCommand cmd = new CompanionDeviceShellCommand(\n-                    CompanionDeviceManagerService.this,\n-                    mAssociationStore,\n-                    mDevicePresenceMonitor);\n-            cmd.exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -72,12 +72,11 @@ import android.os.Environment;\n import android.os.Handler;\n import android.os.Message;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -750,16 +749,13 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            enforceCallerCanManageCompanionDevice(getContext(), \"onShellCommand\");\n-\n-            final CompanionDeviceShellCommand cmd = new CompanionDeviceShellCommand(\n-                    CompanionDeviceManagerService.this,\n-                    mAssociationStore,\n-                    mDevicePresenceMonitor);\n-            cmd.exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "14",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 114.37,
    "ground_truth_diff": "diff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 77b263824b78..3d012f6eacc0 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -819,7 +819,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2145,8 +2145,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -70,6 +70,7 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n \n```",
    "cleaned_ground_truth": "@@ -819,7 +819,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2145,8 +2145,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": "@@ -70,6 +70,7 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n \n```"
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "13",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 429.35,
    "ground_truth_diff": "diff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 6ea416b54811..06561b2617ee 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -735,7 +735,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1981,8 +1981,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -735,7 +735,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1981,8 +1981,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "12L",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 489.93,
    "ground_truth_diff": "diff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 9f31647e038e..c71b1c13e4c8 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "12",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 417.09,
    "ground_truth_diff": "diff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\nindex 9f31647e038e..c71b1c13e4c8 100644\n--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 66.14,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex d0304b43215e..f26a9f8f3aed 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4742,7 +4742,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n@@ -4783,7 +4785,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !AndroidPackageUtils.isPrivileged(pkg)\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4590,7 +4590,9 @@\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n```",
    "cleaned_ground_truth": "@@ -4742,7 +4742,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n@@ -4783,7 +4785,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !AndroidPackageUtils.isPrivileged(pkg)\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "cleaned_upstream_plus_llm": "@@ -4590,7 +4590,9 @@\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n```"
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 95.36,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/InstallPackageHelper.java b/services/core/java/com/android/server/pm/InstallPackageHelper.java\nindex b541e33bde9e..52750e875c02 100644\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4373,7 +4373,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n@@ -4407,7 +4409,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !pkg.isPrivileged()\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ b/services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -2270,7 +2270,9 @@\n         }\n     }\n \n-    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n-            throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n+            throws PackageManagerException {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n```",
    "cleaned_ground_truth": "@@ -4373,7 +4373,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n@@ -4407,7 +4409,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !pkg.isPrivileged()\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "cleaned_upstream_plus_llm": "@@ -2270,7 +2270,9 @@\n         }\n     }\n \n-    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n-            throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n+            throws PackageManagerException {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n```"
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "14",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 443.81,
    "ground_truth_diff": "diff --git a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\nindex 2b5b8f7a108e..b586b9c27dd8 100644\n--- a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -412,19 +424,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -454,30 +459,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -489,13 +520,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -425,17 +425,11 @@\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n-  }\n-\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n+  }\n+\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n@@ -467,6 +461,7 @@\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n\n```",
    "cleaned_ground_truth": "@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -412,19 +424,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -454,30 +459,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -489,13 +520,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "@@ -425,17 +425,11 @@\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n-  }\n-\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n+  }\n+\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n@@ -467,6 +461,7 @@\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n\n```"
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "13",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 279.88,
    "ground_truth_diff": "diff --git a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\nindex add645dee718..b48fe419cca5 100644\n--- a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -411,19 +423,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -453,30 +458,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -488,13 +519,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -426,19 +426,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n-  }\n-\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n+  }\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -462,6 +455,7 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n```",
    "cleaned_ground_truth": "@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -411,19 +423,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -453,30 +458,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -488,13 +519,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "@@ -426,19 +426,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n-  }\n-\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n+  }\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -462,6 +455,7 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n```"
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "12L",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 394.83,
    "ground_truth_diff": "diff --git a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\nindex 248db76da71d..1ad64d58b7c9 100644\n--- a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -341,6 +341,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -398,18 +410,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkMany failed to get initial credentials, %s\", strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -439,30 +445,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -474,13 +506,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -341,6 +341,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -398,18 +410,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkMany failed to get initial credentials, %s\", strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -439,30 +445,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -474,13 +506,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "12",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 387.21,
    "ground_truth_diff": "diff --git a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\nindex 248db76da71d..1ad64d58b7c9 100644\n--- a/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ b/core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -341,6 +341,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -398,18 +410,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkMany failed to get initial credentials, %s\", strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -439,30 +445,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -474,13 +506,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -341,6 +341,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -398,18 +410,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkMany failed to get initial credentials, %s\", strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -439,30 +445,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -474,13 +506,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "13",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 5.73,
    "ground_truth_diff": "diff --git a/system/stack/btm/btm_sec.cc b/system/stack/btm/btm_sec.cc\nindex 3af24dd59c..944eef2759 100644\n--- a/system/stack/btm/btm_sec.cc\n+++ b/system/stack/btm/btm_sec.cc\n@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/btm/btm_sec.cc\n+++ b/system/stack/btm/btm_sec.cc\n@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }\n \n\n```",
    "cleaned_ground_truth": "@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "cleaned_upstream_plus_llm": "@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }\n \n\n```"
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "14",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 6.6,
    "ground_truth_diff": "diff --git a/system/stack/btm/btm_sec.cc b/system/stack/btm/btm_sec.cc\nindex 3af24dd59c..944eef2759 100644\n--- a/system/stack/btm/btm_sec.cc\n+++ b/system/stack/btm/btm_sec.cc\n@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/btm/btm_sec.cc\n+++ b/system/stack/btm/btm_sec.cc\n@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_rec,\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }\n \n\n```",
    "cleaned_ground_truth": "@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "cleaned_upstream_plus_llm": "@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_rec,\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }\n \n\n```"
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 52.75,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 1bde4e22428f..b891aeeb527d 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2186,16 +2186,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -4400,10 +4410,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1307,22 +1307,32 @@\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n             for (int j=0; j<pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n             for (int j=0; j<ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n                     resOps.add(getOpEntryForResult(curOp, elapsedNow));\n                 }\n             }\n         }\n         return resOps;\n     }\n```",
    "cleaned_ground_truth": "@@ -2186,16 +2186,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -4400,10 +4410,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1307,22 +1307,32 @@\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n             for (int j=0; j<pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n             for (int j=0; j<ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n                     resOps.add(getOpEntryForResult(curOp, elapsedNow));\n                 }\n             }\n         }\n         return resOps;\n     }\n```"
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 193.74,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 33655f748230..e2388e2918ab 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1430,16 +1430,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -3615,10 +3625,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1190,19 +1190,29 @@\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n-        if (ops == null) {\n-            resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n-                Op curOp = pkgOps.valueAt(j);\n-                resOps.add(getOpEntryForResult(curOp));\n-            }\n-        } else {\n-            for (int j=0; j<ops.length; j++) {\n-                Op curOp = pkgOps.get(ops[j]);\n-                if (curOp != null) {\n-                    if (resOps == null) {\n-                        resOps = new ArrayList<>();\n-                    }\n-                    resOps.add(getOpEntryForResult(curOp));\n-                }\n-            }\n-        }\n-        return resOps;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n+        if (ops == null) {\n+            resOps = new ArrayList<>();\n+            for (int j = 0; j < pkgOps.size(); j++) {\n+                Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n+                resOps.add(getOpEntryForResult(curOp));\n+            }\n+        } else {\n+            for (int j = 0; j < ops.length; j++) {\n+                Op curOp = pkgOps.get(ops[j]);\n+                if (curOp != null) {\n+                    if (resOps == null) {\n+                        resOps = new ArrayList<>();\n+                    }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n+                    resOps.add(getOpEntryForResult(curOp));\n+                }\n+            }\n+        }\n+        return resOps;\n```",
    "cleaned_ground_truth": "@@ -1430,16 +1430,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -3615,10 +3625,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1190,19 +1190,29 @@\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n-        if (ops == null) {\n-            resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n-                Op curOp = pkgOps.valueAt(j);\n-                resOps.add(getOpEntryForResult(curOp));\n-            }\n-        } else {\n-            for (int j=0; j<ops.length; j++) {\n-                Op curOp = pkgOps.get(ops[j]);\n-                if (curOp != null) {\n-                    if (resOps == null) {\n-                        resOps = new ArrayList<>();\n-                    }\n-                    resOps.add(getOpEntryForResult(curOp));\n-                }\n-            }\n-        }\n-        return resOps;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n+        if (ops == null) {\n+            resOps = new ArrayList<>();\n+            for (int j = 0; j < pkgOps.size(); j++) {\n+                Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n+                resOps.add(getOpEntryForResult(curOp));\n+            }\n+        } else {\n+            for (int j = 0; j < ops.length; j++) {\n+                Op curOp = pkgOps.get(ops[j]);\n+                if (curOp != null) {\n+                    if (resOps == null) {\n+                        resOps = new ArrayList<>();\n+                    }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n+                    resOps.add(getOpEntryForResult(curOp));\n+                }\n+            }\n+        }\n+        return resOps;\n```"
  },
  {
    "cve_id": "ASB-A-293602317",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 130.82,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex 92abc486386a..3b6bcc052726 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,8 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3603,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4981,8 +4994,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4848,7 +4848,8 @@\n             @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int parentId,\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n-                    throws UserManager.CheckedUserOperationException {\n+                    throws UserManager.CheckedUserOperationException {\n+        final String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n\n```",
    "cleaned_ground_truth": "@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,8 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3603,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4981,8 +4994,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "cleaned_upstream_plus_llm": "@@ -4848,7 +4848,8 @@\n             @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int parentId,\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n-                    throws UserManager.CheckedUserOperationException {\n+                    throws UserManager.CheckedUserOperationException {\n+        final String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n\n```"
  },
  {
    "cve_id": "ASB-A-293602317",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 54.73,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex 92abc486386a..3b6bcc052726 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,8 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3603,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4981,8 +4994,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4845,6 +4845,7 @@\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n```",
    "cleaned_ground_truth": "@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,8 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3603,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4981,8 +4994,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "cleaned_upstream_plus_llm": "@@ -4845,6 +4845,7 @@\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n```"
  },
  {
    "cve_id": "ASB-A-293602317",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 76.28,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex d441b76406c2..4179559d778d 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -247,6 +247,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3156,15 +3158,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3204,6 +3208,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3564,6 +3575,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3589,8 +3601,9 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3683,7 +3696,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4976,8 +4989,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4845,7 +4845,8 @@\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n             return null;\n```",
    "cleaned_ground_truth": "@@ -247,6 +247,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3156,15 +3158,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3204,6 +3208,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3564,6 +3575,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3589,8 +3601,9 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3683,7 +3696,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4976,8 +4989,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "cleaned_upstream_plus_llm": "@@ -4845,7 +4845,8 @@\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n             return null;\n```"
  },
  {
    "cve_id": "ASB-A-230492947",
    "downstream_version": "11",
    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
    "runtime_seconds": 300.09,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 004fa6b1608d..145d2ce832cd 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1223,29 +1223,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -1223,29 +1223,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-230492947",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
    "runtime_seconds": 322.3,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 987cff95bba3..c1006914c6a3 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-230492947",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
    "runtime_seconds": 292.52,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\nindex 987cff95bba3..c1006914c6a3 100644\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java\n@@ -1411,25 +1411,35 @@\n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n```",
    "cleaned_ground_truth": "@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -1411,25 +1411,35 @@\n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n```"
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 127.33,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex 80e1c7e9697b..390a09b99e2e 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -284,8 +284,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 11;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -4261,16 +4259,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -4319,11 +4319,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -4771,8 +4771,7 @@ public class UserManagerService extends IUserManager.Stub {\n             @UserIdInt int parentId, boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6373,9 +6372,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4979,7 +4979,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n```",
    "cleaned_ground_truth": "@@ -284,8 +284,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 11;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -4261,16 +4259,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -4319,11 +4319,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -4771,8 +4771,7 @@ public class UserManagerService extends IUserManager.Stub {\n             @UserIdInt int parentId, boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6373,9 +6372,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4979,7 +4979,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n```"
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 48.66,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex 3b6bcc052726..435ceb2eba42 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -248,8 +248,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3160,16 +3158,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3209,11 +3209,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -3576,8 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -4994,9 +4993,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4980,7 +4980,7 @@\n             @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int parentId,\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n-                    throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+                    throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n```",
    "cleaned_ground_truth": "@@ -248,8 +248,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3160,16 +3158,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3209,11 +3209,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -3576,8 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -4994,9 +4993,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4980,7 +4980,7 @@\n             @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int parentId,\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n-                    throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+                    throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n```"
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 19.17,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java\nindex 3b6bcc052726..435ceb2eba42 100644\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -248,8 +248,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3160,16 +3158,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3209,11 +3209,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -3576,8 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -4994,9 +4993,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/pm/UserManagerService.java\n+++ b/services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4981,7 +4981,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n\n```",
    "cleaned_ground_truth": "@@ -248,8 +248,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3160,16 +3158,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3209,11 +3209,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -3576,8 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -4994,9 +4993,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4981,7 +4981,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n\n```"
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 217.55,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 3b30c8f34087..1bde4e22428f 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -3460,6 +3460,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3974,6 +3978,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4714,6 +4722,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -3460,6 +3460,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3974,6 +3978,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4714,6 +4722,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 44.34,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 759099f89b76..cb7b15e17133 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -3436,6 +3436,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3950,6 +3954,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4644,6 +4652,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+            @Nullable String proxyPackageName,\n+            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2353,6 +2353,36 @@\n         }\n         return false;\n     }\n+\n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n \n     void readState() {\n         int oldVersion = NO_VERSION;\n\n```",
    "cleaned_ground_truth": "@@ -3436,6 +3436,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3950,6 +3954,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4644,6 +4652,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+            @Nullable String proxyPackageName,\n+            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -2353,6 +2353,36 @@\n         }\n         return false;\n     }\n+\n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n \n     void readState() {\n         int oldVersion = NO_VERSION;\n\n```"
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 61.66,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex 759099f89b76..cb7b15e17133 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -3436,6 +3436,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3950,6 +3954,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4644,6 +4652,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+            @Nullable String proxyPackageName,\n+            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2282,6 +2282,36 @@\n                 == PackageManager.PERMISSION_GRANTED;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n         UidState uidState = mUidStates.get(uid);\n         if (uidState == null) {\n\n```",
    "cleaned_ground_truth": "@@ -3436,6 +3436,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3950,6 +3954,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4644,6 +4652,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+            @Nullable String proxyPackageName,\n+            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -2282,6 +2282,36 @@\n                 == PackageManager.PERMISSION_GRANTED;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n         UidState uidState = mUidStates.get(uid);\n         if (uidState == null) {\n\n```"
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 232.13,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex a110169ac8c2..33655f748230 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2640,6 +2640,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3177,6 +3181,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -3909,6 +3917,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -2104,6 +2104,36 @@\n         return callingUid == Process.SYSTEM_UID\n                 || resolveUid(resolvedPackage) != Process.INVALID_UID;\n     }\n+\n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n```",
    "cleaned_ground_truth": "@@ -2640,6 +2640,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3177,6 +3181,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -3909,6 +3917,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -2104,6 +2104,36 @@\n         return callingUid == Process.SYSTEM_UID\n                 || resolveUid(resolvedPackage) != Process.INVALID_UID;\n     }\n+\n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n```"
  },
  {
    "cve_id": "ASB-A-355411348",
    "downstream_version": "13",
    "file_name": "PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-283101289",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-283101289",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281666022",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281666022",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-283264674",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-283264674",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281665050",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281665050",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281534749",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281534749",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281848557",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281848557",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281533566",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-281533566",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "13",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "runtime_seconds": 278.5,
    "ground_truth_diff": "diff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 46e3ba144e..10087c9f16 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -48,6 +51,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -116,6 +120,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -247,6 +256,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -48,6 +51,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -116,6 +120,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -247,6 +256,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "runtime_seconds": 126.24,
    "ground_truth_diff": "diff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 2adb8e5f44..7ce134341a 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,4 +32,8 @@\n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n+import android.bluetooth.BluetoothProfile;\n+import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n import android.content.Context;\n@@ -50,4 +54,5 @@\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n```",
    "cleaned_ground_truth": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "cleaned_upstream_plus_llm": "@@ -32,4 +32,8 @@\n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n+import android.bluetooth.BluetoothProfile;\n+import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n import android.content.Context;\n@@ -50,4 +54,5 @@\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n```"
  },
  {
    "cve_id": "ASB-A-366401629",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
    "runtime_seconds": 75.72,
    "ground_truth_diff": "diff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 73583ea8592..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -17,6 +17,7 @@\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n```",
    "cleaned_ground_truth": "@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "cleaned_upstream_plus_llm": "@@ -17,6 +17,7 @@\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n```"
  },
  {
    "cve_id": "ASB-A-366401629",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
    "runtime_seconds": 4.06,
    "ground_truth_diff": "diff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 73583ea8592..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -15,6 +15,7 @@\n package com.android.settings.accounts;\n \n import android.accounts.Account;\n+import android.content.ContentResolver;\n import android.accounts.AuthenticatorDescription;\n import android.content.Context;\n import android.content.Intent;\n```",
    "cleaned_ground_truth": "@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "cleaned_upstream_plus_llm": "@@ -15,6 +15,7 @@\n package com.android.settings.accounts;\n \n import android.accounts.Account;\n+import android.content.ContentResolver;\n import android.accounts.AuthenticatorDescription;\n import android.content.Context;\n import android.content.Intent;\n```"
  },
  {
    "cve_id": "ASB-A-366401629",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
    "runtime_seconds": 42.69,
    "ground_truth_diff": "diff --git a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\nindex 73583ea8592..7cfeb1cc193 100644\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n+++ b/src/com/android/settings/accounts/AccountTypePreferenceLoader.java\n@@ -17,6 +17,7 @@\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n\n```",
    "cleaned_ground_truth": "@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "cleaned_upstream_plus_llm": "@@ -17,6 +17,7 @@\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n\n```"
  },
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "runtime_seconds": 61.88,
    "ground_truth_diff": "diff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -26,9 +26,12 @@\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n```",
    "cleaned_ground_truth": "@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();",
    "cleaned_upstream_plus_llm": "@@ -26,9 +26,12 @@\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n```"
  },
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "runtime_seconds": 59.25,
    "ground_truth_diff": "diff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -22,10 +22,13 @@\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n```",
    "cleaned_ground_truth": "@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();",
    "cleaned_upstream_plus_llm": "@@ -22,10 +22,13 @@\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n```"
  },
  {
    "cve_id": "ASB-A-317203980",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/media/MediaSessionRecord.java",
    "runtime_seconds": 110.04,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex becb944101f2..7db5bf261fe2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -973,6 +973,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    Log.w(\n+                            TAG,\n+                            \"Ignoring invalid media button receiver targeting an activity: \" + pi);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -67,6 +67,15 @@\n  */\n // TODO(jaewan): Do not call service method directly -- introduce listener instead.\n public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n```",
    "cleaned_ground_truth": "@@ -973,6 +973,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    Log.w(\n+                            TAG,\n+                            \"Ignoring invalid media button receiver targeting an activity: \" + pi);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);",
    "cleaned_upstream_plus_llm": "@@ -67,6 +67,15 @@\n  */\n // TODO(jaewan): Do not call service method directly -- introduce listener instead.\n public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n```"
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 11.86,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,7 +772,12 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n-  uint16_t msg_len =\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n+  uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n@@ -805,6 +810,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```",
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -772,7 +772,12 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n-  uint16_t msg_len =\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n+  uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n@@ -805,6 +810,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```"
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 222.97,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 115.27,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -773,6 +773,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -804,6 +809,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n```",
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -773,6 +773,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -804,6 +809,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n```"
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 11.64,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,7 +772,12 @@\n     }\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -805,6 +810,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n\n```",
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -772,7 +772,12 @@\n     }\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -805,6 +810,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n\n```"
  },
  {
    "cve_id": "ASB-A-277207798",
    "downstream_version": "13",
    "file_name": "core/java/com/android/internal/app/ChooserActivity.java",
    "runtime_seconds": 52.63,
    "ground_truth_diff": "diff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex 919c176b5841..4e4305aa73b1 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -16,6 +16,7 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n \n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -32,7 +33,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -68,6 +71,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -77,6 +81,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -663,7 +668,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4038,4 +4047,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -14,6 +14,7 @@\n\n package com.android.internal.app;\n\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n\n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -29,7 +30,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n\n```",
    "cleaned_ground_truth": "@@ -16,6 +16,7 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n \n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -32,7 +33,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -68,6 +71,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -77,6 +81,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -663,7 +668,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4038,4 +4047,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }",
    "cleaned_upstream_plus_llm": "@@ -14,6 +14,7 @@\n\n package com.android.internal.app;\n\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n\n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -29,7 +30,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n\n```"
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "14",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 177.74,
    "ground_truth_diff": "diff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex 5e5c221aec..74719ef9f5 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -230,9 +230,9 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n-            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n+                    permission.getName(), permission.isGranted());\n+            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n```",
    "cleaned_ground_truth": "@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -230,9 +230,9 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n-            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n+                    permission.getName(), permission.isGranted());\n+            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n```"
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "13",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 207.21,
    "ground_truth_diff": "diff --git a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\nindex a6f74c822c..3bfe7ee691 100644\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -226,11 +226,11 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n-            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n+                    permission.getName(), permission.isGranted());\n+            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n```",
    "cleaned_ground_truth": "@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -226,11 +226,11 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n-            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n+                    permission.getName(), permission.isGranted());\n+            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n```"
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "12",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 116.72,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -270,11 +270,11 @@\n \n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + group.getApp().applicationInfo.uid + \" packageName=\"\n                     + group.getApp().packageName + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -270,11 +270,11 @@\n \n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + group.getApp().applicationInfo.uid + \" packageName=\"\n                     + group.getApp().packageName + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n```"
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "12L",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 169.97,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n+++ b/PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java\n@@ -226,10 +226,10 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + group.getApp().applicationInfo.uid + \" packageName=\"\n                     + group.getApp().packageName + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n  \n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -226,10 +226,10 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + group.getApp().applicationInfo.uid + \" packageName=\"\n                     + group.getApp().packageName + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n  \n```"
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "runtime_seconds": 147.87,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex 027ab97693fd..7b59d6fbd820 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -1527,10 +1527,12 @@\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n-                                callerActivityToken, caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n+                                callerActivityToken, caller.mUid, caller.mPid,\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                             opType, convertStartFailureToThrowable(result, activityIntent));\n```",
    "cleaned_ground_truth": "@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "cleaned_upstream_plus_llm": "@@ -1527,10 +1527,12 @@\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n-                                callerActivityToken, caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n+                                callerActivityToken, caller.mUid, caller.mPid,\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                             opType, convertStartFailureToThrowable(result, activityIntent));\n```"
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "runtime_seconds": 99.02,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/wm/WindowOrganizerController.java b/services/core/java/com/android/server/wm/WindowOrganizerController.java\nindex 4f4d5967365c..65dce1352ba4 100644\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -722,8 +722,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 }\n                 final Intent activityIntent = hop.getActivityIntent();\n                 final Bundle activityOptions = hop.getLaunchOptions();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/wm/WindowOrganizerController.java\n+++ b/services/core/java/com/android/server/wm/WindowOrganizerController.java\n@@ -676,10 +676,12 @@\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                     break;\n                 }\n-                final Intent activityIntent = hop.getActivityIntent();\n-                final Bundle activityOptions = hop.getLaunchOptions();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                final Intent activityIntent = hop.getActivityIntent(); // Original line 677\n+                final Bundle activityOptions = hop.getLaunchOptions(); // Original line 678\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                             convertStartFailureToThrowable(result, activityIntent));\n\n```",
    "cleaned_ground_truth": "@@ -722,8 +722,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 }\n                 final Intent activityIntent = hop.getActivityIntent();\n                 final Bundle activityOptions = hop.getLaunchOptions();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "cleaned_upstream_plus_llm": "@@ -676,10 +676,12 @@\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                     break;\n                 }\n-                final Intent activityIntent = hop.getActivityIntent();\n-                final Bundle activityOptions = hop.getLaunchOptions();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                final Intent activityIntent = hop.getActivityIntent(); // Original line 677\n+                final Bundle activityOptions = hop.getLaunchOptions(); // Original line 678\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                             convertStartFailureToThrowable(result, activityIntent));\n\n```"
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 269.53,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 64.07,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -697,6 +697,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -822,6 +827,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```",
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -697,6 +697,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -822,6 +827,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```"
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 91.53,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -769,6 +769,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```",
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -769,6 +769,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```"
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 335.89,
    "ground_truth_diff": "diff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 74.74,
    "ground_truth_diff": "diff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 28e02ec16e2..b430068a7ef 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -462,10 +462,10 @@\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n             removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n \n             final EnforcedAdmin disallowRemoveUserAdmin =\n```",
    "cleaned_ground_truth": "@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -462,10 +462,10 @@\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n             removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n \n             final EnforcedAdmin disallowRemoveUserAdmin =\n```"
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 70.5,
    "ground_truth_diff": "diff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 5ee95ddc45a..a1806fe4770 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -380,8 +380,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -340,7 +340,7 @@\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n         if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+                && mGuestUserAutoCreated && !mUserManager.isProfile())) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
    "cleaned_ground_truth": "@@ -380,8 +380,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -340,7 +340,7 @@\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n         if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+                && mGuestUserAutoCreated && !mUserManager.isProfile())) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```"
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 96.74,
    "ground_truth_diff": "diff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -316,9 +316,9 @@\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()) && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
    "cleaned_ground_truth": "@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -316,9 +316,9 @@\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()) && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```"
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 51.62,
    "ground_truth_diff": "diff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -466,10 +466,10 @@\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n         if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+                && mGuestUserAutoCreated) && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n             removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n \n             final EnforcedAdmin disallowRemoveUserAdmin =\n\n```",
    "cleaned_ground_truth": "@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -466,10 +466,10 @@\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n         if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+                && mGuestUserAutoCreated) && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n             removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n \n             final EnforcedAdmin disallowRemoveUserAdmin =\n\n```"
  },
  {
    "cve_id": "ASB-A-370840874",
    "downstream_version": "12L",
    "file_name": "libs/binder/Parcel.cpp",
    "runtime_seconds": null,
    "ground_truth_diff": "diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..0670307e48 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }",
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-370840874",
    "downstream_version": "12",
    "file_name": "libs/binder/Parcel.cpp",
    "runtime_seconds": null,
    "ground_truth_diff": "diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp\nindex 617708f3d4..0670307e48 100644\n--- a/libs/binder/Parcel.cpp\n+++ b/libs/binder/Parcel.cpp\n@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }",
    "upstream_plus_llm_generated_patch": "",
    "cleaned_ground_truth": "@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-289375038",
    "downstream_version": "13",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 211.37,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -11,6 +11,7 @@\n\n package com.android.bluetooth.btservice;\n\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -11,6 +11,7 @@\n\n package com.android.bluetooth.btservice;\n\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\n```"
  },
  {
    "cve_id": "ASB-A-289375038",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 96.15,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -14,6 +14,7 @@\n package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n@@ -2319,6 +2320,11 @@\n                 debugLog(\"Stack initiated unbond for \" + device.getAddress() + \" , reason: \"\n                         + unbondReason);\n             }\n+\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n         }\n \n         deviceProp.setBondState(newState);\n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -14,6 +14,7 @@\n package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n@@ -2319,6 +2320,11 @@\n                 debugLog(\"Stack initiated unbond for \" + device.getAddress() + \" , reason: \"\n                         + unbondReason);\n             }\n+\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n         }\n \n         deviceProp.setBondState(newState);\n```"
  },
  {
    "cve_id": "ASB-A-369351375",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 104.02,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5083,14 +5083,15 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5083,14 +5083,15 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```"
  },
  {
    "cve_id": "ASB-A-369351375",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 329.5,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5084,14 +5084,15 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5084,14 +5084,15 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```"
  },
  {
    "cve_id": "ASB-A-360846772",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 345.8,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5088,11 +5088,12 @@\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n             if (!intent.filterEquals(simulateIntent)) {\n```",
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5088,11 +5088,12 @@\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n             if (!intent.filterEquals(simulateIntent)) {\n```"
  },
  {
    "cve_id": "ASB-A-360846772",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 224.07,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5086,14 +5086,16 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5086,14 +5086,16 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```"
  },
  {
    "cve_id": "ASB-A-289811388",
    "downstream_version": "13",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 174.93,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -13,6 +13,7 @@\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\n import static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\n import static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -13,6 +13,7 @@\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\n import static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\n import static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\n```"
  },
  {
    "cve_id": "ASB-A-289811388",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 226.68,
    "ground_truth_diff": null,
    "upstream_plus_llm_generated_patch": "```diff\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -12,5 +12,6 @@ package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n```",
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -12,5 +12,6 @@ package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n```"
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 404.72,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex b891aeeb527d..2e48b24eb25c 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -699,7 +699,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -3336,7 +3336,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             verifyAndGetBypass(uid, packageName, null);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n                 return AppOpsManager.MODE_ALLOWED;\n             }\n@@ -3460,7 +3460,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3979,7 +3979,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4442,7 +4442,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -4580,11 +4584,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n+    }\n+\n+    /**\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n+     */\n+    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -4595,13 +4608,16 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n+     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n+            boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n             return new PackageVerificationResult(null,\n@@ -4645,31 +4661,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n-        }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n-                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n+            nonAppUid = resolveNonAppUid(packageName);\n+        }\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n+                if (!suppressErrorLogs) {\n+                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n+                }\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -5536,7 +5568,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -6720,7 +6752,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -7165,7 +7203,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return -1;\n         }",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -699,7 +699,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -3336,7 +3336,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             verifyAndGetBypass(uid, packageName, null);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n                 return AppOpsManager.MODE_ALLOWED;\n             }\n@@ -3460,7 +3460,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3979,7 +3979,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4442,7 +4442,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -4580,11 +4584,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n+    }\n+\n+    /**\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n+     */\n+    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -4595,13 +4608,16 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n+     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n+            boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n             return new PackageVerificationResult(null,\n@@ -4645,31 +4661,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n-        }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n-                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n+            nonAppUid = resolveNonAppUid(packageName);\n+        }\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n+                if (!suppressErrorLogs) {\n+                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n+                }\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -5536,7 +5568,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -6720,7 +6752,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -7165,7 +7203,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return -1;\n         }",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 141.41,
    "ground_truth_diff": "diff --git a/services/core/java/com/android/server/appop/AppOpsService.java b/services/core/java/com/android/server/appop/AppOpsService.java\nindex e2388e2918ab..fe98aa0be319 100644\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -589,7 +589,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -2503,10 +2503,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -2636,7 +2636,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3178,7 +3178,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3671,13 +3671,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -3760,19 +3764,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -3783,14 +3788,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -3834,34 +3840,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -4613,7 +4632,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -5628,7 +5647,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -6077,7 +6102,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/core/java/com/android/server/appop/AppOpsService.java\n+++ b/services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1727,7 +1727,7 @@\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n\n```",
    "cleaned_ground_truth": "@@ -589,7 +589,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -2503,10 +2503,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -2636,7 +2636,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3178,7 +3178,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3671,13 +3671,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -3760,19 +3764,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -3783,14 +3788,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -3834,34 +3840,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -4613,7 +4632,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -5628,7 +5647,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -6077,7 +6102,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1727,7 +1727,7 @@\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n\n```"
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "12",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 348.53,
    "ground_truth_diff": "diff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "12L",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 389.34,
    "ground_truth_diff": "diff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "13",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 168.83,
    "ground_truth_diff": "diff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "upstream_plus_llm_generated_patch": "```diff\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -17,6 +17,7 @@\n import static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n \n import android.annotation.UserIdInt;\n+import android.annotation.NonNull;\n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n import android.app.AlarmManager;\n@@ -149,6 +150,15 @@\n     // Bump if the stored widgets need to be upgraded.\n     private static final int CURRENT_VERSION = 1;\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Every widget update request is associated which an increasing sequence number. This is\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n@@ -1846,10 +1856,31 @@\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n\n```",
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "@@ -17,6 +17,7 @@\n import static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n \n import android.annotation.UserIdInt;\n+import android.annotation.NonNull;\n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n import android.app.AlarmManager;\n@@ -149,6 +150,15 @@\n     // Bump if the stored widgets need to be upgraded.\n     private static final int CURRENT_VERSION = 1;\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Every widget update request is associated which an increasing sequence number. This is\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n@@ -1846,10 +1856,31 @@\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n\n```"
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "14",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 294.93,
    "ground_truth_diff": "diff --git a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\nindex f5063ac4a023..356613ab3377 100644\n--- a/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n+++ b/services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java\n@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-382064697",
    "downstream_version": "14",
    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
    "runtime_seconds": 564.87,
    "ground_truth_diff": "diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nindex 1549677fdbb2..59ca6151639b 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();",
    "cleaned_upstream_plus_llm": ""
  },
  {
    "cve_id": "ASB-A-382064697",
    "downstream_version": "13",
    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
    "runtime_seconds": 685.78,
    "ground_truth_diff": "diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\nindex d87683073844..38efe0c59571 100644\n--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java\n@@ -8868,7 +8868,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -8891,6 +8892,17 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                             UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        admin.ensureUserRestrictions().putBoolean(\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false);\n+                        saveUserRestrictionsLocked(userHandle);\n+                    }\n                 }\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);",
    "upstream_plus_llm_generated_patch": null,
    "cleaned_ground_truth": "@@ -8868,7 +8868,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -8891,6 +8892,17 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                             UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        admin.ensureUserRestrictions().putBoolean(\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false);\n+                        saveUserRestrictionsLocked(userHandle);\n+                    }\n                 }\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);",
    "cleaned_upstream_plus_llm": ""
  }
]