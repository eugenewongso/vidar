[
  {
    "cve_id": "ASB-A-316891059",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 115.49,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": "@@ -52,11 +52,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n-        FeatureFactory.getFactory(this)\n+        FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,10 +138,10 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n-                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n+                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n }",
    "metrics": {
      "relative_line_count_similarity": 0.6829,
      "normalized_edit_similarity": 0.4497,
      "token_level_edit_distance": 193,
      "codebert_score": {
        "precision": 0.8978,
        "recall": 0.8036,
        "f1": 0.8481,
        "f3": 0.8121
      },
      "token_count_upstream": 166,
      "token_count_downstream": 105,
      "token_count_total": 271,
      "cosine_similarity_openai": 0.8573
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 85.92,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": "@@ -52,11 +52,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n-        FeatureFactory.getFactory(this)\n+        FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,10 +138,10 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n-                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n+                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n }",
    "metrics": {
      "relative_line_count_similarity": 0.6829,
      "normalized_edit_similarity": 0.4497,
      "token_level_edit_distance": 193,
      "codebert_score": {
        "precision": 0.8978,
        "recall": 0.8036,
        "f1": 0.8481,
        "f3": 0.8121
      },
      "token_count_upstream": 166,
      "token_count_downstream": 105,
      "token_count_total": 271,
      "cosine_similarity_openai": 0.8574
    }
  },
  {
    "cve_id": "ASB-A-328068777",
    "downstream_version": "14",
    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
    "runtime_seconds": 184.67,
    "cleaned_ground_truth": "@@ -798,6 +798,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 builder);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -816,6 +820,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        builder.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         builder.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -862,6 +874,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);",
    "cleaned_upstream_plus_llm": "@@ -822,7 +822,7 @@\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                     } catch (IllegalArgumentException illegalArgumentException) {\n-                        logger.setHealthDataServiceApiStatusError(\n+                        builder.setHealthDataServiceApiStatusError(\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                         Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                         tryAndThrowException(\n@@ -856,12 +856,12 @@\n     @Override\n     public void getChangeLogs(\n             @NonNull AttributionSource attributionSource,\n-            @NonNull ChangeLogsRequest token,\n+            @NonNull ChangeLogsRequest request,\n             IChangeLogsResponseCallback callback) {\n         final int uid = Binder.getCallingUid();\n         final UserHandle userHandle = Binder.getCallingUserHandle();\n         final String callerPackageName = Objects.requireNonNull(attributionSource.getPackageName());\n-        final HealthConnectServiceLogger.Builder builder =\n+        final HealthConnectServiceLogger.Builder logger =\n                 new HealthConnectServiceLogger.Builder(false, GET_CHANGES)\n                         .setPackageName(callerPackageName);\n \n@@ -874,27 +874,32 @@\n                         throwExceptionIfDataSyncInProgress();\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n-                                        attributionSource.getPackageName(), token.getToken());\n+                                        callerPackageName, request.getToken());\n+                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n+                        tryAcquireApiCallQuota(\n+                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n-                        boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n+                        long startDateAccessEpochMilli = DEFAULT_LONG;\n                         if (!isInForeground) {\n                             throwSecurityException(\n                                     attributionSource.getPackageName()\n                                             + \" must be in foreground to read the change logs\");\n                         }\n-                        tryAcquireApiCallQuota(\n-                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, builder);\n                         Instant startDateInstant =\n                                 mPermissionHelper.getHealthDataStartDateAccess(\n                                         attributionSource.getPackageName(), userHandle);\n                         if (startDateInstant == null) {\n                             throwExceptionIncorrectPermissionState();\n                         }\n-                        long startDateAccess = startDateInstant.toEpochMilli();\n+                        startDateAccessEpochMilli = startDateInstant.toEpochMilli();\n                         final ChangeLogsHelper.ChangeLogsResponse changeLogsResponse =\n                                 ChangeLogsHelper.getInstance()\n-                                        .getChangeLogs(changeLogsTokenRequest, token);\n+                                        .getChangeLogs(changeLogsTokenRequest, request);\n \n                         Map<Integer, List<UUID>> recordTypeToInsertedUuids =\n                                 ChangeLogsHelper.getRecordTypeToInsertedUuids(\n@@ -909,7 +914,7 @@\n                                         new ReadTransactionRequest(\n                                                 callerPackageName,\n                                                 recordTypeToInsertedUuids,\n-                                                startDateAccess,\n+                                                startDateAccessEpochMilli,\n                                                 extraReadPermsToGrantState));\n \n                         List<DeletedLog> deletedLogs =\n@@ -924,11 +929,11 @@\n                                         changeLogsResponse.hasMorePages()));\n                         finishDataDeliveryRead(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n-                        builder.setHealthDataServiceApiStatusSuccess()\n+                        logger.setHealthDataServiceApiStatusSuccess()\n                                 .setNumberOfRecords(recordInternals.size() + deletedLogs.size())\n                                 .setDataTypesFromRecordInternals(recordInternals);\n                     } catch (IllegalArgumentException illegalArgumentException) {\n-                        builder.setHealthDataServiceApiStatusError(\n+                        logger.setHealthDataServiceApiStatusError(\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                         Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                         tryAndThrowException(\n@@ -936,20 +941,20 @@\n                                 illegalArgumentException,\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (SQLiteException sqLiteException) {\n-                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n+                        logger.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                         Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                         tryAndThrowException(\n                                 callback, sqLiteException, HealthConnectException.ERROR_IO);\n                     } catch (SecurityException securityException) {\n-                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n+                        logger.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                     } catch (IllegalStateException illegalStateException) {\n-                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n+                        logger.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                         Slog.e(TAG, \"IllegalStateException: \", illegalStateException);\n                         tryAndThrowException(callback, illegalStateException, ERROR_INTERNAL);\n                     } catch (HealthConnectException healthConnectException) {\n-                        builder.setHealthDataServiceApiStatusError(\n+                        logger.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n                         Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                         tryAndThrowException(\n@@ -957,11 +962,11 @@\n                                 healthConnectException,\n                                 healthConnectException.getErrorCode());\n                     } catch (Exception exception) {\n-                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n+                        logger.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                         Slog.e(TAG, \"Exception: \", exception);\n                         tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                     } finally {\n-                        builder.build().log();\n+                        logger.build().log();\n                     }\n                 },\n                 uid,",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.2025,
      "token_level_edit_distance": 804,
      "codebert_score": {
        "precision": 0.8265,
        "recall": 0.8934,
        "f1": 0.8586,
        "f3": 0.8862
      },
      "token_count_upstream": 124,
      "token_count_downstream": 346,
      "token_count_total": 470,
      "cosine_similarity_openai": 0.7868
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "14",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 1.5,
    "cleaned_ground_truth": "@@ -83,9 +83,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -931,13 +929,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferRequestStore, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 242,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 112,
      "token_count_downstream": 0,
      "token_count_total": 112,
      "cosine_similarity_openai": 0.0622
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "14",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 7.17,
    "cleaned_ground_truth": "@@ -819,7 +819,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2145,8 +2145,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 164,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 112,
      "token_count_downstream": 0,
      "token_count_total": 112,
      "cosine_similarity_openai": 0.0623
    }
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 64.67,
    "cleaned_ground_truth": "@@ -4742,7 +4742,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n@@ -4783,7 +4785,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !AndroidPackageUtils.isPrivileged(pkg)\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 164,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 84,
      "token_count_downstream": 0,
      "token_count_total": 84,
      "cosine_similarity_openai": 0.0705
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "14",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 1.0,
    "cleaned_ground_truth": "@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -412,19 +424,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -454,30 +459,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -489,13 +520,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 801,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 725,
      "token_count_downstream": 0,
      "token_count_total": 725,
      "cosine_similarity_openai": 0.0864
    }
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "14",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 62.05,
    "cleaned_ground_truth": "@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 56,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 30,
      "token_count_downstream": 0,
      "token_count_total": 30,
      "cosine_similarity_openai": 0.0895
    }
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 600.01,
    "cleaned_ground_truth": "@@ -1430,16 +1430,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -3615,10 +3625,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 476,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 241,
      "token_count_downstream": 0,
      "token_count_total": 241,
      "cosine_similarity_openai": 0.0913
    }
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 526.9,
    "cleaned_ground_truth": "@@ -284,8 +284,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 11;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -4261,16 +4259,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -4319,11 +4319,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -4771,8 +4771,7 @@ public class UserManagerService extends IUserManager.Stub {\n             @UserIdInt int parentId, boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6373,9 +6372,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4773,7 +4773,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6378,1113 +6378,4 @@\n                         UserManager.MAX_ACCOUNT_STRING_LENGTH);\n                 userData.seedAccountType = truncateString(accountType,\n                         UserManager.MAX_ACCOUNT_STRING_LENGTH);\n-                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n-                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n-                    userData.seedAccountOptions = accountOptions;\n-                }\n-                userData.persistSeedData = persist;\n-            }\n-            if (persist) {\n-                writeUserLP(userData);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String getSeedAccountName(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountName;\n-        }\n-    }\n-\n-    @Override\n-    public String getSeedAccountType(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountType;\n-        }\n-    }\n-\n-    @Override\n-    public PersistableBundle getSeedAccountOptions(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountOptions;\n-        }\n-    }\n-\n-    @Override\n-    public void clearSeedAccountData(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot clear seed account information\");\n-        synchronized (mPackagesLock) {\n-            UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = getUserDataLU(userId);\n-                if (userData == null) return;\n-                userData.clearSeedAccountData();\n-            }\n-            writeUserLP(userData);\n-        }\n-    }\n-\n-    @Override\n-    public boolean someUserHasSeedAccount(String accountName, String accountType) {\n-        checkManageUsersPermission(\"check seed account information\");\n-        return someUserHasSeedAccountNoChecks(accountName, accountType);\n-    }\n-\n-    private boolean someUserHasSeedAccountNoChecks(String accountName, String accountType) {\n-        synchronized (mUsersLock) {\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                final UserData data = mUsers.valueAt(i);\n-                if (data.info.isInitialized()) continue;\n-                if (mRemovingUserIds.get(data.info.id)) continue;\n-                if (data.seedAccountName == null || !data.seedAccountName.equals(accountName)) {\n-                    continue;\n-                }\n-                if (data.seedAccountType == null || !data.seedAccountType.equals(accountType)) {\n-                    continue;\n-                }\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean someUserHasAccount(String accountName, String accountType) {\n-        checkCreateUsersPermission(\"check seed account information\");\n-        return someUserHasAccountNoChecks(accountName, accountType);\n-    }\n-\n-    private boolean someUserHasAccountNoChecks(\n-            String accountName, String accountType) {\n-        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n-            return false;\n-        }\n-\n-        final Account account = new Account(accountName, accountType);\n-\n-        return Binder.withCleanCallingIdentity(() ->\n-                AccountManager.get(mContext).someUserHasAccount(account)\n-                        || someUserHasSeedAccountNoChecks(accountName, accountType));\n-    }\n-\n-    private void setLastEnteredForegroundTimeToNow(@NonNull UserData userData) {\n-        userData.mLastEnteredForegroundTimeMillis = System.currentTimeMillis();\n-        scheduleWriteUser(userData.info.id);\n-    }\n-\n-    @Override\n-    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n-            FileDescriptor err, String[] args, ShellCallback callback,\n-            ResultReceiver resultReceiver) {\n-        (new UserManagerServiceShellCommand(this, mSystemPackageInstaller,\n-                mLockPatternUtils, mContext))\n-                .exec(this, in, out, err, args, callback, resultReceiver);\n-    }\n-\n-    @Override\n-    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n-        if (!DumpUtils.checkDumpPermission(mContext, LOG_TAG, pw)) return;\n-\n-        final long now = System.currentTimeMillis();\n-        final long nowRealtime = SystemClock.elapsedRealtime();\n-        final StringBuilder sb = new StringBuilder();\n-\n-        if (args != null && args.length > 0) {\n-            switch (args[0]) {\n-                case \"--user\":\n-                    dumpUser(pw, UserHandle.parseUserArg(args[1]), sb, now, nowRealtime);\n-                    return;\n-                case \"--visibility-mediator\":\n-                    mUserVisibilityMediator.dump(pw, args);\n-                    return;\n-            }\n-        }\n-\n-        final int currentUserId = getCurrentUserId();\n-        pw.print(\"Current user: \");\n-        if (currentUserId != UserHandle.USER_NULL) {\n-            pw.println(currentUserId);\n-        } else {\n-            pw.println(\"N/A\");\n-        }\n-\n-        pw.println();\n-        synchronized (mPackagesLock) {\n-            synchronized (mUsersLock) {\n-                pw.println(\"Users:\");\n-                for (int i = 0; i < mUsers.size(); i++) {\n-                    UserData userData = mUsers.valueAt(i);\n-                    if (userData == null) {\n-                        continue;\n-                    }\n-                    dumpUserLocked(pw, userData, sb, now, nowRealtime);\n-                }\n-            }\n-\n-            pw.println();\n-            pw.println(\"Device properties:\");\n-            pw.println(\"  Device policy global restrictions:\");\n-            synchronized (mRestrictionsLock) {\n-                UserRestrictionsUtils.dumpRestrictions(\n-                        pw, \"    \",\n-                        mDevicePolicyUserRestrictions.getRestrictions(UserHandle.USER_ALL));\n-            }\n-            pw.println(\"  Guest restrictions:\");\n-            synchronized (mGuestRestrictions) {\n-                UserRestrictionsUtils.dumpRestrictions(pw, \"    \", mGuestRestrictions);\n-            }\n-            synchronized (mUsersLock) {\n-                pw.println();\n-                pw.println(\"  Device managed: \" + mIsDeviceManaged);\n-                if (mRemovingUserIds.size() > 0) {\n-                    pw.println();\n-                    pw.println(\"  Recently removed userIds: \" + mRecentlyRemovedIds);\n-                }\n-            }\n-            synchronized (mUserStates) {\n-                pw.print(\"  Started users state: [\");\n-                final int size = mUserStates.states.size();\n-                for (int i = 0; i < size; i++) {\n-                    final int userId = mUserStates.states.keyAt(i);\n-                    final int state = mUserStates.states.valueAt(i);\n-                    pw.print(userId);\n-                    pw.print('=');\n-                    pw.print(UserState.stateToString(state));\n-                    if (i != size - 1) pw.print(\", \");\n-                }\n-                pw.println(']');\n-            }\n-            synchronized (mUsersLock) {\n-                pw.print(\"  Cached user IDs: \");\n-                pw.println(Arrays.toString(mUserIds));\n-                pw.print(\"  Cached user IDs (including pre-created): \");\n-                pw.println(Arrays.toString(mUserIdsIncludingPreCreated));\n-            }\n-        } // synchronized (mPackagesLock)\n-\n-        pw.println();\n-        mUserVisibilityMediator.dump(pw, args);\n-        pw.println();\n-\n-        // Dump some capabilities\n-        pw.println();\n-        pw.print(\"  Max users: \" + UserManager.getMaxSupportedUsers());\n-        pw.println(\" (limit reached: \" + isUserLimitReached() + \")\");\n-        pw.println(\"  Supports switchable users: \" + UserManager.supportsMultipleUsers());\n-        pw.println(\"  All guests ephemeral: \" + Resources.getSystem().getBoolean(\n-                com.android.internal.R.bool.config_guestUserEphemeral));\n-        pw.println(\"  Force ephemeral users: \" + mForceEphemeralUsers);\n-        final boolean isHeadlessSystemUserMode = isHeadlessSystemUserMode();\n-        pw.println(\"  Is headless-system mode: \" + isHeadlessSystemUserMode);\n-        if (isHeadlessSystemUserMode != RoSystemProperties.MULTIUSER_HEADLESS_SYSTEM_USER) {\n-            pw.println(\"  (differs from the current default build value)\");\n-        }\n-        if (!TextUtils.isEmpty(SystemProperties.get(SYSTEM_USER_MODE_EMULATION_PROPERTY))) {\n-            pw.println(\"  (emulated by 'cmd user set-system-user-mode-emulation')\");\n-            if (mUpdatingSystemUserMode) {\n-                pw.println(\"  (and being updated after boot)\");\n-            }\n-        }\n-        pw.println(\"  User version: \" + mUserVersion);\n-        pw.println(\"  Owner name: \" + getOwnerName());\n-        if (DBG_ALLOCATION) {\n-            pw.println(\"  System user allocations: \" + mUser0Allocations.get());\n-        }\n-        synchronized (mUsersLock) {\n-            pw.println(\"  Boot user: \" + mBootUser);\n-        }\n-\n-        pw.println();\n-        pw.println(\"Number of listeners for\");\n-        synchronized (mUserRestrictionsListeners) {\n-            pw.println(\"  restrictions: \" + mUserRestrictionsListeners.size());\n-        }\n-        synchronized (mUserLifecycleListeners) {\n-            pw.println(\"  user lifecycle events: \" + mUserLifecycleListeners.size());\n-        }\n-\n-        // Dump UserTypes\n-        pw.println();\n-        pw.println(\"User types version: \" + mUserTypeVersion);\n-        pw.println(\"User types (\" + mUserTypes.size() + \" types):\");\n-        for (int i = 0; i < mUserTypes.size(); i++) {\n-            pw.println(\"    \" + mUserTypes.keyAt(i) + \": \");\n-            mUserTypes.valueAt(i).dump(pw, \"        \");\n-        }\n-\n-        // TODO: create IndentingPrintWriter at the beginning of dump() and use the proper\n-        // indentation methods instead of explicit printing \"  \"\n-        try (IndentingPrintWriter ipw = new IndentingPrintWriter(pw)) {\n-\n-            // Dump SystemPackageInstaller info\n-            ipw.println();\n-            mSystemPackageInstaller.dump(ipw);\n-\n-            // NOTE: pw's not available after this point as it's auto-closed by ipw, so new dump\n-            // statements should use ipw below\n-        }\n-    }\n-\n-    private void dumpUser(PrintWriter pw, @UserIdInt int userId, StringBuilder sb, long now,\n-            long nowRealtime) {\n-        if (userId == UserHandle.USER_CURRENT) {\n-            final int currentUserId = getCurrentUserId();\n-            pw.print(\"Current user: \");\n-            if (currentUserId == UserHandle.USER_NULL) {\n-                pw.println(\"Cannot determine current user\");\n-                return;\n-            }\n-            userId = currentUserId;\n-        }\n-\n-        synchronized (mUsersLock) {\n-            final UserData userData = mUsers.get(userId);\n-            if (userData == null) {\n-                pw.println(\"User \" + userId + \" not found\");\n-                return;\n-            }\n-            dumpUserLocked(pw, userData, sb, now, nowRealtime);\n-        }\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    private void dumpUserLocked(PrintWriter pw, UserData userData, StringBuilder tempStringBuilder,\n-            long now, long nowRealtime) {\n-        final UserInfo userInfo = userData.info;\n-        final int userId = userInfo.id;\n-        pw.print(\"  \"); pw.print(userInfo);\n-        pw.print(\" serialNo=\"); pw.print(userInfo.serialNumber);\n-        pw.print(\" isPrimary=\"); pw.print(userInfo.isPrimary());\n-        if (userInfo.profileGroupId != userInfo.id\n-                &&  userInfo.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID) {\n-            pw.print(\" parentId=\"); pw.print(userInfo.profileGroupId);\n-        }\n-\n-        if (mRemovingUserIds.get(userId)) {\n-            pw.print(\" <removing> \");\n-        }\n-        if (userInfo.partial) {\n-            pw.print(\" <partial>\");\n-        }\n-        if (userInfo.preCreated) {\n-            pw.print(\" <pre-created>\");\n-        }\n-        if (userInfo.convertedFromPreCreated) {\n-            pw.print(\" <converted>\");\n-        }\n-        pw.println();\n-        pw.print(\"    Type: \"); pw.println(userInfo.userType);\n-        pw.print(\"    Flags: \"); pw.print(userInfo.flags); pw.print(\" (\");\n-        pw.print(UserInfo.flagsToString(userInfo.flags)); pw.println(\")\");\n-        pw.print(\"    State: \");\n-        final int state;\n-        synchronized (mUserStates) {\n-            state = mUserStates.get(userId, -1);\n-        }\n-        pw.println(UserState.stateToString(state));\n-        pw.print(\"    Created: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userInfo.creationTime);\n-\n-        pw.print(\"    Last logged in: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userInfo.lastLoggedInTime);\n-\n-        pw.print(\"    Last logged in fingerprint: \");\n-        pw.println(userInfo.lastLoggedInFingerprint);\n-\n-        pw.print(\"    Start time: \");\n-        dumpTimeAgo(pw, tempStringBuilder, nowRealtime, userData.startRealtime);\n-\n-        pw.print(\"    Unlock time: \");\n-        dumpTimeAgo(pw, tempStringBuilder, nowRealtime, userData.unlockRealtime);\n-\n-        pw.print(\"    Last entered foreground: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userData.mLastEnteredForegroundTimeMillis);\n-\n-        pw.print(\"    Has profile owner: \");\n-        pw.println(mIsUserManaged.get(userId));\n-        pw.println(\"    Restrictions:\");\n-        synchronized (mRestrictionsLock) {\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \", mBaseUserRestrictions.getRestrictions(userInfo.id));\n-            pw.println(\"    Device policy restrictions:\");\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \",\n-                    mDevicePolicyUserRestrictions.getRestrictions(userInfo.id));\n-            pw.println(\"    Effective restrictions:\");\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \",\n-                    mCachedEffectiveUserRestrictions.getRestrictions(userInfo.id));\n-        }\n-\n-        if (userData.account != null) {\n-            pw.print(\"    Account name: \" + userData.account);\n-            pw.println();\n-        }\n-\n-        if (userData.seedAccountName != null) {\n-            pw.print(\"    Seed account name: \" + userData.seedAccountName);\n-            pw.println();\n-            if (userData.seedAccountType != null) {\n-                pw.print(\"         account type: \" + userData.seedAccountType);\n-                pw.println();\n-            }\n-            if (userData.seedAccountOptions != null) {\n-                pw.print(\"         account options exist\");\n-                pw.println();\n-            }\n-        }\n-\n-        if (userData.userProperties != null) {\n-            userData.userProperties.println(pw, \"    \");\n-        }\n-\n-        pw.println(\"    Ignore errors preparing storage: \"\n-                + userData.getIgnorePrepareStorageErrors());\n-    }\n-\n-    private static void dumpTimeAgo(PrintWriter pw, StringBuilder sb, long nowTime, long time) {\n-        if (time == 0) {\n-            pw.println(\"<unknown>\");\n-        } else {\n-            sb.setLength(0);\n-            TimeUtils.formatDuration(nowTime - time, sb);\n-            sb.append(\" ago\");\n-            pw.println(sb);\n-        }\n-    }\n-\n-    final class MainHandler extends Handler {\n-\n-        @Override\n-        public void handleMessage(Message msg) {\n-            switch (msg.what) {\n-                case WRITE_USER_LIST_MSG: {\n-                    removeMessages(WRITE_USER_LIST_MSG);\n-                    synchronized (mPackagesLock) {\n-                        writeUserListLP();\n-                    }\n-                    break;\n-                }\n-                case WRITE_USER_MSG:\n-                    removeMessages(WRITE_USER_MSG, msg.obj);\n-                    synchronized (mPackagesLock) {\n-                        int userId = (int) msg.obj;\n-                        UserData userData = getUserDataNoChecks(userId);\n-                        if (userData != null) {\n-                            writeUserLP(userData);\n-                        } else {\n-                            Slog.i(LOG_TAG, \"handle(WRITE_USER_MSG): no data for user \" + userId\n-                                    + \", it was probably removed before handler could handle it\");\n-                        }\n-                    }\n-                    break;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param userId\n-     * @return whether the user has been initialized yet\n-     */\n-    boolean isUserInitialized(@UserIdInt int userId) {\n-        return mLocalService.isUserInitialized(userId);\n-    }\n-\n-    private class LocalService extends UserManagerInternal {\n-        @Override\n-        public void setDevicePolicyUserRestrictions(@UserIdInt int originatingUserId,\n-                @NonNull Bundle global, @NonNull RestrictionsSet local,\n-                boolean isDeviceOwner) {\n-            UserManagerService.this.setDevicePolicyUserRestrictionsInner(originatingUserId,\n-                    global, local, isDeviceOwner);\n-        }\n-\n-        @Override\n-        public void setUserRestriction(int userId, @NonNull String key, boolean value) {\n-            UserManagerService.this.setUserRestrictionInner(userId, key, value);\n-        }\n-\n-        @Override\n-        public boolean getUserRestriction(@UserIdInt int userId, String key) {\n-            return getUserRestrictions(userId).getBoolean(key);\n-        }\n-\n-        @Override\n-        public void addUserRestrictionsListener(UserRestrictionsListener listener) {\n-            synchronized (mUserRestrictionsListeners) {\n-                mUserRestrictionsListeners.add(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserRestrictionsListener(UserRestrictionsListener listener) {\n-            synchronized (mUserRestrictionsListeners) {\n-                mUserRestrictionsListeners.remove(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void addUserLifecycleListener(UserLifecycleListener listener) {\n-            synchronized (mUserLifecycleListeners) {\n-                mUserLifecycleListeners.add(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserLifecycleListener(UserLifecycleListener listener) {\n-            synchronized (mUserLifecycleListeners) {\n-                mUserLifecycleListeners.remove(listener);\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public void setDeviceManaged(boolean isManaged) {\n-            synchronized (mUsersLock) {\n-                mIsDeviceManaged = isManaged;\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public boolean isDeviceManaged() {\n-            synchronized (mUsersLock) {\n-                return mIsDeviceManaged;\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public void setUserManaged(@UserIdInt int userId, boolean isManaged) {\n-            synchronized (mUsersLock) {\n-                mIsUserManaged.put(userId, isManaged);\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public boolean isUserManaged(@UserIdInt int userId) {\n-            synchronized (mUsersLock) {\n-                return mIsUserManaged.get(userId);\n-            }\n-        }\n-\n-        @Override\n-        public void setUserIcon(@UserIdInt int userId, Bitmap bitmap) {\n-            final long ident = Binder.clearCallingIdentity();\n-            try {\n-                synchronized (mPackagesLock) {\n-                    UserData userData = getUserDataNoChecks(userId);\n-                    if (userData == null || userData.info.partial) {\n-                        Slog.w(LOG_TAG, \"setUserIcon: unknown user #\" + userId);\n-                        return;\n-                    }\n-                    writeBitmapLP(userData.info, bitmap);\n-                    writeUserLP(userData);\n-                }\n-                sendUserInfoChangedBroadcast(userId);\n-            } finally {\n-                Binder.restoreCallingIdentity(ident);\n-            }\n-        }\n-\n-        @Override\n-        public void setForceEphemeralUsers(boolean forceEphemeralUsers) {\n-            synchronized (mUsersLock) {\n-                mForceEphemeralUsers = forceEphemeralUsers;\n-            }\n-        }\n-\n-        @Override\n-        public void removeAllUsers() {\n-            if (UserHandle.USER_SYSTEM == getCurrentUserId()) {\n-                // Remove the non-system users straight away.\n-                removeAllUsersExceptSystemAndPermanentAdminMain();\n-            } else {\n-                // Switch to the system user first and then remove the other users.\n-                BroadcastReceiver userSwitchedReceiver = new BroadcastReceiver() {\n-                    @Override\n-                    public void onReceive(Context context, Intent intent) {\n-                        int userId =\n-                                intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n-                        if (userId != UserHandle.USER_SYSTEM) {\n-                            return;\n-                        }\n-                        mContext.unregisterReceiver(this);\n-                        removeAllUsersExceptSystemAndPermanentAdminMain();\n-                    }\n-                };\n-                IntentFilter userSwitchedFilter = new IntentFilter();\n-                userSwitchedFilter.addAction(Intent.ACTION_USER_SWITCHED);\n-                mContext.registerReceiver(\n-                        userSwitchedReceiver, userSwitchedFilter, null, mHandler);\n-\n-                // Switch to the system user.\n-                ActivityManager am =\n-                        (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);\n-                am.switchUser(UserHandle.USER_SYSTEM);\n-            }\n-        }\n-\n-        @Override\n-        public void onEphemeralUserStop(@UserIdInt int userId) {\n-            synchronized (mUsersLock) {\n-               UserInfo userInfo = getUserInfoLU(userId);\n-               if (userInfo != null && userInfo.isEphemeral()) {\n-                    // Do not allow switching back to the ephemeral user again as the user is going\n-                    // to be deleted.\n-                    userInfo.flags |= UserInfo.FLAG_DISABLED;\n-                    if (userInfo.isGuest()) {\n-                        // Indicate that the guest will be deleted after it stops.\n-                        userInfo.guestToRemove = true;\n-                    }\n-               }\n-            }\n-        }\n-\n-        @Override\n-        public @NonNull UserInfo createUserEvenWhenDisallowed(\n-                @Nullable String name, @NonNull String userType, @UserInfoFlag int flags,\n-                @Nullable String[] disallowedPackages, @Nullable Object token)\n-                throws UserManager.CheckedUserOperationException {\n-\n-            return createUserInternalUnchecked(name, userType, flags,\n-                    UserHandle.USER_NULL, /* preCreated= */ false, disallowedPackages, token);\n-        }\n-\n-        @Override\n-        public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId) {\n-            return removeUserWithProfilesUnchecked(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserRunning(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state =  mUserStates.get(userId, UserState.STATE_NONE);\n-            }\n-\n-            return state != UserState.STATE_NONE\n-                    && state != UserState.STATE_STOPPING\n-                    && state != UserState.STATE_SHUTDOWN;\n-        }\n-\n-        @Override\n-        public void setUserState(@UserIdInt int userId, int userState) {\n-            synchronized (mUserStates) {\n-                mUserStates.put(userId, userState);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserState(@UserIdInt int userId) {\n-            synchronized (mUserStates) {\n-                mUserStates.delete(userId);\n-            }\n-        }\n-\n-        @Override\n-        public int[] getUserIds() {\n-            return UserManagerService.this.getUserIds();\n-        }\n-\n-        @Override\n-        public @NonNull List<UserInfo> getUsers(boolean excludeDying) {\n-            return getUsers(/*excludePartial= */ true, excludeDying, /* excludePreCreated= */ true);\n-        }\n-\n-        @Override\n-        public @NonNull List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying,\n-                boolean excludePreCreated) {\n-            return UserManagerService.this.getUsersInternal(excludePartial, excludeDying,\n-                    excludePreCreated);\n-        }\n-\n-        @Override\n-        public @NonNull int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly) {\n-            synchronized (mUsersLock) {\n-                return getProfileIdsLU(userId, null /* userType */, enabledOnly).toArray();\n-            }\n-        }\n-\n-        @Override\n-        public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state = mUserStates.get(userId, -1);\n-            }\n-            // Special case, in the stopping/shutdown state user key can still be unlocked\n-            if (state == UserState.STATE_STOPPING || state == UserState.STATE_SHUTDOWN) {\n-                return StorageManager.isUserKeyUnlocked(userId);\n-            }\n-            return (state == UserState.STATE_RUNNING_UNLOCKING)\n-                    || (state == UserState.STATE_RUNNING_UNLOCKED);\n-        }\n-\n-        /**\n-         * The return values of this method are cached in clients.  If the\n-         * logic in this function changes then the cache invalidation code\n-         * may need to be revisited.\n-         */\n-        @Override\n-        public boolean isUserUnlocked(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state = mUserStates.get(userId, -1);\n-            }\n-            // Special case, in the stopping/shutdown state user key can still be unlocked\n-            if (state == UserState.STATE_STOPPING || state == UserState.STATE_SHUTDOWN) {\n-                return StorageManager.isUserKeyUnlocked(userId);\n-            }\n-            return state == UserState.STATE_RUNNING_UNLOCKED;\n-        }\n-\n-        @Override\n-        public boolean isUserInitialized(@UserIdInt int userId) {\n-            return (getUserInfo(userId).flags & UserInfo.FLAG_INITIALIZED) != 0;\n-        }\n-\n-        @Override\n-        public boolean exists(@UserIdInt int userId) {\n-            return getUserInfoNoChecks(userId) != null;\n-        }\n-\n-        @Override\n-        public boolean isProfileAccessible(int callingUserId, int targetUserId, String debugMsg,\n-                boolean throwSecurityException) {\n-            if (targetUserId == callingUserId) {\n-                return true;\n-            }\n-            synchronized (mUsersLock) {\n-                UserInfo callingUserInfo = getUserInfoLU(callingUserId);\n-                if (callingUserInfo == null || callingUserInfo.isProfile()) {\n-                    if (throwSecurityException) {\n-                        throw new SecurityException(\n-                                debugMsg + \" for another profile \"\n-                                        + targetUserId + \" from \" + callingUserId);\n-                    }\n-                    Slog.w(LOG_TAG, debugMsg + \" for another profile \"\n-                            + targetUserId + \" from \" + callingUserId);\n-                    return false;\n-                }\n-\n-                UserInfo targetUserInfo = getUserInfoLU(targetUserId);\n-                if (targetUserInfo == null || !targetUserInfo.isEnabled()) {\n-                    // Do not throw any exception here as this could happen due to race conditions\n-                    // between the system updating its state and the client getting notified.\n-                    if (throwSecurityException) {\n-                        Slog.w(LOG_TAG, debugMsg + \" for disabled profile \"\n-                                + targetUserId + \" from \" + callingUserId);\n-                    }\n-                    return false;\n-                }\n-\n-                if (targetUserInfo.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID ||\n-                        targetUserInfo.profileGroupId != callingUserInfo.profileGroupId) {\n-                    if (throwSecurityException) {\n-                        throw new SecurityException(\n-                                debugMsg + \" for unrelated profile \" + targetUserId);\n-                    }\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public int getProfileParentId(@UserIdInt int userId) {\n-            return getProfileParentIdUnchecked(userId);\n-        }\n-\n-        @Override\n-        public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId,\n-                String value, int callingUid) {\n-            return UserManagerService.this.isSettingRestrictedForUser(setting, userId,\n-                    value, callingUid);\n-        }\n-\n-        @Override\n-        public boolean hasUserRestriction(String restrictionKey, @UserIdInt int userId) {\n-            if (!UserRestrictionsUtils.isValidRestriction(restrictionKey)) {\n-                return false;\n-            }\n-            Bundle restrictions = getEffectiveUserRestrictions(userId);\n-            return restrictions != null && restrictions.getBoolean(restrictionKey);\n-        }\n-\n-        @Override\n-        public @Nullable UserInfo getUserInfo(@UserIdInt int userId) {\n-            UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = mUsers.get(userId);\n-            }\n-            return userData == null ? null : userData.info;\n-        }\n-\n-        @Override\n-        public @NonNull UserInfo[] getUserInfos() {\n-            synchronized (mUsersLock) {\n-                int userSize = mUsers.size();\n-                UserInfo[] allInfos = new UserInfo[userSize];\n-                for (int i = 0; i < userSize; i++) {\n-                    allInfos[i] = mUsers.valueAt(i).info;\n-                }\n-                return allInfos;\n-            }\n-        }\n-\n-        @Override\n-        public void setDefaultCrossProfileIntentFilters(\n-                @UserIdInt int parentUserId, @UserIdInt int profileUserId) {\n-            final UserTypeDetails userTypeDetails = getUserTypeDetailsNoChecks(profileUserId);\n-            final Bundle restrictions = getEffectiveUserRestrictions(profileUserId);\n-            UserManagerService.this.setDefaultCrossProfileIntentFilters(\n-                    profileUserId, userTypeDetails, restrictions, parentUserId);\n-        }\n-\n-        @Override\n-        public boolean shouldIgnorePrepareStorageErrors(int userId) {\n-            synchronized (mUsersLock) {\n-                UserData userData = mUsers.get(userId);\n-                return userData != null && userData.getIgnorePrepareStorageErrors();\n-            }\n-        }\n-\n-        @Override\n-        public @Nullable UserProperties getUserProperties(@UserIdInt int userId) {\n-            final UserProperties props = getUserPropertiesInternal(userId);\n-            if (props == null) {\n-                Slog.w(LOG_TAG, \"A null UserProperties was returned for user \" + userId);\n-            }\n-            return props;\n-        }\n-\n-        @Override\n-        @UserAssignmentResult\n-        public int assignUserToDisplayOnStart(@UserIdInt int userId,\n-                @UserIdInt int profileGroupId, @UserStartMode int userStartMode, int displayId) {\n-            return mUserVisibilityMediator.assignUserToDisplayOnStart(userId, profileGroupId,\n-                    userStartMode, displayId);\n-        }\n-\n-        @Override\n-        public boolean assignUserToExtraDisplay(int userId, int displayId) {\n-            return mUserVisibilityMediator.assignUserToExtraDisplay(userId, displayId);\n-        }\n-\n-        @Override\n-        public boolean unassignUserFromExtraDisplay(int userId, int displayId) {\n-            return mUserVisibilityMediator.unassignUserFromExtraDisplay(userId, displayId);\n-        }\n-\n-        @Override\n-        public void unassignUserFromDisplayOnStop(@UserIdInt int userId) {\n-            mUserVisibilityMediator.unassignUserFromDisplayOnStop(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserVisible(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.isUserVisible(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserVisible(@UserIdInt int userId, int displayId) {\n-            return mUserVisibilityMediator.isUserVisible(userId, displayId);\n-        }\n-\n-        @Override\n-        public int getMainDisplayAssignedToUser(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.getMainDisplayAssignedToUser(userId);\n-        }\n-\n-        @Override\n-        public @Nullable int[] getDisplaysAssignedToUser(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.getDisplaysAssignedToUser(userId);\n-        }\n-\n-        @Override\n-        public @UserIdInt int getUserAssignedToDisplay(int displayId) {\n-            return mUserVisibilityMediator.getUserAssignedToDisplay(displayId);\n-        }\n-\n-        @Override\n-        public void addUserVisibilityListener(UserVisibilityListener listener) {\n-            mUserVisibilityMediator.addListener(listener);\n-        }\n-\n-        @Override\n-        public void removeUserVisibilityListener(UserVisibilityListener listener) {\n-            mUserVisibilityMediator.removeListener(listener);\n-        }\n-\n-        @Override\n-        public void onSystemUserVisibilityChanged(boolean visible) {\n-            mUserVisibilityMediator.onSystemUserVisibilityChanged(visible);\n-        }\n-\n-        @Override\n-        public int[] getUserTypesForStatsd(@UserIdInt int[] userIds) {\n-            if (userIds == null) {\n-                return null;\n-            }\n-            final int[] userTypes = new int[userIds.length];\n-            for (int i = 0; i < userTypes.length; i++) {\n-                final UserInfo userInfo = getUserInfo(userIds[i]);\n-                if (userInfo == null) {\n-                    // Not possible because the input user ids should all be valid\n-                    userTypes[i] = mUserJourneyLogger.getUserTypeForStatsd(\"\");\n-                } else {\n-                    userTypes[i] = mUserJourneyLogger.getUserTypeForStatsd(userInfo.userType);\n-                }\n-            }\n-            return userTypes;\n-        }\n-\n-        @Override\n-        public @UserIdInt int getMainUserId() {\n-            return getMainUserIdUnchecked();\n-        }\n-\n-        @Override\n-        public @UserIdInt int getBootUser(boolean waitUntilSet)\n-                throws UserManager.CheckedUserOperationException {\n-            if (waitUntilSet) {\n-                final TimingsTraceAndSlog t = new TimingsTraceAndSlog();\n-                t.traceBegin(\"wait-boot-user\");\n-                try {\n-                    if (mBootUserLatch.getCount() != 0) {\n-                        Slogf.d(LOG_TAG,\n-                                \"Sleeping for boot user to be set. \"\n-                                + \"Max sleep for Time: %d\", BOOT_USER_SET_TIMEOUT_MS);\n-                    }\n-                    if (!mBootUserLatch.await(BOOT_USER_SET_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                        Slogf.w(LOG_TAG, \"Boot user not set. Timeout: %d\",\n-                                BOOT_USER_SET_TIMEOUT_MS);\n-                    }\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    Slogf.w(LOG_TAG, e, \"InterruptedException during wait for boot user.\");\n-                }\n-                t.traceEnd();\n-            }\n-\n-            return getBootUserUnchecked();\n-        }\n-\n-    } // class LocalService\n-\n-\n-\n-    /**\n-     * Check if user has restrictions\n-     * @param restriction restrictions to check\n-     * @param userId id of the user\n-     *\n-     * @throws {@link android.os.UserManager.CheckedUserOperationException} if user has any of the\n-     *      specified restrictions\n-     */\n-    private void enforceUserRestriction(String restriction, @UserIdInt int userId, String message)\n-            throws UserManager.CheckedUserOperationException {\n-        if (hasUserRestriction(restriction, userId)) {\n-            String errorMessage = (message != null ? (message + \": \") : \"\")\n-                    + restriction + \" is enabled.\";\n-            Slog.w(LOG_TAG, errorMessage);\n-            throw new UserManager.CheckedUserOperationException(errorMessage,\n-                    USER_OPERATION_ERROR_UNKNOWN);\n-        }\n-    }\n-\n-    /**\n-     * Throws CheckedUserOperationException and shows error log\n-     * @param message message for exception and logging\n-     * @param userOperationResult result/error code\n-     * @throws UserManager.CheckedUserOperationException\n-     */\n-    private void throwCheckedUserOperationException(@NonNull String message,\n-            @UserManager.UserOperationResult int userOperationResult)\n-            throws UserManager.CheckedUserOperationException {\n-        Slog.e(LOG_TAG, message);\n-        throw new UserManager.CheckedUserOperationException(message, userOperationResult);\n-    }\n-\n-    /* Remove all the users except the system and permanent admin main.*/\n-    private void removeAllUsersExceptSystemAndPermanentAdminMain() {\n-        ArrayList<UserInfo> usersToRemove = new ArrayList<>();\n-        synchronized (mUsersLock) {\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                UserInfo ui = mUsers.valueAt(i).info;\n-                if (ui.id != UserHandle.USER_SYSTEM && !isNonRemovableMainUser(ui)) {\n-                    usersToRemove.add(ui);\n-                }\n-            }\n-        }\n-        for (UserInfo ui: usersToRemove) {\n-            removeUser(ui.id);\n-        }\n-    }\n-\n-    private static void debug(String message) {\n-        Slog.d(LOG_TAG, message\n-                + (DBG_WITH_STACKTRACE ? \" called at\\n\" + Debug.getCallers(10, \"  \") : \"\"));\n-    }\n-\n-    /** @see #getMaxUsersOfTypePerParent(UserTypeDetails) */\n-    @VisibleForTesting\n-    int getMaxUsersOfTypePerParent(String userType) {\n-        final UserTypeDetails type = mUserTypes.get(userType);\n-        if (type == null) {\n-            return 0;\n-        }\n-        return getMaxUsersOfTypePerParent(type);\n-    }\n-\n-    /**\n-     * Returns the maximum number of users allowed for the given userTypeDetails per parent user.\n-     * This is applicable for user types that are {@link UserTypeDetails#isProfile()}.\n-     * If there is no maximum, {@link UserTypeDetails#UNLIMITED_NUMBER_OF_USERS} is returned.\n-     * Under certain circumstances (such as after a change-user-type) the max value can actually\n-     * be exceeded: this is allowed in order to keep the device in a usable state.\n-     * An error is logged in {@link UserManagerService#upgradeProfileToTypeLU}\n-     */\n-    private static int getMaxUsersOfTypePerParent(UserTypeDetails userTypeDetails) {\n-        final int defaultMax = userTypeDetails.getMaxAllowedPerParent();\n-        if (!Build.IS_DEBUGGABLE) {\n-            return defaultMax;\n-        } else {\n-            if (userTypeDetails.isManagedProfile()) {\n-                return SystemProperties.getInt(\"persist.sys.max_profiles\", defaultMax);\n-            }\n-        }\n-        return defaultMax;\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    @VisibleForTesting\n-    int getFreeProfileBadgeLU(int parentUserId, String userType) {\n-        Set<Integer> usedBadges = new ArraySet<>();\n-        final int userSize = mUsers.size();\n-        for (int i = 0; i < userSize; i++) {\n-            UserInfo ui = mUsers.valueAt(i).info;\n-            // Check which badge indexes are already used by this profile group.\n-            if (ui.userType.equals(userType)\n-                    && ui.profileGroupId == parentUserId\n-                    && !mRemovingUserIds.get(ui.id)) {\n-                usedBadges.add(ui.profileBadge);\n-            }\n-        }\n-        int maxUsersOfType = getMaxUsersOfTypePerParent(userType);\n-        if (maxUsersOfType == UserTypeDetails.UNLIMITED_NUMBER_OF_USERS) {\n-            maxUsersOfType = Integer.MAX_VALUE;\n-        }\n-        for (int i = 0; i < maxUsersOfType; i++) {\n-            if (!usedBadges.contains(i)) {\n-                return i;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Checks if the given user has a profile associated with it.\n-     * @param userId The parent user\n-     * @return\n-     */\n-    boolean hasProfile(@UserIdInt int userId) {\n-        synchronized (mUsersLock) {\n-            UserInfo userInfo = getUserInfoLU(userId);\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                UserInfo profile = mUsers.valueAt(i).info;\n-                if (userId != profile.id && isProfileOf(userInfo, profile)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Checks if the calling package name matches with the calling UID, throw\n-     * {@link SecurityException} if not.\n-     */\n-    private void verifyCallingPackage(String callingPackage, int callingUid) {\n-        int packageUid = mPm.snapshotComputer()\n-                .getPackageUid(callingPackage, 0,  UserHandle.getUserId(callingUid));\n-        if (packageUid != callingUid) {\n-            throw new SecurityException(\"Specified package \" + callingPackage\n-                    + \" does not match the calling uid \" + callingUid);\n-        }\n-    }\n-\n-    /** Retrieves the internal package manager interface. */\n-    private PackageManagerInternal getPackageManagerInternal() {\n-        // Don't need to synchonize; worst-case scenario LocalServices will be called twice.\n-        if (mPmInternal == null) {\n-            mPmInternal = LocalServices.getService(PackageManagerInternal.class);\n-        }\n-        return mPmInternal;\n-    }\n-\n-    /** Returns the internal device policy manager interface. */\n-    private DevicePolicyManagerInternal getDevicePolicyManagerInternal() {\n-        if (mDevicePolicyManagerInternal == null) {\n-            mDevicePolicyManagerInternal =\n-                    LocalServices.getService(DevicePolicyManagerInternal.class);\n-        }\n-        return mDevicePolicyManagerInternal;\n-    }\n-\n-    /** Returns the internal activity manager interface. */\n-    private @Nullable ActivityManagerInternal getActivityManagerInternal() {\n-        if (mAmInternal == null) {\n-            mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n-        }\n-        return mAmInternal;\n-    }\n-\n-    /**\n-     * Returns true, when user has {@link UserInfo#FLAG_MAIN} and system property\n-     * {@link com.android.internal.R.bool#config_isMainUserPermanentAdmin} is true.\n-     */\n-    private boolean isNonRemovableMainUser(UserInfo userInfo) {\n-        return userInfo.isMain() && isMainUserPermanentAdmin();\n-    }\n-\n-    /**\n-     * Returns true if {@link com.android.internal.R.bool#config_isMainUserPermanentAdmin} is true.\n-     * If the main user is a permanent admin user it can't be deleted\n-     * or downgraded to non-admin status.\n-     */\n-    public boolean isMainUserPermanentAdmin() {\n-        return Resources.getSystem()\n-                .getBoolean(R.bool.config_isMainUserPermanentAdmin);\n-    }\n-\n-    /**\n-     * Returns true if {@link com.android.internal.R.bool#config_canSwitchToHeadlessSystemUser}\n-     * is true. If allowed, headless system user can run in the foreground even though\n-     * it is not a full user.\n-     */\n-    public boolean canSwitchToHeadlessSystemUser() {\n-        return Resources.getSystem()\n-                .getBoolean(R.bool.config_canSwitchToHeadlessSystemUser);\n-    }\n-\n-    /**\n-     * Returns instance of {@link com.android.server.pm.UserJourneyLogger}.\n-     */\n-    public UserJourneyLogger getUserJourneyLogger() {\n-        return mUserJourneyLogger;\n-    }\n-\n-}\n-```+                if (accountOptions != null && accountOptions",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0444,
      "token_level_edit_distance": 6966,
      "codebert_score": {
        "precision": 0.7626,
        "recall": 0.8504,
        "f1": 0.8041,
        "f3": 0.8407
      },
      "token_count_upstream": 290,
      "token_count_downstream": 4534,
      "token_count_total": 4824,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 534.61,
    "cleaned_ground_truth": "@@ -2640,6 +2640,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3177,6 +3181,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -3909,6 +3917,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -4070,6 +4070,45 @@\n     }\n \n     /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n+    private void logVerifyAndGetBypassFailure(int uid, @NonNull SecurityException e,\n+            @NonNull String methodName) {\n+        if (Process.isIsolated(uid)) {\n+            Slog.e(TAG, \"Cannot \" + methodName + \": isolated process\");\n+        } else {\n+            Slog.e(TAG, \"Cannot \" + methodName, e);\n+        }\n+    }\n+\n+    /**\n      * Read recent accesses from persistence (mRecentAccessesFile).\n      * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n      * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n@@ -6456,167 +6495,4 @@\n                 @Nullable String packageName, @Nullable String featureId,\n                 boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                 boolean shouldCollectMessage) {\n-            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    AppOpsService.this::noteOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateProxyOperationImpl(code,\n-                        attributionSource, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation);\n-            }\n-            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n-                    message, shouldCollectMessage,skipProxyOperation);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n-                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation) {\n-            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    AppOpsService.this::noteProxyOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n-                @Nullable String packageName, @NonNull String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                @AttributionFlags int attributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startOperation(token, code, uid, packageName,\n-                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            this::startDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            AppOpsService.this::startOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, attributionFlags, attributionChainId);\n-            }\n-            return startOperationImpl(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n-                @Nullable String packageName, @Nullable String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n-                int attributionChainId) {\n-            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            this::startDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            AppOpsService.this::startProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n-            }\n-            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n-                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n-        }\n-\n-        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n-                String attributionTag) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            this::finishDelegateOperationImpl);\n-                } else {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            AppOpsService.this::finishOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            } else {\n-                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            }\n-        }\n-\n-        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n-                String packageName, String attributionTag) {\n-            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                    AppOpsService.this::finishOperationImpl);\n-        }\n-\n-        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n-                } else {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        skipProxyOperation);\n-            } else {\n-                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n-            }\n-        }\n-\n-        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n-                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-            return null;\n-        }\n-    }\n-}\n-```+            return mCheckOpsDelegate.note",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0948,
      "token_level_edit_distance": 1343,
      "codebert_score": {
        "precision": 0.7727,
        "recall": 0.8595,
        "f1": 0.8138,
        "f3": 0.8499
      },
      "token_count_upstream": 274,
      "token_count_downstream": 984,
      "token_count_total": 1258,
      "cosine_similarity_openai": 0.7646
    }
  }
]