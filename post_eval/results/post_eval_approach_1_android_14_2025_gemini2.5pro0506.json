[
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "runtime_seconds": 90.79,
    "cleaned_ground_truth": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "cleaned_upstream_plus_llm": "@@ -33,6 +33,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -40,7 +42,6 @@\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n-import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -51,11 +52,13 @@\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n  * used for outbound share.\n  */\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n \n@@ -116,16 +119,6 @@\n             if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                 EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                 Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n-                return SEND_FILE_INFO_ERROR;\n-            }\n-\n-            if (isContentUriForOtherUser(uri)) {\n-                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n-                ContentProfileErrorReportUtils.report(\n-                        BluetoothProfile.OPP,\n-                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n-                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n-                        15);\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n@@ -265,12 +258,6 @@\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n-    private static boolean isContentUriForOtherUser(Uri uri) {\n-        String uriUserId = uri.getUserInfo();\n-        return !TextUtils.isEmpty(uriUserId)\n-                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n-    }\n-\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "metrics": {
      "relative_line_count_similarity": 0.7727,
      "normalized_edit_similarity": 0.6466,
      "token_level_edit_distance": 138,
      "codebert_score": {
        "precision": 0.8627,
        "recall": 0.9145,
        "f1": 0.8878,
        "f3": 0.9091
      },
      "token_count_upstream": 161,
      "token_count_downstream": 193,
      "token_count_total": 354,
      "cosine_similarity_openai": 0.9622
    }
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 134.69,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -538,7 +538,7 @@\n \n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n   for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n     if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n@@ -733,13 +733,16 @@\n     }\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  uint16_t msg_len =\n-      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n+  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n+  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n-  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n-                                          e_hdl, p_data, value);\n+  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n   if (reason != GATT_SUCCESS) {\n     osi_free(p_msg);\n     gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n@@ -769,9 +772,14 @@\n     return;\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-  uint16_t buf_len =\n-      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n+  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n+  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n   reason = GATT_NOT_FOUND;\n@@ -901,12 +909,7 @@\n     return;\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n+  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -1053,12 +1056,7 @@\n                                    tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                    uint16_t handle, uint16_t len,\n                                    uint8_t* p_data) {\n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n+  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "metrics": {
      "relative_line_count_similarity": 0.3171,
      "normalized_edit_similarity": 0.4502,
      "token_level_edit_distance": 323,
      "codebert_score": {
        "precision": 0.8846,
        "recall": 0.9042,
        "f1": 0.8943,
        "f3": 0.9022
      },
      "token_count_upstream": 204,
      "token_count_downstream": 319,
      "token_count_total": 523,
      "cosine_similarity_openai": 0.8234
    }
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 136.91,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,11 +913,6 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n \n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -1054,11 +1060,6 @@\n                                    uint16_t handle, uint16_t len,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n \n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "metrics": {
      "relative_line_count_similarity": 0.9756,
      "normalized_edit_similarity": 0.7644,
      "token_level_edit_distance": 72,
      "codebert_score": {
        "precision": 0.9358,
        "recall": 0.9049,
        "f1": 0.9201,
        "f3": 0.9079
      },
      "token_count_upstream": 204,
      "token_count_downstream": 178,
      "token_count_total": 382,
      "cosine_similarity_openai": 0.8384
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "14",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 37.32,
    "cleaned_ground_truth": "@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -258,11 +258,11 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n ",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.9398,
      "token_level_edit_distance": 8,
      "codebert_score": {
        "precision": 0.9732,
        "recall": 0.9456,
        "f1": 0.9592,
        "f3": 0.9483
      },
      "token_count_upstream": 60,
      "token_count_downstream": 54,
      "token_count_total": 114,
      "cosine_similarity_openai": 0.963
    }
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "runtime_seconds": 264.72,
    "cleaned_ground_truth": "@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "cleaned_upstream_plus_llm": "@@ -100,6 +100,7 @@\n import android.window.TaskFragmentOperation;\n import android.window.WindowContainerToken;\n import android.window.WindowContainerTransaction;\n+import android.app.SafeActivityOptions;\n \n import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.protolog.ProtoLogGroup;\n@@ -1190,10 +1191,12 @@\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                             opType, convertStartFailureToThrowable(result, activityIntent));",
    "metrics": {
      "relative_line_count_similarity": 0.0833,
      "normalized_edit_similarity": 0.4306,
      "token_level_edit_distance": 122,
      "codebert_score": {
        "precision": 0.8197,
        "recall": 0.8856,
        "f1": 0.8514,
        "f3": 0.8785
      },
      "token_count_upstream": 52,
      "token_count_downstream": 82,
      "token_count_total": 134,
      "cosine_similarity_openai": 0.8962
    }
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 199.79,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,11 +913,6 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n \n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -1054,11 +1060,6 @@\n                                    uint16_t handle, uint16_t len,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n \n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "metrics": {
      "relative_line_count_similarity": 0.9756,
      "normalized_edit_similarity": 0.7644,
      "token_level_edit_distance": 72,
      "codebert_score": {
        "precision": 0.9358,
        "recall": 0.9049,
        "f1": 0.9201,
        "f3": 0.9079
      },
      "token_count_upstream": 204,
      "token_count_downstream": 178,
      "token_count_total": 382,
      "cosine_similarity_openai": 0.8382
    }
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 203.05,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -735,6 +735,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +775,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,11 +913,6 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n \n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -1054,11 +1060,6 @@\n                                    uint16_t handle, uint16_t len,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-\n-  // This can happen if the channel is already closed.\n-  if (payload_size == 0) {\n-    return;\n-  }\n \n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "metrics": {
      "relative_line_count_similarity": 0.9756,
      "normalized_edit_similarity": 0.7644,
      "token_level_edit_distance": 72,
      "codebert_score": {
        "precision": 0.9358,
        "recall": 0.9049,
        "f1": 0.9201,
        "f3": 0.9079
      },
      "token_count_upstream": 204,
      "token_count_downstream": 178,
      "token_count_total": 382,
      "cosine_similarity_openai": 0.8384
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 128.59,
    "cleaned_ground_truth": "@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -465,7 +465,8 @@\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.8534,
      "token_level_edit_distance": 17,
      "codebert_score": {
        "precision": 0.9524,
        "recall": 0.9511,
        "f1": 0.9518,
        "f3": 0.9512
      },
      "token_count_upstream": 52,
      "token_count_downstream": 49,
      "token_count_total": 101,
      "cosine_similarity_openai": 0.8888
    }
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 223.71,
    "cleaned_ground_truth": "@@ -589,7 +589,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -2503,10 +2503,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -2636,7 +2636,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3178,7 +3178,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3671,13 +3671,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -3760,19 +3764,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -3783,14 +3788,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -3834,34 +3840,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -4613,7 +4632,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -5628,7 +5647,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -6077,7 +6102,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 1610,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 1059,
      "token_count_downstream": 0,
      "token_count_total": 1059,
      "cosine_similarity_openai": 0.0727
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "14",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 17.52,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 670,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 457,
      "token_count_downstream": 0,
      "token_count_total": 457,
      "cosine_similarity_openai": 0.0459
    }
  },
  {
    "cve_id": "ASB-A-382064697",
    "downstream_version": "14",
    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
    "runtime_seconds": 599.66,
    "cleaned_ground_truth": "@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 778,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 449,
      "token_count_downstream": 0,
      "token_count_total": 449,
      "cosine_similarity_openai": 0.0798
    }
  }
]