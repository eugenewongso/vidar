[
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "runtime_seconds": 93.64,
    "cleaned_ground_truth": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (c) 2008-2009, Motorola, Inc.\n  *\n@@ -33,6 +32,10 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n+import android.bluetooth.BluetoothProfile;\n+import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -51,6 +54,7 @@\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -281,5 +285,4 @@\n         }\n         return length;\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.6136,
      "normalized_edit_similarity": 0.2991,
      "token_level_edit_distance": 201,
      "codebert_score": {
        "precision": 0.8592,
        "recall": 0.7485,
        "f1": 0.8,
        "f3": 0.7583
      },
      "token_count_upstream": 161,
      "token_count_downstream": 70,
      "token_count_total": 231,
      "cosine_similarity_openai": 0.768
    }
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 79.2,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```cc\n /******************************************************************************\n  *\n  *  Copyright 2008-2012 Broadcom Corporation\n@@ -735,6 +734,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+ \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,9 +773,14 @@\n     return;\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n+  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n   reason = GATT_NOT_FOUND;\n@@ -1435,5 +1444,4 @@\n         break;\n     }\n   }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.8537,
      "normalized_edit_similarity": 0.435,
      "token_level_edit_distance": 198,
      "codebert_score": {
        "precision": 0.8898,
        "recall": 0.8832,
        "f1": 0.8865,
        "f3": 0.8839
      },
      "token_count_upstream": 204,
      "token_count_downstream": 119,
      "token_count_total": 323,
      "cosine_similarity_openai": 0.7749
    }
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 73.21,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```cc\n /******************************************************************************\n  *\n  *  Copyright 2008-2012 Broadcom Corporation\n@@ -735,6 +734,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +774,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -1435,5 +1444,4 @@\n         break;\n     }\n   }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.7561,
      "normalized_edit_similarity": 0.3988,
      "token_level_edit_distance": 48,
      "codebert_score": {
        "precision": 0.8969,
        "recall": 0.8826,
        "f1": 0.8897,
        "f3": 0.884
      },
      "token_count_upstream": 204,
      "token_count_downstream": 104,
      "token_count_total": 308,
      "cosine_similarity_openai": 0.7676
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "14",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 75.22,
    "cleaned_ground_truth": "@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2017 The Android Open Source Project\n  *\n@@ -258,11 +257,11 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n@@ -495,5 +494,4 @@\n             }\n         }\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.1538,
      "normalized_edit_similarity": 0.741,
      "token_level_edit_distance": 46,
      "codebert_score": {
        "precision": 0.9054,
        "recall": 0.9364,
        "f1": 0.9207,
        "f3": 0.9332
      },
      "token_count_upstream": 60,
      "token_count_downstream": 79,
      "token_count_total": 139,
      "cosine_similarity_openai": 0.885
    }
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "runtime_seconds": 128.7,
    "cleaned_ground_truth": "@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2020 The Android Open Source Project\n  *\n@@ -1190,10 +1189,12 @@\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                             opType, convertStartFailureToThrowable(result, activityIntent));\n@@ -2024,5 +2025,4 @@\n                         + result + \" when starting \" + intent);\n         }\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.4541,
      "token_level_edit_distance": 109,
      "codebert_score": {
        "precision": 0.8435,
        "recall": 0.9004,
        "f1": 0.871,
        "f3": 0.8944
      },
      "token_count_upstream": 52,
      "token_count_downstream": 99,
      "token_count_total": 151,
      "cosine_similarity_openai": 0.8475
    }
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 266.33,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```cc\n /******************************************************************************\n  *\n  *  Copyright 2008-2012 Broadcom Corporation\n@@ -735,6 +734,11 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -770,6 +774,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -1435,5 +1444,4 @@\n         break;\n     }\n   }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.7561,
      "normalized_edit_similarity": 0.3988,
      "token_level_edit_distance": 48,
      "codebert_score": {
        "precision": 0.8969,
        "recall": 0.8826,
        "f1": 0.8897,
        "f3": 0.884
      },
      "token_count_upstream": 204,
      "token_count_downstream": 104,
      "token_count_total": 308,
      "cosine_similarity_openai": 0.7662
    }
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 7.86,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```cc\n /******************************************************************************\n  *\n  *  Copyright 2008-2012 Broadcom Corporation\n@@ -735,7 +734,13 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n-  uint16_t msg_len =\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    LOG(ERROR) << __func__ << \": Channel closed, cid=\" << cid;\n+    return;\n+  }\n+\n+  size_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n@@ -770,7 +775,13 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n-  uint16_t buf_len =\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    LOG(ERROR) << __func__ << \": Channel closed, cid=\" << cid;\n+    return;\n+  }\n+  size_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -1435,5 +1446,4 @@\n         break;\n     }\n   }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.9024,
      "normalized_edit_similarity": 0.3323,
      "token_level_edit_distance": 114,
      "codebert_score": {
        "precision": 0.872,
        "recall": 0.8806,
        "f1": 0.8762,
        "f3": 0.8797
      },
      "token_count_upstream": 204,
      "token_count_downstream": 147,
      "token_count_total": 351,
      "cosine_similarity_openai": 0.7671
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 20.9,
    "cleaned_ground_truth": "@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -465,7 +464,7 @@\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n@@ -1755,5 +1754,4 @@\n                     return niks;\n                 }\n             };\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.6846,
      "token_level_edit_distance": 45,
      "codebert_score": {
        "precision": 0.8827,
        "recall": 0.9318,
        "f1": 0.9066,
        "f3": 0.9267
      },
      "token_count_upstream": 52,
      "token_count_downstream": 72,
      "token_count_total": 124,
      "cosine_similarity_openai": 0.8034
    }
  },
  {
    "cve_id": "ASB-A-289375038",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -5561,5 +5560,4 @@\n     public boolean isMock() {\n         return false;\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 46,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 29,
      "token_count_total": 29,
      "cosine_similarity_openai": 0.1417
    }
  },
  {
    "cve_id": "ASB-A-289811388",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 204.46,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -18,6 +17,7 @@\n package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n@@ -2978,6 +2978,13 @@\n             } catch (RuntimeException e) {\n                 receiver.propagateException(e);\n             }\n+\n+        // If the device is unbonded, clear all related permissions\n+        if (bondState == BluetoothDevice.BOND_NONE) {\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n         }\n         private int getSimAccessPermission(\n                 BluetoothDevice device, AttributionSource attributionSource) {\n@@ -5561,5 +5568,4 @@\n     public boolean isMock() {\n         return false;\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 198,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 96,
      "token_count_total": 96,
      "cosine_similarity_openai": 0.135
    }
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "@@ -589,7 +589,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -2503,10 +2503,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -2636,7 +2636,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3178,7 +3178,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3671,13 +3671,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -3760,19 +3764,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -3783,14 +3788,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -3834,34 +3840,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -4613,7 +4632,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -5628,7 +5647,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -6077,7 +6102,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2012 The Android Open Source Project\n  *\n@@ -6694,5 +6693,4 @@\n             return null;\n         }\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.0591,
      "normalized_edit_similarity": 0.0149,
      "token_level_edit_distance": 1422,
      "codebert_score": {
        "precision": 0.7285,
        "recall": 0.5281,
        "f1": 0.6123,
        "f3": 0.543
      },
      "token_count_upstream": 1059,
      "token_count_downstream": 26,
      "token_count_total": 1085,
      "cosine_similarity_openai": 0.3849
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "14",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2011 The Android Open Source Project\n  *\n@@ -4957,5 +4956,4 @@\n             }\n         }\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.1392,
      "normalized_edit_similarity": 0.0269,
      "token_level_edit_distance": 439,
      "codebert_score": {
        "precision": 0.7008,
        "recall": 0.5283,
        "f1": 0.6025,
        "f3": 0.5417
      },
      "token_count_upstream": 457,
      "token_count_downstream": 25,
      "token_count_total": 482,
      "cosine_similarity_openai": 0.31
    }
  },
  {
    "cve_id": "ASB-A-382064697",
    "downstream_version": "14",
    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();",
    "cleaned_upstream_plus_llm": "@@ -1,4 +1,3 @@\n-```java\n /*\n  * Copyright (C) 2010 The Android Open Source Project\n  *\n@@ -24778,5 +24777,4 @@\n         return getRoleHolderPackageNameOnUser(\n                 RoleManager.ROLE_FINANCED_DEVICE_KIOSK, UserHandle.USER_ALL);\n     }\n-}\n-```+}",
    "metrics": {
      "relative_line_count_similarity": 0.0982,
      "normalized_edit_similarity": 0.0321,
      "token_level_edit_distance": 46,
      "codebert_score": {
        "precision": 0.7096,
        "recall": 0.5728,
        "f1": 0.6339,
        "f3": 0.5841
      },
      "token_count_upstream": 449,
      "token_count_downstream": 27,
      "token_count_total": 476,
      "cosine_similarity_openai": 0.5376
    }
  }
]