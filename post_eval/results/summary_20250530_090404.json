[
  {
    "cve_id": "ASB-A-299441833",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-299441833",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-242996380",
    "downstream_version": "14",
    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-242996380",
    "downstream_version": "13",
    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-316891059",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 385.02,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 358,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 166,
      "token_count_downstream": 0,
      "token_count_total": 166,
      "cosine_similarity_openai": 0.0992
    }
  },
  {
    "cve_id": "ASB-A-317048495",
    "downstream_version": "13",
    "file_name": "packages/SystemUI/src/com/android/systemui/clipboardoverlay/ClipboardListener.java",
    "runtime_seconds": 398.28,
    "cleaned_ground_truth": "@@ -25,6 +25,7 @@ import static com.android.systemui.clipboardoverlay.ClipboardOverlayEvent.CLIPBO\n \n import static com.google.android.setupcompat.util.WizardManagerHelper.SETTINGS_SECURE_USER_SETUP_COMPLETE;\n \n+import android.app.KeyguardManager;\n import android.content.ClipData;\n import android.content.ClipboardManager;\n import android.content.Context;\n@@ -59,18 +60,21 @@ public class ClipboardListener extends CoreStartable\n     private final ClipboardOverlayControllerFactory mOverlayFactory;\n     private final ClipboardToast mClipboardToast;\n     private final ClipboardManager mClipboardManager;\n+    private final KeyguardManager mKeyguardManager;\n     private final UiEventLogger mUiEventLogger;\n     private ClipboardOverlayController mClipboardOverlayController;\n \n     @Inject\n     public ClipboardListener(Context context, DeviceConfigProxy deviceConfigProxy,\n             ClipboardOverlayControllerFactory overlayFactory, ClipboardManager clipboardManager,\n-            ClipboardToast clipboardToast,UiEventLogger uiEventLogger) {\n+            ClipboardToast clipboardToast, KeyguardManager keyguardManager,\n+            UiEventLogger uiEventLogger) {\n         super(context);\n         mDeviceConfig = deviceConfigProxy;\n         mOverlayFactory = overlayFactory;\n         mClipboardToast = clipboardToast;\n         mClipboardManager = clipboardManager;\n+        mKeyguardManager = keyguardManager;\n         mUiEventLogger = uiEventLogger;\n     }\n \n@@ -96,8 +100,11 @@ public class ClipboardListener extends CoreStartable\n             return;\n         }\n \n-        if (!isUserSetupComplete()) {\n-            // just show a toast, user should not access intents from this state\n+        // user should not access intents before setup or while device is locked\n+        if (mKeyguardManager.isDeviceLocked()\n+                || !isUserSetupComplete()\n+                || clipData == null // shouldn't happen, but just in case\n+                || clipData.getItemCount() == 0) {\n             if (shouldShowToast(clipData)) {\n                 mUiEventLogger.log(CLIPBOARD_TOAST_SHOWN, 0, clipSource);\n                 mClipboardToast.showCopiedToast();",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 294,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 170,
      "token_count_downstream": 0,
      "token_count_total": 170,
      "cosine_similarity_openai": 0.0921
    }
  },
  {
    "cve_id": "ASB-A-299931761",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/wifi/WifiDialogActivity.java",
    "runtime_seconds": 351.75,
    "cleaned_ground_truth": "@@ -17,6 +17,8 @@\n package com.android.settings.wifi;\n \n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n \n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -31,6 +33,7 @@ import android.os.Looper;\n import android.os.Process;\n import android.os.SimpleClock;\n import android.os.SystemClock;\n+import android.os.UserManager;\n import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n@@ -115,6 +118,10 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n \n         super.onCreate(savedInstanceState);\n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n \n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n \n@@ -361,6 +368,29 @@ public class WifiDialogActivity extends ObservableActivity implements WifiDialog\n         }\n     }\n \n+    @VisibleForTesting\n+    boolean isConfigWifiAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager == null) return true;\n+        final boolean isConfigWifiAllowed = !userManager.hasUserRestriction(DISALLOW_CONFIG_WIFI);\n+        if (!isConfigWifiAllowed) {\n+            Log.e(TAG, \"The user is not allowed to configure Wi-Fi.\");\n+            EventLog.writeEvent(0x534e4554, \"226133034\", getApplicationContext().getUserId(),\n+                    \"The user is not allowed to configure Wi-Fi.\");\n+        }\n+        return isConfigWifiAllowed;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isAddWifiConfigAllowed() {\n+        UserManager userManager = getSystemService(UserManager.class);\n+        if (userManager != null && userManager.hasUserRestriction(DISALLOW_ADD_WIFI_CONFIG)) {\n+            Log.e(TAG, \"The user is not allowed to add Wi-Fi configuration.\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean hasWifiManager() {\n         if (mWifiManager != null) return true;\n         mWifiManager = getSystemService(WifiManager.class);",
    "cleaned_upstream_plus_llm": "@@ -18,4 +18,6 @@\n import static android.Manifest.permission.ACCESS_FINE_LOCATION;\n \n+import static android.os.UserManager.DISALLOW_ADD_WIFI_CONFIG;\n+import static android.os.UserManager.DISALLOW_CONFIG_WIFI;\n import android.content.DialogInterface;\n import android.content.Intent;\n@@ -100,3 +102,7 @@\n         super.onCreate(savedInstanceState);\n \n+        if (!isConfigWifiAllowed() || !isAddWifiConfigAllowed()) {\n+            finish();\n+            return;\n+        }\n         mIsWifiTrackerLib = !TextUtils.isEmpty(mIntent.getStringExtra(KEY_CHOSEN_WIFIENTRY_KEY));\n```",
    "metrics": {
      "relative_line_count_similarity": 0.2692,
      "normalized_edit_similarity": 0.2672,
      "token_level_edit_distance": 284,
      "codebert_score": {
        "precision": 0.9288,
        "recall": 0.7664,
        "f1": 0.8398,
        "f3": 0.78
      },
      "token_count_upstream": 193,
      "token_count_downstream": 38,
      "token_count_total": 231,
      "cosine_similarity_openai": 0.8337
    }
  },
  {
    "cve_id": "ASB-A-283099444",
    "downstream_version": "11",
    "file_name": "media/codec2/sfplugin/utils/Codec2BufferUtils.cpp",
    "runtime_seconds": null,
    "cleaned_ground_truth": "@@ -361,8 +361,8 @@ status_t ConvertRGBToPlanarYUV(\n     const uint8_t *pBlue  = src.data()[C2PlanarLayout::PLANE_B];\n \n #define CLIP3(x,y,z) (((z) < (x)) ? (x) : (((z) > (y)) ? (y) : (z)))\n-    for (size_t y = 0; y < src.height(); ++y) {\n-        for (size_t x = 0; x < src.width(); ++x) {\n+    for (size_t y = 0; y < src.crop().height; ++y) {\n+        for (size_t x = 0; x < src.crop().width; ++x) {\n             uint8_t red = *pRed;\n             uint8_t green = *pGreen;\n             uint8_t blue = *pBlue;",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 168,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 82,
      "token_count_downstream": 0,
      "token_count_total": 82,
      "cosine_similarity_openai": 0.0886
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 343.93,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.net.Uri;\n import android.os.Bundle;\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -105,7 +104,7 @@ public class SearchResultTrampoline extends Activity {\n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)\n                 || ActivityEmbeddingUtils.isAlreadyEmbedded(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             if (FeatureFlagUtils.isEnabled(this, FeatureFlags.SETTINGS_SEARCH_ALWAYS_EXPAND)) {\n                 startActivity(SettingsActivity.getTrampolineIntent(intent, highlightMenuKey)\n                         .setClass(this, DeepLinkHomepageActivityInternal.class)\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 358,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 166,
      "token_count_downstream": 0,
      "token_count_total": 166,
      "cosine_similarity_openai": 0.0992
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 345.76,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 341,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 172,
      "token_count_downstream": 0,
      "token_count_total": 172,
      "cosine_similarity_openai": 0.0976
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 526.89,
    "cleaned_ground_truth": "@@ -20,7 +20,6 @@ import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_ARGUMENT\n import static com.android.settings.SettingsActivity.EXTRA_SHOW_FRAGMENT_TAB;\n \n import android.app.Activity;\n-import android.content.ComponentName;\n import android.content.Intent;\n import android.os.Bundle;\n import android.provider.Settings;\n@@ -48,11 +47,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -96,7 +95,7 @@ public class SearchResultTrampoline extends Activity {\n \n         if (!ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this)) {\n             startActivity(intent);\n-        } else if (isSettingsIntelligence(callingActivity)) {\n+        } else if (isSettingsIntelligence(callerPackage)) {\n             // Register SplitPairRule for SubSettings, set clearTop false to prevent unexpected back\n             // navigation behavior.\n             ActivityEmbeddingRulesController.registerSubSettingsPairRule(this,\n@@ -122,9 +121,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 341,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 172,
      "token_count_downstream": 0,
      "token_count_total": 172,
      "cosine_similarity_openai": 0.0975
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 566.62,
    "cleaned_ground_truth": "@@ -39,7 +39,7 @@ public class SearchResultTrampoline extends Activity {\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, getCallingActivity());\n+                .verifyLaunchSearchResultPageCaller(this, getLaunchedFromPackage());\n         // Didn't crash, proceed and launch the result as a subsetting.\n         final Intent intent = getIntent();",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 82,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 47,
      "token_count_downstream": 0,
      "token_count_total": 47,
      "cosine_similarity_openai": 0.0889
    }
  },
  {
    "cve_id": "ASB-A-327749022",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/homepage/SettingsHomepageActivity.java",
    "runtime_seconds": 90.38,
    "cleaned_ground_truth": "@@ -154,6 +154,17 @@ public class SettingsHomepageActivity extends FragmentActivity implements\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n         mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this);\n         mIsTwoPaneLastTime = ActivityEmbeddingUtils.isTwoPaneResolution(this);",
    "cleaned_upstream_plus_llm": "@@ -129,6 +129,16 @@\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n         setContentView(R.layout.settings_homepage_container);\n         mIsEmbeddingActivityEnabled = ActivityEmbeddingUtils.isEmbeddingActivityEnabled(this);\n         mIsTwoPaneLastTime = ActivityEmbeddingUtils.isTwoPaneResolution(this);\n\n```",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.9329,
      "token_level_edit_distance": 4,
      "codebert_score": {
        "precision": 0.9825,
        "recall": 0.9615,
        "f1": 0.9718,
        "f3": 0.9635
      },
      "token_count_upstream": 79,
      "token_count_downstream": 73,
      "token_count_total": 152,
      "cosine_similarity_openai": 0.9091
    }
  },
  {
    "cve_id": "ASB-A-327749022",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/homepage/SettingsHomepageActivity.java",
    "runtime_seconds": 104.54,
    "cleaned_ground_truth": "@@ -74,6 +74,17 @@ public class SettingsHomepageActivity extends FragmentActivity implements\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n \n         final View appBar = findViewById(R.id.app_bar_container);",
    "cleaned_upstream_plus_llm": "@@ -54,6 +54,16 @@\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n+        // Ensure device is provisioned in order to access Settings home\n+        // TODO(b/331254029): This should later be replaced in favor of an allowlist\n+        boolean unprovisioned = android.provider.Settings.Global.getInt(getContentResolver(),\n+                android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0;\n+        if (unprovisioned) {\n+            Log.e(TAG, \"Device is not provisioned, exiting Settings\");\n+            finish();\n+            return;\n+        }\n+\n         setContentView(R.layout.settings_homepage_container);\n \n         final View appBar = findViewById(R.id.app_bar_container);\n```",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.9306,
      "token_level_edit_distance": 4,
      "codebert_score": {
        "precision": 0.9806,
        "recall": 0.9558,
        "f1": 0.968,
        "f3": 0.9582
      },
      "token_count_upstream": 78,
      "token_count_downstream": 72,
      "token_count_total": 150,
      "cosine_similarity_openai": 0.9277
    }
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "14",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 150.17,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -17,7 +17,8 @@\n import com.android.systemui.dagger.SysUISingleton;\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n-import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.MediaHost;\n import com.android.systemui.media.controls.ui.MediaHostStatesManager;\n@@ -37,6 +37,7 @@\n     String QUICK_QS_PANEL = \"media_quick_qs_panel\";\n     String KEYGUARD = \"media_keyguard\";\n     String DREAM = \"dream\";\n+    String COMMUNAL_HUB = \"media_communal_hub\";\n \n     /** */\n     @Provides\n@@ -81,3 +82,14 @@\n     }\n \n+    /** */\n+    @Provides\n+    @SysUISingleton\n+    @Named(COMMUNAL_HUB)\n+    static MediaHost providesCommunalMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n+            MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n+            MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n+        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,\n+                carouselController);\n+    }\n+\n     /** Provides a logging buffer related to the media tap-to-transfer chip on the sender device. */\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 255,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 105,
      "token_count_total": 105,
      "cosine_similarity_openai": 0.1147
    }
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "13",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 517.87,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "12L",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 176.88,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -19,6 +19,7 @@\n import com.android.systemui.media.MediaHierarchyManager;\n import com.android.systemui.media.MediaHost;\n import com.android.systemui.media.MediaHostStatesManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n \n import javax.inject.Named;\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 66,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 15,
      "token_count_total": 15,
      "cosine_similarity_openai": 0.1103
    }
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "12",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 120.41,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -19,6 +19,7 @@ import com.android.systemui.media.MediaDataManager;\n import com.android.systemui.media.MediaHierarchyManager;\n import com.android.systemui.media.MediaHost;\n import com.android.systemui.media.MediaHostStatesManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n \n import javax.inject.Named;\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 77,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 17,
      "token_count_total": 17,
      "cosine_similarity_openai": 0.1079
    }
  },
  {
    "cve_id": "ASB-A-283103220",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/wm/ActivityClientController.java",
    "runtime_seconds": 253.72,
    "cleaned_ground_truth": "@@ -73,6 +73,7 @@ import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n@@ -80,6 +81,9 @@ import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.pm.parsing.pkg.AndroidPackage;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -95,6 +99,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -691,6 +702,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -705,6 +717,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -738,6 +751,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -762,6 +788,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {",
    "cleaned_upstream_plus_llm": "@@ -1063,7 +1063,20 @@\n         if (!r.supportsPictureInPicture()) {\n             throw new IllegalStateException(caller\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n+\n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n \n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n```",
    "metrics": {
      "relative_line_count_similarity": 0.2561,
      "normalized_edit_similarity": 0.1928,
      "token_level_edit_distance": 34,
      "codebert_score": {
        "precision": 0.9156,
        "recall": 0.753,
        "f1": 0.8264,
        "f3": 0.7666
      },
      "token_count_upstream": 372,
      "token_count_downstream": 87,
      "token_count_total": 459,
      "cosine_similarity_openai": 0.7995
    }
  },
  {
    "cve_id": "ASB-A-283103220",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/wm/ActivityClientController.java",
    "runtime_seconds": 85.24,
    "cleaned_ground_truth": "@@ -64,17 +64,22 @@ import android.os.PersistableBundle;\n import android.os.RemoteException;\n import android.os.SystemClock;\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n import android.window.SizeConfigurationBuckets;\n \n+import com.android.internal.annotations.VisibleForTesting;\n import com.android.internal.app.AssistUtils;\n import com.android.internal.policy.IKeyguardDismissCallback;\n import com.android.internal.protolog.common.ProtoLog;\n import com.android.server.LocalServices;\n import com.android.server.Watchdog;\n import com.android.server.uri.NeededUriGrants;\n+import com.android.server.utils.quota.Categorizer;\n+import com.android.server.utils.quota.Category;\n+import com.android.server.utils.quota.CountQuotaTracker;\n import com.android.server.vr.VrManagerInternal;\n \n /**\n@@ -90,6 +95,13 @@ class ActivityClientController extends IActivityClientController.Stub {\n     private final ActivityTaskSupervisor mTaskSupervisor;\n     private final Context mContext;\n \n+    // Prevent malicious app abusing the Activity#setPictureInPictureParams API\n+    @VisibleForTesting CountQuotaTracker mSetPipAspectRatioQuotaTracker;\n+    // Limit to 60 times / minute\n+    private static final int SET_PIP_ASPECT_RATIO_LIMIT = 60;\n+    // The timeWindowMs here can not be smaller than QuotaTracker#MIN_WINDOW_SIZE_MS\n+    private static final long SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS = 60_000;\n+\n     /** Wrapper around VoiceInteractionServiceManager. */\n     private AssistUtils mAssistUtils;\n \n@@ -661,6 +673,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"enterPictureInPictureMode\", token, params);\n@@ -675,6 +688,7 @@ class ActivityClientController extends IActivityClientController.Stub {\n     public void setPictureInPictureParams(IBinder token, final PictureInPictureParams params) {\n         final long origId = Binder.clearCallingIdentity();\n         try {\n+            ensureSetPipAspectRatioQuotaTracker();\n             synchronized (mGlobalLock) {\n                 final ActivityRecord r = ensureValidPictureInPictureActivityParams(\n                         \"setPictureInPictureParams\", token, params);\n@@ -708,6 +722,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n         Binder.restoreCallingIdentity(origId);\n     }\n \n+    /**\n+     * Initialize the {@link #mSetPipAspectRatioQuotaTracker} if applicable, which should happen\n+     * out of {@link #mGlobalLock} to avoid deadlock (AM lock is used in QuotaTrack ctor).\n+     */\n+    private void ensureSetPipAspectRatioQuotaTracker() {\n+        if (mSetPipAspectRatioQuotaTracker == null) {\n+            mSetPipAspectRatioQuotaTracker = new CountQuotaTracker(mContext,\n+                    Categorizer.SINGLE_CATEGORIZER);\n+            mSetPipAspectRatioQuotaTracker.setCountLimit(Category.SINGLE_CATEGORY,\n+                    SET_PIP_ASPECT_RATIO_LIMIT, SET_PIP_ASPECT_RATIO_TIME_WINDOW_MS);\n+        }\n+    }\n+\n     /**\n      * Checks the state of the system and the activity associated with the given {@param token} to\n      * verify that picture-in-picture is supported for that activity.\n@@ -732,6 +759,19 @@ class ActivityClientController extends IActivityClientController.Stub {\n                     + \": Current activity does not support picture-in-picture.\");\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatioRational().equals(\n+                params.getAspectRatioRational())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n                 r.mDisplayContent, params.getAspectRatio())) {",
    "cleaned_upstream_plus_llm": "@@ -51,4 +51,5 @@\n import android.os.Trace;\n+import android.os.UserHandle;\n import android.service.voice.VoiceInteractionManagerInternal;\n import android.util.Slog;\n import android.view.RemoteAnimationDefinition;\n@@ -688,4 +689,17 @@\n         }\n \n+        // Rate limit how frequent an app can request aspect ratio change via\n+        // Activity#setPictureInPictureParams\n+        final int userId = UserHandle.getCallingUserId();\n+        if (r.pictureInPictureArgs.hasSetAspectRatio()\n+                && params.hasSetAspectRatio()\n+                && !r.pictureInPictureArgs.getAspectRatio().equals(\n+                params.getAspectRatio())\n+                && !mSetPipAspectRatioQuotaTracker.noteEvent(\n+                userId, r.packageName, \"setPipAspectRatio\")) {\n+            throw new IllegalStateException(caller\n+                    + \": Too many PiP aspect ratio change requests from \" + r.packageName);\n+        }\n+\n         if (params.hasSetAspectRatio()\n                 && !mService.mWindowManager.isValidPictureInPictureAspectRatio(\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.2759,
      "normalized_edit_similarity": 0.2289,
      "token_level_edit_distance": 340,
      "codebert_score": {
        "precision": 0.9285,
        "recall": 0.7673,
        "f1": 0.8403,
        "f3": 0.7809
      },
      "token_count_upstream": 378,
      "token_count_downstream": 87,
      "token_count_total": 465,
      "cosine_similarity_openai": 0.7949
    }
  },
  {
    "cve_id": "ASB-A-308414141",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 319.73,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 267,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 150,
      "token_count_downstream": 0,
      "token_count_total": 150,
      "cosine_similarity_openai": 0.0322
    }
  },
  {
    "cve_id": "ASB-A-308414141",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 366.73,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "@@ -119,6 +119,9 @@\n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -342,6 +345,9 @@\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.525,
      "normalized_edit_similarity": 0.4981,
      "token_level_edit_distance": 158,
      "codebert_score": {
        "precision": 0.9006,
        "recall": 0.8363,
        "f1": 0.8673,
        "f3": 0.8423
      },
      "token_count_upstream": 150,
      "token_count_downstream": 82,
      "token_count_total": 232,
      "cosine_similarity_openai": 0.9191
    }
  },
  {
    "cve_id": "ASB-A-308414141",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 397.27,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 267,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 150,
      "token_count_downstream": 0,
      "token_count_total": 150,
      "cosine_similarity_openai": 0.0322
    }
  },
  {
    "cve_id": "ASB-A-307948424",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 340.63,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "@@ -118,7 +118,10 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                    + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                    > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n@@ -369,6 +372,9 @@\n             }\n \n             if (groupSummaryKey != null) {\n+                String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotificationsWithContext);\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.525,
      "normalized_edit_similarity": 0.4232,
      "token_level_edit_distance": 184,
      "codebert_score": {
        "precision": 0.9017,
        "recall": 0.8242,
        "f1": 0.8612,
        "f3": 0.8314
      },
      "token_count_upstream": 150,
      "token_count_downstream": 75,
      "token_count_total": 225,
      "cosine_similarity_openai": 0.9033
    }
  },
  {
    "cve_id": "ASB-A-307948424",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 338.83,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 267,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 150,
      "token_count_downstream": 0,
      "token_count_total": 150,
      "cosine_similarity_openai": 0.0323
    }
  },
  {
    "cve_id": "ASB-A-307948424",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/notification/SnoozeHelper.java",
    "runtime_seconds": 131.9,
    "cleaned_ground_truth": "@@ -141,13 +141,29 @@ public class SnoozeHelper {\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                || (countPersistedNotificationsLocked() + numberToSnooze)\n+                > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n+    private int countPersistedNotificationsLocked() {\n+        int numNotifications = 0;\n+        for (ArrayMap<String, String> persistedWithContext :\n+                mPersistedSnoozedNotificationsWithContext.values()) {\n+            numNotifications += persistedWithContext.size();\n+        }\n+        for (ArrayMap<String, Long> persistedWithDuration :\n+                mPersistedSnoozedNotifications.values()) {\n+            numNotifications += persistedWithDuration.size();\n+        }\n+        return numNotifications;\n+    }\n+\n+\n     @NonNull\n     protected Long getSnoozeTimeForUnpostedNotification(int userId, String pkg, String key) {\n         Long time = null;\n@@ -450,6 +466,11 @@ public class SnoozeHelper {\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n \n+                final String trimmedKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedKey, userId,\n+                      mPersistedSnoozedNotificationsWithContext);\n+\n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n                         MetricsLogger.action(record.getLogMaker()",
    "cleaned_upstream_plus_llm": "@@ -154,9 +154,12 @@\n \n     protected boolean canSnooze(int numberToSnooze) {\n         synchronized (mLock) {\n-            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT) {\n+            if ((mPackages.size() + numberToSnooze) > CONCURRENT_SNOOZE_LIMIT\n+                    || (mPersistedSnoozedNotifications.size()\n+                            + mPersistedSnoozedNotificationsWithContext.size() + numberToSnooze)\n+                            > CONCURRENT_SNOOZE_LIMIT) {\n                 return false;\n             }\n         }\n         return true;\n     }\n@@ -386,6 +389,9 @@\n                 NotificationRecord record = recordsByKey.remove(groupSummaryKey);\n                 mPackages.remove(groupSummaryKey);\n                 mUsers.remove(groupSummaryKey);\n+                String trimmedGroupSummaryKey = getTrimmedString(groupSummaryKey);\n+                removeRecordLocked(pkg, trimmedGroupSummaryKey, userId, mPersistedSnoozedNotifications);\n+                removeRecordLocked(pkg, trimmedGroupSummaryKey, userId, mPersistedSnoozedNotificationsWithContext);\n \n                 if (record != null && !record.isCanceled) {\n                     Runnable runnable = () -> {\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.575,
      "normalized_edit_similarity": 0.5019,
      "token_level_edit_distance": 150,
      "codebert_score": {
        "precision": 0.8978,
        "recall": 0.8409,
        "f1": 0.8684,
        "f3": 0.8462
      },
      "token_count_upstream": 150,
      "token_count_downstream": 85,
      "token_count_total": 235,
      "cosine_similarity_openai": 0.9218
    }
  },
  {
    "cve_id": "ASB-A-328068777",
    "downstream_version": "14",
    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
    "runtime_seconds": 80.65,
    "cleaned_ground_truth": "@@ -798,6 +798,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                 mAppOpsManagerLocal.isUidInForeground(uid),\n                                 builder);\n                         throwExceptionIfDataSyncInProgress();\n+                        if (request.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 request.getRecordTypesList(), attributionSource);\n                         callback.onResult(\n@@ -816,6 +820,14 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n+                    } catch (IllegalArgumentException illegalArgumentException) {\n+                        builder.setHealthDataServiceApiStatusError(\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n+                        Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n+                        tryAndThrowException(\n+                                callback,\n+                                illegalArgumentException,\n+                                HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (HealthConnectException healthConnectException) {\n                         builder.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n@@ -862,6 +874,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);",
    "cleaned_upstream_plus_llm": "@@ -815,8 +815,12 @@\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                         if (!isInForeground) {\n                             throwSecurityException(\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.3784,
      "normalized_edit_similarity": 0.2491,
      "token_level_edit_distance": 15,
      "codebert_score": {
        "precision": 0.8995,
        "recall": 0.7825,
        "f1": 0.8369,
        "f3": 0.7928
      },
      "token_count_upstream": 124,
      "token_count_downstream": 40,
      "token_count_total": 164,
      "cosine_similarity_openai": 0.7893
    }
  },
  {
    "cve_id": "ASB-A-300090204",
    "downstream_version": "12L",
    "file_name": "core/java/android/service/dreams/DreamService.java",
    "runtime_seconds": 415.99,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-300090204",
    "downstream_version": "11",
    "file_name": "core/java/android/service/dreams/DreamService.java",
    "runtime_seconds": 523.04,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-300090204",
    "downstream_version": "12",
    "file_name": "core/java/android/service/dreams/DreamService.java",
    "runtime_seconds": 558.56,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-321707289",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/notification/ManagedServices.java",
    "runtime_seconds": 275.12,
    "cleaned_ground_truth": "@@ -901,6 +901,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -958,6 +975,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1083,8 +1101,7 @@ abstract public class ManagedServices {\n \n         synchronized (mMutex) {\n             if (enabled) {\n-                if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                        || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                     registerServiceLocked(component, userId);\n                 } else {\n                     Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1222,6 +1239,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1405,28 +1449,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1447,6 +1483,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1548,7 +1593,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1680,6 +1725,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 1116,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 696,
      "token_count_downstream": 0,
      "token_count_total": 696,
      "cosine_similarity_openai": 0.0526
    }
  },
  {
    "cve_id": "ASB-A-321707289",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/notification/ManagedServices.java",
    "runtime_seconds": 150.79,
    "cleaned_ground_truth": "@@ -155,7 +155,9 @@ abstract public class ManagedServices {\n     // List of approved packages or components (by user, then by primary/secondary) that are\n     // allowed to be bound as managed services. A package or component appearing in this list does\n     // not mean that we are currently bound to said package/component.\n-    protected ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved = new ArrayMap<>();\n+    @GuardedBy(\"mApproved\")\n+    protected final ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved =\n+            new ArrayMap<>();\n \n     // List of packages or components (by user) that are configured to be enabled/disabled\n     // explicitly by the user\n@@ -871,6 +873,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -928,6 +947,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1057,8 +1077,7 @@ abstract public class ManagedServices {\n             for (int i = 0; i < userIds.size(); i++) {\n                 final int userId = userIds.get(i);\n                 if (enabled) {\n-                    if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                            || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                    if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                         registerServiceLocked(component, userId);\n                     } else {\n                         Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1197,6 +1216,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1380,28 +1426,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1422,6 +1460,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1523,7 +1570,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1655,6 +1702,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "cleaned_upstream_plus_llm": "@@ -1302,6 +1302,15 @@\n             Slog.e(TAG, \"Unable to bind \" + getCaption() + \" service: \" + intent, ex);\n         }\n     }\n+\n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n \n     boolean isBound(ComponentName cn, int userId) {\n         final Pair<ComponentName, Integer> servicesBindingTag = Pair.create(cn, userId);\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0947,
      "normalized_edit_similarity": 0.0735,
      "token_level_edit_distance": 44,
      "codebert_score": {
        "precision": 0.8834,
        "recall": 0.7354,
        "f1": 0.8026,
        "f3": 0.748
      },
      "token_count_upstream": 800,
      "token_count_downstream": 77,
      "token_count_total": 877,
      "cosine_similarity_openai": 0.7059
    }
  },
  {
    "cve_id": "ASB-A-321707289",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/notification/ManagedServices.java",
    "runtime_seconds": 144.34,
    "cleaned_ground_truth": "@@ -155,7 +155,9 @@ abstract public class ManagedServices {\n     // List of approved packages or components (by user, then by primary/secondary) that are\n     // allowed to be bound as managed services. A package or component appearing in this list does\n     // not mean that we are currently bound to said package/component.\n-    protected ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved = new ArrayMap<>();\n+    @GuardedBy(\"mApproved\")\n+    protected final ArrayMap<Integer, ArrayMap<Boolean, ArraySet<String>>> mApproved =\n+            new ArrayMap<>();\n \n     // List of packages or components (by user) that are configured to be enabled/disabled\n     // explicitly by the user\n@@ -871,6 +873,23 @@ abstract public class ManagedServices {\n         return false;\n     }\n \n+    protected boolean isPackageOrComponentAllowedWithPermission(ComponentName component,\n+            int userId) {\n+        if (!(isPackageOrComponentAllowed(component.flattenToString(), userId)\n+                || isPackageOrComponentAllowed(component.getPackageName(), userId))) {\n+            return false;\n+        }\n+        return componentHasBindPermission(component, userId);\n+    }\n+\n+    private boolean componentHasBindPermission(ComponentName component, int userId) {\n+        ServiceInfo info = getServiceInfo(component, userId);\n+        if (info == null) {\n+            return false;\n+        }\n+        return mConfig.bindPermission.equals(info.permission);\n+    }\n+\n     boolean isPackageOrComponentUserSet(String pkgOrComponent, int userId) {\n         synchronized (mApproved) {\n             ArraySet<String> services = mUserSetServices.get(userId);\n@@ -928,6 +947,7 @@ abstract public class ManagedServices {\n                     for (int uid : uidList) {\n                         if (isPackageAllowed(pkgName, UserHandle.getUserId(uid))) {\n                             anyServicesInvolved = true;\n+                            trimApprovedListsForInvalidServices(pkgName, UserHandle.getUserId(uid));\n                         }\n                     }\n                 }\n@@ -1057,8 +1077,7 @@ abstract public class ManagedServices {\n             for (int i = 0; i < userIds.size(); i++) {\n                 final int userId = userIds.get(i);\n                 if (enabled) {\n-                    if (isPackageOrComponentAllowed(component.flattenToString(), userId)\n-                            || isPackageOrComponentAllowed(component.getPackageName(), userId)) {\n+                    if (isPackageOrComponentAllowedWithPermission(component, userId)) {\n                         registerServiceLocked(component, userId);\n                     } else {\n                         Slog.d(TAG, component + \" no longer has permission to be bound\");\n@@ -1197,6 +1216,33 @@ abstract public class ManagedServices {\n         return removed;\n     }\n \n+    private void trimApprovedListsForInvalidServices(String packageName, int userId) {\n+        synchronized (mApproved) {\n+            final ArrayMap<Boolean, ArraySet<String>> approvedByType = mApproved.get(userId);\n+            if (approvedByType == null) {\n+                return;\n+            }\n+            for (int i = 0; i < approvedByType.size(); i++) {\n+                final ArraySet<String> approved = approvedByType.valueAt(i);\n+                for (int j = approved.size() - 1; j >= 0; j--) {\n+                    final String approvedPackageOrComponent = approved.valueAt(j);\n+                    if (TextUtils.equals(getPackageName(approvedPackageOrComponent), packageName)) {\n+                        final ComponentName component = ComponentName.unflattenFromString(\n+                                approvedPackageOrComponent);\n+                        if (component != null && !componentHasBindPermission(component, userId)) {\n+                            approved.removeAt(j);\n+                            if (DEBUG) {\n+                                Slog.v(TAG, \"Removing \" + approvedPackageOrComponent\n+                                        + \" from approved list; no bind permission found \"\n+                                        + mConfig.bindPermission);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected String getPackageName(String packageOrComponent) {\n         final ComponentName component = ComponentName.unflattenFromString(packageOrComponent);\n         if (component != null) {\n@@ -1380,28 +1426,20 @@ abstract public class ManagedServices {\n             final int userId = componentsToBind.keyAt(i);\n             final Set<ComponentName> add = componentsToBind.get(userId);\n             for (ComponentName component : add) {\n-                try {\n-                    ServiceInfo info = mPm.getServiceInfo(component,\n-                            PackageManager.GET_META_DATA\n-                                    | PackageManager.MATCH_DIRECT_BOOT_AWARE\n-                                    | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n-                            userId);\n-                    if (info == null) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": service not found\");\n-                        continue;\n-                    }\n-                    if (!mConfig.bindPermission.equals(info.permission)) {\n-                        Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n-                                + \": it does not require the permission \" + mConfig.bindPermission);\n-                        continue;\n-                    }\n-                    Slog.v(TAG,\n-                            \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n-                    registerService(info, userId);\n-                } catch (RemoteException e) {\n-                    e.rethrowFromSystemServer();\n+                ServiceInfo info = getServiceInfo(component, userId);\n+                if (info == null) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": service not found\");\n+                    continue;\n                 }\n+                if (!mConfig.bindPermission.equals(info.permission)) {\n+                    Slog.w(TAG, \"Not binding \" + getCaption() + \" service \" + component\n+                            + \": it does not require the permission \" + mConfig.bindPermission);\n+                    continue;\n+                }\n+                Slog.v(TAG,\n+                        \"enabling \" + getCaption() + \" for \" + userId + \": \" + component);\n+                registerService(info, userId);\n             }\n         }\n     }\n@@ -1422,6 +1460,15 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    @VisibleForTesting\n+    void reregisterService(final ComponentName cn, final int userId) {\n+        // If rebinding a package that died, ensure it still has permission\n+        // after the rebind delay\n+        if (isPackageOrComponentAllowedWithPermission(cn, userId)) {\n+            registerService(cn, userId);\n+        }\n+    }\n+\n     /**\n      * Inject a system service into the management list.\n      */\n@@ -1523,7 +1570,7 @@ abstract public class ManagedServices {\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        reregisterService(name, userid);\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n@@ -1655,6 +1702,19 @@ abstract public class ManagedServices {\n         }\n     }\n \n+    private ServiceInfo getServiceInfo(ComponentName component, int userId) {\n+        try {\n+            return mPm.getServiceInfo(component,\n+                    PackageManager.GET_META_DATA\n+                            | PackageManager.MATCH_DIRECT_BOOT_AWARE\n+                            | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,\n+                    userId);\n+        } catch (RemoteException e) {\n+            e.rethrowFromSystemServer();\n+        }\n+        return null;\n+    }\n+\n     public class ManagedServiceInfo implements IBinder.DeathRecipient {\n         public IInterface service;\n         public ComponentName component;",
    "cleaned_upstream_plus_llm": "@@ -1275,7 +1275,17 @@\n                             mHandler.postDelayed(new Runnable() {\n                                     @Override\n                                     public void run() {\n-                                        registerService(name, userid);\n+                                        // If rebinding a package that died, ensure it still has permission\n+                                        // after the rebind delay\n+                                        if (isPackageOrComponentAllowedWithPermission(name, userid)) {\n+                                            registerService(name, userid);\n+                                        } else {\n+                                            Slog.w(TAG, \"Not re-binding \" + name + \" for user \" + userid\n+                                                    + \" as it's no longer allowed or lacks permission.\");\n+                                            synchronized (mMutex) {\n+                                                mServicesRebinding.remove(Pair.create(name, userid));\n+                                            }\n+                                        }\n                                     }\n                                }, ON_BINDING_DIED_REBIND_DELAY_MS);\n                         } else {\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1183,
      "normalized_edit_similarity": 0.0672,
      "token_level_edit_distance": 473,
      "codebert_score": {
        "precision": 0.8875,
        "recall": 0.7447,
        "f1": 0.8099,
        "f3": 0.7569
      },
      "token_count_upstream": 800,
      "token_count_downstream": 89,
      "token_count_total": 889,
      "cosine_similarity_openai": 0.7028
    }
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "14",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 403.61,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "12L",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 360.04,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "12",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 187.2,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -244,6 +244,16 @@\n         this.name = name;\n         this.total = getTotal(jzfile);\n         this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-added: do not accept files with invalid header\n+        // A valid ZIP file must start with a LOC header (locsig=true) or be an empty archive.\n+        // An empty archive (often just an EOCD record) would have locsig=false and total=0.\n+        // If locsig is false (does not start with LOCSIG) AND total is not 0 (not an empty zip),\n+        // then it's an invalid header.\n+        if (!this.locsig && this.total != 0) {\n+            throw new ZipException(\"ZIP file must start with LOC header or be an empty archive. \" +\n+                                   \"File: \" + this.name + \" starts with an invalid signature.\");\n+        }\n+        // END Android-added: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 186,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 141,
      "token_count_total": 141,
      "cosine_similarity_openai": 0.0694
    }
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "13",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 174.81,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -257,6 +257,14 @@\n         this.name = name;\n         this.total = getTotal(jzfile);\n         this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-changed: do not accept files with invalid header\n+        // Ensure that if a zip file has entries, it must start with LOCSIG.\n+        // A zip file can also be empty and start with ENDSIG (total=0, locsig=false).\n+        // This check addresses cases where a file doesn't start with LOCSIG but claims entries.\n+        if (!this.locsig && this.total > 0) {\n+            throw new ZipException(\"Zip file with entries must start with Local File Header.\");\n+        }\n+        // END Android-changed: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 156,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 111,
      "token_count_total": 111,
      "cosine_similarity_openai": 0.0829
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "14",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 264.89,
    "cleaned_ground_truth": "@@ -83,9 +83,7 @@ import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -931,13 +929,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferRequestStore, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": "@@ -947,13 +947,14 @@\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n```",
    "metrics": {
      "relative_line_count_similarity": 0.7,
      "normalized_edit_similarity": 0.6322,
      "token_level_edit_distance": 9,
      "codebert_score": {
        "precision": 0.9257,
        "recall": 0.8639,
        "f1": 0.8937,
        "f3": 0.8697
      },
      "token_count_upstream": 112,
      "token_count_downstream": 83,
      "token_count_total": 195,
      "cosine_similarity_openai": 0.9166
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "12L",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 339.93,
    "cleaned_ground_truth": "@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -702,10 +701,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 241,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 105,
      "token_count_downstream": 0,
      "token_count_total": 105,
      "cosine_similarity_openai": 0.0782
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "12",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 346.52,
    "cleaned_ground_truth": "@@ -86,12 +86,11 @@ import android.os.Handler;\n import android.os.IBinder;\n import android.os.IInterface;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.Process;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.ShellCommand;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -699,10 +698,12 @@ public class CompanionDeviceManagerService extends SystemService implements Bind\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new ShellCmd().exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new ShellCmd()\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 241,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 105,
      "token_count_downstream": 0,
      "token_count_total": 105,
      "cosine_similarity_openai": 0.0788
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "13",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 297.08,
    "cleaned_ground_truth": "@@ -72,12 +72,11 @@ import android.os.Environment;\n import android.os.Handler;\n import android.os.Message;\n import android.os.Parcel;\n+import android.os.ParcelFileDescriptor;\n import android.os.PowerWhitelistManager;\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n-import android.os.ResultReceiver;\n import android.os.ServiceManager;\n-import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -750,16 +749,13 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            enforceCallerCanManageCompanionDevice(getContext(), \"onShellCommand\");\n-\n-            final CompanionDeviceShellCommand cmd = new CompanionDeviceShellCommand(\n-                    CompanionDeviceManagerService.this,\n-                    mAssociationStore,\n-                    mDevicePresenceMonitor);\n-            cmd.exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 276,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 123,
      "token_count_downstream": 0,
      "token_count_total": 123,
      "cosine_similarity_openai": 0.0783
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "14",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 114.37,
    "cleaned_ground_truth": "@@ -819,7 +819,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit(int operationId) {\n+        protected void notifyAccessoryModeExit(int operationId) {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -2145,8 +2145,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      */\n                     operationId = sUsbOperationCount.incrementAndGet();\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit(operationId);\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false, operationId);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": "@@ -70,6 +70,7 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.3333,
      "normalized_edit_similarity": 0.1037,
      "token_level_edit_distance": 52,
      "codebert_score": {
        "precision": 0.6811,
        "recall": 0.5764,
        "f1": 0.6244,
        "f3": 0.5854
      },
      "token_count_upstream": 112,
      "token_count_downstream": 19,
      "token_count_total": 131,
      "cosine_similarity_openai": 0.4756
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "13",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 429.35,
    "cleaned_ground_truth": "@@ -735,7 +735,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1981,8 +1981,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 161,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 118,
      "token_count_downstream": 0,
      "token_count_total": 118,
      "cosine_similarity_openai": 0.0765
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "12L",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 489.93,
    "cleaned_ground_truth": "@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 161,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 118,
      "token_count_downstream": 0,
      "token_count_total": 118,
      "cosine_similarity_openai": 0.0784
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "12",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 417.09,
    "cleaned_ground_truth": "@@ -719,7 +719,7 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n             }\n         }\n \n-        private void notifyAccessoryModeExit() {\n+        protected void notifyAccessoryModeExit() {\n             // make sure accessory mode is off\n             // and restore default functions\n             Slog.d(TAG, \"exited USB accessory mode\");\n@@ -1957,8 +1957,13 @@ public class UsbDeviceManager implements ActivityTaskManagerInternal.ScreenObser\n                      * Dont force to default when the configuration is already set to default.\n                      */\n                     if (msg.arg1 != 1) {\n-                        // Set this since default function may be selected from Developer options\n-                        setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        if (mCurrentFunctions == UsbManager.FUNCTION_ACCESSORY) {\n+                            notifyAccessoryModeExit();\n+                        } else {\n+                            // Set this since default function may be selected from Developer\n+                            // options\n+                            setEnabledFunctions(mScreenUnlockedFunctions, false);\n+                        }\n                     }\n                     break;\n                 case MSG_GADGET_HAL_REGISTERED:",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 161,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 118,
      "token_count_downstream": 0,
      "token_count_total": 118,
      "cosine_similarity_openai": 0.0782
    }
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 66.14,
    "cleaned_ground_truth": "@@ -4742,7 +4742,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n@@ -4783,7 +4785,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !AndroidPackageUtils.isPrivileged(pkg)\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "cleaned_upstream_plus_llm": "@@ -4590,7 +4590,9 @@\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {\n```",
    "metrics": {
      "relative_line_count_similarity": 0.55,
      "normalized_edit_similarity": 0.5061,
      "token_level_edit_distance": 81,
      "codebert_score": {
        "precision": 0.9562,
        "recall": 0.8412,
        "f1": 0.895,
        "f3": 0.8515
      },
      "token_count_upstream": 84,
      "token_count_downstream": 41,
      "token_count_total": 125,
      "cosine_similarity_openai": 0.8844
    }
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 95.36,
    "cleaned_ground_truth": "@@ -4373,7 +4373,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n@@ -4407,7 +4409,8 @@ final class InstallPackageHelper {\n         if (((scanFlags & SCAN_AS_PRIVILEGED) == 0)\n                 && !pkg.isPrivileged()\n                 && (pkg.getSharedUserId() != null)\n-                && !skipVendorPrivilegeScan) {\n+                && !skipVendorPrivilegeScan\n+                && !pkg.isLeavingSharedUid()) {\n             SharedUserSetting sharedUserSetting = null;\n             synchronized (mPm.mLock) {\n                 try {",
    "cleaned_upstream_plus_llm": "@@ -2270,7 +2270,9 @@\n         }\n     }\n \n-    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n-            throws PackageManagerException {\n-        if (!pkg.isPrivileged() && (pkg.getSharedUserId() != null)) {\n+    private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n+            throws PackageManagerException {\n+        if (!pkg.isPrivileged()\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 sharedUserSetting = mPm.mSettings.getSharedUserLPw(pkg.getSharedUserId(),\n```",
    "metrics": {
      "relative_line_count_similarity": 0.75,
      "normalized_edit_similarity": 0.4405,
      "token_level_edit_distance": 93,
      "codebert_score": {
        "precision": 0.9103,
        "recall": 0.8251,
        "f1": 0.8656,
        "f3": 0.8329
      },
      "token_count_upstream": 84,
      "token_count_downstream": 54,
      "token_count_total": 138,
      "cosine_similarity_openai": 0.8783
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "14",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 443.81,
    "cleaned_ground_truth": "@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -412,19 +424,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -454,30 +459,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -489,13 +520,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "@@ -425,17 +425,11 @@\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n-  }\n-\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n+  }\n+\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n@@ -467,6 +461,7 @@\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.252,
      "normalized_edit_similarity": 0.1561,
      "token_level_edit_distance": 152,
      "codebert_score": {
        "precision": 0.9323,
        "recall": 0.8007,
        "f1": 0.8615,
        "f3": 0.8122
      },
      "token_count_upstream": 725,
      "token_count_downstream": 145,
      "token_count_total": 870,
      "cosine_similarity_openai": 0.8165
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "13",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 279.88,
    "cleaned_ground_truth": "@@ -353,6 +353,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -411,19 +423,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -453,30 +458,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -488,13 +519,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "@@ -426,19 +426,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n-  }\n-\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n+  }\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -462,6 +455,7 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n```",
    "metrics": {
      "relative_line_count_similarity": 0.2602,
      "normalized_edit_similarity": 0.1598,
      "token_level_edit_distance": 182,
      "codebert_score": {
        "precision": 0.9547,
        "recall": 0.8322,
        "f1": 0.8892,
        "f3": 0.843
      },
      "token_count_upstream": 725,
      "token_count_downstream": 161,
      "token_count_total": 886,
      "cosine_similarity_openai": 0.8758
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "12L",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 394.83,
    "cleaned_ground_truth": "@@ -341,6 +341,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -398,18 +410,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkMany failed to get initial credentials, %s\", strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -439,30 +445,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -474,13 +506,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 801,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 724,
      "token_count_downstream": 0,
      "token_count_total": 724,
      "cosine_similarity_openai": 0.0887
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "12",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 387.21,
    "cleaned_ground_truth": "@@ -341,6 +341,18 @@ jstring com_android_internal_os_ZygoteCommandBuffer_nativeNextArg(JNIEnv* env, j\n   return result;\n }\n \n+static uid_t getSocketPeerUid(int socket, const std::function<void(const std::string&)>& fail_fn) {\n+  struct ucred credentials;\n+  socklen_t cred_size = sizeof credentials;\n+  if (getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n+      || cred_size != sizeof credentials) {\n+    fail_fn(CREATE_ERROR(\"Failed to get socket credentials, %s\",\n+                         strerror(errno)));\n+  }\n+\n+  return credentials.uid;\n+}\n+\n // Read all lines from the current command into the buffer, and then reset the buffer, so\n // we will start reading again at the beginning of the command, starting with the argument\n // count. And we don't need access to the fd to do so.\n@@ -398,18 +410,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkMany failed to get initial credentials, %s\", strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -439,30 +445,56 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {\n         if (n_buffer->getCount(fail_fn_z) != 0) {\n           break;\n-        }  // else disconnected;\n+        } else {\n+          // Session socket was disconnected\n+          valid_session_socket = false;\n+          close(session_socket);\n+        }\n       } else if (poll_res == 0 || (fd_structs[ZYGOTE_IDX].revents & POLLIN) == 0) {\n         fail_fn_z(\n             CREATE_ERROR(\"Poll returned with no descriptors ready! Poll returned %d\", poll_res));\n       }\n-      // We've now seen either a disconnect or connect request.\n-      close(session_socket);\n-      int new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+      int new_fd = -1;\n+      do {\n+        // We've now seen either a disconnect or connect request.\n+        new_fd = TEMP_FAILURE_RETRY(accept(zygote_socket_fd, nullptr, nullptr));\n+        if (new_fd == -1) {\n+          fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        }\n+        uid_t newPeerUid = getSocketPeerUid(new_fd, fail_fn_1);\n+        if (newPeerUid != static_cast<uid_t>(expected_uid)) {\n+          ALOGW(\"Dropping new connection with a mismatched uid %d\\n\", newPeerUid);\n+          close(new_fd);\n+          new_fd = -1;\n+        } else {\n+          // If we still have a valid session socket, close it now\n+          if (valid_session_socket) {\n+              close(session_socket);\n+          }\n+          valid_session_socket = true;\n+        }\n+      } while (!valid_session_socket);\n+\n+      // At this point we either have a valid new connection (new_fd > 0), or\n+      // an existing session socket we can poll on\n       if (new_fd == -1) {\n-        fail_fn_z(CREATE_ERROR(\"Accept(%d) failed: %s\", zygote_socket_fd, strerror(errno)));\n+        // The new connection wasn't valid, and we still have an old one; retry polling\n+        continue;\n       }\n       if (new_fd != session_socket) {\n-          // Move new_fd back to the old value, so that we don't have to change Java-level data\n-          // structures to reflect a change. This implicitly closes the old one.\n-          if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n-            fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n-                                   new_fd, session_socket, strerror(errno)));\n-          }\n-          close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n+        // Move new_fd back to the old value, so that we don't have to change Java-level data\n+        // structures to reflect a change. This implicitly closes the old one.\n+        if (TEMP_FAILURE_RETRY(dup2(new_fd, session_socket)) != session_socket) {\n+          fail_fn_z(CREATE_ERROR(\"Failed to move fd %d to %d: %s\",\n+                                 new_fd, session_socket, strerror(errno)));\n+        }\n+        close(new_fd);  //  On Linux, fd is closed even if EINTR is returned.\n       }\n       // If we ever return, we effectively reuse the old Java ZygoteConnection.\n       // None of its state needs to change.\n@@ -474,13 +506,6 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n         fail_fn_z(CREATE_ERROR(\"Failed to set send timeout for socket %d: %s\",\n                                session_socket, strerror(errno)));\n       }\n-      if (getsockopt(session_socket, SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany failed to get credentials: %s\", strerror(errno)));\n-      }\n-      if (cred_size != sizeof credentials) {\n-        fail_fn_z(CREATE_ERROR(\"ForkMany credential size = %d, should be %d\",\n-                               cred_size, static_cast<int>(sizeof credentials)));\n-      }\n     }\n     first_time = false;\n   } while (n_buffer->isSimpleForkCommand(minUid, fail_fn_n));",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 801,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 724,
      "token_count_downstream": 0,
      "token_count_total": 724,
      "cosine_similarity_openai": 0.0887
    }
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "13",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 5.73,
    "cleaned_ground_truth": "@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "cleaned_upstream_plus_llm": "@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }\n \n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8889,
      "normalized_edit_similarity": 0.7679,
      "token_level_edit_distance": 14,
      "codebert_score": {
        "precision": 0.9816,
        "recall": 0.9506,
        "f1": 0.9659,
        "f3": 0.9536
      },
      "token_count_upstream": 30,
      "token_count_downstream": 27,
      "token_count_total": 57,
      "cosine_similarity_openai": 0.9614
    }
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "14",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 6.6,
    "cleaned_ground_truth": "@@ -222,8 +222,7 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************",
    "cleaned_upstream_plus_llm": "@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_rec,\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }\n \n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8889,
      "normalized_edit_similarity": 0.7321,
      "token_level_edit_distance": 16,
      "codebert_score": {
        "precision": 0.9784,
        "recall": 0.9448,
        "f1": 0.9613,
        "f3": 0.9481
      },
      "token_count_upstream": 30,
      "token_count_downstream": 27,
      "token_count_total": 57,
      "cosine_similarity_openai": 0.9603
    }
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 52.75,
    "cleaned_ground_truth": "@@ -2186,16 +2186,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -4400,10 +4410,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1307,22 +1307,32 @@\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n         final long elapsedNow = SystemClock.elapsedRealtime();\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n             for (int j=0; j<pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, elapsedNow));\n             }\n         } else {\n             for (int j=0; j<ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n                     resOps.add(getOpEntryForResult(curOp, elapsedNow));\n                 }\n             }\n         }\n         return resOps;\n     }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.6415,
      "normalized_edit_similarity": 0.4877,
      "token_level_edit_distance": 63,
      "codebert_score": {
        "precision": 0.9426,
        "recall": 0.8517,
        "f1": 0.8948,
        "f3": 0.86
      },
      "token_count_upstream": 247,
      "token_count_downstream": 112,
      "token_count_total": 359,
      "cosine_similarity_openai": 0.822
    }
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 193.74,
    "cleaned_ground_truth": "@@ -1430,16 +1430,26 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n@@ -3615,10 +3625,21 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n     private void verifyIncomingOp(int op) {\n         if (op >= 0 && op < AppOpsManager._NUM_OP) {\n-            // Enforce manage appops permission if it's a restricted read op.\n+            // Enforce privileged appops permission if it's a restricted read op.\n             if (opRestrictsRead(op)) {\n-                mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n-                        Binder.getCallingPid(), Binder.getCallingUid(), \"verifyIncomingOp\");\n+                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.GET_APP_OPS_STATS,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n+                        Manifest.permission.MANAGE_APP_OPS_MODES,\n+                        Binder.getCallingPid(), Binder.getCallingUid())\n+                        == PackageManager.PERMISSION_GRANTED)) {\n+                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n+                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n+                            + \"MANAGE_APP_OPS_MODES}\");\n+                }\n             }\n             return;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1190,19 +1190,29 @@\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n-        if (ops == null) {\n-            resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n-                Op curOp = pkgOps.valueAt(j);\n-                resOps.add(getOpEntryForResult(curOp));\n-            }\n-        } else {\n-            for (int j=0; j<ops.length; j++) {\n-                Op curOp = pkgOps.get(ops[j]);\n-                if (curOp != null) {\n-                    if (resOps == null) {\n-                        resOps = new ArrayList<>();\n-                    }\n-                    resOps.add(getOpEntryForResult(curOp));\n-                }\n-            }\n-        }\n-        return resOps;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n+        if (ops == null) {\n+            resOps = new ArrayList<>();\n+            for (int j = 0; j < pkgOps.size(); j++) {\n+                Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n+                resOps.add(getOpEntryForResult(curOp));\n+            }\n+        } else {\n+            for (int j = 0; j < ops.length; j++) {\n+                Op curOp = pkgOps.get(ops[j]);\n+                if (curOp != null) {\n+                    if (resOps == null) {\n+                        resOps = new ArrayList<>();\n+                    }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n+                    resOps.add(getOpEntryForResult(curOp));\n+                }\n+            }\n+        }\n+        return resOps;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.9423,
      "normalized_edit_similarity": 0.2794,
      "token_level_edit_distance": 257,
      "codebert_score": {
        "precision": 0.8988,
        "recall": 0.8469,
        "f1": 0.8721,
        "f3": 0.8518
      },
      "token_count_upstream": 241,
      "token_count_downstream": 196,
      "token_count_total": 437,
      "cosine_similarity_openai": 0.8068
    }
  },
  {
    "cve_id": "ASB-A-293602317",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 130.82,
    "cleaned_ground_truth": "@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,8 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3603,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4981,8 +4994,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "cleaned_upstream_plus_llm": "@@ -4848,7 +4848,8 @@\n             @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int parentId,\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n-                    throws UserManager.CheckedUserOperationException {\n+                    throws UserManager.CheckedUserOperationException {\n+        final String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.141,
      "normalized_edit_similarity": 0.0995,
      "token_level_edit_distance": 270,
      "codebert_score": {
        "precision": 0.9009,
        "recall": 0.7286,
        "f1": 0.8056,
        "f3": 0.7428
      },
      "token_count_upstream": 361,
      "token_count_downstream": 60,
      "token_count_total": 421,
      "cosine_similarity_openai": 0.7018
    }
  },
  {
    "cve_id": "ASB-A-293602317",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 54.73,
    "cleaned_ground_truth": "@@ -248,6 +248,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3157,15 +3159,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3205,6 +3209,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3565,6 +3576,8 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3590,8 +3603,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3684,7 +3697,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4981,8 +4994,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "cleaned_upstream_plus_llm": "@@ -4845,6 +4845,7 @@\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1154,
      "normalized_edit_similarity": 0.1027,
      "token_level_edit_distance": 251,
      "codebert_score": {
        "precision": 0.8894,
        "recall": 0.7019,
        "f1": 0.7846,
        "f3": 0.717
      },
      "token_count_upstream": 361,
      "token_count_downstream": 45,
      "token_count_total": 406,
      "cosine_similarity_openai": 0.6716
    }
  },
  {
    "cve_id": "ASB-A-293602317",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 76.28,
    "cleaned_ground_truth": "@@ -247,6 +247,8 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n+    private static final int MAX_USER_STRING_LENGTH = 500;\n+\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3156,15 +3158,17 @@ public class UserManagerService extends IUserManager.Stub {\n         // Write seed data\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME, userData.seedAccountName);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n+                        truncateString(userData.seedAccountName));\n             }\n             if (userData.seedAccountType != null) {\n-                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE, userData.seedAccountType);\n+                serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n+                        truncateString(userData.seedAccountType));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(userInfo.name);\n+            serializer.text(truncateString(userInfo.name));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3204,6 +3208,13 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n+    private String truncateString(String original) {\n+        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+            return original;\n+        }\n+        return original.substring(0, MAX_USER_STRING_LENGTH);\n+    }\n+\n     /*\n      * Writes the user list file in this format:\n      *\n@@ -3564,6 +3575,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -3589,8 +3601,9 @@ public class UserManagerService extends IUserManager.Stub {\n \n         // Try to use a pre-created user (if available).\n         if (!preCreate && parentId < 0 && isUserTypeEligibleForPreCreation(userTypeDetails)) {\n-            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags, name,\n-                    token);\n+\n+            final UserInfo preCreatedUser = convertPreCreatedUserIfPossible(userType, flags,\n+                    truncatedName, token);\n             if (preCreatedUser != null) {\n                 return preCreatedUser;\n             }\n@@ -3683,7 +3696,7 @@ public class UserManagerService extends IUserManager.Stub {\n                         flags &= ~UserInfo.FLAG_EPHEMERAL;\n                     }\n \n-                    userInfo = new UserInfo(userId, name, null, flags, userType);\n+                    userInfo = new UserInfo(userId, truncatedName, null, flags, userType);\n                     userInfo.serialNumber = mNextSerialNumber++;\n                     userInfo.creationTime = getCreationTime();\n                     userInfo.partial = true;\n@@ -4976,8 +4989,8 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = accountName;\n-                userData.seedAccountType = accountType;\n+                userData.seedAccountName = truncateString(accountName);\n+                userData.seedAccountType = truncateString(accountType);\n                 userData.seedAccountOptions = accountOptions;\n                 userData.persistSeedData = persist;\n             }",
    "cleaned_upstream_plus_llm": "@@ -4845,7 +4845,8 @@\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n+        String truncatedName = truncateString(name);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n             return null;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1282,
      "normalized_edit_similarity": 0.1074,
      "token_level_edit_distance": 94,
      "codebert_score": {
        "precision": 0.8878,
        "recall": 0.7032,
        "f1": 0.7848,
        "f3": 0.7181
      },
      "token_count_upstream": 361,
      "token_count_downstream": 47,
      "token_count_total": 408,
      "cosine_similarity_openai": 0.6739
    }
  },
  {
    "cve_id": "ASB-A-230492947",
    "downstream_version": "11",
    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
    "runtime_seconds": 300.09,
    "cleaned_ground_truth": "@@ -1223,29 +1223,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 445,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 215,
      "token_count_downstream": 0,
      "token_count_total": 215,
      "cosine_similarity_openai": 0.0309
    }
  },
  {
    "cve_id": "ASB-A-230492947",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
    "runtime_seconds": 322.3,
    "cleaned_ground_truth": "@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 445,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 215,
      "token_count_downstream": 0,
      "token_count_total": 215,
      "cosine_similarity_openai": 0.0303
    }
  },
  {
    "cve_id": "ASB-A-230492947",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/wm/ActivityTaskManagerService.java",
    "runtime_seconds": 292.52,
    "cleaned_ground_truth": "@@ -1324,29 +1324,38 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {\n \n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -1411,25 +1411,35 @@\n             final long origId = Binder.clearCallingIdentity();\n             // TODO(b/64750076): Check if calling pid should really be -1.\n-            final int res = getActivityStartController()\n-                    .obtainStarter(intent, \"startNextMatchingActivity\")\n-                    .setCaller(r.app.getThread())\n-                    .setResolvedType(r.resolvedType)\n-                    .setActivityInfo(aInfo)\n-                    .setResultTo(resultTo != null ? resultTo.appToken : null)\n-                    .setResultWho(resultWho)\n-                    .setRequestCode(requestCode)\n-                    .setCallingPid(-1)\n-                    .setCallingUid(r.launchedFromUid)\n-                    .setCallingPackage(r.launchedFromPackage)\n-                    .setCallingFeatureId(r.launchedFromFeatureId)\n-                    .setRealCallingPid(-1)\n-                    .setRealCallingUid(r.launchedFromUid)\n-                    .setActivityOptions(options)\n-                    .execute();\n-            Binder.restoreCallingIdentity(origId);\n-\n-            r.finishing = wasFinishing;\n-            if (res != ActivityManager.START_SUCCESS) {\n-                return false;\n+            try {\n+                if (options == null) {\n+                    options = new SafeActivityOptions(ActivityOptions.makeBasic());\n+                }\n+\n+                // Fixes b/230492947\n+                // Prevents background activity launch through #startNextMatchingActivity\n+                // An activity going into the background could still go back to the foreground\n+                // if the intent used matches both:\n+                // - the activity in the background\n+                // - a second activity.\n+                options.getOptions(r).setAvoidMoveToFront();\n+                final int res = getActivityStartController()\n+                        .obtainStarter(intent, \"startNextMatchingActivity\")\n+                        .setCaller(r.app.getThread())\n+                        .setResolvedType(r.resolvedType)\n+                        .setActivityInfo(aInfo)\n+                        .setResultTo(resultTo != null ? resultTo.appToken : null)\n+                        .setResultWho(resultWho)\n+                        .setRequestCode(requestCode)\n+                        .setCallingPid(-1)\n+                        .setCallingUid(r.launchedFromUid)\n+                        .setCallingPackage(r.launchedFromPackage)\n+                        .setCallingFeatureId(r.launchedFromFeatureId)\n+                        .setRealCallingPid(-1)\n+                        .setRealCallingUid(r.launchedFromUid)\n+                        .setActivityOptions(options)\n+                        .execute();\n+                r.finishing = wasFinishing;\n+                return res == ActivityManager.START_SUCCESS;\n+            } finally {\n+                Binder.restoreCallingIdentity(origId);\n             }\n-            return true;\n         }\n     }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.9661,
      "normalized_edit_similarity": 0.9708,
      "token_level_edit_distance": 6,
      "codebert_score": {
        "precision": 0.9707,
        "recall": 0.9645,
        "f1": 0.9676,
        "f3": 0.9651
      },
      "token_count_upstream": 215,
      "token_count_downstream": 211,
      "token_count_total": 426,
      "cosine_similarity_openai": 0.9546
    }
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 127.33,
    "cleaned_ground_truth": "@@ -284,8 +284,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 11;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -4261,16 +4259,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -4319,11 +4319,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -4771,8 +4771,7 @@ public class UserManagerService extends IUserManager.Stub {\n             @UserIdInt int parentId, boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6373,9 +6372,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4979,7 +4979,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1304,
      "normalized_edit_similarity": 0.1097,
      "token_level_edit_distance": 132,
      "codebert_score": {
        "precision": 0.8612,
        "recall": 0.7053,
        "f1": 0.7755,
        "f3": 0.7183
      },
      "token_count_upstream": 290,
      "token_count_downstream": 36,
      "token_count_total": 326,
      "cosine_similarity_openai": 0.7033
    }
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 48.66,
    "cleaned_ground_truth": "@@ -248,8 +248,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3160,16 +3158,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3209,11 +3209,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -3576,8 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -4994,9 +4993,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4980,7 +4980,7 @@\n             @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int parentId,\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n-                    throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+                    throws UserManager.CheckedUserOperationException {\n+\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n```",
    "metrics": {
      "relative_line_count_similarity": 0.2029,
      "normalized_edit_similarity": 0.1341,
      "token_level_edit_distance": 151,
      "codebert_score": {
        "precision": 0.8575,
        "recall": 0.7522,
        "f1": 0.8014,
        "f3": 0.7616
      },
      "token_count_upstream": 297,
      "token_count_downstream": 67,
      "token_count_total": 364,
      "cosine_similarity_openai": 0.7345
    }
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 19.17,
    "cleaned_ground_truth": "@@ -248,8 +248,6 @@ public class UserManagerService extends IUserManager.Stub {\n \n     private static final int USER_VERSION = 9;\n \n-    private static final int MAX_USER_STRING_LENGTH = 500;\n-\n     private static final long EPOCH_PLUS_30_YEARS = 30L * 365 * 24 * 60 * 60 * 1000L; // ms\n \n     static final int WRITE_USER_MSG = 1;\n@@ -3160,16 +3158,18 @@ public class UserManagerService extends IUserManager.Stub {\n         if (userData.persistSeedData) {\n             if (userData.seedAccountName != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_NAME,\n-                        truncateString(userData.seedAccountName));\n+                        truncateString(userData.seedAccountName,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n             if (userData.seedAccountType != null) {\n                 serializer.attribute(null, ATTR_SEED_ACCOUNT_TYPE,\n-                        truncateString(userData.seedAccountType));\n+                        truncateString(userData.seedAccountType,\n+                                UserManager.MAX_ACCOUNT_STRING_LENGTH));\n             }\n         }\n         if (userInfo.name != null) {\n             serializer.startTag(null, TAG_NAME);\n-            serializer.text(truncateString(userInfo.name));\n+            serializer.text(truncateString(userInfo.name, UserManager.MAX_USER_NAME_LENGTH));\n             serializer.endTag(null, TAG_NAME);\n         }\n         synchronized (mRestrictionsLock) {\n@@ -3209,11 +3209,11 @@ public class UserManagerService extends IUserManager.Stub {\n         serializer.endDocument();\n     }\n \n-    private String truncateString(String original) {\n-        if (original == null || original.length() <= MAX_USER_STRING_LENGTH) {\n+    private String truncateString(String original, int limit) {\n+        if (original == null || original.length() <= limit) {\n             return original;\n         }\n-        return original.substring(0, MAX_USER_STRING_LENGTH);\n+        return original.substring(0, limit);\n     }\n \n     /*\n@@ -3576,8 +3576,7 @@ public class UserManagerService extends IUserManager.Stub {\n             boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n-\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             Slog.e(LOG_TAG, \"Cannot create user of invalid user type: \" + userType);\n@@ -4994,9 +4993,14 @@ public class UserManagerService extends IUserManager.Stub {\n                     Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n                     return;\n                 }\n-                userData.seedAccountName = truncateString(accountName);\n-                userData.seedAccountType = truncateString(accountType);\n-                userData.seedAccountOptions = accountOptions;\n+                userData.seedAccountName = truncateString(accountName,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                userData.seedAccountType = truncateString(accountType,\n+                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n+                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n+                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n+                    userData.seedAccountOptions = accountOptions;\n+                }\n                 userData.persistSeedData = persist;\n             }\n             if (persist) {",
    "cleaned_upstream_plus_llm": "@@ -4981,7 +4981,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n                     throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1304,
      "normalized_edit_similarity": 0.1069,
      "token_level_edit_distance": 8,
      "codebert_score": {
        "precision": 0.8473,
        "recall": 0.705,
        "f1": 0.7696,
        "f3": 0.717
      },
      "token_count_upstream": 297,
      "token_count_downstream": 36,
      "token_count_total": 333,
      "cosine_similarity_openai": 0.703
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 217.55,
    "cleaned_ground_truth": "@@ -3460,6 +3460,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3974,6 +3978,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4714,6 +4722,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 388,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 274,
      "token_count_downstream": 0,
      "token_count_total": 274,
      "cosine_similarity_openai": 0.058
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 44.34,
    "cleaned_ground_truth": "@@ -3436,6 +3436,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3950,6 +3954,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4644,6 +4652,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+            @Nullable String proxyPackageName,\n+            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -2353,6 +2353,36 @@\n         }\n         return false;\n     }\n+\n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n \n     void readState() {\n         int oldVersion = NO_VERSION;\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.6607,
      "normalized_edit_similarity": 0.5773,
      "token_level_edit_distance": 14,
      "codebert_score": {
        "precision": 0.8816,
        "recall": 0.8148,
        "f1": 0.8469,
        "f3": 0.8211
      },
      "token_count_upstream": 274,
      "token_count_downstream": 183,
      "token_count_total": 457,
      "cosine_similarity_openai": 0.694
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 61.66,
    "cleaned_ground_truth": "@@ -3436,6 +3436,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3950,6 +3954,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -4644,6 +4652,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+            @Nullable String proxyPackageName,\n+            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -2282,6 +2282,36 @@\n                 == PackageManager.PERMISSION_GRANTED;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n         UidState uidState = mUidStates.get(uid);\n         if (uidState == null) {\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.6607,
      "normalized_edit_similarity": 0.5361,
      "token_level_edit_distance": 35,
      "codebert_score": {
        "precision": 0.8633,
        "recall": 0.8194,
        "f1": 0.8408,
        "f3": 0.8236
      },
      "token_count_upstream": 274,
      "token_count_downstream": 192,
      "token_count_total": 466,
      "cosine_similarity_openai": 0.7204
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 232.13,
    "cleaned_ground_truth": "@@ -2640,6 +2640,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         synchronized (this) {\n             final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n@@ -3177,6 +3181,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n             return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                     packageName);\n         }\n+        if (proxyAttributionTag != null\n+                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n+            proxyAttributionTag = null;\n+        }\n \n         boolean isRestricted = false;\n         int startType = START_TYPE_FAILED;\n@@ -3909,6 +3917,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                            @Nullable String proxyPackageName,\n+                                            @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     /**\n      * Get (and potentially create) ops.\n      *",
    "cleaned_upstream_plus_llm": "@@ -2104,6 +2104,36 @@\n         return callingUid == Process.SYSTEM_UID\n                 || resolveUid(resolvedPackage) != Process.INVALID_UID;\n     }\n+\n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n```",
    "metrics": {
      "relative_line_count_similarity": 0.6607,
      "normalized_edit_similarity": 0.5644,
      "token_level_edit_distance": 42,
      "codebert_score": {
        "precision": 0.8624,
        "recall": 0.821,
        "f1": 0.8412,
        "f3": 0.825
      },
      "token_count_upstream": 274,
      "token_count_downstream": 191,
      "token_count_total": 465,
      "cosine_similarity_openai": 0.7205
    }
  },
  {
    "cve_id": "ASB-A-355411348",
    "downstream_version": "13",
    "file_name": "PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-283101289",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-283101289",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281666022",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281666022",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-283264674",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-283264674",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281665050",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281665050",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281534749",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281534749",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281848557",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281848557",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281533566",
    "downstream_version": "12L",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-281533566",
    "downstream_version": "12",
    "file_name": "services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java",
    "runtime_seconds": null,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "13",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "runtime_seconds": 278.5,
    "cleaned_ground_truth": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -48,6 +51,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -116,6 +120,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -247,6 +256,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 341,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 161,
      "token_count_downstream": 0,
      "token_count_total": 161,
      "cosine_similarity_openai": 0.0733
    }
  },
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "runtime_seconds": 126.24,
    "cleaned_ground_truth": "@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];",
    "cleaned_upstream_plus_llm": "@@ -32,4 +32,8 @@\n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n+import android.bluetooth.BluetoothProfile;\n+import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n import android.content.Context;\n@@ -50,4 +54,5 @@\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.3182,
      "normalized_edit_similarity": 0.2434,
      "token_level_edit_distance": 217,
      "codebert_score": {
        "precision": 0.8831,
        "recall": 0.693,
        "f1": 0.7766,
        "f3": 0.7083
      },
      "token_count_upstream": 161,
      "token_count_downstream": 31,
      "token_count_total": 192,
      "cosine_similarity_openai": 0.698
    }
  },
  {
    "cve_id": "ASB-A-366401629",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
    "runtime_seconds": 75.72,
    "cleaned_ground_truth": "@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "cleaned_upstream_plus_llm": "@@ -17,6 +17,7 @@\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1569,
      "normalized_edit_similarity": 0.1269,
      "token_level_edit_distance": 343,
      "codebert_score": {
        "precision": 0.9381,
        "recall": 0.5947,
        "f1": 0.7279,
        "f3": 0.6173
      },
      "token_count_upstream": 254,
      "token_count_downstream": 17,
      "token_count_total": 271,
      "cosine_similarity_openai": 0.6412
    }
  },
  {
    "cve_id": "ASB-A-366401629",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
    "runtime_seconds": 4.06,
    "cleaned_ground_truth": "@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "cleaned_upstream_plus_llm": "@@ -15,6 +15,7 @@\n package com.android.settings.accounts;\n \n import android.accounts.Account;\n+import android.content.ContentResolver;\n import android.accounts.AuthenticatorDescription;\n import android.content.Context;\n import android.content.Intent;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1569,
      "normalized_edit_similarity": 0.1193,
      "token_level_edit_distance": 36,
      "codebert_score": {
        "precision": 0.939,
        "recall": 0.6023,
        "f1": 0.7339,
        "f3": 0.6247
      },
      "token_count_upstream": 254,
      "token_count_downstream": 17,
      "token_count_total": 271,
      "cosine_similarity_openai": 0.6617
    }
  },
  {
    "cve_id": "ASB-A-366401629",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/accounts/AccountTypePreferenceLoader.java",
    "runtime_seconds": 42.69,
    "cleaned_ground_truth": "@@ -19,6 +19,8 @@ package com.android.settings.accounts;\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ClipData;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n@@ -177,13 +179,16 @@ public class AccountTypePreferenceLoader {\n                                  * exploiting the fact that settings has system privileges.\n                                  */\n                             if (isSafeIntent(pm, prefIntent, acccountType)) {\n+                                // Explicitly set an empty ClipData to ensure that we don't offer to\n+                                // promote any Uris contained inside for granting purposes\n+                                prefIntent.setClipData(ClipData.newPlainText(null, null));\n                                 mFragment.getActivity().startActivityAsUser(\n                                     prefIntent, mUserHandle);\n                             } else {\n                                 Log.e(TAG,\n-                                    \"Refusing to launch authenticator intent because\"\n-                                        + \"it exploits Settings permissions: \"\n-                                        + prefIntent);\n+                                        \"Refusing to launch authenticator intent because \"\n+                                                + \"it exploits Settings permissions: \"\n+                                                + prefIntent);\n                             }\n                             return true;\n                         }\n@@ -237,13 +242,19 @@ public class AccountTypePreferenceLoader {\n     }\n \n     /**\n-     * Determines if the supplied Intent is safe. A safe intent is one that is\n-     * will launch a exported=true activity or owned by the same uid as the\n+     * Determines if the supplied Intent is safe. A safe intent is one that\n+     * will launch an exported=true activity or owned by the same uid as the\n      * authenticator supplying the intent.\n      */\n-    private boolean isSafeIntent(PackageManager pm, Intent intent, String acccountType) {\n+    @VisibleForTesting\n+    boolean isSafeIntent(PackageManager pm, Intent intent, String accountType) {\n+        if (TextUtils.equals(intent.getScheme(), ContentResolver.SCHEME_CONTENT)) {\n+            Log.e(TAG, \"Intent with a content scheme is unsafe.\");\n+            return false;\n+        }\n+\n         AuthenticatorDescription authDesc =\n-            mAuthenticatorHelper.getAccountTypeDescription(acccountType);\n+                mAuthenticatorHelper.getAccountTypeDescription(accountType);\n         ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());\n         if (resolveInfo == null) {\n             return false;",
    "cleaned_upstream_plus_llm": "@@ -17,6 +17,7 @@\n \n import android.accounts.Account;\n import android.accounts.AuthenticatorDescription;\n+import android.content.ContentResolver;\n import android.content.Context;\n import android.content.Intent;\n import android.content.pm.ActivityInfo;\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1569,
      "normalized_edit_similarity": 0.1269,
      "token_level_edit_distance": 343,
      "codebert_score": {
        "precision": 0.9379,
        "recall": 0.5941,
        "f1": 0.7274,
        "f3": 0.6167
      },
      "token_count_upstream": 254,
      "token_count_downstream": 17,
      "token_count_total": 271,
      "cosine_similarity_openai": 0.6391
    }
  },
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "runtime_seconds": 61.88,
    "cleaned_ground_truth": "@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();",
    "cleaned_upstream_plus_llm": "@@ -26,9 +26,12 @@\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1765,
      "normalized_edit_similarity": 0.1736,
      "token_level_edit_distance": 514,
      "codebert_score": {
        "precision": 0.9386,
        "recall": 0.669,
        "f1": 0.7812,
        "f3": 0.6888
      },
      "token_count_upstream": 310,
      "token_count_downstream": 31,
      "token_count_total": 341,
      "cosine_similarity_openai": 0.6337
    }
  },
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "runtime_seconds": 59.25,
    "cleaned_ground_truth": "@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();",
    "cleaned_upstream_plus_llm": "@@ -22,10 +22,13 @@\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1882,
      "normalized_edit_similarity": 0.1851,
      "token_level_edit_distance": 498,
      "codebert_score": {
        "precision": 0.9546,
        "recall": 0.6788,
        "f1": 0.7934,
        "f3": 0.699
      },
      "token_count_upstream": 310,
      "token_count_downstream": 33,
      "token_count_total": 343,
      "cosine_similarity_openai": 0.6446
    }
  },
  {
    "cve_id": "ASB-A-317203980",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/media/MediaSessionRecord.java",
    "runtime_seconds": 110.04,
    "cleaned_ground_truth": "@@ -973,6 +973,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    Log.w(\n+                            TAG,\n+                            \"Ignoring invalid media button receiver targeting an activity: \" + pi);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);",
    "cleaned_upstream_plus_llm": "@@ -67,6 +67,15 @@\n  */\n // TODO(jaewan): Do not call service method directly -- introduce listener instead.\n public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8667,
      "normalized_edit_similarity": 0.1757,
      "token_level_edit_distance": 126,
      "codebert_score": {
        "precision": 0.6848,
        "recall": 0.7668,
        "f1": 0.7235,
        "f3": 0.7577
      },
      "token_count_upstream": 51,
      "token_count_downstream": 102,
      "token_count_total": 153,
      "cosine_similarity_openai": 0.7272
    }
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 11.86,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -772,7 +772,12 @@\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n-  uint16_t msg_len =\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n+  uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n@@ -805,6 +810,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.5854,
      "normalized_edit_similarity": 0.3776,
      "token_level_edit_distance": 212,
      "codebert_score": {
        "precision": 0.9317,
        "recall": 0.8821,
        "f1": 0.9062,
        "f3": 0.8868
      },
      "token_count_upstream": 204,
      "token_count_downstream": 97,
      "token_count_total": 301,
      "cosine_similarity_openai": 0.8117
    }
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 222.97,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 331,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 204,
      "token_count_downstream": 0,
      "token_count_total": 204,
      "cosine_similarity_openai": 0.1034
    }
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 115.27,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -773,6 +773,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -804,6 +809,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.5122,
      "normalized_edit_similarity": 0.3505,
      "token_level_edit_distance": 196,
      "codebert_score": {
        "precision": 0.9285,
        "recall": 0.8448,
        "f1": 0.8847,
        "f3": 0.8525
      },
      "token_count_upstream": 204,
      "token_count_downstream": 81,
      "token_count_total": 285,
      "cosine_similarity_openai": 0.7963
    }
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 11.64,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -772,7 +772,12 @@\n     }\n   }\n \n-  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -805,6 +810,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.5854,
      "normalized_edit_similarity": 0.3656,
      "token_level_edit_distance": 222,
      "codebert_score": {
        "precision": 0.9272,
        "recall": 0.8501,
        "f1": 0.887,
        "f3": 0.8572
      },
      "token_count_upstream": 204,
      "token_count_downstream": 90,
      "token_count_total": 294,
      "cosine_similarity_openai": 0.7856
    }
  },
  {
    "cve_id": "ASB-A-277207798",
    "downstream_version": "13",
    "file_name": "core/java/com/android/internal/app/ChooserActivity.java",
    "runtime_seconds": 52.63,
    "cleaned_ground_truth": "@@ -16,6 +16,7 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n \n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -32,7 +33,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -68,6 +71,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -77,6 +81,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -663,7 +668,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4038,4 +4047,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }",
    "cleaned_upstream_plus_llm": "@@ -14,6 +14,7 @@\n\n package com.android.internal.app;\n\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n\n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -29,7 +30,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.1818,
      "normalized_edit_similarity": 0.2197,
      "token_level_edit_distance": 476,
      "codebert_score": {
        "precision": 0.9642,
        "recall": 0.7323,
        "f1": 0.8324,
        "f3": 0.7503
      },
      "token_count_upstream": 275,
      "token_count_downstream": 40,
      "token_count_total": 315,
      "cosine_similarity_openai": 0.7427
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "14",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 177.74,
    "cleaned_ground_truth": "@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -230,9 +230,9 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n-            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n+                    permission.getName(), permission.isGranted());\n+            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.9231,
      "normalized_edit_similarity": 0.8201,
      "token_level_edit_distance": 19,
      "codebert_score": {
        "precision": 0.9459,
        "recall": 0.9276,
        "f1": 0.9367,
        "f3": 0.9294
      },
      "token_count_upstream": 60,
      "token_count_downstream": 68,
      "token_count_total": 128,
      "cosine_similarity_openai": 0.9268
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "13",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 207.21,
    "cleaned_ground_truth": "@@ -257,11 +257,11 @@ public final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }",
    "cleaned_upstream_plus_llm": "@@ -226,11 +226,11 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                     group.getPackageName(),\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n-            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n+                    permission.getName(), permission.isGranted());\n+            Log.i(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                     + group.getPackageName() + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.8462,
      "normalized_edit_similarity": 0.8429,
      "token_level_edit_distance": 22,
      "codebert_score": {
        "precision": 0.9476,
        "recall": 0.9293,
        "f1": 0.9384,
        "f3": 0.9311
      },
      "token_count_upstream": 60,
      "token_count_downstream": 69,
      "token_count_total": 129,
      "cosine_similarity_openai": 0.9233
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "12",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 116.72,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -270,11 +270,11 @@\n \n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + group.getApp().applicationInfo.uid + \" packageName=\"\n                     + group.getApp().packageName + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 131,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 55,
      "token_count_total": 55,
      "cosine_similarity_openai": 0.0579
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "12L",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "runtime_seconds": 169.97,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -226,10 +226,10 @@\n             PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                     changeId, group.getApp().applicationInfo.uid, group.getApp().packageName,\n-                    permission.getName(), permission.isGrantedIncludingAppOp());\n+                    permission.getName(), permission.isGranted());\n             Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                     + group.getApp().applicationInfo.uid + \" packageName=\"\n                     + group.getApp().packageName + \" permission=\"\n-                    + permission.getName() + \" granted=\" + permission.isGrantedIncludingAppOp());\n+                    + permission.getName() + \" granted=\" + permission.isGranted());\n         }\n     }\n  \n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 131,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 55,
      "token_count_total": 55,
      "cosine_similarity_openai": 0.0514
    }
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "runtime_seconds": 147.87,
    "cleaned_ground_truth": "@@ -1189,8 +1189,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                 callerActivityToken, caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "cleaned_upstream_plus_llm": "@@ -1527,10 +1527,12 @@\n                 final IBinder callerActivityToken = operation.getActivityToken();\n                 final Intent activityIntent = operation.getActivityIntent();\n                 final Bundle activityOptions = operation.getBundle();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n-                                callerActivityToken, caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n+                                callerActivityToken, caller.mUid, caller.mPid,\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                             opType, convertStartFailureToThrowable(result, activityIntent));\n```",
    "metrics": {
      "relative_line_count_similarity": 0.5,
      "normalized_edit_similarity": 0.5123,
      "token_level_edit_distance": 77,
      "codebert_score": {
        "precision": 0.8766,
        "recall": 0.8973,
        "f1": 0.8869,
        "f3": 0.8952
      },
      "token_count_upstream": 52,
      "token_count_downstream": 72,
      "token_count_total": 124,
      "cosine_similarity_openai": 0.8857
    }
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "runtime_seconds": 99.02,
    "cleaned_ground_truth": "@@ -722,8 +722,10 @@ class WindowOrganizerController extends IWindowOrganizerController.Stub\n                 }\n                 final Intent activityIntent = hop.getActivityIntent();\n                 final Bundle activityOptions = hop.getLaunchOptions();\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                 final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n                                 errorCallbackToken);\n                 if (!isStartResultSuccessful(result)) {",
    "cleaned_upstream_plus_llm": "@@ -676,10 +676,12 @@\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken, exception);\n                     break;\n                 }\n-                final Intent activityIntent = hop.getActivityIntent();\n-                final Bundle activityOptions = hop.getLaunchOptions();\n-                final int result = mService.getActivityStartController()\n-                        .startActivityInTaskFragment(tf, activityIntent, activityOptions,\n+                final Intent activityIntent = hop.getActivityIntent(); // Original line 677\n+                final Bundle activityOptions = hop.getLaunchOptions(); // Original line 678\n+                final SafeActivityOptions safeOptions =\n+                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n+                final int result = waitAsyncStart(() -> mService.getActivityStartController()\n+                        .startActivityInTaskFragment(tf, activityIntent, safeOptions,\n                                 hop.getCallingActivity(), caller.mUid, caller.mPid,\n-                                errorCallbackToken);\n+                                errorCallbackToken));\n                 if (!isStartResultSuccessful(result)) {\n                     sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                             convertStartFailureToThrowable(result, activityIntent));\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.25,
      "normalized_edit_similarity": 0.4565,
      "token_level_edit_distance": 104,
      "codebert_score": {
        "precision": 0.835,
        "recall": 0.8783,
        "f1": 0.8561,
        "f3": 0.8738
      },
      "token_count_upstream": 48,
      "token_count_downstream": 87,
      "token_count_total": 135,
      "cosine_similarity_openai": 0.8645
    }
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 269.53,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 331,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 204,
      "token_count_downstream": 0,
      "token_count_total": 204,
      "cosine_similarity_openai": 0.1037
    }
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 64.07,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -697,6 +697,11 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -822,6 +827,12 @@\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.5366,
      "normalized_edit_similarity": 0.3565,
      "token_level_edit_distance": 204,
      "codebert_score": {
        "precision": 0.9296,
        "recall": 0.8507,
        "f1": 0.8884,
        "f3": 0.858
      },
      "token_count_upstream": 204,
      "token_count_downstream": 82,
      "token_count_total": 286,
      "cosine_similarity_openai": 0.8021
    }
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "13",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 91.53,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "@@ -769,6 +769,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n \n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.5366,
      "normalized_edit_similarity": 0.4169,
      "token_level_edit_distance": 193,
      "codebert_score": {
        "precision": 0.959,
        "recall": 0.9016,
        "f1": 0.9294,
        "f3": 0.907
      },
      "token_count_upstream": 204,
      "token_count_downstream": 93,
      "token_count_total": 297,
      "cosine_similarity_openai": 0.9261
    }
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "runtime_seconds": 335.89,
    "cleaned_ground_truth": "@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 331,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 204,
      "token_count_downstream": 0,
      "token_count_total": 204,
      "cosine_similarity_openai": 0.1031
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 74.74,
    "cleaned_ground_truth": "@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -462,10 +462,10 @@\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n             removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n \n             final EnforcedAdmin disallowRemoveUserAdmin =\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8,
      "normalized_edit_similarity": 0.8083,
      "token_level_edit_distance": 18,
      "codebert_score": {
        "precision": 0.9141,
        "recall": 0.9379,
        "f1": 0.9259,
        "f3": 0.9355
      },
      "token_count_upstream": 52,
      "token_count_downstream": 52,
      "token_count_total": 104,
      "cosine_similarity_openai": 0.8974
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "13",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 70.5,
    "cleaned_ground_truth": "@@ -380,8 +380,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -340,7 +340,7 @@\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n         if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+                && mGuestUserAutoCreated && !mUserManager.isProfile())) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
    "metrics": {
      "relative_line_count_similarity": 0.9091,
      "normalized_edit_similarity": 0.7537,
      "token_level_edit_distance": 21,
      "codebert_score": {
        "precision": 0.9367,
        "recall": 0.8975,
        "f1": 0.9167,
        "f3": 0.9012
      },
      "token_count_upstream": 67,
      "token_count_downstream": 51,
      "token_count_total": 118,
      "cosine_similarity_openai": 0.871
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 96.74,
    "cleaned_ground_truth": "@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -316,9 +316,9 @@\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()) && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8182,
      "normalized_edit_similarity": 0.7917,
      "token_level_edit_distance": 41,
      "codebert_score": {
        "precision": 0.9147,
        "recall": 0.9367,
        "f1": 0.9256,
        "f3": 0.9345
      },
      "token_count_upstream": 67,
      "token_count_downstream": 70,
      "token_count_total": 137,
      "cosine_similarity_openai": 0.8594
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "runtime_seconds": 51.62,
    "cleaned_ground_truth": "@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));",
    "cleaned_upstream_plus_llm": "@@ -466,10 +466,10 @@\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n         if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+                && mGuestUserAutoCreated) && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n             removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n \n             final EnforcedAdmin disallowRemoveUserAdmin =\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.9091,
      "normalized_edit_similarity": 0.6567,
      "token_level_edit_distance": 35,
      "codebert_score": {
        "precision": 0.8919,
        "recall": 0.8927,
        "f1": 0.8923,
        "f3": 0.8926
      },
      "token_count_upstream": 67,
      "token_count_downstream": 56,
      "token_count_total": 123,
      "cosine_similarity_openai": 0.8659
    }
  },
  {
    "cve_id": "ASB-A-370840874",
    "downstream_version": "12L",
    "file_name": "libs/binder/Parcel.cpp",
    "runtime_seconds": null,
    "cleaned_ground_truth": "@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 240,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 143,
      "token_count_downstream": 0,
      "token_count_total": 143,
      "cosine_similarity_openai": 0.0996
    }
  },
  {
    "cve_id": "ASB-A-370840874",
    "downstream_version": "12",
    "file_name": "libs/binder/Parcel.cpp",
    "runtime_seconds": null,
    "cleaned_ground_truth": "@@ -796,6 +796,10 @@ restart_write:\n         //printf(\"Writing %ld bytes, padded to %ld\\n\", len, padded);\n         uint8_t* const data = mData+mDataPos;\n \n+        if (status_t status = validateReadData(mDataPos + padded); status != OK) {\n+            return nullptr; // drops status\n+        }\n+\n         // Need to pad at end?\n         if (padded != len) {\n #if BYTE_ORDER == BIG_ENDIAN\n@@ -1313,6 +1317,10 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)\n     const bool enoughObjects = mObjectsSize < mObjectsCapacity;\n     if (enoughData && enoughObjects) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;\n \n         // remember if it's a file descriptor\n@@ -1505,6 +1513,10 @@ status_t Parcel::writeAligned(T val) {\n \n     if ((mDataPos+sizeof(val)) <= mDataCapacity) {\n restart_write:\n+        if (status_t status = validateReadData(mDataPos + sizeof(val)); status != OK) {\n+            return status;\n+        }\n+\n         *reinterpret_cast<T*>(mData+mDataPos) = val;\n         return finishWrite(sizeof(val));\n     }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 240,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 143,
      "token_count_downstream": 0,
      "token_count_total": 143,
      "cosine_similarity_openai": 0.1001
    }
  },
  {
    "cve_id": "ASB-A-289375038",
    "downstream_version": "13",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 211.37,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -11,6 +11,7 @@\n\n package com.android.bluetooth.btservice;\n\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 62,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 19,
      "token_count_total": 19,
      "cosine_similarity_openai": 0.1248
    }
  },
  {
    "cve_id": "ASB-A-289375038",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 96.15,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -14,6 +14,7 @@\n package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n@@ -2319,6 +2320,11 @@\n                 debugLog(\"Stack initiated unbond for \" + device.getAddress() + \" , reason: \"\n                         + unbondReason);\n             }\n+\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n         }\n \n         deviceProp.setBondState(newState);\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 133,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 58,
      "token_count_total": 58,
      "cosine_similarity_openai": 0.1102
    }
  },
  {
    "cve_id": "ASB-A-369351375",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 104.02,
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5083,14 +5083,15 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8148,
      "normalized_edit_similarity": 0.5121,
      "token_level_edit_distance": 50,
      "codebert_score": {
        "precision": 0.8822,
        "recall": 0.8264,
        "f1": 0.8534,
        "f3": 0.8316
      },
      "token_count_upstream": 93,
      "token_count_downstream": 80,
      "token_count_total": 173,
      "cosine_similarity_openai": 0.8914
    }
  },
  {
    "cve_id": "ASB-A-369351375",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 329.5,
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5084,14 +5084,15 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8148,
      "normalized_edit_similarity": 0.5217,
      "token_level_edit_distance": 48,
      "codebert_score": {
        "precision": 0.8788,
        "recall": 0.8253,
        "f1": 0.8512,
        "f3": 0.8303
      },
      "token_count_upstream": 93,
      "token_count_downstream": 80,
      "token_count_total": 173,
      "cosine_similarity_openai": 0.8943
    }
  },
  {
    "cve_id": "ASB-A-360846772",
    "downstream_version": "12L",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 345.8,
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5088,11 +5088,12 @@\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n             if (!intent.filterEquals(simulateIntent)) {\n```",
    "metrics": {
      "relative_line_count_similarity": 0.7037,
      "normalized_edit_similarity": 0.4976,
      "token_level_edit_distance": 49,
      "codebert_score": {
        "precision": 0.8821,
        "recall": 0.82,
        "f1": 0.85,
        "f3": 0.8258
      },
      "token_count_upstream": 93,
      "token_count_downstream": 76,
      "token_count_total": 169,
      "cosine_similarity_openai": 0.8931
    }
  },
  {
    "cve_id": "ASB-A-360846772",
    "downstream_version": "12",
    "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
    "runtime_seconds": 224.07,
    "cleaned_ground_truth": "@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }",
    "cleaned_upstream_plus_llm": "@@ -5086,14 +5086,16 @@\n             p.setDataPosition(0);\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n-            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n-            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n+            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n+            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n+                    Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
    "metrics": {
      "relative_line_count_similarity": 0.8519,
      "normalized_edit_similarity": 0.5169,
      "token_level_edit_distance": 49,
      "codebert_score": {
        "precision": 0.8832,
        "recall": 0.827,
        "f1": 0.8542,
        "f3": 0.8323
      },
      "token_count_upstream": 93,
      "token_count_downstream": 81,
      "token_count_total": 174,
      "cosine_similarity_openai": 0.8923
    }
  },
  {
    "cve_id": "ASB-A-289811388",
    "downstream_version": "13",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 174.93,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -13,6 +13,7 @@\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\n import static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\n import static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 79,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 23,
      "token_count_total": 23,
      "cosine_similarity_openai": 0.1215
    }
  },
  {
    "cve_id": "ASB-A-289811388",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "runtime_seconds": 226.68,
    "cleaned_ground_truth": "",
    "cleaned_upstream_plus_llm": "@@ -12,5 +12,6 @@ package com.android.bluetooth.btservice;\n \n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n import static android.text.format.DateUtils.SECOND_IN_MILLIS;\n \n```",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 62,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 19,
      "token_count_total": 19,
      "cosine_similarity_openai": 0.1256
    }
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "13",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 404.72,
    "cleaned_ground_truth": "@@ -699,7 +699,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -3336,7 +3336,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             verifyAndGetBypass(uid, packageName, null);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName) && !filterAppAccessUnlocked(packageName))) {\n                 return AppOpsManager.MODE_ALLOWED;\n             }\n@@ -3460,7 +3460,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3979,7 +3979,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -4442,7 +4442,11 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -4580,11 +4584,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n+    }\n+\n+    /**\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n+     */\n+    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -4595,13 +4608,16 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n+     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n+            boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n             return new PackageVerificationResult(null,\n@@ -4645,31 +4661,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n-        }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n-                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n+            nonAppUid = resolveNonAppUid(packageName);\n+        }\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n+                if (!suppressErrorLogs) {\n+                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n+                }\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -5536,7 +5568,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -6720,7 +6752,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -7165,7 +7203,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return -1;\n         }",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 1495,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 1015,
      "token_count_downstream": 0,
      "token_count_total": 1015,
      "cosine_similarity_openai": 0.071
    }
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 141.41,
    "cleaned_ground_truth": "@@ -589,7 +589,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    /** Returned from {@link #verifyAndGetBypass(int, String, String, String, boolean)}. */\n+    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n     private static final class PackageVerificationResult {\n \n         final RestrictionBypass bypass;\n@@ -2503,10 +2503,10 @@ public class AppOpsService extends IAppOpsService.Stub {\n     public int checkPackage(int uid, String packageName) {\n         Objects.requireNonNull(packageName);\n         try {\n-            verifyAndGetBypass(uid, packageName, null, null, true);\n+            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n             // When the caller is the system, it's possible that the packageName is the special\n             // one (e.g., \"root\") which isn't actually existed.\n-            if (resolveUid(packageName) == uid\n+            if (resolveNonAppUid(packageName) == uid\n                     || (isPackageExisted(packageName)\n                             && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                 return AppOpsManager.MODE_ALLOWED;\n@@ -2636,7 +2636,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n@@ -3178,7 +3178,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             int attributionChainId, boolean dryRun) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n             }\n@@ -3671,13 +3671,17 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n         final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n         return callingUid == Process.SYSTEM_UID\n-                || resolveUid(resolvedPackage) != Process.INVALID_UID;\n+                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n     }\n \n     private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n         if (attributionSource.getUid() != Binder.getCallingUid()\n                 && attributionSource.isTrusted(mContext)) {\n-            return true;\n+            // if there is a next attribution source, it must be trusted, as well.\n+            if (attributionSource.getNext() == null\n+                    || attributionSource.getNext().isTrusted(mContext)) {\n+                return true;\n+            }\n         }\n         return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                 Binder.getCallingPid(), Binder.getCallingUid(), null)\n@@ -3760,19 +3764,20 @@ public class AppOpsService extends IAppOpsService.Stub {\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n             @Nullable String attributionTag) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, null);\n+        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n     }\n \n     /**\n-     * @see #verifyAndGetBypass(int, String, String, String, boolean)\n+     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName) {\n-        return verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName, false);\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n+        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n+                false);\n     }\n \n     /**\n@@ -3783,14 +3788,15 @@ public class AppOpsService extends IAppOpsService.Stub {\n      * @param uid The uid the package belongs to\n      * @param packageName The package the might belong to the uid\n      * @param attributionTag attribution tag or {@code null} if no need to verify\n-     * @param proxyPackageName The proxy package, from which the attribution tag is to be pulled\n+     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n+     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n      * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n      *\n      * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n      *         attribution tag is valid\n      */\n     private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n-            @Nullable String attributionTag, @Nullable String proxyPackageName,\n+            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n             boolean suppressErrorLogs) {\n         if (uid == Process.ROOT_UID) {\n             // For backwards compatibility, don't check package name for root UID.\n@@ -3834,34 +3840,47 @@ public class AppOpsService extends IAppOpsService.Stub {\n \n         int callingUid = Binder.getCallingUid();\n \n-        // Allow any attribution tag for resolvable uids\n-        int pkgUid;\n+        // Allow any attribution tag for resolvable, non-app uids\n+        int nonAppUid;\n         if (Objects.equals(packageName, \"com.android.shell\")) {\n             // Special case for the shell which is a package but should be able\n             // to bypass app attribution tag restrictions.\n-            pkgUid = Process.SHELL_UID;\n+            nonAppUid = Process.SHELL_UID;\n         } else {\n-            pkgUid = resolveUid(packageName);\n+            nonAppUid = resolveNonAppUid(packageName);\n         }\n-        if (pkgUid != Process.INVALID_UID) {\n-            if (pkgUid != UserHandle.getAppId(uid)) {\n+        if (nonAppUid != Process.INVALID_UID) {\n+            if (nonAppUid != UserHandle.getAppId(uid)) {\n                 if (!suppressErrorLogs) {\n                     Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n-                            + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n-                            + \".\");\n+                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n+                                + \".\");\n+                }\n+                String otherUidMessage =\n+                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n+                throw new SecurityException(\"Specified package \\\"\" + packageName\n+                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n+            }\n+            // We only allow bypassing the attribution tag verification if the proxy is a\n+            // system app (or is null), in order to prevent abusive apps clogging the appops\n+            // system with unlimited attribution tags via proxy calls.\n+            boolean proxyIsSystemAppOrNull = true;\n+            if (proxyPackageName != null) {\n+                int proxyAppId = UserHandle.getAppId(proxyUid);\n+                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n+                    proxyIsSystemAppOrNull =\n+                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                 }\n-                String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n-                throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \"\n-                        +  UserHandle.getAppId(uid) + otherUidMessage);\n             }\n             return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n-                    /* isAttributionTagValid */ true);\n+                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n         }\n \n         int userId = UserHandle.getUserId(uid);\n         RestrictionBypass bypass = null;\n         boolean isAttributionTagValid = false;\n \n+        int pkgUid = nonAppUid;\n         final long ident = Binder.clearCallingIdentity();\n         try {\n             PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n@@ -4613,7 +4632,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n             if (nonpackageUid != -1) {\n                 packageName = null;\n             } else {\n-                packageUid = resolveUid(packageName);\n+                packageUid = resolveNonAppUid(packageName);\n                 if (packageUid < 0) {\n                     packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                             PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n@@ -5628,7 +5647,13 @@ public class AppOpsService extends IAppOpsService.Stub {\n                 if (restricted && attrOp.isRunning()) {\n                     attrOp.pause();\n                 } else if (attrOp.isPaused()) {\n-                    attrOp.resume();\n+                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n+                            .bypass;\n+                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n+                            bypass, false)) {\n+                        // Only resume if there are no other restrictions remaining on this op\n+                        attrOp.resume();\n+                    }\n                 }\n             }\n         }\n@@ -6077,7 +6102,7 @@ public class AppOpsService extends IAppOpsService.Stub {\n         }\n     }\n \n-    private static int resolveUid(String packageName)  {\n+    private static int resolveNonAppUid(String packageName)  {\n         if (packageName == null) {\n             return Process.INVALID_UID;\n         }",
    "cleaned_upstream_plus_llm": "@@ -1727,7 +1727,7 @@\n             boolean shouldCollectMessage) {\n         PackageVerificationResult pvr;\n         try {\n-            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n+            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n             boolean wasNull = attributionTag == null;\n             if (!pvr.isAttributionTagValid) {\n                 attributionTag = null;\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.0538,
      "normalized_edit_similarity": 0.0398,
      "token_level_edit_distance": 1546,
      "codebert_score": {
        "precision": 0.8909,
        "recall": 0.689,
        "f1": 0.7771,
        "f3": 0.705
      },
      "token_count_upstream": 1059,
      "token_count_downstream": 39,
      "token_count_total": 1098,
      "cosine_similarity_openai": 0.6596
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "12",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 348.53,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 670,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 457,
      "token_count_downstream": 0,
      "token_count_total": 457,
      "cosine_similarity_openai": 0.0457
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "12L",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 389.34,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 670,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 457,
      "token_count_downstream": 0,
      "token_count_total": 457,
      "cosine_similarity_openai": 0.0465
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "13",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 168.83,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "@@ -17,6 +17,7 @@\n import static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n \n import android.annotation.UserIdInt;\n+import android.annotation.NonNull;\n import android.app.ActivityManager;\n import android.app.ActivityManagerInternal;\n import android.app.AlarmManager;\n@@ -149,6 +150,15 @@\n     // Bump if the stored widgets need to be upgraded.\n     private static final int CURRENT_VERSION = 1;\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     // Every widget update request is associated which an increasing sequence number. This is\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n@@ -1846,10 +1856,31 @@\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(@NonNull final Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.\n\n```",
    "metrics": {
      "relative_line_count_similarity": 0.6835,
      "normalized_edit_similarity": 0.4627,
      "token_level_edit_distance": 303,
      "codebert_score": {
        "precision": 0.8828,
        "recall": 0.871,
        "f1": 0.8768,
        "f3": 0.8722
      },
      "token_count_upstream": 457,
      "token_count_downstream": 319,
      "token_count_total": 776,
      "cosine_similarity_openai": 0.8759
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "14",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "runtime_seconds": 294.93,
    "cleaned_ground_truth": "@@ -170,6 +170,15 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n     // used to verify which request has successfully been received by the host.\n     private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n \n+    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n+    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n+    // surfaces in the host app.\n+    // @see AppWidgetHost\n+    // @see AppWidgetHost#mHostId\n+    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n+    // Hard limit of number of widgets can be pinned by a host.\n+    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n+\n     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n@@ -1698,7 +1707,7 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         if (host != null) {\n             return host;\n         }\n-\n+        ensureHostCountBeforeAddLocked(id);\n         host = new Host();\n         host.id = id;\n         mHosts.add(host);\n@@ -1706,6 +1715,24 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n         return host;\n     }\n \n+    /**\n+     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n+     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n+     * removes the oldest host.\n+     */\n+    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n+        final List<Host> hosts = new ArrayList<>();\n+        for (Host host : mHosts) {\n+            if (host.id.uid == hostId.uid\n+                    && host.id.packageName.equals(hostId.packageName)) {\n+                hosts.add(host);\n+            }\n+        }\n+        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n+            deleteHostLocked(hosts.remove(0));\n+        }\n+    }\n+\n     private void deleteHostLocked(Host host) {\n         final int N = host.widgets.size();\n         for (int i = N - 1; i >= 0; i--) {\n@@ -2833,11 +2860,32 @@ class AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBacku\n      * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n      */\n     void addWidgetLocked(Widget widget) {\n+        ensureWidgetCountBeforeAddLocked(widget);\n         mWidgets.add(widget);\n \n         onWidgetProviderAddedOrChangedLocked(widget);\n     }\n \n+    /**\n+     * Ensures that the widget count for the widget's host is not greater than the maximum\n+     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n+     * from the host until the count is less than or equal to the maximum.\n+     */\n+    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n+        if (widget.host == null || widget.host.id == null) {\n+            return;\n+        }\n+        final List<Widget> widgetsInSameHost = new ArrayList<>();\n+        for (Widget w : mWidgets) {\n+            if (w.host != null && widget.host.id.equals(w.host.id)) {\n+                widgetsInSameHost.add(w);\n+            }\n+        }\n+        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n+            removeWidgetLocked(widgetsInSameHost.remove(0));\n+        }\n+    }\n+\n     /**\n      * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n      * that have bound widgets.",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 670,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 457,
      "token_count_downstream": 0,
      "token_count_total": 457,
      "cosine_similarity_openai": 0.0459
    }
  },
  {
    "cve_id": "ASB-A-382064697",
    "downstream_version": "14",
    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
    "runtime_seconds": 564.87,
    "cleaned_ground_truth": "@@ -2663,13 +2663,14 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n      * Apply default restrictions that haven't been applied to a given admin yet.\n      */\n     private void maybeSetDefaultRestrictionsForAdminLocked(int userId, ActiveAdmin admin) {\n-        Set<String> defaultRestrictions =\n-                UserRestrictionsUtils.getDefaultEnabledForManagedProfiles();\n-        if (defaultRestrictions.equals(admin.defaultEnabledRestrictionsAlreadySet)) {\n+        final Set<String> restrictionsToSet =\n+            new ArraySet<>(UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n+        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n+        if (restrictionsToSet.isEmpty()) {\n             return; // The same set of default restrictions has been already applied.\n         }\n         if (isPolicyEngineForFinanceFlagEnabled()) {\n-            for (String restriction : defaultRestrictions) {\n+            for (String restriction : restrictionsToSet) {\n                 mDevicePolicyEngine.setLocalPolicy(\n                         PolicyDefinition.getPolicyDefinitionForUserRestriction(restriction),\n                         EnforcingAdmin.createEnterpriseEnforcingAdmin(\n@@ -2678,9 +2679,9 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                         new BooleanPolicyValue(true),\n                         userId);\n             }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(defaultRestrictions);\n+            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n             Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" +\n-                    defaultRestrictions);\n+                    restrictionsToSet);\n             return;\n         }\n \n@@ -2688,21 +2689,16 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n \n         if (VERBOSE_LOG) {\n             Slogf.d(LOG_TAG, \"Default enabled restrictions: \"\n-                    + defaultRestrictions\n+                    + restrictionsToSet\n                     + \". Restrictions already enabled: \"\n                     + admin.defaultEnabledRestrictionsAlreadySet);\n         }\n-\n-        final Set<String> restrictionsToSet = new ArraySet<>(defaultRestrictions);\n-        restrictionsToSet.removeAll(admin.defaultEnabledRestrictionsAlreadySet);\n-        if (!restrictionsToSet.isEmpty()) {\n-            for (final String restriction : restrictionsToSet) {\n-                admin.ensureUserRestrictions().putBoolean(restriction, true);\n-            }\n-            admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n-            Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n-            saveUserRestrictionsLocked(userId);\n+        for (final String restriction : restrictionsToSet) {\n+            admin.ensureUserRestrictions().putBoolean(restriction, true);\n         }\n+        admin.defaultEnabledRestrictionsAlreadySet.addAll(restrictionsToSet);\n+        Slogf.i(LOG_TAG, \"Enabled the following restrictions by default: \" + restrictionsToSet);\n+        saveUserRestrictionsLocked(userId);\n     }\n \n     private void setDeviceOwnershipSystemPropertyLocked() {\n@@ -10192,7 +10188,8 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -10214,7 +10211,19 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n                     maybeSetDefaultRestrictionsForAdminLocked(userHandle, admin);\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        setLocalUserRestrictionInternal(\n+                            EnforcingAdmin.createEnterpriseEnforcingAdmin(who, userHandle),\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false, userHandle);\n+                    }\n                 }\n+\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);\n             });\n@@ -11131,7 +11140,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (mOwners.hasDeviceOwner()) {\n             return false;\n         }\n-        \n+\n         final ComponentName profileOwner = getProfileOwnerAsUser(userId);\n         if (profileOwner == null) {\n             return false;\n@@ -11140,7 +11149,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n         if (isManagedProfile(userId)) {\n             return false;\n         }\n-        \n+\n         return true;\n     }\n     private void enforceCanQueryLockTaskLocked(ComponentName who, String callerPackageName) {\n@@ -24460,7 +24469,7 @@ public class DevicePolicyManagerService extends IDevicePolicyManager.Stub {\n             }\n         });\n     }\n-    \n+\n     private void migrateUserControlDisabledPackagesLocked() {\n         Binder.withCleanCallingIdentity(() -> {\n             List<UserInfo> users = mUserManager.getUsers();",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 778,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 449,
      "token_count_downstream": 0,
      "token_count_total": 449,
      "cosine_similarity_openai": 0.0799
    }
  },
  {
    "cve_id": "ASB-A-382064697",
    "downstream_version": "13",
    "file_name": "services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java",
    "runtime_seconds": 685.78,
    "cleaned_ground_truth": "@@ -8868,7 +8868,8 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                 return false;\n             }\n \n-            if (isAdb(caller)) {\n+            boolean isAdb = isAdb(caller);\n+            if (isAdb) {\n                 // Log profile owner provisioning was started using adb.\n                 MetricsLogger.action(mContext, PROVISIONING_ENTRY_POINT_ADB, LOG_TAG_PROFILE_OWNER);\n                 DevicePolicyEventLogger\n@@ -8891,6 +8892,17 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {\n                             UserRestrictionsUtils.getDefaultEnabledForManagedProfiles());\n                     ensureUnknownSourcesRestrictionForProfileOwnerLocked(userHandle, admin,\n                             true /* newOwner */);\n+                    if (isAdb) {\n+                        // DISALLOW_DEBUGGING_FEATURES is being added to newly-created\n+                        // work profile by default due to b/382064697 . This would have\n+                        //  impacted certain CTS test flows when they interact with the\n+                        // work profile via ADB (for example installing an app into the\n+                        // work profile). Remove DISALLOW_DEBUGGING_FEATURES here to\n+                        // reduce the potential impact.\n+                        admin.ensureUserRestrictions().putBoolean(\n+                            UserManager.DISALLOW_DEBUGGING_FEATURES, false);\n+                        saveUserRestrictionsLocked(userHandle);\n+                    }\n                 }\n                 sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,\n                         userHandle);",
    "cleaned_upstream_plus_llm": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 206,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 132,
      "token_count_downstream": 0,
      "token_count_total": 132,
      "cosine_similarity_openai": 0.0901
    }
  }
]