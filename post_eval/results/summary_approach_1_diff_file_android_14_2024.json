[
  {
    "cve_id": "ASB-A-242996380",
    "downstream_version": "14",
    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
    "runtime_seconds": null,
    "rej_file_diff": "",
    "llm_generated_patch": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-316891059",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 6.72,
    "rej_file_diff": "--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -52,11 +52,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +138,9 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.8044,
      "token_level_edit_distance": 29,
      "codebert_score": {
        "precision": 0.9366,
        "recall": 0.8818,
        "f1": 0.9084,
        "f3": 0.887
      },
      "token_count_upstream": 114,
      "token_count_downstream": 102,
      "token_count_total": 216,
      "cosine_similarity_openai": 0.8788
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 5.55,
    "rej_file_diff": "--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -52,11 +52,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFactory(this)\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +138,9 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.8044,
      "token_level_edit_distance": 29,
      "codebert_score": {
        "precision": 0.9366,
        "recall": 0.8818,
        "f1": 0.9084,
        "f3": 0.887
      },
      "token_count_upstream": 114,
      "token_count_downstream": 102,
      "token_count_total": 216,
      "cosine_similarity_openai": 0.8786
    }
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "14",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 19.08,
    "rej_file_diff": "--- packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n+++ packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n@@ -20,6 +20,7 @@ import com.android.systemui.dagger.SysUISingleton;\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n import com.android.systemui.media.controls.domain.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.controller.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.controller.MediaHostStatesManager;\n import com.android.systemui.media.controls.ui.view.MediaHost;\n@@ -98,8 +103,9 @@ public interface MediaModule {\n     @Named(COMMUNAL_HUB)\n     static MediaHost providesCommunalMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n             MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n-            MediaHostStatesManager statesManager) {\n-        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager);\n+            MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n+        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,\n+                carouselController);\n     }\n \n     /** Provides a logging buffer related to the media tap-to-transfer chip on the sender device. */",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -21,6 +21,7 @@\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.MediaHost;\n import com.android.systemui.media.controls.ui.MediaHostStatesManager;",
    "metrics": {
      "relative_line_count_similarity": 0.4762,
      "normalized_edit_similarity": 0.4053,
      "token_level_edit_distance": 148,
      "codebert_score": {
        "precision": 0.8798,
        "recall": 0.7401,
        "f1": 0.8039,
        "f3": 0.7521
      },
      "token_count_upstream": 84,
      "token_count_downstream": 22,
      "token_count_total": 106,
      "cosine_similarity_openai": 0.768
    }
  },
  {
    "cve_id": "ASB-A-328068777",
    "downstream_version": "14",
    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
    "runtime_seconds": 105.96,
    "rej_file_diff": "--- service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -1031,6 +1043,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                         callerPackageName, request.getToken());\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         long startDateAccessEpochMilli = DEFAULT_LONG;",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -822,7 +822,7 @@\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                     } catch (IllegalArgumentException illegalArgumentException) {\n-                        logger.setHealthDataServiceApiStatusError(\n+                        builder.setHealthDataServiceApiStatusError(\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                         Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                         tryAndThrowException(\n@@ -840,8 +840,7 @@\n                     } catch (Exception e) {\n                         builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                         tryAndThrowException(callback, e, ERROR_INTERNAL);\n-                    }\n-                    {\n+                    } finally {\n                         builder.build().log();\n                     }\n                 },\n@@ -875,8 +874,6 @@\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n                                         attributionSource.getPackageName(), token.getToken());\n-                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n-                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                         if (!isInForeground) {\n                             throwSecurityException(\n@@ -885,6 +882,12 @@\n                         }\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, builder);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n+                        mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n+                                changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         Instant startDateInstant =\n                                 mPermissionHelper.getHealthDataStartDateAccess(\n                                         attributionSource.getPackageName(), userHandle);",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.2577,
      "token_level_edit_distance": 195,
      "codebert_score": {
        "precision": 0.7795,
        "recall": 0.8037,
        "f1": 0.7914,
        "f3": 0.8012
      },
      "token_count_upstream": 46,
      "token_count_downstream": 116,
      "token_count_total": 162,
      "cosine_similarity_openai": 0.8243
    }
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "14",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 77.62,
    "rej_file_diff": "--- ojluni/src/main/java/java/util/zip/ZipFile.java\n+++ ojluni/src/main/java/java/util/zip/ZipFile.java\n@@ -1436,7 +1436,18 @@ public class ZipFile implements ZipConstants, Closeable {\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -296,8 +296,47 @@\n         // sun.misc.PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);\n         // sun.misc.PerfCounter.getZipFileCount().increment();\n         this.name = name;\n-        this.total = getTotal(jzfile);\n-        this.locsig = startsWithLOC(jzfile);\n+        // BEGIN Android-changed: do not accept files with invalid header\n+        // The patch reads the first 4 bytes and validates the signature.\n+        // In this structure, we rely on native methods.\n+        // startsWithLOC checks for LOCSIG.\n+        // The patch allows LOCSIG or ENDSIG at offset 0.\n+        // If startsWithLOC is false, it means the header is NOT LOCSIG.\n+        // It could be ENDSIG (empty file) or something else (invalid).\n+        // The patch throws if it's not LOCSIG AND not ENDSIG.\n+\n+        // We need to distinguish ENDSIG from other invalid headers when startsWithLOC is false.\n+        // An empty zip starts with ENDSIG and has total entries = 0.\n+        // A non-empty file with an invalid header (not LOCSIG, not ENDSIG) will have startsWithLOC=false and total > 0.\n+\n+        // So, if startsWithLOC is false AND total > 0, throw.\n+        // We need total for this check, but total is set *after* locsig in the original code.\n+        // Let's get total first to use in the check, aligning with the patched logic's need to know if the file is effectively empty or not (implied by checking against ENDSIG).\n+\n+        int totalEntries = getTotal(jzfile); // Get total entries early\n+\n+        // Now, apply the patch logic using the available info (startsWithLOC boolean and totalEntries count)\n+        boolean startsWithLoc = startsWithLOC(jzfile); // Check for LOCSIG\n+\n+        // The patch's core validation is: if (locsig != LOCSIG && locsig != ENDSIG) throw ...\n+        // Translating this to our available info:\n+        // locsig != LOCSIG  <=>  !startsWithLoc\n+        // locsig != ENDSIG  <=> The header is not ENDSIG.\n+        // An empty file (total=0) starting with ENDSIG is the valid non-LOCSIG case.\n+        // Any other header when total > 0 must be invalid.\n+\n+        // So, if header is not LOCSIG (!startsWithLoc) AND it's not the valid ENDSIG case (total > 0 implies it's not the empty file ENDSIG case), then throw.\n+        if (!startsWithLoc && totalEntries > 0) {\n+             // Cannot get the actual invalid signature value (locsig) here to print.\n+             String msg = \"Invalid LFH signature at offset zero\"; // Simplified message\n+             throw new ZipException(msg);\n+        }\n+\n+        // Set the instance fields using the values we got for the check\n+        this.locsig = startsWithLoc; // Set locsig flag based on LOCSIG header\n+        this.total = totalEntries;   // Set total entries\n+\n+        // END Android-changed: do not accept files with invalid header\n         // Android-added: CloseGuard support.\n         guard.open(\"close\");\n     }\n@@ -710,7 +749,7 @@\n             return;\n         // Android-added: CloseGuard support.\n         if (guard != null) {\n-            guard.close();\n+            guard.warnIfOpen();\n         }\n         closeRequested = true;",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.1663,
      "token_level_edit_distance": 382,
      "codebert_score": {
        "precision": 0.7513,
        "recall": 0.7973,
        "f1": 0.7736,
        "f3": 0.7924
      },
      "token_count_upstream": 133,
      "token_count_downstream": 476,
      "token_count_total": 609,
      "cosine_similarity_openai": 0.7746
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "14",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 51.1,
    "rej_file_diff": "--- services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -949,13 +947,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -55,7 +55,6 @@\n import android.app.AppOpsManager;\n import android.app.NotificationManager;\n import android.app.PendingIntent;\n-import android.bluetooth.BluetoothDevice;\n import android.companion.AssociationInfo;\n import android.companion.AssociationRequest;\n import android.companion.DeviceNotAssociatedException;\n@@ -930,13 +929,14 @@\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferRequestStore, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override\n@@ -1084,7 +1084,7 @@\n      * @return {@code true} if the application does NOT need be removed from the list of the role\n      *         holders OR if the application was successfully removed from the list of role holders.\n      *         I.e.: from the role-management perspective the association is done with.\n-     *         {@code false} if the application needs to be removed from the list of role the role\n+     *         {@code false} if the application needs to be removed from the list of the role the role\n      *         holders, BUT it CDMS would prefer to do it later.\n      *         I.e.: application is in the foreground at the moment, but invoking\n      *         {@code RoleManager.removeRoleHolderAsUser()} will kill the application's process,",
    "metrics": {
      "relative_line_count_similarity": 0.2273,
      "normalized_edit_similarity": 0.4164,
      "token_level_edit_distance": 217,
      "codebert_score": {
        "precision": 0.7961,
        "recall": 0.8952,
        "f1": 0.8427,
        "f3": 0.8842
      },
      "token_count_upstream": 92,
      "token_count_downstream": 220,
      "token_count_total": 312,
      "cosine_similarity_openai": 0.7335
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "14",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 89.26,
    "rej_file_diff": "--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -77,9 +77,11 @@\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n \n+import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;",
    "metrics": {
      "relative_line_count_similarity": 0.9167,
      "normalized_edit_similarity": 0.4453,
      "token_level_edit_distance": 32,
      "codebert_score": {
        "precision": 0.8574,
        "recall": 0.8316,
        "f1": 0.8443,
        "f3": 0.8341
      },
      "token_count_upstream": 28,
      "token_count_downstream": 28,
      "token_count_total": 56,
      "cosine_similarity_openai": 0.8196
    }
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 196.61,
    "rej_file_diff": "--- services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4590,7 +4590,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageLegacyUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageLegacyUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -3690,7 +3690,10 @@\n                     throw new IllegalStateException(\"Failed to scan: \" + ai.modulePath, e);\n                 }\n             } else if (throwable instanceof PackageManagerException) {\n-                throw new IllegalStateException(\"Unable to parse: \" + ai.modulePath, throwable);\n+                PackageManagerException e = (PackageManagerException) throwable;\n+                errorCode = e.error;\n+                errorMsg = \"Failed to parse \" + parseResult.scanFile + \": \" + e.getMessage();\n+                Slog.w(TAG, errorMsg);\n             } else {\n                 throw new IllegalStateException(\"Unexpected exception occurred while parsing \"\n                         + ai.modulePath, throwable);\n@@ -4743,7 +4746,9 @@\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageLegacyUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.4249,
      "token_level_edit_distance": 113,
      "codebert_score": {
        "precision": 0.7562,
        "recall": 0.7811,
        "f1": 0.7685,
        "f3": 0.7786
      },
      "token_count_upstream": 48,
      "token_count_downstream": 116,
      "token_count_total": 164,
      "cosine_similarity_openai": 0.8379
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "14",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 34.03,
    "rej_file_diff": "--- core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -425,19 +437,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != static_cast<uid_t>(expected_uid)) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -465,6 +470,7 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n       }\n     }\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Clear buffer and get count from next command.\n       n_buffer->clear();\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -425,19 +425,13 @@\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n \n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -467,6 +461,7 @@\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {",
    "metrics": {
      "relative_line_count_similarity": 0.9688,
      "normalized_edit_similarity": 0.6381,
      "token_level_edit_distance": 79,
      "codebert_score": {
        "precision": 0.912,
        "recall": 0.8966,
        "f1": 0.9042,
        "f3": 0.8981
      },
      "token_count_upstream": 146,
      "token_count_downstream": 156,
      "token_count_total": 302,
      "cosine_similarity_openai": 0.9039
    }
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "14",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 224.99,
    "rej_file_diff": "--- system/stack/btm/btm_sec.cc\n+++ system/stack/btm/btm_sec.cc\n@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-         p_dev_rec->sec_rec.is_device_authenticated() &&\n          p_dev_rec->sec_rec.is_bond_type_temporary();\n }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -144,7 +144,7 @@\n /*  BTM_IO_CAP_IN       2   KeyboardOnly */\n /*  BTM_IO_CAP_NONE     3   NoInputNoOutput */\n \n-static void NotifyBondingChange(tBTM_SEC_DEV_REC& p_dev_rec,\n+void NotifyBondingChange(tBTM_SEC_DEV_REC& p_dev_rec,\n                                 tHCI_STATUS status) {\n   if (btm_cb.api.p_auth_complete_callback != nullptr) {\n     (*btm_cb.api.p_auth_complete_callback)(\n@@ -223,8 +223,7 @@\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n-    p_dev_rec->is_bond_type_temporary();\n+         p_dev_rec->is_bond_type_temporary();\n }\n \n /*******************************************************************************\n@@ -2301,7 +2300,8 @@\n           \"Remote read request complete for known device pairing_state:%s \"\n           \"name:%s sec_state:%s\",\n           btm_pair_state_descr(btm_cb.pairing_state), p_bd_name,\n-          security_state_text(p_dev_rec->sec_state).c_str());\n+          security_state_text(p_dev_rec->sec_state).c_str(),\n+          p_dev_rec->sec_state);\n \n       strlcpy((char*)p_dev_rec->sec_bd_name, (const char*)p_bd_name,\n               BTM_MAX_REM_BD_NAME_LEN + 1);\n@@ -4835,7 +4835,7 @@\n                                      tBTM_SEC_CALLBACK* p_callback,\n                                      void* p_ref_data) {\n   tBTM_SEC_QUEUE_ENTRY* p_e =\n-      (tBTM_SEC_QUEUE_ENTRY*)osi_malloc(sizeof(tBTM_SEC_QUEUE_ENTRY));\n+      (tBTM_SEC_QUEUE_ENTRY*)osi_malloc(sizeof(tBTM_SEC_QUEUE_ENTRY) + 1);\n \n   p_e->psm = psm;\n   p_e->is_orig = is_orig;",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.1429,
      "token_level_edit_distance": 206,
      "codebert_score": {
        "precision": 0.7281,
        "recall": 0.84,
        "f1": 0.78,
        "f3": 0.8272
      },
      "token_count_upstream": 30,
      "token_count_downstream": 112,
      "token_count_total": 142,
      "cosine_similarity_openai": 0.6936
    }
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 185.35,
    "rej_file_diff": "--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -1429,22 +1429,33 @@\n         mHistoricalRegistry.shutdown();\n     }\n \n-    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n+    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n+            String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n-                resOps.add(getOpEntryForResult(curOp));\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n+                resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n-                    resOps.add(getOpEntryForResult(curOp));\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n+                    resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }\n         }\n@@ -1506,7 +1517,7 @@\n                 final int packageCount = packages.size();\n                 for (int j = 0; j < packageCount; j++) {\n                     Ops pkgOps = packages.valueAt(j);\n-                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n+                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops, null); // Added null for persistentDeviceId\n                     if (resOps != null) {\n                         if (res == null) {\n                             res = new ArrayList<>();\n@@ -1538,7 +1549,7 @@\n             if (pkgOps == null) {\n                 return null;\n             }\n-            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n+            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops, null); // Added null for persistentDeviceId\n             if (resOps == null) {\n                 return null;\n             }\n@@ -5837,7 +5848,7 @@\n      * @param uid Uid of the package which reported the op\n      * @param packageName The package which reported the op\n      * @param opCode Code of AppOp\n-     * @param attributionTag FeautreId of AppOp reported\n+     * @param attributionTag FeatureId of AppOp reported\n      * @param message Message describing AppOp access (can be stack trace)\n      */\n     private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n@@ -5982,682 +5993,4 @@\n                                 if (!candidates.contains(packageName)) {\n                                     continue;\n                                 }\n-                                AppOpsManager.HistoricalPackageOps packageOps =\n-                                        uidOps.getPackageOpsAt(pkgIdx);\n-                                if (packageOps.getOpCount() != 0) {\n-                                    candidates.remove(packageName);\n-                                }\n-                            }\n-                        }\n-                        synchronized (this) {\n-                            int numPkgs = mRarelyUsedPackages.size();\n-                            for (int i = 0; i < numPkgs; i++) {\n-                                candidates.add(mRarelyUsedPackages.valueAt(i));\n-                            }\n-                            mRarelyUsedPackages = candidates;\n-                        }\n-                    }\n-                });\n-    }\n-\n-    /** List of app ops related to runtime permissions */\n-    private List<String> getRuntimeAppOpsList() {\n-        ArrayList<String> result = new ArrayList();\n-        for (int i = 0; i < _NUM_OP; i++) {\n-            if (shouldCollectNotes(i)) {\n-                result.add(opToPublicName(i));\n-            }\n-        }\n-        return result;\n-    }\n-\n-    /** Returns list of packages to be used for package sampling */\n-    private @NonNull List<String> getPackageNamesForSampling() {\n-        List<String> packageNames = new ArrayList<>();\n-        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n-                PackageManagerInternal.class);\n-        PackageList packages = packageManagerInternal.getPackageList();\n-        for (String packageName : packages.getPackageNames()) {\n-            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n-                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n-            if (isSamplingTarget(pkg)) {\n-                packageNames.add(pkg.packageName);\n-            }\n-        }\n-        return packageNames;\n-    }\n-\n-    /** Checks whether package should be included in sampling pool */\n-    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n-        if (pkg == null) {\n-            return false;\n-        }\n-        String[] requestedPermissions = pkg.requestedPermissions;\n-        if (requestedPermissions == null) {\n-            return false;\n-        }\n-        for (String permission : requestedPermissions) {\n-            PermissionInfo permissionInfo;\n-            try {\n-                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n-            } catch (PackageManager.NameNotFoundException ignored) {\n-                continue;\n-            }\n-            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @GuardedBy(\"this\")\n-    private void removeUidsForUserLocked(int userHandle) {\n-        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n-            final int uid = mUidStates.keyAt(i);\n-            if (UserHandle.getUserId(uid) == userHandle) {\n-                mUidStates.valueAt(i).clear();\n-                mUidStates.removeAt(i);\n-            }\n-        }\n-    }\n-\n-    private void checkSystemUid(String function) {\n-        int uid = Binder.getCallingUid();\n-        if (uid != Process.SYSTEM_UID) {\n-            throw new SecurityException(function + \" must by called by the system\");\n-        }\n-    }\n-\n-    private static int resolveUid(String packageName)  {\n-        if (packageName == null) {\n-            return Process.INVALID_UID;\n-        }\n-        switch (packageName) {\n-            case \"root\":\n-                return Process.ROOT_UID;\n-            case \"shell\":\n-            case \"dumpstate\":\n-                return Process.SHELL_UID;\n-            case \"media\":\n-                return Process.MEDIA_UID;\n-            case \"audioserver\":\n-                return Process.AUDIOSERVER_UID;\n-            case \"cameraserver\":\n-                return Process.CAMERASERVER_UID;\n-        }\n-        return Process.INVALID_UID;\n-    }\n-\n-    private static String[] getPackagesForUid(int uid) {\n-        String[] packageNames = null;\n-\n-        // Very early during boot the package manager is not yet or not yet fully started. At this\n-        // time there are no packages yet.\n-        if (AppGlobals.getPackageManager() != null) {\n-            try {\n-                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n-            } catch (RemoteException e) {\n-                /* ignore - local call */\n-            }\n-        }\n-        if (packageNames == null) {\n-            return EmptyArray.STRING;\n-        }\n-        return packageNames;\n-    }\n-\n-    private final class ClientUserRestrictionState implements DeathRecipient {\n-        private final IBinder token;\n-\n-        ClientUserRestrictionState(IBinder token)\n-                throws RemoteException {\n-            token.linkToDeath(this, 0);\n-            this.token = token;\n-        }\n-\n-        public boolean setRestriction(int code, boolean restricted,\n-                PackageTagsList excludedPackageTags, int userId) {\n-            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n-                    restricted, excludedPackageTags);\n-        }\n-\n-        public boolean hasRestriction(int code, String packageName, String attributionTag,\n-                int userId, boolean isCheckOp) {\n-            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n-                    attributionTag, isCheckOp);\n-        }\n-\n-        public void removeUser(int userId) {\n-            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n-        }\n-\n-        public boolean isDefault() {\n-            return !mAppOpsRestrictions.hasUserRestrictions(token);\n-        }\n-\n-        @Override\n-        public void binderDied() {\n-            synchronized (AppOpsService.this) {\n-                mAppOpsRestrictions.clearUserRestrictions(token);\n-                mOpUserRestrictions.remove(token);\n-                destroy();\n-            }\n-        }\n-\n-        public void destroy() {\n-            token.unlinkToDeath(this, 0);\n-        }\n-    }\n-\n-    private final class ClientGlobalRestrictionState implements DeathRecipient {\n-        final IBinder mToken;\n-\n-        ClientGlobalRestrictionState(IBinder token)\n-                throws RemoteException {\n-            token.linkToDeath(this, 0);\n-            this.mToken = token;\n-        }\n-\n-        boolean setRestriction(int code, boolean restricted) {\n-            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n-        }\n-\n-        boolean hasRestriction(int code) {\n-            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n-        }\n-\n-        boolean isDefault() {\n-            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n-        }\n-\n-        @Override\n-        public void binderDied() {\n-            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n-            mOpGlobalRestrictions.remove(mToken);\n-            destroy();\n-        }\n-\n-        void destroy() {\n-            mToken.unlinkToDeath(this, 0);\n-        }\n-    }\n-\n-    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n-        @Override\n-        public boolean isUidInForeground(int uid) {\n-            synchronized (AppOpsService.this) {\n-                return mUidStateTracker.isUidInForeground(uid);\n-            }\n-        }\n-    }\n-\n-    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n-        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n-            synchronized (AppOpsService.this) {\n-                mProfileOwners = owners;\n-            }\n-        }\n-\n-        @Override\n-        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n-                boolean visible) {\n-            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n-        }\n-\n-        @Override\n-        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n-                @Nullable IAppOpsCallback callback) {\n-            setUidMode(code, uid, mode, callback);\n-        }\n-\n-        @Override\n-        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n-                int mode, @Nullable IAppOpsCallback callback) {\n-            setMode(code, uid, packageName, mode, callback);\n-        }\n-\n-\n-        @Override\n-        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n-            if (Binder.getCallingPid() != Process.myPid()) {\n-                // TODO instead of this enforcement put in AppOpsManagerInternal\n-                throw new SecurityException(\"Only the system can set global restrictions\");\n-            }\n-\n-            synchronized (AppOpsService.this) {\n-                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n-\n-                if (restrictionState == null) {\n-                    try {\n-                        restrictionState = new ClientGlobalRestrictionState(token);\n-                    } catch (RemoteException  e) {\n-                        return;\n-                    }\n-                    mOpGlobalRestrictions.put(token, restrictionState);\n-                }\n-\n-                if (restrictionState.setRestriction(code, restricted)) {\n-                    mHandler.sendMessage(PooledLambda.obtainMessage(\n-                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n-                            UID_ANY));\n-                    mHandler.sendMessage(PooledLambda.obtainMessage(\n-                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n-                            code, restricted, UserHandle.USER_ALL));\n-                }\n-\n-                if (restrictionState.isDefault()) {\n-                    mOpGlobalRestrictions.remove(token);\n-                    restrictionState.destroy();\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n-                String attributionTag) {\n-            int number = 0;\n-            synchronized (AppOpsService.this) {\n-                int numRestrictions = mOpUserRestrictions.size();\n-                for (int i = 0; i < numRestrictions; i++) {\n-                    if (mOpUserRestrictions.valueAt(i)\n-                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n-                                    false)) {\n-                        number++;\n-                    }\n-                }\n-\n-                numRestrictions = mOpGlobalRestrictions.size();\n-                for (int i = 0; i < numRestrictions; i++) {\n-                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n-                        number++;\n-                    }\n-                }\n-            }\n-\n-            return number;\n-        }\n-    }\n-\n-    /**\n-     * Async task for writing note op stack trace, op code, package name and version to file\n-     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n-     */\n-    private void writeNoteOps() {\n-        synchronized (this) {\n-            mWriteNoteOpsScheduled = false;\n-        }\n-        synchronized (mNoteOpCallerStacktracesFile) {\n-            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n-                int numTraces = mNoteOpCallerStacktraces.size();\n-                for (int i = 0; i < numTraces; i++) {\n-                    // Writing json formatted string into file\n-                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n-                    // Comma separation, so we can wrap the entire log as a JSON object\n-                    // when all results are collected\n-                    writer.write(\",\");\n-                }\n-            } catch (IOException e) {\n-                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n-     * be written to file to use for permissions data validation in JSON format\n-     */\n-    @Immutable\n-    static class NoteOpTrace {\n-        static final String STACKTRACE = \"stackTrace\";\n-        static final String OP = \"op\";\n-        static final String PACKAGENAME = \"packageName\";\n-        static final String VERSION = \"version\";\n-\n-        private final @NonNull String mStackTrace;\n-        private final int mOp;\n-        private final @Nullable String mPackageName;\n-        private final long mVersion;\n-\n-        /**\n-         * Initialize a NoteOp object using a JSON object containing the necessary fields\n-         *\n-         * @param jsonTrace JSON object represented as a string\n-         *\n-         * @return NoteOpTrace object initialized with JSON fields\n-         */\n-        static NoteOpTrace fromJson(String jsonTrace) {\n-            try {\n-                // Re-add closing bracket which acted as a delimiter by the reader\n-                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n-                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n-                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n-            } catch (JSONException e) {\n-                // Swallow error, only meant for logging ops, should not affect flow of the code\n-                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n-                        + \"JSON trace format incorrect\", e);\n-                return null;\n-            }\n-        }\n-\n-        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n-            mStackTrace = stackTrace;\n-            mOp = op;\n-            mPackageName = packageName;\n-            mVersion = version;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            NoteOpTrace that = (NoteOpTrace) o;\n-            return mOp == that.mOp\n-                    && mVersion == that.mVersion\n-                    && mStackTrace.equals(that.mStackTrace)\n-                    && Objects.equals(mPackageName, that.mPackageName);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n-        }\n-\n-        /**\n-         * The object is formatted as a JSON object and returned as a String\n-         *\n-         * @return JSON formatted string\n-         */\n-        public String asJson() {\n-            return  \"{\"\n-                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n-                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n-                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n-                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n-                    + '}';\n-        }\n-    }\n-\n-    /**\n-     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n-     * which will be used for permissions data validation, the given parameters to this method\n-     * will be logged in json format\n-     *\n-     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n-     * @param op op code\n-     * @param packageName package making call\n-     * @param version android version for this call\n-     */\n-    @Override\n-    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n-            long version) {\n-        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n-            return;\n-        }\n-\n-        Objects.requireNonNull(stackTrace);\n-        Preconditions.checkArgument(op >= 0);\n-        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n-\n-        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n-\n-        boolean noteOpSetWasChanged;\n-        synchronized (this) {\n-            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n-            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n-                mWriteNoteOpsScheduled = true;\n-                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n-                    AsyncTask.execute(() -> {\n-                        that.writeNoteOps();\n-                    });\n-                }, this), 2500);\n-            }\n-        }\n-    }\n-\n-    @Immutable\n-    private final class CheckOpsDelegateDispatcher {\n-        private final @Nullable CheckOpsDelegate mPolicy;\n-        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n-\n-        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n-                @Nullable CheckOpsDelegate checkOpsDelegate) {\n-            mPolicy = policy;\n-            mCheckOpsDelegate = checkOpsDelegate;\n-        }\n-\n-        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n-            return mCheckOpsDelegate;\n-        }\n-\n-        public int checkOperation(int code, int uid, String packageName,\n-                @Nullable String attributionTag, boolean raw) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n-                            this::checkDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n-                            AppOpsService.this::checkOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n-            }\n-            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n-        }\n-\n-        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n-                @Nullable String attributionTag, boolean raw) {\n-            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n-                    AppOpsService.this::checkOperationImpl);\n-        }\n-\n-        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n-                            this::checkDelegateAudioOperationImpl);\n-                } else {\n-                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n-                            AppOpsService.this::checkAudioOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n-            }\n-            return checkAudioOperationImpl(code, usage, uid, packageName);\n-        }\n-\n-        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n-                String packageName) {\n-            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n-                    AppOpsService.this::checkAudioOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n-                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            this::noteDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            AppOpsService.this::noteOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateOperationImpl(code, uid, packageName,\n-                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-            }\n-            return noteOperationImpl(code, uid, packageName, attributionTag,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n-                @Nullable String packageName, @Nullable String featureId,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage) {\n-            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    AppOpsService.this::noteOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateProxyOperationImpl(code,\n-                        attributionSource, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation);\n-            }\n-            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n-                    message, shouldCollectMessage,skipProxyOperation);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n-                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation) {\n-            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    AppOpsService.this::noteProxyOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n-                @Nullable String packageName, @NonNull String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                @AttributionFlags int attributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startOperation(token, code, uid, packageName,\n-                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            this::startDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            AppOpsService.this::startOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, attributionFlags, attributionChainId);\n-            }\n-            return startOperationImpl(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n-                @Nullable String packageName, @Nullable String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n-                int attributionChainId) {\n-            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            this::startDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            AppOpsService.this::startProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n-            }\n-            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n-                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n-        }\n-\n-        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n-                String attributionTag) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            this::finishDelegateOperationImpl);\n-                } else {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            AppOpsService.this::finishOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            } else {\n-                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            }\n-        }\n-\n-        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n-                String packageName, String attributionTag) {\n-            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                    AppOpsService.this::finishOperationImpl);\n-        }\n-\n-        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n-                } else {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        skipProxyOperation);\n-            } else {\n-                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n-            }\n-        }\n-\n-        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n-                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-            return null;\n-        }\n-    }\n-}\n-```+                                AppOpsManager.HistoricalPackageOps packageOps",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0508,
      "token_level_edit_distance": 4863,
      "codebert_score": {
        "precision": 0.7307,
        "recall": 0.9095,
        "f1": 0.8103,
        "f3": 0.8878
      },
      "token_count_upstream": 138,
      "token_count_downstream": 3182,
      "token_count_total": 3320,
      "cosine_similarity_openai": 0.6887
    }
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 176.63,
    "rej_file_diff": "--- services/core/java/com/android/server/pm/UserManagerService.java\n+++ services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4979,7 +4979,7 @@ public class UserManagerService extends IUserManager.Stub {\n             @UserIdInt int parentId, boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -340,9 +340,9 @@\n     /** Installs system packages based on user-type. */\n     private final UserSystemPackageInstaller mSystemPackageInstaller;\n \n-    private PackageManagerInternal mPmInternal;\n-    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n-    private ActivityManagerInternal mAmInternal;\n+    PackageManagerInternal mPmInternal;\n+    DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n+    ActivityManagerInternal mAmInternal;\n \n     /** Indicates that this is the 1st boot after the system user mode was changed by emulation. */\n     private boolean mUpdatingSystemUserMode;\n@@ -3944,7 +3944,6 @@\n         // Reminder: If you add another upgrade, make sure to increment USER_VERSION too.\n \n         // Done with userVersion changes, moving on to deal with userTypeVersion upgrades\n-        // Upgrade from previous user type to a new user type\n         final int newUserTypeVersion = UserTypeFactory.getUserTypeVersion();\n         if (newUserTypeVersion > userTypeVersion) {\n             synchronized (mUsersLock) {\n@@ -4773,7 +4772,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6368,1123 +6367,4 @@\n \n         synchronized (mPackagesLock) {\n             final UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = getUserDataLU(userId);\n-                if (userData == null) {\n-                    Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n-                    return;\n-                }\n-                userData.seedAccountName = truncateString(accountName,\n-                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n-                userData.seedAccountType = truncateString(accountType,\n-                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n-                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n-                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n-                    userData.seedAccountOptions = accountOptions;\n-                }\n-                userData.persistSeedData = persist;\n-            }\n-            if (persist) {\n-                writeUserLP(userData);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String getSeedAccountName(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountName;\n-        }\n-    }\n-\n-    @Override\n-    public String getSeedAccountType(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountType;\n-        }\n-    }\n-\n-    @Override\n-    public PersistableBundle getSeedAccountOptions(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountOptions;\n-        }\n-    }\n-\n-    @Override\n-    public void clearSeedAccountData(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot clear seed account information\");\n-        synchronized (mPackagesLock) {\n-            UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = getUserDataLU(userId);\n-                if (userData == null) return;\n-                userData.clearSeedAccountData();\n-            }\n-            writeUserLP(userData);\n-        }\n-    }\n-\n-    @Override\n-    public boolean someUserHasSeedAccount(String accountName, String accountType) {\n-        checkManageUsersPermission(\"check seed account information\");\n-        return someUserHasSeedAccountNoChecks(accountName, accountType);\n-    }\n-\n-    private boolean someUserHasSeedAccountNoChecks(String accountName, String accountType) {\n-        synchronized (mUsersLock) {\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                final UserData data = mUsers.valueAt(i);\n-                if (data.info.isInitialized()) continue;\n-                if (mRemovingUserIds.get(data.info.id)) continue;\n-                if (data.seedAccountName == null || !data.seedAccountName.equals(accountName)) {\n-                    continue;\n-                }\n-                if (data.seedAccountType == null || !data.seedAccountType.equals(accountType)) {\n-                    continue;\n-                }\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean someUserHasAccount(String accountName, String accountType) {\n-        checkCreateUsersPermission(\"check seed account information\");\n-        return someUserHasAccountNoChecks(accountName, accountType);\n-    }\n-\n-    private boolean someUserHasAccountNoChecks(\n-            String accountName, String accountType) {\n-        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n-            return false;\n-        }\n-\n-        final Account account = new Account(accountName, accountType);\n-\n-        return Binder.withCleanCallingIdentity(() ->\n-                AccountManager.get(mContext).someUserHasAccount(account)\n-                        || someUserHasSeedAccountNoChecks(accountName, accountType));\n-    }\n-\n-    private void setLastEnteredForegroundTimeToNow(@NonNull UserData userData) {\n-        userData.mLastEnteredForegroundTimeMillis = System.currentTimeMillis();\n-        scheduleWriteUser(userData.info.id);\n-    }\n-\n-    @Override\n-    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n-            FileDescriptor err, String[] args, ShellCallback callback,\n-            ResultReceiver resultReceiver) {\n-        (new UserManagerServiceShellCommand(this, mSystemPackageInstaller,\n-                mLockPatternUtils, mContext))\n-                .exec(this, in, out, err, args, callback, resultReceiver);\n-    }\n-\n-    @Override\n-    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n-        if (!DumpUtils.checkDumpPermission(mContext, LOG_TAG, pw)) return;\n-\n-        final long now = System.currentTimeMillis();\n-        final long nowRealtime = SystemClock.elapsedRealtime();\n-        final StringBuilder sb = new StringBuilder();\n-\n-        if (args != null && args.length > 0) {\n-            switch (args[0]) {\n-                case \"--user\":\n-                    dumpUser(pw, UserHandle.parseUserArg(args[1]), sb, now, nowRealtime);\n-                    return;\n-                case \"--visibility-mediator\":\n-                    mUserVisibilityMediator.dump(pw, args);\n-                    return;\n-            }\n-        }\n-\n-        final int currentUserId = getCurrentUserId();\n-        pw.print(\"Current user: \");\n-        if (currentUserId != UserHandle.USER_NULL) {\n-            pw.println(currentUserId);\n-        } else {\n-            pw.println(\"N/A\");\n-        }\n-\n-        pw.println();\n-        synchronized (mPackagesLock) {\n-            synchronized (mUsersLock) {\n-                pw.println(\"Users:\");\n-                for (int i = 0; i < mUsers.size(); i++) {\n-                    UserData userData = mUsers.valueAt(i);\n-                    if (userData == null) {\n-                        continue;\n-                    }\n-                    dumpUserLocked(pw, userData, sb, now, nowRealtime);\n-                }\n-            }\n-\n-            pw.println();\n-            pw.println(\"Device properties:\");\n-            pw.println(\"  Device policy global restrictions:\");\n-            synchronized (mRestrictionsLock) {\n-                UserRestrictionsUtils.dumpRestrictions(\n-                        pw, \"    \",\n-                        mDevicePolicyUserRestrictions.getRestrictions(UserHandle.USER_ALL));\n-            }\n-            pw.println(\"  Guest restrictions:\");\n-            synchronized (mGuestRestrictions) {\n-                UserRestrictionsUtils.dumpRestrictions(pw, \"    \", mGuestRestrictions);\n-            }\n-            synchronized (mUsersLock) {\n-                pw.println();\n-                pw.println(\"  Device managed: \" + mIsDeviceManaged);\n-                if (mRemovingUserIds.size() > 0) {\n-                    pw.println();\n-                    pw.println(\"  Recently removed userIds: \" + mRecentlyRemovedIds);\n-                }\n-            }\n-            synchronized (mUserStates) {\n-                pw.print(\"  Started users state: [\");\n-                final int size = mUserStates.states.size();\n-                for (int i = 0; i < size; i++) {\n-                    final int userId = mUserStates.states.keyAt(i);\n-                    final int state = mUserStates.states.valueAt(i);\n-                    pw.print(userId);\n-                    pw.print('=');\n-                    pw.print(UserState.stateToString(state));\n-                    if (i != size - 1) pw.print(\", \");\n-                }\n-                pw.println(']');\n-            }\n-            synchronized (mUsersLock) {\n-                pw.print(\"  Cached user IDs: \");\n-                pw.println(Arrays.toString(mUserIds));\n-                pw.print(\"  Cached user IDs (including pre-created): \");\n-                pw.println(Arrays.toString(mUserIdsIncludingPreCreated));\n-            }\n-        } // synchronized (mPackagesLock)\n-\n-        pw.println();\n-        mUserVisibilityMediator.dump(pw, args);\n-        pw.println();\n-\n-        // Dump some capabilities\n-        pw.println();\n-        pw.print(\"  Max users: \" + UserManager.getMaxSupportedUsers());\n-        pw.println(\" (limit reached: \" + isUserLimitReached() + \")\");\n-        pw.println(\"  Supports switchable users: \" + UserManager.supportsMultipleUsers());\n-        pw.println(\"  All guests ephemeral: \" + Resources.getSystem().getBoolean(\n-                com.android.internal.R.bool.config_guestUserEphemeral));\n-        pw.println(\"  Force ephemeral users: \" + mForceEphemeralUsers);\n-        final boolean isHeadlessSystemUserMode = isHeadlessSystemUserMode();\n-        pw.println(\"  Is headless-system mode: \" + isHeadlessSystemUserMode);\n-        if (isHeadlessSystemUserMode != RoSystemProperties.MULTIUSER_HEADLESS_SYSTEM_USER) {\n-            pw.println(\"  (differs from the current default build value)\");\n-        }\n-        if (!TextUtils.isEmpty(SystemProperties.get(SYSTEM_USER_MODE_EMULATION_PROPERTY))) {\n-            pw.println(\"  (emulated by 'cmd user set-system-user-mode-emulation')\");\n-            if (mUpdatingSystemUserMode) {\n-                pw.println(\"  (and being updated after boot)\");\n-            }\n-        }\n-        pw.println(\"  User version: \" + mUserVersion);\n-        pw.println(\"  Owner name: \" + getOwnerName());\n-        if (DBG_ALLOCATION) {\n-            pw.println(\"  System user allocations: \" + mUser0Allocations.get());\n-        }\n-        synchronized (mUsersLock) {\n-            pw.println(\"  Boot user: \" + mBootUser);\n-        }\n-\n-        pw.println();\n-        pw.println(\"Number of listeners for\");\n-        synchronized (mUserRestrictionsListeners) {\n-            pw.println(\"  restrictions: \" + mUserRestrictionsListeners.size());\n-        }\n-        synchronized (mUserLifecycleListeners) {\n-            pw.println(\"  user lifecycle events: \" + mUserLifecycleListeners.size());\n-        }\n-\n-        // Dump UserTypes\n-        pw.println();\n-        pw.println(\"User types version: \" + mUserTypeVersion);\n-        pw.println(\"User types (\" + mUserTypes.size() + \" types):\");\n-        for (int i = 0; i < mUserTypes.size(); i++) {\n-            pw.println(\"    \" + mUserTypes.keyAt(i) + \": \");\n-            mUserTypes.valueAt(i).dump(pw, \"        \");\n-        }\n-\n-        // TODO: create IndentingPrintWriter at the beginning of dump() and use the proper\n-        // indentation methods instead of explicit printing \"  \"\n-        try (IndentingPrintWriter ipw = new IndentingPrintWriter(pw)) {\n-\n-            // Dump SystemPackageInstaller info\n-            ipw.println();\n-            mSystemPackageInstaller.dump(ipw);\n-\n-            // NOTE: pw's not available after this point as it's auto-closed by ipw, so new dump\n-            // statements should use ipw below\n-        }\n-    }\n-\n-    private void dumpUser(PrintWriter pw, @UserIdInt int userId, StringBuilder sb, long now,\n-            long nowRealtime) {\n-        if (userId == UserHandle.USER_CURRENT) {\n-            final int currentUserId = getCurrentUserId();\n-            pw.print(\"Current user: \");\n-            if (currentUserId == UserHandle.USER_NULL) {\n-                pw.println(\"Cannot determine current user\");\n-                return;\n-            }\n-            userId = currentUserId;\n-        }\n-\n-        synchronized (mUsersLock) {\n-            final UserData userData = mUsers.get(userId);\n-            if (userData == null) {\n-                pw.println(\"User \" + userId + \" not found\");\n-                return;\n-            }\n-            dumpUserLocked(pw, userData, sb, now, nowRealtime);\n-        }\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    private void dumpUserLocked(PrintWriter pw, UserData userData, StringBuilder tempStringBuilder,\n-            long now, long nowRealtime) {\n-        final UserInfo userInfo = userData.info;\n-        final int userId = userInfo.id;\n-        pw.print(\"  \"); pw.print(userInfo);\n-        pw.print(\" serialNo=\"); pw.print(userInfo.serialNumber);\n-        pw.print(\" isPrimary=\"); pw.print(userInfo.isPrimary());\n-        if (userInfo.profileGroupId != userInfo.id\n-                &&  userInfo.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID) {\n-            pw.print(\" parentId=\"); pw.print(userInfo.profileGroupId);\n-        }\n-\n-        if (mRemovingUserIds.get(userId)) {\n-            pw.print(\" <removing> \");\n-        }\n-        if (userInfo.partial) {\n-            pw.print(\" <partial>\");\n-        }\n-        if (userInfo.preCreated) {\n-            pw.print(\" <pre-created>\");\n-        }\n-        if (userInfo.convertedFromPreCreated) {\n-            pw.print(\" <converted>\");\n-        }\n-        pw.println();\n-        pw.print(\"    Type: \"); pw.println(userInfo.userType);\n-        pw.print(\"    Flags: \"); pw.print(userInfo.flags); pw.print(\" (\");\n-        pw.print(UserInfo.flagsToString(userInfo.flags)); pw.println(\")\");\n-        pw.print(\"    State: \");\n-        final int state;\n-        synchronized (mUserStates) {\n-            state = mUserStates.get(userId, -1);\n-        }\n-        pw.println(UserState.stateToString(state));\n-        pw.print(\"    Created: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userInfo.creationTime);\n-\n-        pw.print(\"    Last logged in: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userInfo.lastLoggedInTime);\n-\n-        pw.print(\"    Last logged in fingerprint: \");\n-        pw.println(userInfo.lastLoggedInFingerprint);\n-\n-        pw.print(\"    Start time: \");\n-        dumpTimeAgo(pw, tempStringBuilder, nowRealtime, userData.startRealtime);\n-\n-        pw.print(\"    Unlock time: \");\n-        dumpTimeAgo(pw, tempStringBuilder, nowRealtime, userData.unlockRealtime);\n-\n-        pw.print(\"    Last entered foreground: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userData.mLastEnteredForegroundTimeMillis);\n-\n-        pw.print(\"    Has profile owner: \");\n-        pw.println(mIsUserManaged.get(userId));\n-        pw.println(\"    Restrictions:\");\n-        synchronized (mRestrictionsLock) {\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \", mBaseUserRestrictions.getRestrictions(userInfo.id));\n-            pw.println(\"    Device policy restrictions:\");\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \",\n-                    mDevicePolicyUserRestrictions.getRestrictions(userInfo.id));\n-            pw.println(\"    Effective restrictions:\");\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \",\n-                    mCachedEffectiveUserRestrictions.getRestrictions(userInfo.id));\n-        }\n-\n-        if (userData.account != null) {\n-            pw.print(\"    Account name: \" + userData.account);\n-            pw.println();\n-        }\n-\n-        if (userData.seedAccountName != null) {\n-            pw.print(\"    Seed account name: \" + userData.seedAccountName);\n-            pw.println();\n-            if (userData.seedAccountType != null) {\n-                pw.print(\"         account type: \" + userData.seedAccountType);\n-                pw.println();\n-            }\n-            if (userData.seedAccountOptions != null) {\n-                pw.print(\"         account options exist\");\n-                pw.println();\n-            }\n-        }\n-\n-        if (userData.userProperties != null) {\n-            userData.userProperties.println(pw, \"    \");\n-        }\n-\n-        pw.println(\"    Ignore errors preparing storage: \"\n-                + userData.getIgnorePrepareStorageErrors());\n-    }\n-\n-    private static void dumpTimeAgo(PrintWriter pw, StringBuilder sb, long nowTime, long time) {\n-        if (time == 0) {\n-            pw.println(\"<unknown>\");\n-        } else {\n-            sb.setLength(0);\n-            TimeUtils.formatDuration(nowTime - time, sb);\n-            sb.append(\" ago\");\n-            pw.println(sb);\n-        }\n-    }\n-\n-    final class MainHandler extends Handler {\n-\n-        @Override\n-        public void handleMessage(Message msg) {\n-            switch (msg.what) {\n-                case WRITE_USER_LIST_MSG: {\n-                    removeMessages(WRITE_USER_LIST_MSG);\n-                    synchronized (mPackagesLock) {\n-                        writeUserListLP();\n-                    }\n-                    break;\n-                }\n-                case WRITE_USER_MSG:\n-                    removeMessages(WRITE_USER_MSG, msg.obj);\n-                    synchronized (mPackagesLock) {\n-                        int userId = (int) msg.obj;\n-                        UserData userData = getUserDataNoChecks(userId);\n-                        if (userData != null) {\n-                            writeUserLP(userData);\n-                        } else {\n-                            Slog.i(LOG_TAG, \"handle(WRITE_USER_MSG): no data for user \" + userId\n-                                    + \", it was probably removed before handler could handle it\");\n-                        }\n-                    }\n-                    break;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param userId\n-     * @return whether the user has been initialized yet\n-     */\n-    boolean isUserInitialized(@UserIdInt int userId) {\n-        return mLocalService.isUserInitialized(userId);\n-    }\n-\n-    private class LocalService extends UserManagerInternal {\n-        @Override\n-        public void setDevicePolicyUserRestrictions(@UserIdInt int originatingUserId,\n-                @NonNull Bundle global, @NonNull RestrictionsSet local,\n-                boolean isDeviceOwner) {\n-            UserManagerService.this.setDevicePolicyUserRestrictionsInner(originatingUserId,\n-                    global, local, isDeviceOwner);\n-        }\n-\n-        @Override\n-        public void setUserRestriction(int userId, @NonNull String key, boolean value) {\n-            UserManagerService.this.setUserRestrictionInner(userId, key, value);\n-        }\n-\n-        @Override\n-        public boolean getUserRestriction(@UserIdInt int userId, String key) {\n-            return getUserRestrictions(userId).getBoolean(key);\n-        }\n-\n-        @Override\n-        public void addUserRestrictionsListener(UserRestrictionsListener listener) {\n-            synchronized (mUserRestrictionsListeners) {\n-                mUserRestrictionsListeners.add(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserRestrictionsListener(UserRestrictionsListener listener) {\n-            synchronized (mUserRestrictionsListeners) {\n-                mUserRestrictionsListeners.remove(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void addUserLifecycleListener(UserLifecycleListener listener) {\n-            synchronized (mUserLifecycleListeners) {\n-                mUserLifecycleListeners.add(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserLifecycleListener(UserLifecycleListener listener) {\n-            synchronized (mUserLifecycleListeners) {\n-                mUserLifecycleListeners.remove(listener);\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public void setDeviceManaged(boolean isManaged) {\n-            synchronized (mUsersLock) {\n-                mIsDeviceManaged = isManaged;\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public boolean isDeviceManaged() {\n-            synchronized (mUsersLock) {\n-                return mIsDeviceManaged;\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public void setUserManaged(@UserIdInt int userId, boolean isManaged) {\n-            synchronized (mUsersLock) {\n-                mIsUserManaged.put(userId, isManaged);\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public boolean isUserManaged(@UserIdInt int userId) {\n-            synchronized (mUsersLock) {\n-                return mIsUserManaged.get(userId);\n-            }\n-        }\n-\n-        @Override\n-        public void setUserIcon(@UserIdInt int userId, Bitmap bitmap) {\n-            final long ident = Binder.clearCallingIdentity();\n-            try {\n-                synchronized (mPackagesLock) {\n-                    UserData userData = getUserDataNoChecks(userId);\n-                    if (userData == null || userData.info.partial) {\n-                        Slog.w(LOG_TAG, \"setUserIcon: unknown user #\" + userId);\n-                        return;\n-                    }\n-                    writeBitmapLP(userData.info, bitmap);\n-                    writeUserLP(userData);\n-                }\n-                sendUserInfoChangedBroadcast(userId);\n-            } finally {\n-                Binder.restoreCallingIdentity(ident);\n-            }\n-        }\n-\n-        @Override\n-        public void setForceEphemeralUsers(boolean forceEphemeralUsers) {\n-            synchronized (mUsersLock) {\n-                mForceEphemeralUsers = forceEphemeralUsers;\n-            }\n-        }\n-\n-        @Override\n-        public void removeAllUsers() {\n-            if (UserHandle.USER_SYSTEM == getCurrentUserId()) {\n-                // Remove the non-system users straight away.\n-                removeAllUsersExceptSystemAndPermanentAdminMain();\n-            } else {\n-                // Switch to the system user first and then remove the other users.\n-                BroadcastReceiver userSwitchedReceiver = new BroadcastReceiver() {\n-                    @Override\n-                    public void onReceive(Context context, Intent intent) {\n-                        int userId =\n-                                intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n-                        if (userId != UserHandle.USER_SYSTEM) {\n-                            return;\n-                        }\n-                        mContext.unregisterReceiver(this);\n-                        removeAllUsersExceptSystemAndPermanentAdminMain();\n-                    }\n-                };\n-                IntentFilter userSwitchedFilter = new IntentFilter();\n-                userSwitchedFilter.addAction(Intent.ACTION_USER_SWITCHED);\n-                mContext.registerReceiver(\n-                        userSwitchedReceiver, userSwitchedFilter, null, mHandler);\n-\n-                // Switch to the system user.\n-                ActivityManager am =\n-                        (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);\n-                am.switchUser(UserHandle.USER_SYSTEM);\n-            }\n-        }\n-\n-        @Override\n-        public void onEphemeralUserStop(@UserIdInt int userId) {\n-            synchronized (mUsersLock) {\n-               UserInfo userInfo = getUserInfoLU(userId);\n-               if (userInfo != null && userInfo.isEphemeral()) {\n-                    // Do not allow switching back to the ephemeral user again as the user is going\n-                    // to be deleted.\n-                    userInfo.flags |= UserInfo.FLAG_DISABLED;\n-                    if (userInfo.isGuest()) {\n-                        // Indicate that the guest will be deleted after it stops.\n-                        userInfo.guestToRemove = true;\n-                    }\n-               }\n-            }\n-        }\n-\n-        @Override\n-        public @NonNull UserInfo createUserEvenWhenDisallowed(\n-                @Nullable String name, @NonNull String userType, @UserInfoFlag int flags,\n-                @Nullable String[] disallowedPackages, @Nullable Object token)\n-                throws UserManager.CheckedUserOperationException {\n-\n-            return createUserInternalUnchecked(name, userType, flags,\n-                    UserHandle.USER_NULL, /* preCreated= */ false, disallowedPackages, token);\n-        }\n-\n-        @Override\n-        public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId) {\n-            return removeUserWithProfilesUnchecked(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserRunning(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state =  mUserStates.get(userId, UserState.STATE_NONE);\n-            }\n-\n-            return state != UserState.STATE_NONE\n-                    && state != UserState.STATE_STOPPING\n-                    && state != UserState.STATE_SHUTDOWN;\n-        }\n-\n-        @Override\n-        public void setUserState(@UserIdInt int userId, int userState) {\n-            synchronized (mUserStates) {\n-                mUserStates.put(userId, userState);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserState(@UserIdInt int userId) {\n-            synchronized (mUserStates) {\n-                mUserStates.delete(userId);\n-            }\n-        }\n-\n-        @Override\n-        public int[] getUserIds() {\n-            return UserManagerService.this.getUserIds();\n-        }\n-\n-        @Override\n-        public @NonNull List<UserInfo> getUsers(boolean excludeDying) {\n-            return getUsers(/*excludePartial= */ true, excludeDying, /* excludePreCreated= */ true);\n-        }\n-\n-        @Override\n-        public @NonNull List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying,\n-                boolean excludePreCreated) {\n-            return UserManagerService.this.getUsersInternal(excludePartial, excludeDying,\n-                    excludePreCreated);\n-        }\n-\n-        @Override\n-        public @NonNull int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly) {\n-            synchronized (mUsersLock) {\n-                return getProfileIdsLU(userId, null /* userType */, enabledOnly).toArray();\n-            }\n-        }\n-\n-        @Override\n-        public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state = mUserStates.get(userId, -1);\n-            }\n-            // Special case, in the stopping/shutdown state user key can still be unlocked\n-            if (state == UserState.STATE_STOPPING || state == UserState.STATE_SHUTDOWN) {\n-                return StorageManager.isUserKeyUnlocked(userId);\n-            }\n-            return (state == UserState.STATE_RUNNING_UNLOCKING)\n-                    || (state == UserState.STATE_RUNNING_UNLOCKED);\n-        }\n-\n-        /**\n-         * The return values of this method are cached in clients.  If the\n-         * logic in this function changes then the cache invalidation code\n-         * may need to be revisited.\n-         */\n-        @Override\n-        public boolean isUserUnlocked(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state = mUserStates.get(userId, -1);\n-            }\n-            // Special case, in the stopping/shutdown state user key can still be unlocked\n-            if (state == UserState.STATE_STOPPING || state == UserState.STATE_SHUTDOWN) {\n-                return StorageManager.isUserKeyUnlocked(userId);\n-            }\n-            return state == UserState.STATE_RUNNING_UNLOCKED;\n-        }\n-\n-        @Override\n-        public boolean isUserInitialized(@UserIdInt int userId) {\n-            return (getUserInfo(userId).flags & UserInfo.FLAG_INITIALIZED) != 0;\n-        }\n-\n-        @Override\n-        public boolean exists(@UserIdInt int userId) {\n-            return getUserInfoNoChecks(userId) != null;\n-        }\n-\n-        @Override\n-        public boolean isProfileAccessible(int callingUserId, int targetUserId, String debugMsg,\n-                boolean throwSecurityException) {\n-            if (targetUserId == callingUserId) {\n-                return true;\n-            }\n-            synchronized (mUsersLock) {\n-                UserInfo callingUserInfo = getUserInfoLU(callingUserId);\n-                if (callingUserInfo == null || callingUserInfo.isProfile()) {\n-                    if (throwSecurityException) {\n-                        throw new SecurityException(\n-                                debugMsg + \" for another profile \"\n-                                        + targetUserId + \" from \" + callingUserId);\n-                    }\n-                    Slog.w(LOG_TAG, debugMsg + \" for another profile \"\n-                            + targetUserId + \" from \" + callingUserId);\n-                    return false;\n-                }\n-\n-                UserInfo targetUserInfo = getUserInfoLU(targetUserId);\n-                if (targetUserInfo == null || !targetUserInfo.isEnabled()) {\n-                    // Do not throw any exception here as this could happen due to race conditions\n-                    // between the system updating its state and the client getting notified.\n-                    if (throwSecurityException) {\n-                        Slog.w(LOG_TAG, debugMsg + \" for disabled profile \"\n-                                + targetUserId + \" from \" + callingUserId);\n-                    }\n-                    return false;\n-                }\n-\n-                if (targetUserInfo.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID ||\n-                        targetUserInfo.profileGroupId != callingUserInfo.profileGroupId) {\n-                    if (throwSecurityException) {\n-                        throw new SecurityException(\n-                                debugMsg + \" for unrelated profile \" + targetUserId);\n-                    }\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public int getProfileParentId(@UserIdInt int userId) {\n-            return getProfileParentIdUnchecked(userId);\n-        }\n-\n-        @Override\n-        public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId,\n-                String value, int callingUid) {\n-            return UserManagerService.this.isSettingRestrictedForUser(setting, userId,\n-                    value, callingUid);\n-        }\n-\n-        @Override\n-        public boolean hasUserRestriction(String restrictionKey, @UserIdInt int userId) {\n-            if (!UserRestrictionsUtils.isValidRestriction(restrictionKey)) {\n-                return false;\n-            }\n-            Bundle restrictions = getEffectiveUserRestrictions(userId);\n-            return restrictions != null && restrictions.getBoolean(restrictionKey);\n-        }\n-\n-        @Override\n-        public @Nullable UserInfo getUserInfo(@UserIdInt int userId) {\n-            UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = mUsers.get(userId);\n-            }\n-            return userData == null ? null : userData.info;\n-        }\n-\n-        @Override\n-        public @NonNull UserInfo[] getUserInfos() {\n-            synchronized (mUsersLock) {\n-                int userSize = mUsers.size();\n-                UserInfo[] allInfos = new UserInfo[userSize];\n-                for (int i = 0; i < userSize; i++) {\n-                    allInfos[i] = mUsers.valueAt(i).info;\n-                }\n-                return allInfos;\n-            }\n-        }\n-\n-        @Override\n-        public void setDefaultCrossProfileIntentFilters(\n-                @UserIdInt int parentUserId, @UserIdInt int profileUserId) {\n-            final UserTypeDetails userTypeDetails = getUserTypeDetailsNoChecks(profileUserId);\n-            final Bundle restrictions = getEffectiveUserRestrictions(profileUserId);\n-            UserManagerService.this.setDefaultCrossProfileIntentFilters(\n-                    profileUserId, userTypeDetails, restrictions, parentUserId);\n-        }\n-\n-        @Override\n-        public boolean shouldIgnorePrepareStorageErrors(int userId) {\n-            synchronized (mUsersLock) {\n-                UserData userData = mUsers.get(userId);\n-                return userData != null && userData.getIgnorePrepareStorageErrors();\n-            }\n-        }\n-\n-        @Override\n-        public @Nullable UserProperties getUserProperties(@UserIdInt int userId) {\n-            final UserProperties props = getUserPropertiesInternal(userId);\n-            if (props == null) {\n-                Slog.w(LOG_TAG, \"A null UserProperties was returned for user \" + userId);\n-            }\n-            return props;\n-        }\n-\n-        @Override\n-        @UserAssignmentResult\n-        public int assignUserToDisplayOnStart(@UserIdInt int userId,\n-                @UserIdInt int profileGroupId, @UserStartMode int userStartMode, int displayId) {\n-            return mUserVisibilityMediator.assignUserToDisplayOnStart(userId, profileGroupId,\n-                    userStartMode, displayId);\n-        }\n-\n-        @Override\n-        public boolean assignUserToExtraDisplay(int userId, int displayId) {\n-            return mUserVisibilityMediator.assignUserToExtraDisplay(userId, displayId);\n-        }\n-\n-        @Override\n-        public boolean unassignUserFromExtraDisplay(int userId, int displayId) {\n-            return mUserVisibilityMediator.unassignUserFromExtraDisplay(userId, displayId);\n-        }\n-\n-        @Override\n-        public void unassignUserFromDisplayOnStop(@UserIdInt int userId) {\n-            mUserVisibilityMediator.unassignUserFromDisplayOnStop(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserVisible(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.isUserVisible(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserVisible(@UserIdInt int userId, int displayId) {\n-            return mUserVisibilityMediator.isUserVisible(userId, displayId);\n-        }\n-\n-        @Override\n-        public int getMainDisplayAssignedToUser(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.getMainDisplayAssignedToUser(userId);\n-        }\n-\n-        @Override\n-        public @Nullable int[] getDisplaysAssignedToUser(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.getDisplaysAssignedToUser(userId);\n-        }\n-\n-        @Override\n-        public @UserIdInt int getUserAssignedToDisplay(int displayId) {\n-            return mUserVisibilityMediator.getUserAssignedToDisplay(displayId);\n-        }\n-\n-        @Override\n-        public void addUserVisibilityListener(UserVisibilityListener listener) {\n-            mUserVisibilityMediator.addListener(listener);\n-        }\n-\n-        @Override\n-        public void removeUserVisibilityListener(UserVisibilityListener listener) {\n-            mUserVisibilityMediator.removeListener(listener);\n-        }\n-\n-        @Override\n-        public void onSystemUserVisibilityChanged(boolean visible) {\n-            mUserVisibilityMediator.onSystemUserVisibilityChanged(visible);\n-        }\n-\n-        @Override\n-        public int[] getUserTypesForStatsd(@UserIdInt int[] userIds) {\n-            if (userIds == null) {\n-                return null;\n-            }\n-            final int[] userTypes = new int[userIds.length];\n-            for (int i = 0; i < userTypes.length; i++) {\n-                final UserInfo userInfo = getUserInfo(userIds[i]);\n-                if (userInfo == null) {\n-                    // Not possible because the input user ids should all be valid\n-                    userTypes[i] = mUserJourneyLogger.getUserTypeForStatsd(\"\");\n-                } else {\n-                    userTypes[i] = mUserJourneyLogger.getUserTypeForStatsd(userInfo.userType);\n-                }\n-            }\n-            return userTypes;\n-        }\n-\n-        @Override\n-        public @UserIdInt int getMainUserId() {\n-            return getMainUserIdUnchecked();\n-        }\n-\n-        @Override\n-        public @UserIdInt int getBootUser(boolean waitUntilSet)\n-                throws UserManager.CheckedUserOperationException {\n-            if (waitUntilSet) {\n-                final TimingsTraceAndSlog t = new TimingsTraceAndSlog();\n-                t.traceBegin(\"wait-boot-user\");\n-                try {\n-                    if (mBootUserLatch.getCount() != 0) {\n-                        Slogf.d(LOG_TAG,\n-                                \"Sleeping for boot user to be set. \"\n-                                + \"Max sleep for Time: %d\", BOOT_USER_SET_TIMEOUT_MS);\n-                    }\n-                    if (!mBootUserLatch.await(BOOT_USER_SET_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                        Slogf.w(LOG_TAG, \"Boot user not set. Timeout: %d\",\n-                                BOOT_USER_SET_TIMEOUT_MS);\n-                    }\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    Slogf.w(LOG_TAG, e, \"InterruptedException during wait for boot user.\");\n-                }\n-                t.traceEnd();\n-            }\n-\n-            return getBootUserUnchecked();\n-        }\n-\n-    } // class LocalService\n-\n-\n-\n-    /**\n-     * Check if user has restrictions\n-     * @param restriction restrictions to check\n-     * @param userId id of the user\n-     *\n-     * @throws {@link android.os.UserManager.CheckedUserOperationException} if user has any of the\n-     *      specified restrictions\n-     */\n-    private void enforceUserRestriction(String restriction, @UserIdInt int userId, String message)\n-            throws UserManager.CheckedUserOperationException {\n-        if (hasUserRestriction(restriction, userId)) {\n-            String errorMessage = (message != null ? (message + \": \") : \"\")\n-                    + restriction + \" is enabled.\";\n-            Slog.w(LOG_TAG, errorMessage);\n-            throw new UserManager.CheckedUserOperationException(errorMessage,\n-                    USER_OPERATION_ERROR_UNKNOWN);\n-        }\n-    }\n-\n-    /**\n-     * Throws CheckedUserOperationException and shows error log\n-     * @param message message for exception and logging\n-     * @param userOperationResult result/error code\n-     * @throws UserManager.CheckedUserOperationException\n-     */\n-    private void throwCheckedUserOperationException(@NonNull String message,\n-            @UserManager.UserOperationResult int userOperationResult)\n-            throws UserManager.CheckedUserOperationException {\n-        Slog.e(LOG_TAG, message);\n-        throw new UserManager.CheckedUserOperationException(message, userOperationResult);\n-    }\n-\n-    /* Remove all the users except the system and permanent admin main.*/\n-    private void removeAllUsersExceptSystemAndPermanentAdminMain() {\n-        ArrayList<UserInfo> usersToRemove = new ArrayList<>();\n-        synchronized (mUsersLock) {\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                UserInfo ui = mUsers.valueAt(i).info;\n-                if (ui.id != UserHandle.USER_SYSTEM && !isNonRemovableMainUser(ui)) {\n-                    usersToRemove.add(ui);\n-                }\n-            }\n-        }\n-        for (UserInfo ui: usersToRemove) {\n-            removeUser(ui.id);\n-        }\n-    }\n-\n-    private static void debug(String message) {\n-        Slog.d(LOG_TAG, message\n-                + (DBG_WITH_STACKTRACE ? \" called at\\n\" + Debug.getCallers(10, \"  \") : \"\"));\n-    }\n-\n-    /** @see #getMaxUsersOfTypePerParent(UserTypeDetails) */\n-    @VisibleForTesting\n-    int getMaxUsersOfTypePerParent(String userType) {\n-        final UserTypeDetails type = mUserTypes.get(userType);\n-        if (type == null) {\n-            return 0;\n-        }\n-        return getMaxUsersOfTypePerParent(type);\n-    }\n-\n-    /**\n-     * Returns the maximum number of users allowed for the given userTypeDetails per parent user.\n-     * This is applicable for user types that are {@link UserTypeDetails#isProfile()}.\n-     * If there is no maximum, {@link UserTypeDetails#UNLIMITED_NUMBER_OF_USERS} is returned.\n-     * Under certain circumstances (such as after a change-user-type) the max value can actually\n-     * be exceeded: this is allowed in order to keep the device in a usable state.\n-     * An error is logged in {@link UserManagerService#upgradeProfileToTypeLU}\n-     */\n-    private static int getMaxUsersOfTypePerParent(UserTypeDetails userTypeDetails) {\n-        final int defaultMax = userTypeDetails.getMaxAllowedPerParent();\n-        if (!Build.IS_DEBUGGABLE) {\n-            return defaultMax;\n-        } else {\n-            if (userTypeDetails.isManagedProfile()) {\n-                return SystemProperties.getInt(\"persist.sys.max_profiles\", defaultMax);\n-            }\n-        }\n-        return defaultMax;\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    @VisibleForTesting\n-    int getFreeProfileBadgeLU(int parentUserId, String userType) {\n-        Set<Integer> usedBadges = new ArraySet<>();\n-        final int userSize = mUsers.size();\n-        for (int i = 0; i < userSize; i++) {\n-            UserInfo ui = mUsers.valueAt(i).info;\n-            // Check which badge indexes are already used by this profile group.\n-            if (ui.userType.equals(userType)\n-                    && ui.profileGroupId == parentUserId\n-                    && !mRemovingUserIds.get(ui.id)) {\n-                usedBadges.add(ui.profileBadge);\n-            }\n-        }\n-        int maxUsersOfType = getMaxUsersOfTypePerParent(userType);\n-        if (maxUsersOfType == UserTypeDetails.UNLIMITED_NUMBER_OF_USERS) {\n-            maxUsersOfType = Integer.MAX_VALUE;\n-        }\n-        for (int i = 0; i < maxUsersOfType; i++) {\n-            if (!usedBadges.contains(i)) {\n-                return i;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Checks if the given user has a profile associated with it.\n-     * @param userId The parent user\n-     * @return\n-     */\n-    boolean hasProfile(@UserIdInt int userId) {\n-        synchronized (mUsersLock) {\n-            UserInfo userInfo = getUserInfoLU(userId);\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                UserInfo profile = mUsers.valueAt(i).info;\n-                if (userId != profile.id && isProfileOf(userInfo, profile)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Checks if the calling package name matches with the calling UID, throw\n-     * {@link SecurityException} if not.\n-     */\n-    private void verifyCallingPackage(String callingPackage, int callingUid) {\n-        int packageUid = mPm.snapshotComputer()\n-                .getPackageUid(callingPackage, 0,  UserHandle.getUserId(callingUid));\n-        if (packageUid != callingUid) {\n-            throw new SecurityException(\"Specified package \" + callingPackage\n-                    + \" does not match the calling uid \" + callingUid);\n-        }\n-    }\n-\n-    /** Retrieves the internal package manager interface. */\n-    private PackageManagerInternal getPackageManagerInternal() {\n-        // Don't need to synchonize; worst-case scenario LocalServices will be called twice.\n-        if (mPmInternal == null) {\n-            mPmInternal = LocalServices.getService(PackageManagerInternal.class);\n-        }\n-        return mPmInternal;\n-    }\n-\n-    /** Returns the internal device policy manager interface. */\n-    private DevicePolicyManagerInternal getDevicePolicyManagerInternal() {\n-        if (mDevicePolicyManagerInternal == null) {\n-            mDevicePolicyManagerInternal =\n-                    LocalServices.getService(DevicePolicyManagerInternal.class);\n-        }\n-        return mDevicePolicyManagerInternal;\n-    }\n-\n-    /** Returns the internal activity manager interface. */\n-    private @Nullable ActivityManagerInternal getActivityManagerInternal() {\n-        if (mAmInternal == null) {\n-            mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n-        }\n-        return mAmInternal;\n-    }\n-\n-    /**\n-     * Returns true, when user has {@link UserInfo#FLAG_MAIN} and system property\n-     * {@link com.android.internal.R.bool#config_isMainUserPermanentAdmin} is true.\n-     */\n-    private boolean isNonRemovableMainUser(UserInfo userInfo) {\n-        return userInfo.isMain() && isMainUserPermanentAdmin();\n-    }\n-\n-    /**\n-     * Returns true if {@link com.android.internal.R.bool#config_isMainUserPermanentAdmin} is true.\n-     * If the main user is a permanent admin user it can't be deleted\n-     * or downgraded to non-admin status.\n-     */\n-    public boolean isMainUserPermanentAdmin() {\n-        return Resources.getSystem()\n-                .getBoolean(R.bool.config_isMainUserPermanentAdmin);\n-    }\n-\n-    /**\n-     * Returns true if {@link com.android.internal.R.bool#config_canSwitchToHeadlessSystemUser}\n-     * is true. If allowed, headless system user can run in the foreground even though\n-     * it is not a full user.\n-     */\n-    public boolean canSwitchToHeadlessSystemUser() {\n-        return Resources.getSystem()\n-                .getBoolean(R.bool.config_canSwitchToHeadlessSystemUser);\n-    }\n-\n-    /**\n-     * Returns instance of {@link com.android.server.pm.UserJourneyLogger}.\n-     */\n-    public UserJourneyLogger getUserJourneyLogger() {\n-        return mUserJourneyLogger;\n-    }\n-\n-}\n-```+            synchronized (",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0092,
      "token_level_edit_distance": 7213,
      "codebert_score": {
        "precision": 0.6943,
        "recall": 0.8504,
        "f1": 0.7645,
        "f3": 0.8317
      },
      "token_count_upstream": 53,
      "token_count_downstream": 4689,
      "token_count_total": 4742,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 201.7,
    "rej_file_diff": "--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -4342,6 +4350,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     private void logVerifyAndGetBypassFailure(int uid, @NonNull SecurityException e,\n             @NonNull String methodName) {\n         if (Process.isIsolated(uid)) {",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -3919,6 +3919,45 @@\n     }\n \n     /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n+    private void logVerifyAndGetBypassFailure(int uid, @NonNull SecurityException e,\n+            @NonNull String methodName) {\n+        if (Process.isIsolated(uid)) {\n+            Slog.e(TAG, \"Cannot verifyAndGetBypass for uid \" + uid + \": isolated process\");\n+        } else {\n+            Slog.e(TAG, \"Cannot verifyAndGetBypass\", e);\n+        }\n+    }\n+\n+    /**\n      * Get (and potentially create) ops.\n      *\n      * @param uid The uid the package belongs to\n@@ -6487,136 +6526,4 @@\n                 @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                 @Nullable String message, boolean shouldCollectMessage,\n                 boolean skipProxyOperation) {\n-            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    AppOpsService.this::noteProxyOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n-                @Nullable String packageName, @NonNull String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                @AttributionFlags int attributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startOperation(token, code, uid, packageName,\n-                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            this::startDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            AppOpsService.this::startOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, attributionFlags, attributionChainId);\n-            }\n-            return startOperationImpl(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n-                @Nullable String packageName, @Nullable String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n-                int attributionChainId) {\n-            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            this::startDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            AppOpsService.this::startProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n-            }\n-            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n-                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n-        }\n-\n-        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n-                String attributionTag) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            this::finishDelegateOperationImpl);\n-                } else {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            AppOpsService.this::finishOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            } else {\n-                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            }\n-        }\n-\n-        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n-                String packageName, String attributionTag) {\n-            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                    AppOpsService.this::finishOperationImpl);\n-        }\n-\n-        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n-                } else {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        skipProxyOperation);\n-            } else {\n-                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n-            }\n-        }\n-\n-        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n-                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-            return null;\n-        }\n-    }\n-}\n-```+            return mCheckOpsDelegate",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.1527,
      "token_level_edit_distance": 1084,
      "codebert_score": {
        "precision": 0.7625,
        "recall": 0.8769,
        "f1": 0.8157,
        "f3": 0.8639
      },
      "token_count_upstream": 198,
      "token_count_downstream": 847,
      "token_count_total": 1045,
      "cosine_similarity_openai": 0.7621
    }
  }
]