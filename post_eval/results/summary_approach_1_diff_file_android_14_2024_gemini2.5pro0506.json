[
  {
    "cve_id": "ASB-A-242996380",
    "downstream_version": "14",
    "file_name": "service/src/com/android/server/bluetooth/BtPermissionUtils.java",
    "runtime_seconds": null,
    "rej_file_diff": "",
    "llm_generated_patch": "",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 0,
      "token_count_downstream": 0,
      "token_count_total": 0,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-316891059",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 89.25,
    "rej_file_diff": "--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -52,11 +52,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n-        FeatureFactory.getFactory(this)\n+        FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,10 +138,10 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n-                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n+                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n }",
    "metrics": {
      "relative_line_count_similarity": 0.8889,
      "normalized_edit_similarity": 0.72,
      "token_level_edit_distance": 35,
      "codebert_score": {
        "precision": 0.9444,
        "recall": 0.8923,
        "f1": 0.9176,
        "f3": 0.8973
      },
      "token_count_upstream": 114,
      "token_count_downstream": 109,
      "token_count_total": 223,
      "cosine_similarity_openai": 0.8718
    }
  },
  {
    "cve_id": "ASB-A-333364513",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/search/SearchResultTrampoline.java",
    "runtime_seconds": 13.94,
    "rej_file_diff": "--- src/com/android/settings/search/SearchResultTrampoline.java\n+++ src/com/android/settings/search/SearchResultTrampoline.java\n@@ -52,11 +51,11 @@ public class SearchResultTrampoline extends Activity {\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n         FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,9 +137,9 @@ public class SearchResultTrampoline extends Activity {\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n                 FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -52,11 +52,11 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        final ComponentName callingActivity = getCallingActivity();\n+        final String callerPackage = getLaunchedFromPackage();\n         // First make sure caller has privilege to launch a search result page.\n-        FeatureFactory.getFactory(this)\n+        FeatureFactory.getFeatureFactory()\n                 .getSearchFeatureProvider()\n-                .verifyLaunchSearchResultPageCaller(this, callingActivity);\n+                .verifyLaunchSearchResultPageCaller(this, callerPackage);\n         // Didn't crash, proceed and launch the result as a subsetting.\n         Intent intent = getIntent();\n         final String highlightMenuKey = intent.getStringExtra(\n@@ -138,10 +138,10 @@\n         finish();\n     }\n \n-    private boolean isSettingsIntelligence(ComponentName callingActivity) {\n-        return callingActivity != null && TextUtils.equals(\n-                callingActivity.getPackageName(),\n-                FeatureFactory.getFactory(this).getSearchFeatureProvider()\n+    private boolean isSettingsIntelligence(String callerPackage) {\n+        return TextUtils.equals(\n+                callerPackage,\n+                FeatureFactory.getFeatureFactory().getSearchFeatureProvider()\n                         .getSettingsIntelligencePkgName(this));\n     }\n }",
    "metrics": {
      "relative_line_count_similarity": 0.8889,
      "normalized_edit_similarity": 0.72,
      "token_level_edit_distance": 35,
      "codebert_score": {
        "precision": 0.9444,
        "recall": 0.8923,
        "f1": 0.9176,
        "f3": 0.8973
      },
      "token_count_upstream": 114,
      "token_count_downstream": 109,
      "token_count_total": 223,
      "cosine_similarity_openai": 0.8721
    }
  },
  {
    "cve_id": "ASB-A-314333719",
    "downstream_version": "14",
    "file_name": "packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java",
    "runtime_seconds": 81.44,
    "rej_file_diff": "--- packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n+++ packages/SystemUI/src/com/android/systemui/media/dagger/MediaModule.java\n@@ -20,6 +20,7 @@ import com.android.systemui.dagger.SysUISingleton;\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n import com.android.systemui.media.controls.domain.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.controller.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.controller.MediaHostStatesManager;\n import com.android.systemui.media.controls.ui.view.MediaHost;\n@@ -98,8 +103,9 @@ public interface MediaModule {\n     @Named(COMMUNAL_HUB)\n     static MediaHost providesCommunalMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n             MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n-            MediaHostStatesManager statesManager) {\n-        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager);\n+            MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n+        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,\n+                carouselController);\n     }\n \n     /** Provides a logging buffer related to the media tap-to-transfer chip on the sender device. */",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -21,6 +21,7 @@\n import com.android.systemui.log.LogBuffer;\n import com.android.systemui.log.LogBufferFactory;\n import com.android.systemui.media.controls.pipeline.MediaDataManager;\n+import com.android.systemui.media.controls.ui.controller.MediaCarouselController;\n import com.android.systemui.media.controls.ui.MediaHierarchyManager;\n import com.android.systemui.media.controls.ui.MediaHost;\n import com.android.systemui.media.controls.ui.MediaHostStatesManager;\n@@ -50,6 +51,7 @@\n     String QUICK_QS_PANEL = \"media_quick_qs_panel\";\n     String KEYGUARD = \"media_keyguard\";\n     String DREAM = \"dream\";\n+    String COMMUNAL_HUB = \"communal_hub\";\n \n     /** */\n     @Provides\n@@ -89,6 +91,17 @@\n     @SysUISingleton\n     @Named(DREAM)\n     static MediaHost providesDreamMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n+            MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n+            MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n+        return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,\n+                carouselController);\n+    }\n+\n+    /** */\n+    @Provides\n+    @SysUISingleton\n+    @Named(COMMUNAL_HUB)\n+    static MediaHost providesCommunalMediaHost(MediaHost.MediaHostStateHolder stateHolder,\n             MediaHierarchyManager hierarchyManager, MediaDataManager dataManager,\n             MediaHostStatesManager statesManager, MediaCarouselController carouselController) {\n         return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager,",
    "metrics": {
      "relative_line_count_similarity": 0.3333,
      "normalized_edit_similarity": 0.4129,
      "token_level_edit_distance": 164,
      "codebert_score": {
        "precision": 0.8616,
        "recall": 0.8531,
        "f1": 0.8573,
        "f3": 0.8539
      },
      "token_count_upstream": 84,
      "token_count_downstream": 108,
      "token_count_total": 192,
      "cosine_similarity_openai": 0.7777
    }
  },
  {
    "cve_id": "ASB-A-328068777",
    "downstream_version": "14",
    "file_name": "service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java",
    "runtime_seconds": 182.34,
    "rej_file_diff": "--- service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n+++ service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java\n@@ -1031,6 +1043,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {\n                                         callerPackageName, request.getToken());\n                         tryAcquireApiCallQuota(\n                                 uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n                         long startDateAccessEpochMilli = DEFAULT_LONG;",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -822,7 +822,7 @@\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                     } catch (IllegalArgumentException illegalArgumentException) {\n-                        logger.setHealthDataServiceApiStatusError(\n+                        builder.setHealthDataServiceApiStatusError(\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                         Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                         tryAndThrowException(\n@@ -856,12 +856,12 @@\n     @Override\n     public void getChangeLogs(\n             @NonNull AttributionSource attributionSource,\n-            @NonNull ChangeLogsRequest token,\n+            @NonNull ChangeLogsRequest request,\n             IChangeLogsResponseCallback callback) {\n         final int uid = Binder.getCallingUid();\n         final UserHandle userHandle = Binder.getCallingUserHandle();\n         final String callerPackageName = Objects.requireNonNull(attributionSource.getPackageName());\n-        final HealthConnectServiceLogger.Builder builder =\n+        final HealthConnectServiceLogger.Builder logger =\n                 new HealthConnectServiceLogger.Builder(false, GET_CHANGES)\n                         .setPackageName(callerPackageName);\n \n@@ -874,27 +874,32 @@\n                         throwExceptionIfDataSyncInProgress();\n                         ChangeLogsRequestHelper.TokenRequest changeLogsTokenRequest =\n                                 ChangeLogsRequestHelper.getRequest(\n-                                        attributionSource.getPackageName(), token.getToken());\n+                                        callerPackageName, request.getToken());\n+                        tryAcquireApiCallQuota(\n+                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, logger);\n+                        if (changeLogsTokenRequest.getRecordTypes().isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Requested record types must not be empty.\");\n+                        }\n                         mDataPermissionEnforcer.enforceRecordIdsReadPermissions(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n+                        long startDateAccessEpochMilli = DEFAULT_LONG;\n                         boolean isInForeground = mAppOpsManagerLocal.isUidInForeground(uid);\n                         if (!isInForeground) {\n                             throwSecurityException(\n                                     attributionSource.getPackageName()\n                                             + \" must be in foreground to read the change logs\");\n                         }\n-                        tryAcquireApiCallQuota(\n-                                uid, QuotaCategory.QUOTA_CATEGORY_READ, isInForeground, builder);\n                         Instant startDateInstant =\n                                 mPermissionHelper.getHealthDataStartDateAccess(\n                                         attributionSource.getPackageName(), userHandle);\n                         if (startDateInstant == null) {\n                             throwExceptionIncorrectPermissionState();\n                         }\n-                        long startDateAccess = startDateInstant.toEpochMilli();\n+                        startDateAccessEpochMilli = startDateInstant.toEpochMilli();\n                         final ChangeLogsHelper.ChangeLogsResponse changeLogsResponse =\n                                 ChangeLogsHelper.getInstance()\n-                                        .getChangeLogs(changeLogsTokenRequest, token);\n+                                        .getChangeLogs(changeLogsTokenRequest, request);\n \n                         Map<Integer, List<UUID>> recordTypeToInsertedUuids =\n                                 ChangeLogsHelper.getRecordTypeToInsertedUuids(\n@@ -909,7 +914,7 @@\n                                         new ReadTransactionRequest(\n                                                 callerPackageName,\n                                                 recordTypeToInsertedUuids,\n-                                                startDateAccess,\n+                                                startDateAccessEpochMilli,\n                                                 extraReadPermsToGrantState));\n \n                         List<DeletedLog> deletedLogs =\n@@ -924,11 +929,11 @@\n                                         changeLogsResponse.hasMorePages()));\n                         finishDataDeliveryRead(\n                                 changeLogsTokenRequest.getRecordTypes(), attributionSource);\n-                        builder.setHealthDataServiceApiStatusSuccess()\n+                        logger.setHealthDataServiceApiStatusSuccess()\n                                 .setNumberOfRecords(recordInternals.size() + deletedLogs.size())\n                                 .setDataTypesFromRecordInternals(recordInternals);\n                     } catch (IllegalArgumentException illegalArgumentException) {\n-                        builder.setHealthDataServiceApiStatusError(\n+                        logger.setHealthDataServiceApiStatusError(\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                         Slog.e(TAG, \"IllegalArgumentException: \", illegalArgumentException);\n                         tryAndThrowException(\n@@ -936,20 +941,20 @@\n                                 illegalArgumentException,\n                                 HealthConnectException.ERROR_INVALID_ARGUMENT);\n                     } catch (SQLiteException sqLiteException) {\n-                        builder.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n+                        logger.setHealthDataServiceApiStatusError(HealthConnectException.ERROR_IO);\n                         Slog.e(TAG, \"SQLiteException: \", sqLiteException);\n                         tryAndThrowException(\n                                 callback, sqLiteException, HealthConnectException.ERROR_IO);\n                     } catch (SecurityException securityException) {\n-                        builder.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n+                        logger.setHealthDataServiceApiStatusError(ERROR_SECURITY);\n                         Slog.e(TAG, \"SecurityException: \", securityException);\n                         tryAndThrowException(callback, securityException, ERROR_SECURITY);\n                     } catch (IllegalStateException illegalStateException) {\n-                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n+                        logger.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                         Slog.e(TAG, \"IllegalStateException: \", illegalStateException);\n                         tryAndThrowException(callback, illegalStateException, ERROR_INTERNAL);\n                     } catch (HealthConnectException healthConnectException) {\n-                        builder.setHealthDataServiceApiStatusError(\n+                        logger.setHealthDataServiceApiStatusError(\n                                 healthConnectException.getErrorCode());\n                         Slog.e(TAG, \"HealthConnectException: \", healthConnectException);\n                         tryAndThrowException(\n@@ -957,11 +962,11 @@\n                                 healthConnectException,\n                                 healthConnectException.getErrorCode());\n                     } catch (Exception exception) {\n-                        builder.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n+                        logger.setHealthDataServiceApiStatusError(ERROR_INTERNAL);\n                         Slog.e(TAG, \"Exception: \", exception);\n                         tryAndThrowException(callback, exception, ERROR_INTERNAL);\n                     } finally {\n-                        builder.build().log();\n+                        logger.build().log();\n                     }\n                 },\n                 uid,",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.091,
      "token_level_edit_distance": 729,
      "codebert_score": {
        "precision": 0.7422,
        "recall": 0.8492,
        "f1": 0.7921,
        "f3": 0.8371
      },
      "token_count_upstream": 46,
      "token_count_downstream": 344,
      "token_count_total": 390,
      "cosine_similarity_openai": 0.7136
    }
  },
  {
    "cve_id": "ASB-A-309938635",
    "downstream_version": "14",
    "file_name": "ojluni/src/main/java/java/util/zip/ZipFile.java",
    "runtime_seconds": 232.9,
    "rej_file_diff": "--- ojluni/src/main/java/java/util/zip/ZipFile.java\n+++ ojluni/src/main/java/java/util/zip/ZipFile.java\n@@ -1436,7 +1436,18 @@ public class ZipFile implements ZipConstants, Closeable {\n                 initCEN(-1);\n                 byte[] buf = new byte[4];\n                 readFullyAt(buf, 0, 4, 0);\n-                this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                // BEGIN Android-changed: do not accept files with invalid header\n+                // this.startsWithLoc = (LOCSIG(buf) == LOCSIG);\n+                long locsig = LOCSIG(buf);\n+                this.startsWithLoc = (locsig == LOCSIG);\n+                // If a zip file starts with \"end of central directory record\" it means that such\n+                // file is empty.\n+                if (locsig != LOCSIG && locsig != ENDSIG) {\n+                    String msg = \"Entry at offset zero has invalid LFH signature \"\n+                                    + Long.toHexString(locsig);\n+                    throw new ZipException(msg);\n+                }\n+                // END Android-changed: do not accept files with invalid header\n             } catch (IOException x) {\n                 try {\n                     this.zfile.close();",
    "llm_generated_patch": "",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0,
      "token_level_edit_distance": 227,
      "codebert_score": {
        "error": "Candidate code and ground truth code must not be empty."
      },
      "token_count_upstream": 133,
      "token_count_downstream": 0,
      "token_count_total": 133,
      "cosine_similarity_openai": 0.0806
    }
  },
  {
    "cve_id": "ASB-A-313428840",
    "downstream_version": "14",
    "file_name": "services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java",
    "runtime_seconds": 200.05,
    "rej_file_diff": "--- services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n+++ services/companion/java/com/android/server/companion/CompanionDeviceManagerService.java\n@@ -949,13 +947,14 @@ public class CompanionDeviceManagerService extends SystemService {\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferProcessor,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -85,9 +85,11 @@\n import android.os.RemoteCallbackList;\n import android.os.RemoteException;\n import android.os.ServiceManager;\n+import android.os.ShellCallback;\n import android.os.SystemProperties;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.os.ResultReceiver;\n import android.util.ArraySet;\n import android.util.ExceptionUtils;\n import android.util.Log;\n@@ -930,13 +932,14 @@\n         }\n \n         @Override\n-        public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err,\n-                String[] args, ShellCallback callback, ResultReceiver resultReceiver)\n-                throws RemoteException {\n-            new CompanionDeviceShellCommand(CompanionDeviceManagerService.this, mAssociationStore,\n-                    mDevicePresenceMonitor, mTransportManager, mSystemDataTransferRequestStore,\n-                    mAssociationRequestsProcessor)\n-                    .exec(this, in, out, err, args, callback, resultReceiver);\n+        public int handleShellCommand(@NonNull ParcelFileDescriptor in,\n+                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,\n+                @NonNull String[] args) {\n+            return new CompanionDeviceShellCommand(CompanionDeviceManagerService.this,\n+                    mAssociationStore, mDevicePresenceMonitor, mTransportManager,\n+                    mSystemDataTransferProcessor, mAssociationRequestsProcessor)\n+                    .exec(this, in.getFileDescriptor(), out.getFileDescriptor(),\n+                            err.getFileDescriptor(), args);\n         }\n \n         @Override",
    "metrics": {
      "relative_line_count_similarity": 0.4545,
      "normalized_edit_similarity": 0.6194,
      "token_level_edit_distance": 98,
      "codebert_score": {
        "precision": 0.8688,
        "recall": 0.8805,
        "f1": 0.8746,
        "f3": 0.8793
      },
      "token_count_upstream": 92,
      "token_count_downstream": 112,
      "token_count_total": 204,
      "cosine_similarity_openai": 0.9142
    }
  },
  {
    "cve_id": "ASB-A-353712853",
    "downstream_version": "14",
    "file_name": "services/usb/java/com/android/server/usb/UsbDeviceManager.java",
    "runtime_seconds": 201.89,
    "rej_file_diff": "--- services/usb/java/com/android/server/usb/UsbDeviceManager.java\n+++ services/usb/java/com/android/server/usb/UsbDeviceManager.java\n@@ -80,9 +80,9 @@ import android.os.storage.StorageVolume;\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n-import android.text.TextUtils;\n \n import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -77,9 +77,11 @@\n import android.provider.Settings;\n import android.service.usb.UsbDeviceManagerProto;\n import android.service.usb.UsbHandlerProto;\n+import android.text.TextUtils;\n import android.util.Pair;\n import android.util.Slog;\n \n+import com.android.internal.R;\n import com.android.internal.annotations.GuardedBy;\n import com.android.internal.logging.MetricsLogger;\n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;",
    "metrics": {
      "relative_line_count_similarity": 0.9167,
      "normalized_edit_similarity": 0.4453,
      "token_level_edit_distance": 32,
      "codebert_score": {
        "precision": 0.8574,
        "recall": 0.8316,
        "f1": 0.8443,
        "f3": 0.8341
      },
      "token_count_upstream": 28,
      "token_count_downstream": 28,
      "token_count_total": 56,
      "cosine_similarity_openai": 0.8195
    }
  },
  {
    "cve_id": "ASB-A-311374917",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/InstallPackageHelper.java",
    "runtime_seconds": 454.57,
    "rej_file_diff": "--- services/core/java/com/android/server/pm/InstallPackageHelper.java\n+++ services/core/java/com/android/server/pm/InstallPackageHelper.java\n@@ -4590,7 +4590,9 @@ final class InstallPackageHelper {\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageLegacyUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageLegacyUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -4743,7 +4743,9 @@\n \n     private void assertPackageWithSharedUserIdIsPrivileged(AndroidPackage pkg)\n             throws PackageManagerException {\n-        if (!AndroidPackageUtils.isPrivileged(pkg) && (pkg.getSharedUserId() != null)) {\n+        if (!AndroidPackageUtils.isPrivileged(pkg)\n+                && (pkg.getSharedUserId() != null)\n+                && !pkg.isLeavingSharedUser()) {\n             SharedUserSetting sharedUserSetting = null;\n             try {\n                 synchronized (mPm.mLock) {",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.664,
      "token_level_edit_distance": 10,
      "codebert_score": {
        "precision": 0.9287,
        "recall": 0.8418,
        "f1": 0.8831,
        "f3": 0.8498
      },
      "token_count_upstream": 48,
      "token_count_downstream": 44,
      "token_count_total": 92,
      "cosine_similarity_openai": 0.9064
    }
  },
  {
    "cve_id": "ASB-A-319081336",
    "downstream_version": "14",
    "file_name": "core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp",
    "runtime_seconds": 183.46,
    "rej_file_diff": "--- core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n+++ core/jni/com_android_internal_os_ZygoteCommandBuffer.cpp\n@@ -425,19 +437,12 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n-\n   bool first_time = true;\n   do {\n-    if (credentials.uid != static_cast<uid_t>(expected_uid)) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -465,6 +470,7 @@ jboolean com_android_internal_os_ZygoteCommandBuffer_nativeForkRepeatedly(\n       }\n     }\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Clear buffer and get count from next command.\n       n_buffer->clear();\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -425,19 +425,13 @@\n     fail_fn_z(\"Failed to retrieve session socket timeout\");\n   }\n \n-  struct ucred credentials;\n-  socklen_t cred_size = sizeof credentials;\n-  if (getsockopt(n_buffer->getFd(), SOL_SOCKET, SO_PEERCRED, &credentials, &cred_size) == -1\n-      || cred_size != sizeof credentials) {\n-    fail_fn_1(CREATE_ERROR(\"ForkRepeatedly failed to get initial credentials, %s\",\n-                           strerror(errno)));\n+  uid_t peerUid = getSocketPeerUid(session_socket, fail_fn_1);\n+  if (peerUid != static_cast<uid_t>(expected_uid)) {\n+    return JNI_FALSE;\n   }\n \n   bool first_time = true;\n   do {\n-    if (credentials.uid != expected_uid) {\n-      return JNI_FALSE;\n-    }\n     n_buffer->readAllLines(first_time ? fail_fn_1 : fail_fn_n);\n     n_buffer->reset();\n     int pid = zygote::forkApp(env, /* no pipe FDs */ -1, -1, session_socket_fds,\n@@ -467,6 +461,7 @@\n     // Clear buffer and get count from next command.\n     n_buffer->clear();\n     for (;;) {\n+      bool valid_session_socket = true;\n       // Poll isn't strictly necessary for now. But without it, disconnect is hard to detect.\n       int poll_res = TEMP_FAILURE_RETRY(poll(fd_structs, 2, -1 /* infinite timeout */));\n       if ((fd_structs[SESSION_IDX].revents & POLLIN) != 0) {",
    "metrics": {
      "relative_line_count_similarity": 0.9688,
      "normalized_edit_similarity": 0.6381,
      "token_level_edit_distance": 79,
      "codebert_score": {
        "precision": 0.912,
        "recall": 0.8966,
        "f1": 0.9042,
        "f3": 0.8981
      },
      "token_count_upstream": 146,
      "token_count_downstream": 156,
      "token_count_total": 302,
      "cosine_similarity_openai": 0.9041
    }
  },
  {
    "cve_id": "ASB-A-318374503",
    "downstream_version": "14",
    "file_name": "system/stack/btm/btm_sec.cc",
    "runtime_seconds": 528.51,
    "rej_file_diff": "--- system/stack/btm/btm_sec.cc\n+++ system/stack/btm/btm_sec.cc\n@@ -267,7 +267,6 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-         p_dev_rec->sec_rec.is_device_authenticated() &&\n          p_dev_rec->sec_rec.is_bond_type_temporary();\n }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -223,7 +223,6 @@\n                                                  bool locally_initiated,\n                                                  uint16_t security_req) {\n   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&\n-    p_dev_rec->is_device_authenticated() &&\n     p_dev_rec->is_bond_type_temporary();\n }",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 0.5493,
      "token_level_edit_distance": 16,
      "codebert_score": {
        "precision": 0.9202,
        "recall": 0.8374,
        "f1": 0.8768,
        "f3": 0.845
      },
      "token_count_upstream": 30,
      "token_count_downstream": 25,
      "token_count_total": 55,
      "cosine_similarity_openai": 0.8136
    }
  },
  {
    "cve_id": "ASB-A-336323279",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 509.96,
    "rej_file_diff": "--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -1563,19 +1563,29 @@ public class AppOpsService extends IAppOpsService.Stub {\n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops,\n             String persistentDeviceId) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n                     }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n+                    }\n                     resOps.add(getOpEntryForResult(curOp, persistentDeviceId));\n                 }\n             }",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -1431,18 +1431,28 @@\n \n     private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n         ArrayList<AppOpsManager.OpEntry> resOps = null;\n+        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n+                Manifest.permission.GET_APP_OPS_STATS,\n+                Binder.getCallingPid(), Binder.getCallingUid())\n+                == PackageManager.PERMISSION_GRANTED;\n         if (ops == null) {\n             resOps = new ArrayList<>();\n-            for (int j=0; j<pkgOps.size(); j++) {\n+            for (int j = 0; j < pkgOps.size(); j++) {\n                 Op curOp = pkgOps.valueAt(j);\n+                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                    continue;\n+                }\n                 resOps.add(getOpEntryForResult(curOp));\n             }\n         } else {\n-            for (int j=0; j<ops.length; j++) {\n+            for (int j = 0; j < ops.length; j++) {\n                 Op curOp = pkgOps.get(ops[j]);\n                 if (curOp != null) {\n                     if (resOps == null) {\n                         resOps = new ArrayList<>();\n+                    }\n+                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n+                        continue;\n                     }\n                     resOps.add(getOpEntryForResult(curOp));\n                 }\n@@ -5668,7 +5678,7 @@\n             return false;\n         }\n         // TODO moltmann: Allow to check for attribution op activeness\n-        synchronized (AppOpsService.this) {\n+        synchronized (this) {\n             Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n             if (pkgOps == null) {\n                 return false;\n@@ -5733,931 +5743,4 @@\n             mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n             if (removedOps != null) {\n                 scheduleFastWriteLocked();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n-            long baseSnapshotInterval, int compressionStep) {\n-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n-                \"setHistoryParameters\");\n-        // Must not hold the appops lock\n-        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n-    }\n-\n-    @Override\n-    public void offsetHistory(long offsetMillis) {\n-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n-                \"offsetHistory\");\n-        // Must not hold the appops lock\n-        mHistoricalRegistry.offsetHistory(offsetMillis);\n-        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n-    }\n-\n-    @Override\n-    public void addHistoricalOps(HistoricalOps ops) {\n-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n-                \"addHistoricalOps\");\n-        // Must not hold the appops lock\n-        mHistoricalRegistry.addHistoricalOps(ops);\n-    }\n-\n-    @Override\n-    public void resetHistoryParameters() {\n-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n-                \"resetHistoryParameters\");\n-        // Must not hold the appops lock\n-        mHistoricalRegistry.resetHistoryParameters();\n-    }\n-\n-    @Override\n-    public void clearHistory() {\n-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n-                \"clearHistory\");\n-        // Must not hold the appops lock\n-        mHistoricalRegistry.clearAllHistory();\n-    }\n-\n-    @Override\n-    public void rebootHistory(long offlineDurationMillis) {\n-        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n-                \"rebootHistory\");\n-\n-        Preconditions.checkArgument(offlineDurationMillis >= 0);\n-\n-        // Must not hold the appops lock\n-        mHistoricalRegistry.shutdown();\n-\n-        if (offlineDurationMillis > 0) {\n-            SystemClock.sleep(offlineDurationMillis);\n-        }\n-\n-        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n-        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n-        mHistoricalRegistry.persistPendingHistory();\n-    }\n-\n-    /**\n-     * Report runtime access to AppOp together with message (including stack trace)\n-     *\n-     * @param packageName The package which reported the op\n-     * @param notedAppOp contains code of op and attributionTag provided by developer\n-     * @param message Message describing AppOp access (can be stack trace)\n-     *\n-     * @return Config for future sampling to reduce amount of reporting\n-     */\n-    @Override\n-    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n-            String packageName, SyncNotedAppOp notedAppOp, String message) {\n-        int uid = Binder.getCallingUid();\n-        Objects.requireNonNull(packageName);\n-        synchronized (this) {\n-            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n-            if (!packageName.equals(mSampledPackage)) {\n-                return new MessageSamplingConfig(OP_NONE, 0,\n-                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n-            }\n-\n-            Objects.requireNonNull(notedAppOp);\n-            Objects.requireNonNull(message);\n-\n-            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n-                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n-                    notedAppOp.getAttributionTag(), message);\n-\n-            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n-                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n-        }\n-    }\n-\n-    /**\n-     * Report runtime access to AppOp together with message (entry point for reporting\n-     * asynchronous access)\n-     * @param uid Uid of the package which reported the op\n-     * @param packageName The package which reported the op\n-     * @param opCode Code of AppOp\n-     * @param attributionTag FeautreId of AppOp reported\n-     * @param message Message describing AppOp access (can be stack trace)\n-     */\n-    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n-            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n-            @NonNull String message) {\n-        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n-        if (!Objects.equals(mSampledPackage, packageName)) {\n-            return;\n-        }\n-        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n-                message);\n-    }\n-\n-    /**\n-     * Decides whether reported message is within the range of watched AppOps and picks it for\n-     * reporting uniformly at random across all received messages.\n-     */\n-    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n-            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n-            @NonNull String message) {\n-        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n-                mSampledAppOpCode, _NUM_OP);\n-\n-        if (mAcceptableLeftDistance < newLeftDistance\n-                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n-            return;\n-        }\n-\n-        if (mAcceptableLeftDistance > newLeftDistance\n-                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n-            mAcceptableLeftDistance = newLeftDistance;\n-            mMessagesCollectedCount = 0.0f;\n-        }\n-\n-        mMessagesCollectedCount += 1.0f;\n-        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n-            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n-                    packageName, attributionTag, message, mSamplingStrategy);\n-        }\n-        return;\n-    }\n-\n-    /** Pulls current AppOps access report and resamples package and app op to watch */\n-    @Override\n-    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n-        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n-        boolean isCallerInstrumented =\n-                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n-        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n-        if (!isCallerSystem && !isCallerInstrumented) {\n-            return null;\n-        }\n-        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n-                Binder.getCallingPid(), Binder.getCallingUid(), null);\n-        RuntimeAppOpAccessMessage result;\n-        synchronized (this) {\n-            result = mCollectedRuntimePermissionMessage;\n-            mCollectedRuntimePermissionMessage = null;\n-        }\n-        mHandler.sendMessage(PooledLambda.obtainMessage(\n-                AppOpsService::getPackageListAndResample,\n-                this));\n-        return result;\n-    }\n-\n-    /**\n-     * Checks if package is in the list of rarely used package and starts watching the new package\n-     * to collect incoming message or if collection is happening in first minutes since boot.\n-     * @param packageName\n-     */\n-    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n-        if (mSampledPackage == null) {\n-            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n-                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n-                resampleAppOpForPackageLocked(packageName, true);\n-            }\n-        } else if (mRarelyUsedPackages.contains(packageName)) {\n-            mRarelyUsedPackages.remove(packageName);\n-            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n-                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n-                resampleAppOpForPackageLocked(packageName, true);\n-            }\n-        }\n-    }\n-\n-    /** Obtains package list and resamples package and appop to watch. */\n-    private List<String> getPackageListAndResample() {\n-        List<String> packageNames = getPackageNamesForSampling();\n-        synchronized (this) {\n-            resamplePackageAndAppOpLocked(packageNames);\n-        }\n-        return packageNames;\n-    }\n-\n-    /** Resamples package and appop to watch from the list provided. */\n-    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n-        if (!packageNames.isEmpty()) {\n-            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n-                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n-                resampleAppOpForPackageLocked(packageNames.get(\n-                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n-            } else {\n-                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n-                resampleAppOpForPackageLocked(packageNames.get(\n-                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n-            }\n-        }\n-    }\n-\n-    /** Resamples appop for the chosen package and initializes sampling state */\n-    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n-        mMessagesCollectedCount = 0.0f;\n-        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n-        mAcceptableLeftDistance = _NUM_OP - 1;\n-        mSampledPackage = packageName;\n-    }\n-\n-    /**\n-     * Creates list of rarely used packages - packages which were not used over last week or\n-     * which declared but did not use permissions over last week.\n-     *  */\n-    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n-        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n-        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n-        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n-                new AppOpsManager.HistoricalOpsRequest.Builder(\n-                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n-                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n-                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n-        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n-                new Consumer<HistoricalOps>() {\n-                    @Override\n-                    public void accept(HistoricalOps histOps) {\n-                        int uidCount = histOps.getUidCount();\n-                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n-                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n-                                    uidIdx);\n-                            int pkgCount = uidOps.getPackageCount();\n-                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n-                                String packageName = uidOps.getPackageOpsAt(\n-                                        pkgIdx).getPackageName();\n-                                if (!candidates.contains(packageName)) {\n-                                    continue;\n-                                }\n-                                AppOpsManager.HistoricalPackageOps packageOps =\n-                                        uidOps.getPackageOpsAt(pkgIdx);\n-                                if (packageOps.getOpCount() != 0) {\n-                                    candidates.remove(packageName);\n-                                }\n-                            }\n-                        }\n-                        synchronized (this) {\n-                            int numPkgs = mRarelyUsedPackages.size();\n-                            for (int i = 0; i < numPkgs; i++) {\n-                                candidates.add(mRarelyUsedPackages.valueAt(i));\n-                            }\n-                            mRarelyUsedPackages = candidates;\n-                        }\n-                    }\n-                });\n-    }\n-\n-    /** List of app ops related to runtime permissions */\n-    private List<String> getRuntimeAppOpsList() {\n-        ArrayList<String> result = new ArrayList();\n-        for (int i = 0; i < _NUM_OP; i++) {\n-            if (shouldCollectNotes(i)) {\n-                result.add(opToPublicName(i));\n-            }\n-        }\n-        return result;\n-    }\n-\n-    /** Returns list of packages to be used for package sampling */\n-    private @NonNull List<String> getPackageNamesForSampling() {\n-        List<String> packageNames = new ArrayList<>();\n-        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n-                PackageManagerInternal.class);\n-        PackageList packages = packageManagerInternal.getPackageList();\n-        for (String packageName : packages.getPackageNames()) {\n-            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n-                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n-            if (isSamplingTarget(pkg)) {\n-                packageNames.add(pkg.packageName);\n-            }\n-        }\n-        return packageNames;\n-    }\n-\n-    /** Checks whether package should be included in sampling pool */\n-    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n-        if (pkg == null) {\n-            return false;\n-        }\n-        String[] requestedPermissions = pkg.requestedPermissions;\n-        if (requestedPermissions == null) {\n-            return false;\n-        }\n-        for (String permission : requestedPermissions) {\n-            PermissionInfo permissionInfo;\n-            try {\n-                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n-            } catch (PackageManager.NameNotFoundException ignored) {\n-                continue;\n-            }\n-            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @GuardedBy(\"this\")\n-    private void removeUidsForUserLocked(int userHandle) {\n-        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n-            final int uid = mUidStates.keyAt(i);\n-            if (UserHandle.getUserId(uid) == userHandle) {\n-                mUidStates.valueAt(i).clear();\n-                mUidStates.removeAt(i);\n-            }\n-        }\n-    }\n-\n-    private void checkSystemUid(String function) {\n-        int uid = Binder.getCallingUid();\n-        if (uid != Process.SYSTEM_UID) {\n-            throw new SecurityException(function + \" must by called by the system\");\n-        }\n-    }\n-\n-    private static int resolveUid(String packageName)  {\n-        if (packageName == null) {\n-            return Process.INVALID_UID;\n-        }\n-        switch (packageName) {\n-            case \"root\":\n-                return Process.ROOT_UID;\n-            case \"shell\":\n-            case \"dumpstate\":\n-                return Process.SHELL_UID;\n-            case \"media\":\n-                return Process.MEDIA_UID;\n-            case \"audioserver\":\n-                return Process.AUDIOSERVER_UID;\n-            case \"cameraserver\":\n-                return Process.CAMERASERVER_UID;\n-        }\n-        return Process.INVALID_UID;\n-    }\n-\n-    private static String[] getPackagesForUid(int uid) {\n-        String[] packageNames = null;\n-\n-        // Very early during boot the package manager is not yet or not yet fully started. At this\n-        // time there are no packages yet.\n-        if (AppGlobals.getPackageManager() != null) {\n-            try {\n-                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n-            } catch (RemoteException e) {\n-                /* ignore - local call */\n-            }\n-        }\n-        if (packageNames == null) {\n-            return EmptyArray.STRING;\n-        }\n-        return packageNames;\n-    }\n-\n-    private final class ClientUserRestrictionState implements DeathRecipient {\n-        private final IBinder token;\n-\n-        ClientUserRestrictionState(IBinder token)\n-                throws RemoteException {\n-            token.linkToDeath(this, 0);\n-            this.token = token;\n-        }\n-\n-        public boolean setRestriction(int code, boolean restricted,\n-                PackageTagsList excludedPackageTags, int userId) {\n-            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n-                    restricted, excludedPackageTags);\n-        }\n-\n-        public boolean hasRestriction(int code, String packageName, String attributionTag,\n-                int userId, boolean isCheckOp) {\n-            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n-                    attributionTag, isCheckOp);\n-        }\n-\n-        public void removeUser(int userId) {\n-            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n-        }\n-\n-        public boolean isDefault() {\n-            return !mAppOpsRestrictions.hasUserRestrictions(token);\n-        }\n-\n-        @Override\n-        public void binderDied() {\n-            synchronized (AppOpsService.this) {\n-                mAppOpsRestrictions.clearUserRestrictions(token);\n-                mOpUserRestrictions.remove(token);\n-                destroy();\n-            }\n-        }\n-\n-        public void destroy() {\n-            token.unlinkToDeath(this, 0);\n-        }\n-    }\n-\n-    private final class ClientGlobalRestrictionState implements DeathRecipient {\n-        final IBinder mToken;\n-\n-        ClientGlobalRestrictionState(IBinder token)\n-                throws RemoteException {\n-            token.linkToDeath(this, 0);\n-            this.mToken = token;\n-        }\n-\n-        boolean setRestriction(int code, boolean restricted) {\n-            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n-        }\n-\n-        boolean hasRestriction(int code) {\n-            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n-        }\n-\n-        boolean isDefault() {\n-            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n-        }\n-\n-        @Override\n-        public void binderDied() {\n-            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n-            mOpGlobalRestrictions.remove(mToken);\n-            destroy();\n-        }\n-\n-        void destroy() {\n-            mToken.unlinkToDeath(this, 0);\n-        }\n-    }\n-\n-    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n-        @Override\n-        public boolean isUidInForeground(int uid) {\n-            synchronized (AppOpsService.this) {\n-                return mUidStateTracker.isUidInForeground(uid);\n-            }\n-        }\n-    }\n-\n-    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n-        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n-            synchronized (AppOpsService.this) {\n-                mProfileOwners = owners;\n-            }\n-        }\n-\n-        @Override\n-        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n-                boolean visible) {\n-            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n-        }\n-\n-        @Override\n-        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n-                @Nullable IAppOpsCallback callback) {\n-            setUidMode(code, uid, mode, callback);\n-        }\n-\n-        @Override\n-        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n-                int mode, @Nullable IAppOpsCallback callback) {\n-            setMode(code, uid, packageName, mode, callback);\n-        }\n-\n-\n-        @Override\n-        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n-            if (Binder.getCallingPid() != Process.myPid()) {\n-                // TODO instead of this enforcement put in AppOpsManagerInternal\n-                throw new SecurityException(\"Only the system can set global restrictions\");\n-            }\n-\n-            synchronized (AppOpsService.this) {\n-                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n-\n-                if (restrictionState == null) {\n-                    try {\n-                        restrictionState = new ClientGlobalRestrictionState(token);\n-                    } catch (RemoteException  e) {\n-                        return;\n-                    }\n-                    mOpGlobalRestrictions.put(token, restrictionState);\n-                }\n-\n-                if (restrictionState.setRestriction(code, restricted)) {\n-                    mHandler.sendMessage(PooledLambda.obtainMessage(\n-                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n-                            UID_ANY));\n-                    mHandler.sendMessage(PooledLambda.obtainMessage(\n-                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n-                            code, restricted, UserHandle.USER_ALL));\n-                }\n-\n-                if (restrictionState.isDefault()) {\n-                    mOpGlobalRestrictions.remove(token);\n-                    restrictionState.destroy();\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n-                String attributionTag) {\n-            int number = 0;\n-            synchronized (AppOpsService.this) {\n-                int numRestrictions = mOpUserRestrictions.size();\n-                for (int i = 0; i < numRestrictions; i++) {\n-                    if (mOpUserRestrictions.valueAt(i)\n-                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n-                                    false)) {\n-                        number++;\n-                    }\n-                }\n-\n-                numRestrictions = mOpGlobalRestrictions.size();\n-                for (int i = 0; i < numRestrictions; i++) {\n-                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n-                        number++;\n-                    }\n-                }\n-            }\n-\n-            return number;\n-        }\n-    }\n-\n-    /**\n-     * Async task for writing note op stack trace, op code, package name and version to file\n-     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n-     */\n-    private void writeNoteOps() {\n-        synchronized (this) {\n-            mWriteNoteOpsScheduled = false;\n-        }\n-        synchronized (mNoteOpCallerStacktracesFile) {\n-            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n-                int numTraces = mNoteOpCallerStacktraces.size();\n-                for (int i = 0; i < numTraces; i++) {\n-                    // Writing json formatted string into file\n-                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n-                    // Comma separation, so we can wrap the entire log as a JSON object\n-                    // when all results are collected\n-                    writer.write(\",\");\n-                }\n-            } catch (IOException e) {\n-                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n-     * be written to file to use for permissions data validation in JSON format\n-     */\n-    @Immutable\n-    static class NoteOpTrace {\n-        static final String STACKTRACE = \"stackTrace\";\n-        static final String OP = \"op\";\n-        static final String PACKAGENAME = \"packageName\";\n-        static final String VERSION = \"version\";\n-\n-        private final @NonNull String mStackTrace;\n-        private final int mOp;\n-        private final @Nullable String mPackageName;\n-        private final long mVersion;\n-\n-        /**\n-         * Initialize a NoteOp object using a JSON object containing the necessary fields\n-         *\n-         * @param jsonTrace JSON object represented as a string\n-         *\n-         * @return NoteOpTrace object initialized with JSON fields\n-         */\n-        static NoteOpTrace fromJson(String jsonTrace) {\n-            try {\n-                // Re-add closing bracket which acted as a delimiter by the reader\n-                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n-                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n-                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n-            } catch (JSONException e) {\n-                // Swallow error, only meant for logging ops, should not affect flow of the code\n-                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n-                        + \"JSON trace format incorrect\", e);\n-                return null;\n-            }\n-        }\n-\n-        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n-            mStackTrace = stackTrace;\n-            mOp = op;\n-            mPackageName = packageName;\n-            mVersion = version;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            NoteOpTrace that = (NoteOpTrace) o;\n-            return mOp == that.mOp\n-                    && mVersion == that.mVersion\n-                    && mStackTrace.equals(that.mStackTrace)\n-                    && Objects.equals(mPackageName, that.mPackageName);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n-        }\n-\n-        /**\n-         * The object is formatted as a JSON object and returned as a String\n-         *\n-         * @return JSON formatted string\n-         */\n-        public String asJson() {\n-            return  \"{\"\n-                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n-                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n-                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n-                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n-                    + '}';\n-        }\n-    }\n-\n-    /**\n-     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n-     * which will be used for permissions data validation, the given parameters to this method\n-     * will be logged in json format\n-     *\n-     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n-     * @param op op code\n-     * @param packageName package making call\n-     * @param version android version for this call\n-     */\n-    @Override\n-    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n-            long version) {\n-        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n-            return;\n-        }\n-\n-        Objects.requireNonNull(stackTrace);\n-        Preconditions.checkArgument(op >= 0);\n-        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n-\n-        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n-\n-        boolean noteOpSetWasChanged;\n-        synchronized (this) {\n-            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n-            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n-                mWriteNoteOpsScheduled = true;\n-                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n-                    AsyncTask.execute(() -> {\n-                        that.writeNoteOps();\n-                    });\n-                }, this), 2500);\n-            }\n-        }\n-    }\n-\n-    @Immutable\n-    private final class CheckOpsDelegateDispatcher {\n-        private final @Nullable CheckOpsDelegate mPolicy;\n-        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n-\n-        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n-                @Nullable CheckOpsDelegate checkOpsDelegate) {\n-            mPolicy = policy;\n-            mCheckOpsDelegate = checkOpsDelegate;\n-        }\n-\n-        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n-            return mCheckOpsDelegate;\n-        }\n-\n-        public int checkOperation(int code, int uid, String packageName,\n-                @Nullable String attributionTag, boolean raw) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n-                            this::checkDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n-                            AppOpsService.this::checkOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n-            }\n-            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n-        }\n-\n-        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n-                @Nullable String attributionTag, boolean raw) {\n-            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n-                    AppOpsService.this::checkOperationImpl);\n-        }\n-\n-        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n-                            this::checkDelegateAudioOperationImpl);\n-                } else {\n-                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n-                            AppOpsService.this::checkAudioOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n-            }\n-            return checkAudioOperationImpl(code, usage, uid, packageName);\n-        }\n-\n-        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n-                String packageName) {\n-            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n-                    AppOpsService.this::checkAudioOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n-                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            this::noteDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            AppOpsService.this::noteOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateOperationImpl(code, uid, packageName,\n-                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-            }\n-            return noteOperationImpl(code, uid, packageName, attributionTag,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n-                @Nullable String packageName, @Nullable String featureId,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage) {\n-            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    AppOpsService.this::noteOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateProxyOperationImpl(code,\n-                        attributionSource, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation);\n-            }\n-            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n-                    message, shouldCollectMessage,skipProxyOperation);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n-                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation) {\n-            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    AppOpsService.this::noteProxyOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n-                @Nullable String packageName, @NonNull String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                @AttributionFlags int attributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startOperation(token, code, uid, packageName,\n-                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            this::startDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            AppOpsService.this::startOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, attributionFlags, attributionChainId);\n-            }\n-            return startOperationImpl(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n-                @Nullable String packageName, @Nullable String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n-                int attributionChainId) {\n-            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            this::startDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            AppOpsService.this::startProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n-            }\n-            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n-                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n-        }\n-\n-        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n-                String attributionTag) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            this::finishDelegateOperationImpl);\n-                } else {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            AppOpsService.this::finishOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            } else {\n-                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            }\n-        }\n-\n-        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n-                String packageName, String attributionTag) {\n-            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                    AppOpsService.this::finishOperationImpl);\n-        }\n-\n-        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n-                } else {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        skipProxyOperation);\n-            } else {\n-                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n-            }\n-        }\n-\n-        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n-                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-            return null;\n-        }\n-    }\n-}\n-```+            }",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0334,
      "token_level_edit_distance": 6413,
      "codebert_score": {
        "precision": 0.7197,
        "recall": 0.8826,
        "f1": 0.7929,
        "f3": 0.8631
      },
      "token_count_upstream": 138,
      "token_count_downstream": 4084,
      "token_count_total": 4222,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-293602970",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/pm/UserManagerService.java",
    "runtime_seconds": 539.26,
    "rej_file_diff": "--- services/core/java/com/android/server/pm/UserManagerService.java\n+++ services/core/java/com/android/server/pm/UserManagerService.java\n@@ -4979,7 +4979,7 @@ public class UserManagerService extends IUserManager.Stub {\n             @UserIdInt int parentId, boolean preCreate, @Nullable String[] disallowedPackages,\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -4773,7 +4773,7 @@\n             @NonNull TimingsTraceAndSlog t, @Nullable Object token)\n             throws UserManager.CheckedUserOperationException {\n \n-        String truncatedName = truncateString(name);\n+        String truncatedName = truncateString(name, UserManager.MAX_USER_NAME_LENGTH);\n         final UserTypeDetails userTypeDetails = mUserTypes.get(userType);\n         if (userTypeDetails == null) {\n             throwCheckedUserOperationException(\n@@ -6329,1162 +6329,4 @@\n         }\n         // If we got here, we probably recycled user ids, so invalidate any caches.\n         UserManager.invalidateStaticUserProperties();\n-        UserManager.invalidateUserPropertiesCache();\n-        if (nextId < 0) {\n-            throw new IllegalStateException(\"No user id available!\");\n-        }\n-        return nextId;\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    private int scanNextAvailableIdLocked() {\n-        for (int i = MIN_USER_ID; i < MAX_USER_ID; i++) {\n-            if (mUsers.indexOfKey(i) < 0 && !mRemovingUserIds.get(i)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    private static String packageToRestrictionsFileName(String packageName) {\n-        return RESTRICTIONS_FILE_PREFIX + packageName + XML_SUFFIX;\n-    }\n-\n-    @Nullable\n-    private static String getRedacted(@Nullable String string) {\n-        return string == null ? null : string.length() + \"_chars\";\n-    }\n-\n-    @Override\n-    public void setSeedAccountData(@UserIdInt int userId, String accountName, String accountType,\n-            PersistableBundle accountOptions, boolean persist) {\n-        checkManageUsersPermission(\"set user seed account data\");\n-        setSeedAccountDataNoChecks(userId, accountName, accountType, accountOptions, persist);\n-    }\n-\n-    private void setSeedAccountDataNoChecks(@UserIdInt int userId, @Nullable String accountName,\n-            @Nullable String accountType, @Nullable PersistableBundle accountOptions,\n-            boolean persist) {\n-\n-        synchronized (mPackagesLock) {\n-            final UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = getUserDataLU(userId);\n-                if (userData == null) {\n-                    Slog.e(LOG_TAG, \"No such user for settings seed data u=\" + userId);\n-                    return;\n-                }\n-                userData.seedAccountName = truncateString(accountName,\n-                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n-                userData.seedAccountType = truncateString(accountType,\n-                        UserManager.MAX_ACCOUNT_STRING_LENGTH);\n-                if (accountOptions != null && accountOptions.isBundleContentsWithinLengthLimit(\n-                        UserManager.MAX_ACCOUNT_OPTIONS_LENGTH)) {\n-                    userData.seedAccountOptions = accountOptions;\n-                }\n-                userData.persistSeedData = persist;\n-            }\n-            if (persist) {\n-                writeUserLP(userData);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String getSeedAccountName(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountName;\n-        }\n-    }\n-\n-    @Override\n-    public String getSeedAccountType(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountType;\n-        }\n-    }\n-\n-    @Override\n-    public PersistableBundle getSeedAccountOptions(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot get seed account information\");\n-        synchronized (mUsersLock) {\n-            final UserData userData = getUserDataLU(userId);\n-            return userData == null ? null : userData.seedAccountOptions;\n-        }\n-    }\n-\n-    @Override\n-    public void clearSeedAccountData(@UserIdInt int userId) throws RemoteException {\n-        checkManageUsersPermission(\"Cannot clear seed account information\");\n-        synchronized (mPackagesLock) {\n-            UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = getUserDataLU(userId);\n-                if (userData == null) return;\n-                userData.clearSeedAccountData();\n-            }\n-            writeUserLP(userData);\n-        }\n-    }\n-\n-    @Override\n-    public boolean someUserHasSeedAccount(String accountName, String accountType) {\n-        checkManageUsersPermission(\"check seed account information\");\n-        return someUserHasSeedAccountNoChecks(accountName, accountType);\n-    }\n-\n-    private boolean someUserHasSeedAccountNoChecks(String accountName, String accountType) {\n-        synchronized (mUsersLock) {\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                final UserData data = mUsers.valueAt(i);\n-                if (data.info.isInitialized()) continue;\n-                if (mRemovingUserIds.get(data.info.id)) continue;\n-                if (data.seedAccountName == null || !data.seedAccountName.equals(accountName)) {\n-                    continue;\n-                }\n-                if (data.seedAccountType == null || !data.seedAccountType.equals(accountType)) {\n-                    continue;\n-                }\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean someUserHasAccount(String accountName, String accountType) {\n-        checkCreateUsersPermission(\"check seed account information\");\n-        return someUserHasAccountNoChecks(accountName, accountType);\n-    }\n-\n-    private boolean someUserHasAccountNoChecks(\n-            String accountName, String accountType) {\n-        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {\n-            return false;\n-        }\n-\n-        final Account account = new Account(accountName, accountType);\n-\n-        return Binder.withCleanCallingIdentity(() ->\n-                AccountManager.get(mContext).someUserHasAccount(account)\n-                        || someUserHasSeedAccountNoChecks(accountName, accountType));\n-    }\n-\n-    private void setLastEnteredForegroundTimeToNow(@NonNull UserData userData) {\n-        userData.mLastEnteredForegroundTimeMillis = System.currentTimeMillis();\n-        scheduleWriteUser(userData.info.id);\n-    }\n-\n-    @Override\n-    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n-            FileDescriptor err, String[] args, ShellCallback callback,\n-            ResultReceiver resultReceiver) {\n-        (new UserManagerServiceShellCommand(this, mSystemPackageInstaller,\n-                mLockPatternUtils, mContext))\n-                .exec(this, in, out, err, args, callback, resultReceiver);\n-    }\n-\n-    @Override\n-    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n-        if (!DumpUtils.checkDumpPermission(mContext, LOG_TAG, pw)) return;\n-\n-        final long now = System.currentTimeMillis();\n-        final long nowRealtime = SystemClock.elapsedRealtime();\n-        final StringBuilder sb = new StringBuilder();\n-\n-        if (args != null && args.length > 0) {\n-            switch (args[0]) {\n-                case \"--user\":\n-                    dumpUser(pw, UserHandle.parseUserArg(args[1]), sb, now, nowRealtime);\n-                    return;\n-                case \"--visibility-mediator\":\n-                    mUserVisibilityMediator.dump(pw, args);\n-                    return;\n-            }\n-        }\n-\n-        final int currentUserId = getCurrentUserId();\n-        pw.print(\"Current user: \");\n-        if (currentUserId != UserHandle.USER_NULL) {\n-            pw.println(currentUserId);\n-        } else {\n-            pw.println(\"N/A\");\n-        }\n-\n-        pw.println();\n-        synchronized (mPackagesLock) {\n-            synchronized (mUsersLock) {\n-                pw.println(\"Users:\");\n-                for (int i = 0; i < mUsers.size(); i++) {\n-                    UserData userData = mUsers.valueAt(i);\n-                    if (userData == null) {\n-                        continue;\n-                    }\n-                    dumpUserLocked(pw, userData, sb, now, nowRealtime);\n-                }\n-            }\n-\n-            pw.println();\n-            pw.println(\"Device properties:\");\n-            pw.println(\"  Device policy global restrictions:\");\n-            synchronized (mRestrictionsLock) {\n-                UserRestrictionsUtils.dumpRestrictions(\n-                        pw, \"    \",\n-                        mDevicePolicyUserRestrictions.getRestrictions(UserHandle.USER_ALL));\n-            }\n-            pw.println(\"  Guest restrictions:\");\n-            synchronized (mGuestRestrictions) {\n-                UserRestrictionsUtils.dumpRestrictions(pw, \"    \", mGuestRestrictions);\n-            }\n-            synchronized (mUsersLock) {\n-                pw.println();\n-                pw.println(\"  Device managed: \" + mIsDeviceManaged);\n-                if (mRemovingUserIds.size() > 0) {\n-                    pw.println();\n-                    pw.println(\"  Recently removed userIds: \" + mRecentlyRemovedIds);\n-                }\n-            }\n-            synchronized (mUserStates) {\n-                pw.print(\"  Started users state: [\");\n-                final int size = mUserStates.states.size();\n-                for (int i = 0; i < size; i++) {\n-                    final int userId = mUserStates.states.keyAt(i);\n-                    final int state = mUserStates.states.valueAt(i);\n-                    pw.print(userId);\n-                    pw.print('=');\n-                    pw.print(UserState.stateToString(state));\n-                    if (i != size - 1) pw.print(\", \");\n-                }\n-                pw.println(']');\n-            }\n-            synchronized (mUsersLock) {\n-                pw.print(\"  Cached user IDs: \");\n-                pw.println(Arrays.toString(mUserIds));\n-                pw.print(\"  Cached user IDs (including pre-created): \");\n-                pw.println(Arrays.toString(mUserIdsIncludingPreCreated));\n-            }\n-        } // synchronized (mPackagesLock)\n-\n-        pw.println();\n-        mUserVisibilityMediator.dump(pw, args);\n-        pw.println();\n-\n-        // Dump some capabilities\n-        pw.println();\n-        pw.print(\"  Max users: \" + UserManager.getMaxSupportedUsers());\n-        pw.println(\" (limit reached: \" + isUserLimitReached() + \")\");\n-        pw.println(\"  Supports switchable users: \" + UserManager.supportsMultipleUsers());\n-        pw.println(\"  All guests ephemeral: \" + Resources.getSystem().getBoolean(\n-                com.android.internal.R.bool.config_guestUserEphemeral));\n-        pw.println(\"  Force ephemeral users: \" + mForceEphemeralUsers);\n-        final boolean isHeadlessSystemUserMode = isHeadlessSystemUserMode();\n-        pw.println(\"  Is headless-system mode: \" + isHeadlessSystemUserMode);\n-        if (isHeadlessSystemUserMode != RoSystemProperties.MULTIUSER_HEADLESS_SYSTEM_USER) {\n-            pw.println(\"  (differs from the current default build value)\");\n-        }\n-        if (!TextUtils.isEmpty(SystemProperties.get(SYSTEM_USER_MODE_EMULATION_PROPERTY))) {\n-            pw.println(\"  (emulated by 'cmd user set-system-user-mode-emulation')\");\n-            if (mUpdatingSystemUserMode) {\n-                pw.println(\"  (and being updated after boot)\");\n-            }\n-        }\n-        pw.println(\"  User version: \" + mUserVersion);\n-        pw.println(\"  Owner name: \" + getOwnerName());\n-        if (DBG_ALLOCATION) {\n-            pw.println(\"  System user allocations: \" + mUser0Allocations.get());\n-        }\n-        synchronized (mUsersLock) {\n-            pw.println(\"  Boot user: \" + mBootUser);\n-        }\n-\n-        pw.println();\n-        pw.println(\"Number of listeners for\");\n-        synchronized (mUserRestrictionsListeners) {\n-            pw.println(\"  restrictions: \" + mUserRestrictionsListeners.size());\n-        }\n-        synchronized (mUserLifecycleListeners) {\n-            pw.println(\"  user lifecycle events: \" + mUserLifecycleListeners.size());\n-        }\n-\n-        // Dump UserTypes\n-        pw.println();\n-        pw.println(\"User types version: \" + mUserTypeVersion);\n-        pw.println(\"User types (\" + mUserTypes.size() + \" types):\");\n-        for (int i = 0; i < mUserTypes.size(); i++) {\n-            pw.println(\"    \" + mUserTypes.keyAt(i) + \": \");\n-            mUserTypes.valueAt(i).dump(pw, \"        \");\n-        }\n-\n-        // TODO: create IndentingPrintWriter at the beginning of dump() and use the proper\n-        // indentation methods instead of explicit printing \"  \"\n-        try (IndentingPrintWriter ipw = new IndentingPrintWriter(pw)) {\n-\n-            // Dump SystemPackageInstaller info\n-            ipw.println();\n-            mSystemPackageInstaller.dump(ipw);\n-\n-            // NOTE: pw's not available after this point as it's auto-closed by ipw, so new dump\n-            // statements should use ipw below\n-        }\n-    }\n-\n-    private void dumpUser(PrintWriter pw, @UserIdInt int userId, StringBuilder sb, long now,\n-            long nowRealtime) {\n-        if (userId == UserHandle.USER_CURRENT) {\n-            final int currentUserId = getCurrentUserId();\n-            pw.print(\"Current user: \");\n-            if (currentUserId == UserHandle.USER_NULL) {\n-                pw.println(\"Cannot determine current user\");\n-                return;\n-            }\n-            userId = currentUserId;\n-        }\n-\n-        synchronized (mUsersLock) {\n-            final UserData userData = mUsers.get(userId);\n-            if (userData == null) {\n-                pw.println(\"User \" + userId + \" not found\");\n-                return;\n-            }\n-            dumpUserLocked(pw, userData, sb, now, nowRealtime);\n-        }\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    private void dumpUserLocked(PrintWriter pw, UserData userData, StringBuilder tempStringBuilder,\n-            long now, long nowRealtime) {\n-        final UserInfo userInfo = userData.info;\n-        final int userId = userInfo.id;\n-        pw.print(\"  \"); pw.print(userInfo);\n-        pw.print(\" serialNo=\"); pw.print(userInfo.serialNumber);\n-        pw.print(\" isPrimary=\"); pw.print(userInfo.isPrimary());\n-        if (userInfo.profileGroupId != userInfo.id\n-                &&  userInfo.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID) {\n-            pw.print(\" parentId=\"); pw.print(userInfo.profileGroupId);\n-        }\n-\n-        if (mRemovingUserIds.get(userId)) {\n-            pw.print(\" <removing> \");\n-        }\n-        if (userInfo.partial) {\n-            pw.print(\" <partial>\");\n-        }\n-        if (userInfo.preCreated) {\n-            pw.print(\" <pre-created>\");\n-        }\n-        if (userInfo.convertedFromPreCreated) {\n-            pw.print(\" <converted>\");\n-        }\n-        pw.println();\n-        pw.print(\"    Type: \"); pw.println(userInfo.userType);\n-        pw.print(\"    Flags: \"); pw.print(userInfo.flags); pw.print(\" (\");\n-        pw.print(UserInfo.flagsToString(userInfo.flags)); pw.println(\")\");\n-        pw.print(\"    State: \");\n-        final int state;\n-        synchronized (mUserStates) {\n-            state = mUserStates.get(userId, -1);\n-        }\n-        pw.println(UserState.stateToString(state));\n-        pw.print(\"    Created: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userInfo.creationTime);\n-\n-        pw.print(\"    Last logged in: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userInfo.lastLoggedInTime);\n-\n-        pw.print(\"    Last logged in fingerprint: \");\n-        pw.println(userInfo.lastLoggedInFingerprint);\n-\n-        pw.print(\"    Start time: \");\n-        dumpTimeAgo(pw, tempStringBuilder, nowRealtime, userData.startRealtime);\n-\n-        pw.print(\"    Unlock time: \");\n-        dumpTimeAgo(pw, tempStringBuilder, nowRealtime, userData.unlockRealtime);\n-\n-        pw.print(\"    Last entered foreground: \");\n-        dumpTimeAgo(pw, tempStringBuilder, now, userData.mLastEnteredForegroundTimeMillis);\n-\n-        pw.print(\"    Has profile owner: \");\n-        pw.println(mIsUserManaged.get(userId));\n-        pw.println(\"    Restrictions:\");\n-        synchronized (mRestrictionsLock) {\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \", mBaseUserRestrictions.getRestrictions(userInfo.id));\n-            pw.println(\"    Device policy restrictions:\");\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \",\n-                    mDevicePolicyUserRestrictions.getRestrictions(userInfo.id));\n-            pw.println(\"    Effective restrictions:\");\n-            UserRestrictionsUtils.dumpRestrictions(\n-                    pw, \"      \",\n-                    mCachedEffectiveUserRestrictions.getRestrictions(userInfo.id));\n-        }\n-\n-        if (userData.account != null) {\n-            pw.print(\"    Account name: \" + userData.account);\n-            pw.println();\n-        }\n-\n-        if (userData.seedAccountName != null) {\n-            pw.print(\"    Seed account name: \" + userData.seedAccountName);\n-            pw.println();\n-            if (userData.seedAccountType != null) {\n-                pw.print(\"         account type: \" + userData.seedAccountType);\n-                pw.println();\n-            }\n-            if (userData.seedAccountOptions != null) {\n-                pw.print(\"         account options exist\");\n-                pw.println();\n-            }\n-        }\n-\n-        if (userData.userProperties != null) {\n-            userData.userProperties.println(pw, \"    \");\n-        }\n-\n-        pw.println(\"    Ignore errors preparing storage: \"\n-                + userData.getIgnorePrepareStorageErrors());\n-    }\n-\n-    private static void dumpTimeAgo(PrintWriter pw, StringBuilder sb, long nowTime, long time) {\n-        if (time == 0) {\n-            pw.println(\"<unknown>\");\n-        } else {\n-            sb.setLength(0);\n-            TimeUtils.formatDuration(nowTime - time, sb);\n-            sb.append(\" ago\");\n-            pw.println(sb);\n-        }\n-    }\n-\n-    final class MainHandler extends Handler {\n-\n-        @Override\n-        public void handleMessage(Message msg) {\n-            switch (msg.what) {\n-                case WRITE_USER_LIST_MSG: {\n-                    removeMessages(WRITE_USER_LIST_MSG);\n-                    synchronized (mPackagesLock) {\n-                        writeUserListLP();\n-                    }\n-                    break;\n-                }\n-                case WRITE_USER_MSG:\n-                    removeMessages(WRITE_USER_MSG, msg.obj);\n-                    synchronized (mPackagesLock) {\n-                        int userId = (int) msg.obj;\n-                        UserData userData = getUserDataNoChecks(userId);\n-                        if (userData != null) {\n-                            writeUserLP(userData);\n-                        } else {\n-                            Slog.i(LOG_TAG, \"handle(WRITE_USER_MSG): no data for user \" + userId\n-                                    + \", it was probably removed before handler could handle it\");\n-                        }\n-                    }\n-                    break;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param userId\n-     * @return whether the user has been initialized yet\n-     */\n-    boolean isUserInitialized(@UserIdInt int userId) {\n-        return mLocalService.isUserInitialized(userId);\n-    }\n-\n-    private class LocalService extends UserManagerInternal {\n-        @Override\n-        public void setDevicePolicyUserRestrictions(@UserIdInt int originatingUserId,\n-                @NonNull Bundle global, @NonNull RestrictionsSet local,\n-                boolean isDeviceOwner) {\n-            UserManagerService.this.setDevicePolicyUserRestrictionsInner(originatingUserId,\n-                    global, local, isDeviceOwner);\n-        }\n-\n-        @Override\n-        public void setUserRestriction(int userId, @NonNull String key, boolean value) {\n-            UserManagerService.this.setUserRestrictionInner(userId, key, value);\n-        }\n-\n-        @Override\n-        public boolean getUserRestriction(@UserIdInt int userId, String key) {\n-            return getUserRestrictions(userId).getBoolean(key);\n-        }\n-\n-        @Override\n-        public void addUserRestrictionsListener(UserRestrictionsListener listener) {\n-            synchronized (mUserRestrictionsListeners) {\n-                mUserRestrictionsListeners.add(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserRestrictionsListener(UserRestrictionsListener listener) {\n-            synchronized (mUserRestrictionsListeners) {\n-                mUserRestrictionsListeners.remove(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void addUserLifecycleListener(UserLifecycleListener listener) {\n-            synchronized (mUserLifecycleListeners) {\n-                mUserLifecycleListeners.add(listener);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserLifecycleListener(UserLifecycleListener listener) {\n-            synchronized (mUserLifecycleListeners) {\n-                mUserLifecycleListeners.remove(listener);\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public void setDeviceManaged(boolean isManaged) {\n-            synchronized (mUsersLock) {\n-                mIsDeviceManaged = isManaged;\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public boolean isDeviceManaged() {\n-            synchronized (mUsersLock) {\n-                return mIsDeviceManaged;\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public void setUserManaged(@UserIdInt int userId, boolean isManaged) {\n-            synchronized (mUsersLock) {\n-                mIsUserManaged.put(userId, isManaged);\n-            }\n-        }\n-\n-        // TODO(b/258213147): Remove\n-        @Override\n-        public boolean isUserManaged(@UserIdInt int userId) {\n-            synchronized (mUsersLock) {\n-                return mIsUserManaged.get(userId);\n-            }\n-        }\n-\n-        @Override\n-        public void setUserIcon(@UserIdInt int userId, Bitmap bitmap) {\n-            final long ident = Binder.clearCallingIdentity();\n-            try {\n-                synchronized (mPackagesLock) {\n-                    UserData userData = getUserDataNoChecks(userId);\n-                    if (userData == null || userData.info.partial) {\n-                        Slog.w(LOG_TAG, \"setUserIcon: unknown user #\" + userId);\n-                        return;\n-                    }\n-                    writeBitmapLP(userData.info, bitmap);\n-                    writeUserLP(userData);\n-                }\n-                sendUserInfoChangedBroadcast(userId);\n-            } finally {\n-                Binder.restoreCallingIdentity(ident);\n-            }\n-        }\n-\n-        @Override\n-        public void setForceEphemeralUsers(boolean forceEphemeralUsers) {\n-            synchronized (mUsersLock) {\n-                mForceEphemeralUsers = forceEphemeralUsers;\n-            }\n-        }\n-\n-        @Override\n-        public void removeAllUsers() {\n-            if (UserHandle.USER_SYSTEM == getCurrentUserId()) {\n-                // Remove the non-system users straight away.\n-                removeAllUsersExceptSystemAndPermanentAdminMain();\n-            } else {\n-                // Switch to the system user first and then remove the other users.\n-                BroadcastReceiver userSwitchedReceiver = new BroadcastReceiver() {\n-                    @Override\n-                    public void onReceive(Context context, Intent intent) {\n-                        int userId =\n-                                intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n-                        if (userId != UserHandle.USER_SYSTEM) {\n-                            return;\n-                        }\n-                        mContext.unregisterReceiver(this);\n-                        removeAllUsersExceptSystemAndPermanentAdminMain();\n-                    }\n-                };\n-                IntentFilter userSwitchedFilter = new IntentFilter();\n-                userSwitchedFilter.addAction(Intent.ACTION_USER_SWITCHED);\n-                mContext.registerReceiver(\n-                        userSwitchedReceiver, userSwitchedFilter, null, mHandler);\n-\n-                // Switch to the system user.\n-                ActivityManager am =\n-                        (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);\n-                am.switchUser(UserHandle.USER_SYSTEM);\n-            }\n-        }\n-\n-        @Override\n-        public void onEphemeralUserStop(@UserIdInt int userId) {\n-            synchronized (mUsersLock) {\n-               UserInfo userInfo = getUserInfoLU(userId);\n-               if (userInfo != null && userInfo.isEphemeral()) {\n-                    // Do not allow switching back to the ephemeral user again as the user is going\n-                    // to be deleted.\n-                    userInfo.flags |= UserInfo.FLAG_DISABLED;\n-                    if (userInfo.isGuest()) {\n-                        // Indicate that the guest will be deleted after it stops.\n-                        userInfo.guestToRemove = true;\n-                    }\n-               }\n-            }\n-        }\n-\n-        @Override\n-        public @NonNull UserInfo createUserEvenWhenDisallowed(\n-                @Nullable String name, @NonNull String userType, @UserInfoFlag int flags,\n-                @Nullable String[] disallowedPackages, @Nullable Object token)\n-                throws UserManager.CheckedUserOperationException {\n-\n-            return createUserInternalUnchecked(name, userType, flags,\n-                    UserHandle.USER_NULL, /* preCreated= */ false, disallowedPackages, token);\n-        }\n-\n-        @Override\n-        public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId) {\n-            return removeUserWithProfilesUnchecked(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserRunning(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state =  mUserStates.get(userId, UserState.STATE_NONE);\n-            }\n-\n-            return state != UserState.STATE_NONE\n-                    && state != UserState.STATE_STOPPING\n-                    && state != UserState.STATE_SHUTDOWN;\n-        }\n-\n-        @Override\n-        public void setUserState(@UserIdInt int userId, int userState) {\n-            synchronized (mUserStates) {\n-                mUserStates.put(userId, userState);\n-            }\n-        }\n-\n-        @Override\n-        public void removeUserState(@UserIdInt int userId) {\n-            synchronized (mUserStates) {\n-                mUserStates.delete(userId);\n-            }\n-        }\n-\n-        @Override\n-        public int[] getUserIds() {\n-            return UserManagerService.this.getUserIds();\n-        }\n-\n-        @Override\n-        public @NonNull List<UserInfo> getUsers(boolean excludeDying) {\n-            return getUsers(/*excludePartial= */ true, excludeDying, /* excludePreCreated= */ true);\n-        }\n-\n-        @Override\n-        public @NonNull List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying,\n-                boolean excludePreCreated) {\n-            return UserManagerService.this.getUsersInternal(excludePartial, excludeDying,\n-                    excludePreCreated);\n-        }\n-\n-        @Override\n-        public @NonNull int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly) {\n-            synchronized (mUsersLock) {\n-                return getProfileIdsLU(userId, null /* userType */, enabledOnly).toArray();\n-            }\n-        }\n-\n-        @Override\n-        public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state = mUserStates.get(userId, -1);\n-            }\n-            // Special case, in the stopping/shutdown state user key can still be unlocked\n-            if (state == UserState.STATE_STOPPING || state == UserState.STATE_SHUTDOWN) {\n-                return StorageManager.isUserKeyUnlocked(userId);\n-            }\n-            return (state == UserState.STATE_RUNNING_UNLOCKING)\n-                    || (state == UserState.STATE_RUNNING_UNLOCKED);\n-        }\n-\n-        /**\n-         * The return values of this method are cached in clients.  If the\n-         * logic in this function changes then the cache invalidation code\n-         * may need to be revisited.\n-         */\n-        @Override\n-        public boolean isUserUnlocked(@UserIdInt int userId) {\n-            int state;\n-            synchronized (mUserStates) {\n-                state = mUserStates.get(userId, -1);\n-            }\n-            // Special case, in the stopping/shutdown state user key can still be unlocked\n-            if (state == UserState.STATE_STOPPING || state == UserState.STATE_SHUTDOWN) {\n-                return StorageManager.isUserKeyUnlocked(userId);\n-            }\n-            return state == UserState.STATE_RUNNING_UNLOCKED;\n-        }\n-\n-        @Override\n-        public boolean isUserInitialized(@UserIdInt int userId) {\n-            return (getUserInfo(userId).flags & UserInfo.FLAG_INITIALIZED) != 0;\n-        }\n-\n-        @Override\n-        public boolean exists(@UserIdInt int userId) {\n-            return getUserInfoNoChecks(userId) != null;\n-        }\n-\n-        @Override\n-        public boolean isProfileAccessible(int callingUserId, int targetUserId, String debugMsg,\n-                boolean throwSecurityException) {\n-            if (targetUserId == callingUserId) {\n-                return true;\n-            }\n-            synchronized (mUsersLock) {\n-                UserInfo callingUserInfo = getUserInfoLU(callingUserId);\n-                if (callingUserInfo == null || callingUserInfo.isProfile()) {\n-                    if (throwSecurityException) {\n-                        throw new SecurityException(\n-                                debugMsg + \" for another profile \"\n-                                        + targetUserId + \" from \" + callingUserId);\n-                    }\n-                    Slog.w(LOG_TAG, debugMsg + \" for another profile \"\n-                            + targetUserId + \" from \" + callingUserId);\n-                    return false;\n-                }\n-\n-                UserInfo targetUserInfo = getUserInfoLU(targetUserId);\n-                if (targetUserInfo == null || !targetUserInfo.isEnabled()) {\n-                    // Do not throw any exception here as this could happen due to race conditions\n-                    // between the system updating its state and the client getting notified.\n-                    if (throwSecurityException) {\n-                        Slog.w(LOG_TAG, debugMsg + \" for disabled profile \"\n-                                + targetUserId + \" from \" + callingUserId);\n-                    }\n-                    return false;\n-                }\n-\n-                if (targetUserInfo.profileGroupId == UserInfo.NO_PROFILE_GROUP_ID ||\n-                        targetUserInfo.profileGroupId != callingUserInfo.profileGroupId) {\n-                    if (throwSecurityException) {\n-                        throw new SecurityException(\n-                                debugMsg + \" for unrelated profile \" + targetUserId);\n-                    }\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public int getProfileParentId(@UserIdInt int userId) {\n-            return getProfileParentIdUnchecked(userId);\n-        }\n-\n-        @Override\n-        public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId,\n-                String value, int callingUid) {\n-            return UserManagerService.this.isSettingRestrictedForUser(setting, userId,\n-                    value, callingUid);\n-        }\n-\n-        @Override\n-        public boolean hasUserRestriction(String restrictionKey, @UserIdInt int userId) {\n-            if (!UserRestrictionsUtils.isValidRestriction(restrictionKey)) {\n-                return false;\n-            }\n-            Bundle restrictions = getEffectiveUserRestrictions(userId);\n-            return restrictions != null && restrictions.getBoolean(restrictionKey);\n-        }\n-\n-        @Override\n-        public @Nullable UserInfo getUserInfo(@UserIdInt int userId) {\n-            UserData userData;\n-            synchronized (mUsersLock) {\n-                userData = mUsers.get(userId);\n-            }\n-            return userData == null ? null : userData.info;\n-        }\n-\n-        @Override\n-        public @NonNull UserInfo[] getUserInfos() {\n-            synchronized (mUsersLock) {\n-                int userSize = mUsers.size();\n-                UserInfo[] allInfos = new UserInfo[userSize];\n-                for (int i = 0; i < userSize; i++) {\n-                    allInfos[i] = mUsers.valueAt(i).info;\n-                }\n-                return allInfos;\n-            }\n-        }\n-\n-        @Override\n-        public void setDefaultCrossProfileIntentFilters(\n-                @UserIdInt int parentUserId, @UserIdInt int profileUserId) {\n-            final UserTypeDetails userTypeDetails = getUserTypeDetailsNoChecks(profileUserId);\n-            final Bundle restrictions = getEffectiveUserRestrictions(profileUserId);\n-            UserManagerService.this.setDefaultCrossProfileIntentFilters(\n-                    profileUserId, userTypeDetails, restrictions, parentUserId);\n-        }\n-\n-        @Override\n-        public boolean shouldIgnorePrepareStorageErrors(int userId) {\n-            synchronized (mUsersLock) {\n-                UserData userData = mUsers.get(userId);\n-                return userData != null && userData.getIgnorePrepareStorageErrors();\n-            }\n-        }\n-\n-        @Override\n-        public @Nullable UserProperties getUserProperties(@UserIdInt int userId) {\n-            final UserProperties props = getUserPropertiesInternal(userId);\n-            if (props == null) {\n-                Slog.w(LOG_TAG, \"A null UserProperties was returned for user \" + userId);\n-            }\n-            return props;\n-        }\n-\n-        @Override\n-        @UserAssignmentResult\n-        public int assignUserToDisplayOnStart(@UserIdInt int userId,\n-                @UserIdInt int profileGroupId, @UserStartMode int userStartMode, int displayId) {\n-            return mUserVisibilityMediator.assignUserToDisplayOnStart(userId, profileGroupId,\n-                    userStartMode, displayId);\n-        }\n-\n-        @Override\n-        public boolean assignUserToExtraDisplay(int userId, int displayId) {\n-            return mUserVisibilityMediator.assignUserToExtraDisplay(userId, displayId);\n-        }\n-\n-        @Override\n-        public boolean unassignUserFromExtraDisplay(int userId, int displayId) {\n-            return mUserVisibilityMediator.unassignUserFromExtraDisplay(userId, displayId);\n-        }\n-\n-        @Override\n-        public void unassignUserFromDisplayOnStop(@UserIdInt int userId) {\n-            mUserVisibilityMediator.unassignUserFromDisplayOnStop(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserVisible(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.isUserVisible(userId);\n-        }\n-\n-        @Override\n-        public boolean isUserVisible(@UserIdInt int userId, int displayId) {\n-            return mUserVisibilityMediator.isUserVisible(userId, displayId);\n-        }\n-\n-        @Override\n-        public int getMainDisplayAssignedToUser(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.getMainDisplayAssignedToUser(userId);\n-        }\n-\n-        @Override\n-        public @Nullable int[] getDisplaysAssignedToUser(@UserIdInt int userId) {\n-            return mUserVisibilityMediator.getDisplaysAssignedToUser(userId);\n-        }\n-\n-        @Override\n-        public @UserIdInt int getUserAssignedToDisplay(int displayId) {\n-            return mUserVisibilityMediator.getUserAssignedToDisplay(displayId);\n-        }\n-\n-        @Override\n-        public void addUserVisibilityListener(UserVisibilityListener listener) {\n-            mUserVisibilityMediator.addListener(listener);\n-        }\n-\n-        @Override\n-        public void removeUserVisibilityListener(UserVisibilityListener listener) {\n-            mUserVisibilityMediator.removeListener(listener);\n-        }\n-\n-        @Override\n-        public void onSystemUserVisibilityChanged(boolean visible) {\n-            mUserVisibilityMediator.onSystemUserVisibilityChanged(visible);\n-        }\n-\n-        @Override\n-        public int[] getUserTypesForStatsd(@UserIdInt int[] userIds) {\n-            if (userIds == null) {\n-                return null;\n-            }\n-            final int[] userTypes = new int[userIds.length];\n-            for (int i = 0; i < userTypes.length; i++) {\n-                final UserInfo userInfo = getUserInfo(userIds[i]);\n-                if (userInfo == null) {\n-                    // Not possible because the input user ids should all be valid\n-                    userTypes[i] = mUserJourneyLogger.getUserTypeForStatsd(\"\");\n-                } else {\n-                    userTypes[i] = mUserJourneyLogger.getUserTypeForStatsd(userInfo.userType);\n-                }\n-            }\n-            return userTypes;\n-        }\n-\n-        @Override\n-        public @UserIdInt int getMainUserId() {\n-            return getMainUserIdUnchecked();\n-        }\n-\n-        @Override\n-        public @UserIdInt int getBootUser(boolean waitUntilSet)\n-                throws UserManager.CheckedUserOperationException {\n-            if (waitUntilSet) {\n-                final TimingsTraceAndSlog t = new TimingsTraceAndSlog();\n-                t.traceBegin(\"wait-boot-user\");\n-                try {\n-                    if (mBootUserLatch.getCount() != 0) {\n-                        Slogf.d(LOG_TAG,\n-                                \"Sleeping for boot user to be set. \"\n-                                + \"Max sleep for Time: %d\", BOOT_USER_SET_TIMEOUT_MS);\n-                    }\n-                    if (!mBootUserLatch.await(BOOT_USER_SET_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                        Slogf.w(LOG_TAG, \"Boot user not set. Timeout: %d\",\n-                                BOOT_USER_SET_TIMEOUT_MS);\n-                    }\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    Slogf.w(LOG_TAG, e, \"InterruptedException during wait for boot user.\");\n-                }\n-                t.traceEnd();\n-            }\n-\n-            return getBootUserUnchecked();\n-        }\n-\n-    } // class LocalService\n-\n-\n-\n-    /**\n-     * Check if user has restrictions\n-     * @param restriction restrictions to check\n-     * @param userId id of the user\n-     *\n-     * @throws {@link android.os.UserManager.CheckedUserOperationException} if user has any of the\n-     *      specified restrictions\n-     */\n-    private void enforceUserRestriction(String restriction, @UserIdInt int userId, String message)\n-            throws UserManager.CheckedUserOperationException {\n-        if (hasUserRestriction(restriction, userId)) {\n-            String errorMessage = (message != null ? (message + \": \") : \"\")\n-                    + restriction + \" is enabled.\";\n-            Slog.w(LOG_TAG, errorMessage);\n-            throw new UserManager.CheckedUserOperationException(errorMessage,\n-                    USER_OPERATION_ERROR_UNKNOWN);\n-        }\n-    }\n-\n-    /**\n-     * Throws CheckedUserOperationException and shows error log\n-     * @param message message for exception and logging\n-     * @param userOperationResult result/error code\n-     * @throws UserManager.CheckedUserOperationException\n-     */\n-    private void throwCheckedUserOperationException(@NonNull String message,\n-            @UserManager.UserOperationResult int userOperationResult)\n-            throws UserManager.CheckedUserOperationException {\n-        Slog.e(LOG_TAG, message);\n-        throw new UserManager.CheckedUserOperationException(message, userOperationResult);\n-    }\n-\n-    /* Remove all the users except the system and permanent admin main.*/\n-    private void removeAllUsersExceptSystemAndPermanentAdminMain() {\n-        ArrayList<UserInfo> usersToRemove = new ArrayList<>();\n-        synchronized (mUsersLock) {\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                UserInfo ui = mUsers.valueAt(i).info;\n-                if (ui.id != UserHandle.USER_SYSTEM && !isNonRemovableMainUser(ui)) {\n-                    usersToRemove.add(ui);\n-                }\n-            }\n-        }\n-        for (UserInfo ui: usersToRemove) {\n-            removeUser(ui.id);\n-        }\n-    }\n-\n-    private static void debug(String message) {\n-        Slog.d(LOG_TAG, message\n-                + (DBG_WITH_STACKTRACE ? \" called at\\n\" + Debug.getCallers(10, \"  \") : \"\"));\n-    }\n-\n-    /** @see #getMaxUsersOfTypePerParent(UserTypeDetails) */\n-    @VisibleForTesting\n-    int getMaxUsersOfTypePerParent(String userType) {\n-        final UserTypeDetails type = mUserTypes.get(userType);\n-        if (type == null) {\n-            return 0;\n-        }\n-        return getMaxUsersOfTypePerParent(type);\n-    }\n-\n-    /**\n-     * Returns the maximum number of users allowed for the given userTypeDetails per parent user.\n-     * This is applicable for user types that are {@link UserTypeDetails#isProfile()}.\n-     * If there is no maximum, {@link UserTypeDetails#UNLIMITED_NUMBER_OF_USERS} is returned.\n-     * Under certain circumstances (such as after a change-user-type) the max value can actually\n-     * be exceeded: this is allowed in order to keep the device in a usable state.\n-     * An error is logged in {@link UserManagerService#upgradeProfileToTypeLU}\n-     */\n-    private static int getMaxUsersOfTypePerParent(UserTypeDetails userTypeDetails) {\n-        final int defaultMax = userTypeDetails.getMaxAllowedPerParent();\n-        if (!Build.IS_DEBUGGABLE) {\n-            return defaultMax;\n-        } else {\n-            if (userTypeDetails.isManagedProfile()) {\n-                return SystemProperties.getInt(\"persist.sys.max_profiles\", defaultMax);\n-            }\n-        }\n-        return defaultMax;\n-    }\n-\n-    @GuardedBy(\"mUsersLock\")\n-    @VisibleForTesting\n-    int getFreeProfileBadgeLU(int parentUserId, String userType) {\n-        Set<Integer> usedBadges = new ArraySet<>();\n-        final int userSize = mUsers.size();\n-        for (int i = 0; i < userSize; i++) {\n-            UserInfo ui = mUsers.valueAt(i).info;\n-            // Check which badge indexes are already used by this profile group.\n-            if (ui.userType.equals(userType)\n-                    && ui.profileGroupId == parentUserId\n-                    && !mRemovingUserIds.get(ui.id)) {\n-                usedBadges.add(ui.profileBadge);\n-            }\n-        }\n-        int maxUsersOfType = getMaxUsersOfTypePerParent(userType);\n-        if (maxUsersOfType == UserTypeDetails.UNLIMITED_NUMBER_OF_USERS) {\n-            maxUsersOfType = Integer.MAX_VALUE;\n-        }\n-        for (int i = 0; i < maxUsersOfType; i++) {\n-            if (!usedBadges.contains(i)) {\n-                return i;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Checks if the given user has a profile associated with it.\n-     * @param userId The parent user\n-     * @return\n-     */\n-    boolean hasProfile(@UserIdInt int userId) {\n-        synchronized (mUsersLock) {\n-            UserInfo userInfo = getUserInfoLU(userId);\n-            final int userSize = mUsers.size();\n-            for (int i = 0; i < userSize; i++) {\n-                UserInfo profile = mUsers.valueAt(i).info;\n-                if (userId != profile.id && isProfileOf(userInfo, profile)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Checks if the calling package name matches with the calling UID, throw\n-     * {@link SecurityException} if not.\n-     */\n-    private void verifyCallingPackage(String callingPackage, int callingUid) {\n-        int packageUid = mPm.snapshotComputer()\n-                .getPackageUid(callingPackage, 0,  UserHandle.getUserId(callingUid));\n-        if (packageUid != callingUid) {\n-            throw new SecurityException(\"Specified package \" + callingPackage\n-                    + \" does not match the calling uid \" + callingUid);\n-        }\n-    }\n-\n-    /** Retrieves the internal package manager interface. */\n-    private PackageManagerInternal getPackageManagerInternal() {\n-        // Don't need to synchonize; worst-case scenario LocalServices will be called twice.\n-        if (mPmInternal == null) {\n-            mPmInternal = LocalServices.getService(PackageManagerInternal.class);\n-        }\n-        return mPmInternal;\n-    }\n-\n-    /** Returns the internal device policy manager interface. */\n-    private DevicePolicyManagerInternal getDevicePolicyManagerInternal() {\n-        if (mDevicePolicyManagerInternal == null) {\n-            mDevicePolicyManagerInternal =\n-                    LocalServices.getService(DevicePolicyManagerInternal.class);\n-        }\n-        return mDevicePolicyManagerInternal;\n-    }\n-\n-    /** Returns the internal activity manager interface. */\n-    private @Nullable ActivityManagerInternal getActivityManagerInternal() {\n-        if (mAmInternal == null) {\n-            mAmInternal = LocalServices.getService(ActivityManagerInternal.class);\n-        }\n-        return mAmInternal;\n-    }\n-\n-    /**\n-     * Returns true, when user has {@link UserInfo#FLAG_MAIN} and system property\n-     * {@link com.android.internal.R.bool#config_isMainUserPermanentAdmin} is true.\n-     */\n-    private boolean isNonRemovableMainUser(UserInfo userInfo) {\n-        return userInfo.isMain() && isMainUserPermanentAdmin();\n-    }\n-\n-    /**\n-     * Returns true if {@link com.android.internal.R.bool#config_isMainUserPermanentAdmin} is true.\n-     * If the main user is a permanent admin user it can't be deleted\n-     * or downgraded to non-admin status.\n-     */\n-    public boolean isMainUserPermanentAdmin() {\n-        return Resources.getSystem()\n-                .getBoolean(R.bool.config_isMainUserPermanentAdmin);\n-    }\n-\n-    /**\n-     * Returns true if {@link com.android.internal.R.bool#config_canSwitchToHeadlessSystemUser}\n-     * is true. If allowed, headless system user can run in the foreground even though\n-     * it is not a full user.\n-     */\n-    public boolean canSwitchToHeadlessSystemUser() {\n-        return Resources.getSystem()\n-                .getBoolean(R.bool.config_canSwitchToHeadlessSystemUser);\n-    }\n-\n-    /**\n-     * Returns instance of {@link com.android.server.pm.UserJourneyLogger}.\n-     */\n-    public UserJourneyLogger getUserJourneyLogger() {\n-        return mUserJourneyLogger;\n-    }\n-\n-}\n-```+        UserManager.invalidateUserPropertiesCache();",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.0091,
      "token_level_edit_distance": 7344,
      "codebert_score": {
        "precision": 0.695,
        "recall": 0.8339,
        "f1": 0.7582,
        "f3": 0.8176
      },
      "token_count_upstream": 53,
      "token_count_downstream": 4751,
      "token_count_total": 4804,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-304983146",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "runtime_seconds": 536.06,
    "rej_file_diff": "--- services/core/java/com/android/server/appop/AppOpsService.java\n+++ services/core/java/com/android/server/appop/AppOpsService.java\n@@ -4342,6 +4350,36 @@ public class AppOpsService extends IAppOpsService.Stub {\n         return false;\n     }\n \n+    /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n     private void logVerifyAndGetBypassFailure(int uid, @NonNull SecurityException e,\n             @NonNull String methodName) {\n         if (Process.isIsolated(uid)) {",
    "llm_generated_patch": "--- original\n+++ patched\n@@ -3919,6 +3919,45 @@\n     }\n \n     /**\n+     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n+     * This method is intended for ProxyAttributionTag validation and returns false\n+     * if it does not exist in either one of them.\n+     *\n+     * @param packageName Name of the package\n+     * @param proxyPackageName Name of the proxy package\n+     * @param attributionTag attribution tag to be checked\n+     *\n+     * @return boolean specifying if attribution tag is valid or not\n+     */\n+    private boolean isAttributionTagDefined(@Nullable String packageName,\n+                                          @Nullable String proxyPackageName,\n+                                          @Nullable String attributionTag) {\n+        if (packageName == null) {\n+            return false;\n+        } else if (attributionTag == null) {\n+            return true;\n+        }\n+        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n+        if (proxyPackageName != null) {\n+            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n+            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n+                return true;\n+            }\n+        }\n+        AndroidPackage pkg = pmInt.getPackage(packageName);\n+        return isAttributionInPackage(pkg, attributionTag);\n+    }\n+\n+    private void logVerifyAndGetBypassFailure(int uid, @NonNull SecurityException e,\n+            @NonNull String methodName) {\n+        if (Process.isIsolated(uid)) {\n+            Slog.e(TAG, \"Cannot \" + methodName + \": isolated process\");\n+        } else {\n+            Slog.e(TAG, \"Cannot \" + methodName, e);\n+        }\n+    }\n+\n+    /**\n      * Get (and potentially create) ops.\n      *\n      * @param uid The uid the package belongs to\n@@ -6399,224 +6438,4 @@\n                             AppOpsService.this::checkOperationImpl);\n                 }\n             } else if (mCheckOpsDelegate != null) {\n-                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n-            }\n-            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n-        }\n-\n-        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n-                @Nullable String attributionTag, boolean raw) {\n-            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n-                    AppOpsService.this::checkOperationImpl);\n-        }\n-\n-        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n-                            this::checkDelegateAudioOperationImpl);\n-                } else {\n-                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n-                            AppOpsService.this::checkAudioOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n-            }\n-            return checkAudioOperationImpl(code, usage, uid, packageName);\n-        }\n-\n-        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n-                String packageName) {\n-            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n-                    AppOpsService.this::checkAudioOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n-                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            this::noteDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            AppOpsService.this::noteOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateOperationImpl(code, uid, packageName,\n-                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-            }\n-            return noteOperationImpl(code, uid, packageName, attributionTag,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n-                @Nullable String packageName, @Nullable String featureId,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage) {\n-            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    AppOpsService.this::noteOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n-                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n-                boolean shouldCollectMessage, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.noteProxyOperation(code, attributionSource,\n-                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return noteDelegateProxyOperationImpl(code,\n-                        attributionSource, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation);\n-            }\n-            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n-                    message, shouldCollectMessage,skipProxyOperation);\n-        }\n-\n-        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n-                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation) {\n-            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    AppOpsService.this::noteProxyOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n-                @Nullable String packageName, @NonNull String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n-                @Nullable String message, boolean shouldCollectMessage,\n-                @AttributionFlags int attributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startOperation(token, code, uid, packageName,\n-                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            this::startDelegateOperationImpl);\n-                } else {\n-                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, attributionFlags, attributionChainId,\n-                            AppOpsService.this::startOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, attributionFlags, attributionChainId);\n-            }\n-            return startOperationImpl(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n-                @Nullable String packageName, @Nullable String attributionTag,\n-                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n-                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n-                int attributionChainId) {\n-            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n-        }\n-\n-        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            this::startDelegateProxyOperationImpl);\n-                } else {\n-                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n-                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                            proxiedAttributionFlags, attributionChainId,\n-                            AppOpsService.this::startProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n-                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n-                        proxiedAttributionFlags, attributionChainId);\n-            }\n-            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n-                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n-                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n-        }\n-\n-        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n-                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n-                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n-                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n-            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n-                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n-                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n-                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n-        }\n-\n-        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n-                String attributionTag) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            this::finishDelegateOperationImpl);\n-                } else {\n-                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                            AppOpsService.this::finishOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            } else {\n-                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n-            }\n-        }\n-\n-        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n-                String packageName, String attributionTag) {\n-            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n-                    AppOpsService.this::finishOperationImpl);\n-        }\n-\n-        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            if (mPolicy != null) {\n-                if (mCheckOpsDelegate != null) {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n-                } else {\n-                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n-                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-                }\n-            } else if (mCheckOpsDelegate != null) {\n-                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n-                        skipProxyOperation);\n-            } else {\n-                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n-            }\n-        }\n-\n-        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n-                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n-            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n-                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n-            return null;\n-        }\n-    }\n-}\n-```+                return checkDelegateOperation",
    "metrics": {
      "relative_line_count_similarity": 0.0,
      "normalized_edit_similarity": 0.1025,
      "token_level_edit_distance": 1736,
      "codebert_score": {
        "precision": 0.755,
        "recall": 0.8776,
        "f1": 0.8117,
        "f3": 0.8636
      },
      "token_count_upstream": 198,
      "token_count_downstream": 1229,
      "token_count_total": 1427,
      "cosine_similarity_openai": 0.7524
    }
  }
]