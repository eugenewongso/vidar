[
  {
    "cve_id": "ASB-A-296915500",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
    "llm_patched_code": "/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9767,
      "normalized_edit_similarity": 0.9704,
      "token_level_edit_distance": 40,
      "codebert_score": {
        "precision": 0.952,
        "recall": 0.9461,
        "f1": 0.9491,
        "f3": 0.9467
      },
      "token_count_upstream": 1156,
      "token_count_downstream": 1149,
      "token_count_total": 2305,
      "cosine_similarity_openai": 0.9948
    }
  },
  {
    "cve_id": "ASB-A-364027949",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "llm_patched_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "ground_truth_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9967,
      "normalized_edit_similarity": 0.9997,
      "token_level_edit_distance": 1,
      "codebert_score": {
        "precision": 0.9877,
        "recall": 0.9877,
        "f1": 0.9877,
        "f3": 0.9877
      },
      "token_count_upstream": 4687,
      "token_count_downstream": 4704,
      "token_count_total": 9391,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-364025411",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "llm_patched_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "ground_truth_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9934,
      "normalized_edit_similarity": 0.9997,
      "token_level_edit_distance": 1,
      "codebert_score": {
        "precision": 0.9805,
        "recall": 0.9806,
        "f1": 0.9805,
        "f3": 0.9806
      },
      "token_count_upstream": 4670,
      "token_count_downstream": 4704,
      "token_count_total": 9374,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-340480881",
    "downstream_version": "14",
    "file_name": "PermissionController/src/com/android/permissioncontroller/permission/ui/handheld/ReviewPermissionsFragment.java",
    "llm_patched_code": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.permissioncontroller.permission.ui.handheld;\n\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\nimport static android.content.pm.PackageManager.FLAG_PERMISSION_USER_SET;\n\nimport static com.android.permissioncontroller.PermissionControllerStatsLog.REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED;\n\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.graphics.drawable.Drawable;\nimport android.os.Bundle;\nimport android.os.RemoteCallback;\nimport android.os.UserHandle;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.lifecycle.ViewModelProvider;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceCategory;\nimport androidx.preference.PreferenceFragmentCompat;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.permissioncontroller.PermissionControllerStatsLog;\nimport com.android.permissioncontroller.R;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightAppPermGroup;\nimport com.android.permissioncontroller.permission.model.livedatatypes.LightPermission;\nimport com.android.permissioncontroller.permission.ui.ManagePermissionsActivity;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionViewModelFactory;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel;\nimport com.android.permissioncontroller.permission.ui.model.ReviewPermissionsViewModel.PermissionTarget;\nimport com.android.permissioncontroller.permission.utils.KotlinUtils;\nimport com.android.permissioncontroller.permission.utils.Utils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * If an app does not support runtime permissions the user is prompted via this fragment to select\n * which permissions to grant to the app before first use and if an update changed the permissions.\n */\npublic final class ReviewPermissionsFragment extends PreferenceFragmentCompat\n        implements View.OnClickListener, PermissionPreference.PermissionPreferenceChangeListener,\n        PermissionPreference.PermissionPreferenceOwnerFragment {\n\n    private static final String EXTRA_PACKAGE_INFO =\n            \"com.android.permissioncontroller.permission.ui.extra.PACKAGE_INFO\";\n    private static final String LOG_TAG = ReviewPermissionsFragment.class.getSimpleName();\n\n    private ReviewPermissionsViewModel mViewModel;\n    private View mView;\n    private Button mContinueButton;\n    private Button mCancelButton;\n    private Button mMoreInfoButton;\n    private PreferenceCategory mNewPermissionsCategory;\n    private PreferenceCategory mCurrentPermissionsCategory;\n\n    private boolean mHasConfirmedRevoke;\n\n    /**\n     * Creates bundle arguments for the navigation graph\n     * @param packageInfo packageInfo added to the bundle\n     * @return the bundle\n     */\n    public static Bundle getArgs(PackageInfo packageInfo) {\n        Bundle arguments = new Bundle();\n        arguments.putParcelable(EXTRA_PACKAGE_INFO, packageInfo);\n        return arguments;\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n\n        PackageInfo packageInfo = getArguments().getParcelable(EXTRA_PACKAGE_INFO);\n        if (packageInfo == null) {\n            activity.finishAfterTransition();\n            return;\n        }\n\n        ReviewPermissionViewModelFactory factory = new ReviewPermissionViewModelFactory(\n                getActivity().getApplication(), packageInfo);\n        mViewModel = new ViewModelProvider(this, factory).get(ReviewPermissionsViewModel.class);\n        mViewModel.getPermissionGroupsLiveData().observe(this,\n                (Map<String, LightAppPermGroup> permGroupsMap) -> {\n                    if (getActivity().isFinishing()) {\n                        return;\n                    }\n                    if (permGroupsMap.isEmpty()) {\n                        //If the system called for a review but no groups are found, this means\n                        // that all groups are restricted. Hence there is nothing to review\n                        // and instantly continue.\n                        confirmPermissionsReview();\n                        executeCallback(true);\n                        activity.finishAfterTransition();\n                    } else {\n                        bindUi(permGroupsMap);\n                        loadPreferences(permGroupsMap);\n                    }\n                });\n    }\n\n    @Override\n    public void onCreatePreferences(Bundle bundle, String s) {\n        // empty\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,\n            @Nullable Bundle savedInstanceState) {\n        mView = inflater.inflate(R.layout.review_permissions, container, false);\n        ViewGroup preferenceRootView = mView.requireViewById(R.id.preferences_frame);\n        View prefsContainer = super.onCreateView(inflater, preferenceRootView, savedInstanceState);\n        preferenceRootView.addView(prefsContainer);\n        return mView;\n    }\n\n    @Override\n    public void onClick(View view) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (view == mContinueButton) {\n            confirmPermissionsReview();\n            executeCallback(true);\n        } else if (view == mCancelButton) {\n            executeCallback(false);\n            activity.setResult(Activity.RESULT_CANCELED);\n        } else if (view == mMoreInfoButton) {\n            Intent intent = new Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);\n            intent.putExtra(Intent.EXTRA_PACKAGE_NAME,\n                    mViewModel.getPackageInfo().packageName);\n            intent.putExtra(Intent.EXTRA_USER, UserHandle.getUserHandleForUid(\n                    mViewModel.getPackageInfo().applicationInfo.uid));\n            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, true);\n            getActivity().startActivity(intent);\n        }\n        activity.finishAfterTransition();\n    }\n\n    private void confirmPermissionsReview() {\n        final List<PreferenceGroup> preferenceGroups = new ArrayList<>();\n        if (mNewPermissionsCategory != null) {\n            preferenceGroups.add(mNewPermissionsCategory);\n            preferenceGroups.add(mCurrentPermissionsCategory);\n        } else {\n            PreferenceScreen preferenceScreen = getPreferenceScreen();\n            if (preferenceScreen != null) {\n                preferenceGroups.add(preferenceScreen);\n            }\n        }\n\n        final int preferenceGroupCount = preferenceGroups.size();\n        long changeIdForLogging = new Random().nextLong();\n        Application app = getActivity().getApplication();\n        for (int groupNum = 0; groupNum < preferenceGroupCount; groupNum++) {\n            final PreferenceGroup preferenceGroup = preferenceGroups.get(groupNum);\n\n            final int preferenceCount = preferenceGroup.getPreferenceCount();\n            for (int prefNum = 0; prefNum < preferenceCount; prefNum++) {\n                Preference preference = preferenceGroup.getPreference(prefNum);\n                if (preference instanceof PermissionReviewPreference) {\n                    PermissionReviewPreference permPreference =\n                            (PermissionReviewPreference) preference;\n                    LightAppPermGroup group = permPreference.getGroup();\n\n\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_FOREGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantForegroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState().and(\n                            PermissionTarget.PERMISSION_BACKGROUND)\n                            != PermissionTarget.PERMISSION_NONE.getValue()) {\n                        KotlinUtils.INSTANCE.grantBackgroundRuntimePermissions(app, group);\n                    }\n                    if (permPreference.getState() == PermissionTarget.PERMISSION_NONE) {\n                        KotlinUtils.INSTANCE.revokeForegroundRuntimePermissions(app, group);\n                        KotlinUtils.INSTANCE.revokeBackgroundRuntimePermissions(app, group);\n                    }\n                    logReviewPermissionsFragmentResult(changeIdForLogging, group);\n                }\n            }\n        }\n\n        // Some permission might be restricted and hence there is no AppPermissionGroup for it.\n        // Manually unset all review-required flags, regardless of restriction.\n        PackageManager pm = getContext().getPackageManager();\n        PackageInfo pkg = mViewModel.getPackageInfo();\n        UserHandle user = UserHandle.getUserHandleForUid(pkg.applicationInfo.uid);\n\n        if (pkg.requestedPermissions == null) {\n            // No flag updating to do\n            return;\n        }\n\n        for (String perm : pkg.requestedPermissions) {\n            try {\n                pm.updatePermissionFlags(perm, pkg.packageName,\n                        FLAG_PERMISSION_REVIEW_REQUIRED | FLAG_PERMISSION_USER_SET,\n                        FLAG_PERMISSION_USER_SET, user);\n            } catch (IllegalArgumentException e) {\n                Log.e(LOG_TAG, \"Cannot unmark \" + perm + \" requested by \" + pkg.packageName\n                        + \" as review required\", e);\n            }\n        }\n    }\n\n    private void logReviewPermissionsFragmentResult(long changeId, LightAppPermGroup group) {\n        ArrayList<LightPermission> permissions = new ArrayList<>(\n                group.getAllPermissions().values());\n\n        int numPermissions = permissions.size();\n        for (int i = 0; i < numPermissions; i++) {\n            LightPermission permission = permissions.get(i);\n\n            PermissionControllerStatsLog.write(REVIEW_PERMISSIONS_FRAGMENT_RESULT_REPORTED,\n                    changeId, mViewModel.getPackageInfo().applicationInfo.uid,\n                    group.getPackageName(),\n                    permission.getName(), permission.isGranted());\n            Log.v(LOG_TAG, \"Permission grant via permission review changeId=\" + changeId + \" uid=\"\n                    + mViewModel.getPackageInfo().applicationInfo.uid + \" packageName=\"\n                    + group.getPackageName() + \" permission=\"\n                    + permission.getName() + \" granted=\" + permission.isGranted());\n        }\n    }\n\n    private void bindUi(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        Drawable icon = mViewModel.getPackageInfo().applicationInfo.loadIcon(\n                    getContext().getPackageManager());\n        ImageView iconView = mView.requireViewById(R.id.app_icon);\n        iconView.setImageDrawable(icon);\n\n        // Set message\n        final int labelTemplateResId = mViewModel.isPackageUpdated()\n                ? R.string.permission_review_title_template_update\n                : R.string.permission_review_title_template_install;\n        Spanned message = Html.fromHtml(getString(labelTemplateResId,\n                Utils.getAppLabel(mViewModel.getPackageInfo().applicationInfo,\n                        getActivity().getApplication())), 0);\n        // Set the permission message as the title so it can be announced.\n        activity.setTitle(message.toString());\n\n        // Color the app name.\n        TextView permissionsMessageView = mView.requireViewById(\n                R.id.permissions_message);\n        permissionsMessageView.setText(message);\n\n        mContinueButton = mView.requireViewById(R.id.continue_button);\n        mContinueButton.setOnClickListener(this);\n\n        mCancelButton = mView.requireViewById(R.id.cancel_button);\n        mCancelButton.setOnClickListener(this);\n\n        if (activity.getPackageManager().arePermissionsIndividuallyControlled()) {\n            mMoreInfoButton = mView.requireViewById(\n                    R.id.permission_more_info_button);\n            mMoreInfoButton.setOnClickListener(this);\n            mMoreInfoButton.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private PermissionReviewPreference getPreference(String key) {\n        if (mNewPermissionsCategory != null) {\n            PermissionReviewPreference pref =\n                    mNewPermissionsCategory.findPreference(key);\n\n            if (pref == null && mCurrentPermissionsCategory != null) {\n                return mCurrentPermissionsCategory.findPreference(key);\n            } else {\n                return pref;\n            }\n        } else {\n            return getPreferenceScreen().findPreference(key);\n        }\n    }\n\n    private void loadPreferences(Map<String, LightAppPermGroup> permGroupsMap) {\n        Activity activity = getActivity();\n        if (activity == null || !mViewModel.isInitialized()) {\n            return;\n        }\n\n        PreferenceScreen screen = getPreferenceScreen();\n        if (screen == null) {\n            screen = getPreferenceManager().createPreferenceScreen(getContext());\n            setPreferenceScreen(screen);\n        } else {\n            screen.removeAll();\n        }\n\n        mCurrentPermissionsCategory = null;\n        mNewPermissionsCategory = null;\n\n        final boolean isPackageUpdated = mViewModel.isPackageUpdated();\n\n        for (LightAppPermGroup group : permGroupsMap.values()) {\n            PermissionReviewPreference preference = getPreference(group.getPermGroupName());\n            if (preference == null) {\n                preference = new PermissionReviewPreference(this,\n                        group, this, mViewModel);\n                preference.setKey(group.getPermGroupName());\n                Drawable icon = KotlinUtils.INSTANCE.getPermGroupIcon(getContext(),\n                        group.getPermGroupName());\n                preference.setIcon(icon);\n                preference.setTitle(KotlinUtils.INSTANCE.getPermGroupLabel(getContext(),\n                        group.getPermGroupName()));\n            } else {\n                preference.updateUi();\n            }\n\n            if (group.isReviewRequired()) {\n                if (!isPackageUpdated) {\n                    screen.addPreference(preference);\n                } else {\n                    if (mNewPermissionsCategory == null) {\n                        mNewPermissionsCategory = new PreferenceCategory(activity);\n                        mNewPermissionsCategory.setTitle(R.string.new_permissions_category);\n                        mNewPermissionsCategory.setOrder(1);\n                        screen.addPreference(mNewPermissionsCategory);\n                    }\n                    mNewPermissionsCategory.addPreference(preference);\n                }\n            } else {\n                if (mCurrentPermissionsCategory == null) {\n                    mCurrentPermissionsCategory = new PreferenceCategory(activity);\n                    mCurrentPermissionsCategory.setTitle(R.string.current_permissions_category);\n                    mCurrentPermissionsCategory.setOrder(2);\n                    screen.addPreference(mCurrentPermissionsCategory);\n                }\n                mCurrentPermissionsCategory.addPreference(preference);\n            }\n        }\n    }\n\n    private void executeCallback(boolean success) {\n        Activity activity = getActivity();\n        if (activity == null) {\n            return;\n        }\n        if (success) {\n            IntentSender intent = activity.getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n            if (intent != null) {\n                try {\n                    int flagMask = 0;\n                    int flagValues = 0;\n                    if (activity.getIntent().getBooleanExtra(\n                            Intent.EXTRA_RESULT_NEEDED, false)) {\n                        flagMask = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                        flagValues = Intent.FLAG_ACTIVITY_FORWARD_RESULT;\n                    }\n                    activity.startIntentSenderForResult(intent, -1, null,\n                            flagMask, flagValues, 0);\n                } catch (IntentSender.SendIntentException e) {\n                        /* ignore */\n                }\n                return;\n            }\n        }\n        RemoteCallback callback = activity.getIntent().getParcelableExtra(\n                Intent.EXTRA_REMOTE_CALLBACK);\n        if (callback != null) {\n            Bundle result = new Bundle();\n            result.putBoolean(Intent.EXTRA_RETURN_RESULT, success);\n            callback.sendResult(result);\n        }\n    }\n\n    @Override\n    public boolean shouldConfirmDefaultPermissionRevoke() {\n        return !mHasConfirmedRevoke;\n    }\n\n    @Override\n    public void hasConfirmDefaultPermissionRevoke() {\n        mHasConfirmedRevoke = true;\n    }\n\n    @Override\n    public void onPreferenceChanged(String key) {\n        getPreference(key).setChanged();\n    }\n\n    @Override\n    public void onDenyAnyWay(String key, PermissionTarget changeTarget) {\n        getPreference(key).onDenyAnyWay(changeTarget);\n    }\n\n    @Override\n    public void onBackgroundAccessChosen(String key, int chosenItem) {\n        getPreference(key).onBackgroundAccessChosen(chosenItem);\n    }\n\n    /**\n     * Extend the {@link PermissionPreference}:\n     * <ul>\n     *     <li>Show the description of the permission group</li>\n     *     <li>Show the permission group as granted if the user has not toggled it yet. This means\n     *     that if the user does not touch the preference, we will later grant the permission\n     *     in {@link #confirmPermissionsReview()}.</li>\n     * </ul>\n     */\n    private static class PermissionReviewPreference extends PermissionPreference {\n        private final LightAppPermGroup mGroup;\n        private final Context mContext;\n        private boolean mWasChanged;\n\n        PermissionReviewPreference(PreferenceFragmentCompat fragment, LightAppPermGroup group,\n                PermissionPreferenceChangeListener callbacks,\n                ReviewPermissionsViewModel reviewPermissionsViewModel) {\n            super(fragment, group, callbacks, reviewPermissionsViewModel);\n            mGroup = group;\n            mContext = fragment.getContext();\n            updateUi();\n        }\n\n        LightAppPermGroup getGroup() {\n            return mGroup;\n        }\n\n        /**\n         * Mark the permission as changed by the user\n         */\n        void setChanged() {\n            mWasChanged = true;\n            updateUi();\n        }\n\n        @Override\n        void updateUi() {\n            // updateUi might be called in super-constructor before group is initialized\n            if (mGroup == null) {\n                return;\n            }\n\n            super.updateUi();\n\n            if (isEnabled()) {\n                if (mGroup.isReviewRequired() && !mWasChanged) {\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                    setCheckedOverride(true);\n                } else if (TextUtils.isEmpty(getSummary())) {\n                    // Sometimes the summary is already used, e.g. when this for a\n                    // foreground/background group. In this case show leave the original summary.\n                    setSummary(KotlinUtils.INSTANCE.getPermGroupDescription(mContext,\n                            mGroup.getPermGroupName()));\n                }\n            }\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "precision": 1.0,
        "recall": 1.0,
        "f1": 1.0,
        "f3": 1.0
      },
      "token_count_upstream": 1385,
      "token_count_downstream": 1385,
      "token_count_total": 2770,
      "cosine_similarity_openai": 1.0
    }
  },
  {
    "cve_id": "ASB-A-369103643",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/wm/WindowOrganizerController.java",
    "llm_patched_code": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                // operations so we don't end up splitting effects between the WM\n                // pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                        & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter it. Instead, send a signal to request PIP\n                // mode to the app if they wish to support it below in #applyTaskChanges.\n                return effects;\n            }\n\n            final int prevMode = container.getRequestedOverrideWindowingMode();\n            container.setWindowingMode(windowingMode);\n            if (prevMode != container.getWindowingMode()) {\n                // The activity in the container may become focusable or non-focusable due to\n                // windowing modes changes (such as entering or leaving pinned windowing mode),\n                // so also apply the lifecycle effects to this transaction.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        return effects;\n    }\n\n    private int applyTaskChanges(Task tr, WindowContainerTransaction.Change c) {\n        int effects = applyChanges(tr, c);\n        final SurfaceControl.Transaction t = c.getBoundsChangeTransaction();\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n            if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                effects = TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_FORCE_TRANSLUCENT) != 0) {\n            tr.setForceTranslucent(c.getForceTranslucent());\n            effects = TRANSACT_EFFECTS_LIFECYCLE;\n        }\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_DRAG_RESIZING) != 0) {\n            tr.setDragResizing(c.getDragResizing());\n        }\n\n        final int childWindowingMode = c.getActivityWindowingMode();\n        if (childWindowingMode > -1) {\n            tr.forAllActivities(a -> { a.setWindowingMode(childWindowingMode); });\n        }\n\n        if (t != null) {\n            tr.setMainWindowSizeChangeTransaction(t);\n        }\n\n        Rect enterPipBounds = c.getEnterPipBounds();\n        if (enterPipBounds != null) {\n            tr.mDisplayContent.mPinnedTaskController.setEnterPipBounds(enterPipBounds);\n        }\n\n        if (c.getWindowingMode() == WindowConfiguration.WINDOWING_MODE_PINNED\n                && !tr.inPinnedWindowingMode()) {\n            final ActivityRecord activity = tr.getTopNonFinishingActivity();\n            if (activity != null) {\n                final boolean lastSupportsEnterPipOnTaskSwitch =\n                        activity.supportsEnterPipOnTaskSwitch;\n                // Temporarily force enable enter PIP on task switch so that PIP is requested\n                // regardless of whether the activity is resumed or paused.\n                activity.supportsEnterPipOnTaskSwitch = true;\n                boolean canEnterPip = activity.checkEnterPictureInPictureState(\n                        \"applyTaskChanges\", true /* beforeStopping */);\n                if (canEnterPip) {\n                    canEnterPip = mService.mActivityClientController\n                            .requestPictureInPictureMode(activity);\n                }\n                if (!canEnterPip) {\n                    // Restore the flag to its previous state when the activity cannot enter PIP.\n                    activity.supportsEnterPipOnTaskSwitch = lastSupportsEnterPipOnTaskSwitch;\n                }\n            }\n        }\n\n        return effects;\n    }\n\n    private int applyDisplayAreaChanges(DisplayArea displayArea,\n            WindowContainerTransaction.Change c) {\n        final int[] effects = new int[1];\n        effects[0] = applyChanges(displayArea, c);\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_IGNORE_ORIENTATION_REQUEST) != 0) {\n            if (displayArea.setIgnoreOrientationRequest(c.getIgnoreOrientationRequest())) {\n                effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        displayArea.forAllTasks(task -> {\n            Task tr = (Task) task;\n            if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n                if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                    effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n        });\n\n        return effects[0];\n    }\n\n    private int applyTaskFragmentChanges(@NonNull TaskFragment taskFragment,\n            @NonNull WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        if (taskFragment.isEmbeddedTaskFragmentInPip()) {\n            // No override from organizer for embedded TaskFragment in a PIP Task.\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        // When the TaskFragment is resized, we may want to create a change transition for it, for\n        // which we want to defer the surface update until we determine whether or not to start\n        // change transition.\n        mTmpBounds0.set(taskFragment.getBounds());\n        mTmpBounds1.set(taskFragment.getRelativeEmbeddedBounds());\n        taskFragment.deferOrganizedTaskFragmentSurfaceUpdate();\n        final Rect relBounds = c.getRelativeBounds();\n        if (relBounds != null) {\n            // Make sure the requested bounds satisfied the min dimensions requirement.\n            adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(taskFragment, relBounds,\n                    errorCallbackToken);\n\n            // For embedded TaskFragment, the organizer set the bounds in parent coordinate to\n            // prevent flicker in case there is a racing condition between the parent bounds changed\n            // and the organizer request.\n            final Rect parentBounds = taskFragment.getParent().getBounds();\n            // Convert relative bounds to screen space.\n            final Rect absBounds = taskFragment.translateRelativeBoundsToAbsoluteBounds(relBounds,\n                    parentBounds);\n            c.getConfiguration().windowConfiguration.setBounds(absBounds);\n            taskFragment.setRelativeEmbeddedBounds(relBounds);\n        }\n        final int effects = applyChanges(taskFragment, c);\n        if (taskFragment.shouldStartChangeTransition(mTmpBounds0, mTmpBounds1)) {\n            taskFragment.initializeChangeTransition(mTmpBounds0);\n        }\n        taskFragment.continueOrganizedTaskFragmentSurfaceUpdate();\n        return effects;\n    }\n\n    /**\n     * Adjusts the requested relative bounds on {@link TaskFragment} to make sure it satisfies the\n     * activity min dimensions.\n     */\n    private void adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(\n            @NonNull TaskFragment taskFragment, @NonNull Rect inOutRelativeBounds,\n            @Nullable IBinder errorCallbackToken) {\n        if (inOutRelativeBounds.isEmpty()) {\n            return;\n        }\n        final Point minDimensions = taskFragment.calculateMinDimension();\n        if (inOutRelativeBounds.width() < minDimensions.x\n                || inOutRelativeBounds.height() < minDimensions.y) {\n            // Notify organizer about the request failure.\n            final Throwable exception = new SecurityException(\"The requested relative bounds:\"\n                    + inOutRelativeBounds + \" does not satisfy minimum dimensions:\"\n                    + minDimensions);\n            sendTaskFragmentOperationFailure(taskFragment.getTaskFragmentOrganizer(),\n                    errorCallbackToken, taskFragment, OP_TYPE_SET_RELATIVE_BOUNDS, exception);\n\n            // Reset to match parent bounds.\n            inOutRelativeBounds.setEmpty();\n        }\n    }\n\n    private int applyHierarchyOp(WindowContainerTransaction.HierarchyOp hop, int effects,\n            int syncId, @Nullable Transition transition, boolean isInLockTaskMode,\n            @NonNull CallerInfo caller, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable Transition finishTransition) {\n        final int type = hop.getType();\n        switch (type) {\n            case HIERARCHY_OP_TYPE_REMOVE_TASK: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || wc.asTask() == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to remove invalid task: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                task.remove(true, \"Applying remove task Hierarchy Op\");\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch root to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (task.getTaskDisplayArea() == null) {\n                    throw new IllegalArgumentException(\"Cannot set a task without display area as \"\n                            + \"launch root: \" + wc);\n                } else {\n                    task.getDisplayArea().setLaunchRootTask(task,\n                            hop.getWindowingModes(), hop.getActivityTypes());\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch adjacent to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                final boolean clearRoot = hop.getToTop();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-organized task as adjacent flag root: \" + wc);\n                } else if (task.getAdjacentTaskFragment() == null && !clearRoot) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-adjacent task as adjacent flag root: \" + wc);\n                }\n\n                task.getDisplayArea().setLaunchAdjacentFlagRootTask(clearRoot ? null : task);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS: {\n                effects |= setAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS: {\n                effects |= clearAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT: {\n                effects |= reparentChildrenTasksHierarchyOp(hop, transition, syncId,\n                        isInLockTaskMode);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_FINISH_ACTIVITY: {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(hop.getContainer());\n                if (activity == null || activity.finishing) {\n                    break;\n                }\n                if (activity.isVisible() || activity.isVisibleRequested()) {\n                    // Prevent the transition from being executed too early if the activity is\n                    // visible.\n                    activity.finishIfPossible(\"finish-activity-op\", false /* oomAdj */);\n                } else {\n                    activity.destroyIfPossible(\"finish-activity-op\");\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_LAUNCH_TASK: {\n                mService.mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                        \"launchTask HierarchyOp\");\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final int taskId = launchOpts.getInt(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                launchOpts.remove(WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(launchOpts, caller.mPid, caller.mUid);\n                waitAsyncStart(() -> mService.mTaskSupervisor.startActivityFromRecents(\n                        caller.mPid, caller.mUid, taskId, safeOptions));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REORDER:\n            case HIERARCHY_OP_TYPE_REPARENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    break;\n                }\n                // There is no use case to ask the reparent operation in lock-task mode now, so keep\n                // skipping this operation as usual.\n                if (isInLockTaskMode && type == HIERARCHY_OP_TYPE_REPARENT) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    break;\n                }\n                if (isLockTaskModeViolation(wc.getParent(), wc.asTask(), isInLockTaskMode)) {\n                    break;\n                }\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) {\n                    transition.collect(wc);\n                    if (hop.isReparent()) {\n                        if (wc.getParent() != null) {\n                            // Collect the current parent. It's visibility may change as\n                            // a result of this reparenting.\n                            transition.collect(wc.getParent());\n                        }\n                        if (hop.getNewParent() != null) {\n                            final WindowContainer parentWc =\n                                    WindowContainer.fromBinder(hop.getNewParent());\n                            if (parentWc == null) {\n                                Slog.e(TAG, \"Can't resolve parent window from token\");\n                                break;\n                            }\n                            transition.collect(parentWc);\n                        }\n                    }\n                }\n                effects |= sanitizeAndApplyHierarchyOp(wc, hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION: {\n                effects |= applyTaskFragmentOperation(hop, transition, isInLockTaskMode, caller,\n                        errorCallbackToken, organizer);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_PENDING_INTENT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                ActivityOptions activityOptions = launchOpts != null\n                        ? new ActivityOptions(launchOpts) : null;\n                if (activityOptions != null && activityOptions.getTransientLaunch()\n                        && mService.isCallerRecents(hop.getPendingIntent().getCreatorUid())) {\n                    if (mService.getActivityStartController().startExistingRecentsIfPossible(\n                            hop.getActivityIntent(), activityOptions)) {\n                        // Start recents successfully.\n                        break;\n                    }\n                }\n\n                String resolvedType = hop.getActivityIntent() != null\n                        ? hop.getActivityIntent().resolveTypeIfNeeded(\n                        mService.mContext.getContentResolver())\n                        : null;\n\n                if (hop.getPendingIntent().isActivity()) {\n                    // Set the context display id as preferred for this activity launches, so that\n                    // it can land on caller's display. Or just brought the task to front at the\n                    // display where it was on since it has higher preference.\n                    if (activityOptions == null) {\n                        activityOptions = ActivityOptions.makeBasic();\n                    }\n                    activityOptions.setCallerDisplayId(DEFAULT_DISPLAY);\n                }\n                final Bundle options = activityOptions != null ? activityOptions.toBundle() : null;\n                int res = waitAsyncStart(() -> mService.mAmInternal.sendIntentSender(\n                        hop.getPendingIntent().getTarget(),\n                        hop.getPendingIntent().getWhitelistToken(), 0 /* code */,\n                        hop.getActivityIntent(), resolvedType, null /* finishReceiver */,\n                        null /* requiredPermission */, options));\n                if (ActivityManager.isStartResultSuccessful(res)) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            default: {\n                // The other operations may change task order so they are skipped while in lock\n                // task mode. The above operations are still allowed because they don't move\n                // tasks. And it may be necessary such as clearing launch root after entering\n                // lock task mode.\n                if (isInLockTaskMode) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    return effects;\n                }\n            }\n        }\n\n        switch (type) {\n            case HIERARCHY_OP_TYPE_START_SHORTCUT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final String callingPackage = launchOpts.getString(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n                launchOpts.remove(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n\n                final LauncherAppsServiceInternal launcherApps = LocalServices.getService(\n                        LauncherAppsServiceInternal.class);\n\n                final boolean success = launcherApps.startShortcut(caller.mUid, caller.mPid,\n                        callingPackage, hop.getShortcutInfo().getPackage(), null /* featureId */,\n                        hop.getShortcutInfo().getId(), null /* sourceBounds */, launchOpts,\n                        hop.getShortcutInfo().getUserId());\n                if (success) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER: {\n                if (finishTransition == null) break;\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) break;\n                final Task thisTask = container.asActivityRecord() != null\n                        ? container.asActivityRecord().getTask() : container.asTask();\n                if (thisTask == null) break;\n                final Task restoreAt = finishTransition.getTransientLaunchRestoreTarget(container);\n                if (restoreAt == null) break;\n                final TaskDisplayArea taskDisplayArea = thisTask.getTaskDisplayArea();\n                taskDisplayArea.moveRootTaskBehindRootTask(thisTask.getRootTask(), restoreAt);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to add local insets source provider on unknown: \"\n                            + container);\n                    break;\n                }\n                container.addLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to remove local insets source provider from unknown: \"\n                                    + container);\n                    break;\n                }\n                container.removeLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null || container.asDisplayArea() == null\n                        || !container.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached display area: \"\n                            + container);\n                    break;\n                }\n                container.setAlwaysOnTop(hop.isAlwaysOnTop());\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = container != null ? container.asTask() : null;\n                if (task == null || !task.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \"\n                            + container);\n                    break;\n                }\n                if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-organized task : \" + task);\n                }\n                if (!task.isRootTask()) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-root task : \" + task);\n                }\n                task.setReparentLeafTaskIfRelaunch(hop.isReparentLeafTaskIfRelaunch());\n                break;\n            }\n        }\n        return effects;\n    }\n\n    /**\n     * Applies change set through {@link WindowContainerTransaction#addTaskFragmentOperation}.\n     * @return an int to represent the transaction effects, such as {@link #TRANSACT_EFFECTS_NONE},\n     *         {@link #TRANSACT_EFFECTS_LIFECYCLE} or {@link #TRANSACT_EFFECTS_CLIENT_CONFIG}.\n     */\n    private int applyTaskFragmentOperation(@NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, boolean isInLockTaskMode, @NonNull CallerInfo caller,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        if (!validateTaskFragmentOperation(hop, errorCallbackToken, organizer)) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final int opType = operation.getOpType();\n\n        int effects = TRANSACT_EFFECTS_NONE;\n        switch (opType) {\n            case OP_TYPE_CREATE_TASK_FRAGMENT: {\n                final TaskFragmentCreationParams taskFragmentCreationParams =\n                        operation.getTaskFragmentCreationParams();\n                if (taskFragmentCreationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentCreationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                createTaskFragment(taskFragmentCreationParams, errorCallbackToken, caller,\n                        transition);\n                break;\n            }\n            case OP_TYPE_DELETE_TASK_FRAGMENT: {\n                if (isInLockTaskMode) {\n                    final ActivityRecord bottomActivity = taskFragment.getActivity(\n                            a -> !a.finishing, false /* traverseTopToBottom */);\n                    if (bottomActivity != null\n                            && mService.getLockTaskController().activityBlockedFromFinish(\n                            bottomActivity)) {\n                        Slog.w(TAG, \"Skip removing TaskFragment due in lock task mode.\");\n                        sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                                taskFragment, opType, new IllegalStateException(\n                                        \"Not allow to delete task fragment in lock task mode.\"));\n                        break;\n                    }\n                }\n                effects |= deleteTaskFragment(taskFragment, transition);\n                break;\n            }\n            case OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT: {\n                final IBinder callerActivityToken = operation.getActivityToken();\n                final Intent activityIntent = operation.getActivityIntent();\n                final Bundle activityOptions = operation.getBundle();\n                final int result = mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, activityOptions,\n                                callerActivityToken, caller.mUid, caller.mPid,\n                                errorCallbackToken);\n                if (!isStartResultSuccessful(result)) {\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, convertStartFailureToThrowable(result, activityIntent));\n                } else {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT: {\n                final IBinder activityToken = operation.getActivityToken();\n                ActivityRecord activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    // The token may be a temporary token if the activity doesn't belong to\n                    // the organizer process.\n                    activity = mTaskFragmentOrganizerController\n                            .getReparentActivityFromTemporaryToken(organizer, activityToken);\n                }\n                if (activity == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED) {\n                    final Throwable exception = new SecurityException(\n                            \"The task fragment is not allowed to embed the given activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getTask() != activity.getTask()) {\n                    final Throwable exception = new SecurityException(\"The reparented activity is\"\n                            + \" not in the same Task as the target TaskFragment.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (transition != null) {\n                    transition.collect(activity);\n                    if (activity.getParent() != null) {\n                        // Collect the current parent. Its visibility may change as a result of\n                        // this reparenting.\n                        transition.collect(activity.getParent());\n                    }\n                    transition.collect(taskFragment);\n                }\n                activity.reparent(taskFragment, POSITION_TOP);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS: {\n                final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment secondaryTaskFragment =\n                        mLaunchTaskFragments.get(secondaryFragmentToken);\n                if (secondaryTaskFragment == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"SecondaryFragmentToken must be set for setAdjacentTaskFragments.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getAdjacentTaskFragment() != secondaryTaskFragment) {\n                    // Only have lifecycle effect if the adjacent changed.\n                    taskFragment.setAdjacentTaskFragment(secondaryTaskFragment);\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n\n                final Bundle bundle = hop.getLaunchOptions();\n                final WindowContainerTransaction.TaskFragmentAdjacentParams adjacentParams =\n                        bundle != null\n                                ? new WindowContainerTransaction.TaskFragmentAdjacentParams(bundle)\n                                : null;\n                taskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelayPrimaryLastActivityRemoval());\n                secondaryTaskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelaySecondaryLastActivityRemoval());\n                break;\n            }\n            case OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS: {\n                final TaskFragment adjacentTaskFragment = taskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFragment == null) {\n                    break;\n                }\n                taskFragment.resetAdjacentTaskFragment();\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n\n                // Clear the focused app if the focused app is no longer visible after reset the\n                // adjacent TaskFragments.\n                final ActivityRecord focusedApp = taskFragment.getDisplayContent().mFocusedApp;\n                final TaskFragment focusedTaskFragment = focusedApp != null\n                        ? focusedApp.getTaskFragment()\n                        : null;\n                if ((focusedTaskFragment == taskFragment\n                        || focusedTaskFragment == adjacentTaskFragment)\n                        && !focusedTaskFragment.shouldBeVisible(null /* starting */)) {\n                    focusedTaskFragment.getDisplayContent().setFocusedApp(null /* newFocus */);\n                }\n                break;\n            }\n            case OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT: {\n                final ActivityRecord curFocus = taskFragment.getDisplayContent().mFocusedApp;\n                if (curFocus != null && curFocus.getTaskFragment() == taskFragment) {\n                    Slog.d(TAG, \"The requested TaskFragment already has the focus.\");\n                    break;\n                }\n                if (curFocus != null && curFocus.getTask() != taskFragment.getTask()) {\n                    Slog.d(TAG, \"The Task of the requested TaskFragment doesn't have focus.\");\n                    break;\n                }\n                final ActivityRecord targetFocus = taskFragment.getTopResumedActivity();\n                if (targetFocus == null) {\n                    Slog.d(TAG, \"There is no resumed activity in the requested TaskFragment.\");\n                    break;\n                }\n                taskFragment.getDisplayContent().setFocusedApp(targetFocus);\n                break;\n            }\n            case OP_TYPE_SET_COMPANION_TASK_FRAGMENT: {\n                final IBinder companionFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment companionTaskFragment = companionFragmentToken != null\n                        ? mLaunchTaskFragments.get(companionFragmentToken)\n                        : null;\n                taskFragment.setCompanionTaskFragment(companionTaskFragment);\n                break;\n            }\n            case OP_TYPE_SET_ANIMATION_PARAMS: {\n                final TaskFragmentAnimationParams animationParams = operation.getAnimationParams();\n                if (animationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentAnimationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                taskFragment.setAnimationParams(animationParams);\n                break;\n            }\n        }\n        return effects;\n    }\n\n    private boolean validateTaskFragmentOperation(\n            @NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        if (operation == null) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"TaskFragmentOperation must be non-null\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    OP_TYPE_UNKNOWN, exception);\n            return false;\n        }\n        final int opType = operation.getOpType();\n        if (opType == OP_TYPE_CREATE_TASK_FRAGMENT) {\n            // No need to check TaskFragment.\n            return true;\n        }\n\n        if (!validateTaskFragment(taskFragment, opType, errorCallbackToken, organizer)) {\n            return false;\n        }\n\n        final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n        return secondaryFragmentToken == null\n                || validateTaskFragment(mLaunchTaskFragments.get(secondaryFragmentToken), opType,\n                errorCallbackToken, organizer);\n    }\n\n    private boolean validateTaskFragment(@Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer) {\n        if (taskFragment == null || !taskFragment.isAttached()) {\n            // TaskFragment doesn't exist.\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on invalid fragment tokens opType=\" + opType);\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        if (taskFragment.isEmbeddedTaskFragmentInPip()\n                && (opType != OP_TYPE_DELETE_TASK_FRAGMENT\n                // When the Task enters PiP before the organizer removes the empty TaskFragment, we\n                // should allow it to delete the TaskFragment for cleanup.\n                || taskFragment.getTopNonFinishingActivity() != null)) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on PIP TaskFragment\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Post and wait for the result of the activity start to prevent potential deadlock against\n     * {@link WindowManagerGlobalLock}.\n     */\n    private int waitAsyncStart(IntSupplier startActivity) {\n        final Integer[] starterResult = {null};\n        final Handler handler = (Looper.myLooper() == mService.mH.getLooper())\n                // uncommon case where a queued transaction is trying to start an activity. We can't\n                // post to our own thread and wait (otherwise we deadlock), so use anim thread\n                // instead (which is 1 higher priority).\n                ? mService.mWindowManager.mAnimationHandler\n                // Otherwise just put it on main handler\n                : mService.mH;\n        handler.post(() -> {\n            try {\n                starterResult[0] = startActivity.getAsInt();\n            } catch (Throwable t) {\n                starterResult[0] = ActivityManager.START_CANCELED;\n                Slog.w(TAG, t);\n            }\n            synchronized (mGlobalLock) {\n                mGlobalLock.notifyAll();\n            }\n        });\n        while (starterResult[0] == null) {\n            try {\n                mGlobalLock.wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        return starterResult[0];\n    }\n\n    private int sanitizeAndApplyHierarchyOp(WindowContainer container,\n            WindowContainerTransaction.HierarchyOp hop) {\n        final Task task = container.asTask();\n        if (task == null) {\n            throw new IllegalArgumentException(\"Invalid container in hierarchy op\");\n        }\n        final DisplayContent dc = task.getDisplayContent();\n        if (dc == null) {\n            Slog.w(TAG, \"Container is no longer attached: \" + task);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final Task as = task;\n\n        if (hop.isReparent()) {\n            final boolean isNonOrganizedRootableTask =\n                    task.isRootTask() || task.getParent().asTask().mCreatedByOrganizer;\n            if (isNonOrganizedRootableTask) {\n                WindowContainer newParent = hop.getNewParent() == null\n                        ? dc.getDefaultTaskDisplayArea()\n                        : WindowContainer.fromBinder(hop.getNewParent());\n                if (newParent == null) {\n                    Slog.e(TAG, \"Can't resolve parent window from token\");\n                    return TRANSACT_EFFECTS_NONE;\n                }\n                if (task.getParent() != newParent) {\n                    if (newParent.asTaskDisplayArea() != null) {\n                        // For now, reparenting to displayarea is different from other reparents...\n                        as.reparent(newParent.asTaskDisplayArea(), hop.getToTop());\n                    } else if (newParent.asTask() != null) {\n                        if (newParent.inMultiWindowMode() && task.isLeafTask()) {\n                            if (newParent.inPinnedWindowingMode()) {\n                                Slog.w(TAG, \"Can't support moving a task to another PIP window...\"\n                                        + \" newParent=\" + newParent + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                            if (!task.supportsMultiWindowInDisplayArea(\n                                    newParent.asTask().getDisplayArea())) {\n                                Slog.w(TAG, \"Can't support task that doesn't support multi-window\"\n                                        + \" mode in multi-window mode... newParent=\" + newParent\n                                        + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                        }\n                        task.reparent((Task) newParent,\n                                hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                                false /*moveParents*/, \"sanitizeAndApplyHierarchyOp\");\n                    } else {\n                        throw new RuntimeException(\"Can only reparent task to another task or\"\n                                + \" taskDisplayArea, but not \" + newParent);\n                    }\n                } else {\n                    final Task rootTask = (Task) (\n                            (newParent != null && !(newParent instanceof TaskDisplayArea))\n                                    ? newParent : task.getRootTask());\n                    as.getDisplayArea().positionChildAt(\n                            hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM, rootTask,\n                            false /* includingParents */);\n                }\n            } else {\n                throw new RuntimeException(\"Reparenting leaf Tasks is not supported now. \" + task);\n            }\n        } else {\n            task.getParent().positionChildAt(\n                    hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                    task, false /* includingParents */);\n        }\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private boolean isLockTaskModeViolation(WindowContainer parent, Task task,\n            boolean isInLockTaskMode) {\n        if (!isInLockTaskMode || parent == null || task == null) {\n            return false;\n        }\n        final LockTaskController lockTaskController = mService.getLockTaskController();\n        boolean taskViolation = lockTaskController.isLockTaskModeViolation(task);\n        if (!taskViolation && parent.asTask() != null) {\n            taskViolation = lockTaskController.isLockTaskModeViolation(parent.asTask());\n        }\n        if (taskViolation) {\n            Slog.w(TAG, \"Can't support the operation since in lock task mode violation. \"\n                    + \" Task: \" + task + \" Parent : \" + parent);\n        }\n        return taskViolation;\n    }\n\n    private int reparentChildrenTasksHierarchyOp(WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, int syncId, boolean isInLockTaskMode) {\n        WindowContainer<?> currentParent = hop.getContainer() != null\n                ? WindowContainer.fromBinder(hop.getContainer()) : null;\n        WindowContainer newParent = hop.getNewParent() != null\n                ? WindowContainer.fromBinder(hop.getNewParent()) : null;\n        if (currentParent == null && newParent == null) {\n            throw new IllegalArgumentException(\"reparentChildrenTasksHierarchyOp: \" + hop);\n        } else if (currentParent == null) {\n            currentParent = newParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        } else if (newParent == null) {\n            newParent = currentParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        }\n\n        if (currentParent == newParent) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp parent not changing: \" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!currentParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp currentParent detached=\"\n                    + currentParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!newParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent detached=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (newParent.inPinnedWindowingMode()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent in PIP=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        final boolean newParentInMultiWindow = newParent.inMultiWindowMode();\n        final TaskDisplayArea newParentTda = newParent.asTask() != null\n                ? newParent.asTask().getDisplayArea()\n                : newParent.asTaskDisplayArea();\n        final WindowContainer finalCurrentParent = currentParent;\n        final WindowContainer finalNewParent = newParent;\n        Slog.i(TAG, \"reparentChildrenTasksHierarchyOp\"\n                + \" currentParent=\" + currentParent + \" newParent=\" + newParent + \" hop=\" + hop);\n\n        // We want to collect the tasks first before re-parenting to avoid array shifting on us.\n        final ArrayList<Task> tasksToReparent = new ArrayList<>();\n\n        currentParent.forAllTasks(task -> {\n            Slog.i(TAG, \" Processing task=\" + task);\n            final boolean reparent;\n            if (task.mCreatedByOrganizer || task.getParent() != finalCurrentParent) {\n                // We only care about non-organized task that are direct children of the thing we\n                // are reparenting from.\n                return false;\n            }\n            if (newParentInMultiWindow && !task.supportsMultiWindowInDisplayArea(newParentTda)) {\n                Slog.e(TAG, \"reparentChildrenTasksHierarchyOp non-resizeable task to multi window,\"\n                        + \" task=\" + task);\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getActivityTypes())\n                    && !ArrayUtils.contains(hop.getActivityTypes(), task.getActivityType())) {\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getWindowingModes())\n                    && !ArrayUtils.contains(hop.getWindowingModes(), task.getWindowingMode())) {\n                return false;\n            }\n            if (isLockTaskModeViolation(finalNewParent, task, isInLockTaskMode)) {\n                return false;\n            }\n\n            if (hop.getToTop()) {\n                tasksToReparent.add(0, task);\n            } else {\n                tasksToReparent.add(task);\n            }\n            return hop.getReparentTopOnly() && tasksToReparent.size() == 1;\n        });\n\n        final int count = tasksToReparent.size();\n        for (int i = 0; i < count; ++i) {\n            final Task task = tasksToReparent.get(i);\n            if (syncId >= 0) {\n                addToSyncSet(syncId, task);\n            }\n            if (transition != null) transition.collect(task);\n\n            if (newParent instanceof TaskDisplayArea) {\n                // For now, reparenting to display area is different from other reparents...\n                task.reparent((TaskDisplayArea) newParent, hop.getToTop());\n            } else {\n                task.reparent((Task) newParent,\n                        hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                        false /*moveParents*/, \"processChildrenTaskReparentHierarchyOp\");\n            }\n        }\n\n        if (transition != null) transition.collect(newParent);\n\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int setAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root1 = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        final TaskFragment root2 =\n                WindowContainer.fromBinder(hop.getAdjacentRoot()).asTaskFragment();\n        if (!root1.mCreatedByOrganizer || !root2.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"setAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root1=\" + root1 + \" root2=\" + root2);\n        }\n        if (root1.getAdjacentTaskFragment() == root2) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root1.setAdjacentTaskFragment(root2);\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int clearAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        if (!root.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"clearAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root=\" + root);\n        }\n        if (root.getAdjacentTaskFragment() == null) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root.resetAdjacentTaskFragment();\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private void sanitizeWindowContainer(WindowContainer wc) {\n        if (!(wc instanceof TaskFragment) && !(wc instanceof DisplayArea)) {\n            throw new RuntimeException(\"Invalid token in task fragment or displayArea transaction\");\n        }\n    }\n\n    private int applyWindowContainerChange(WindowContainer wc,\n            WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        sanitizeWindowContainer(wc);\n        if (wc.asDisplayArea() != null) {\n            return applyDisplayAreaChanges(wc.asDisplayArea(), c);\n        } else if (wc.asTask() != null) {\n            return applyTaskChanges(wc.asTask(), c);\n        } else if (wc.asTaskFragment() != null && wc.asTaskFragment().isEmbedded()) {\n            return applyTaskFragmentChanges(wc.asTaskFragment(), c, errorCallbackToken);\n        } else {\n            return applyChanges(wc, c);\n        }\n    }\n\n    @Override\n    public ITaskOrganizerController getTaskOrganizerController() {\n        enforceTaskPermission(\"getTaskOrganizerController()\");\n        return mTaskOrganizerController;\n    }\n\n    @Override\n    public IDisplayAreaOrganizerController getDisplayAreaOrganizerController() {\n        enforceTaskPermission(\"getDisplayAreaOrganizerController()\");\n        return mDisplayAreaOrganizerController;\n    }\n\n    @Override\n    public ITaskFragmentOrganizerController getTaskFragmentOrganizerController() {\n        return mTaskFragmentOrganizerController;\n    }\n\n    /**\n     * This will prepare a {@link BLASTSyncEngine.SyncGroup} for the organizer to track, but the\n     * {@link BLASTSyncEngine.SyncGroup} may not be active until the {@link BLASTSyncEngine} is\n     * free.\n     */\n    private BLASTSyncEngine.SyncGroup prepareSyncWithOrganizer(\n            IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = mService.mWindowManager.mSyncEngine\n                .prepareSyncSet(this, \"Organizer\");\n        mTransactionCallbacksByPendingSyncId.put(s.mSyncId, callback);\n        return s;\n    }\n\n    @VisibleForTesting\n    int startSyncWithOrganizer(IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = prepareSyncWithOrganizer(callback);\n        mService.mWindowManager.mSyncEngine.startSyncSet(s);\n        return s.mSyncId;\n    }\n\n    @VisibleForTesting\n    void setSyncReady(int id) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Set sync ready, syncId=%d\", id);\n        mService.mWindowManager.mSyncEngine.setReady(id);\n    }\n\n    @VisibleForTesting\n    void addToSyncSet(int syncId, WindowContainer wc) {\n        mService.mWindowManager.mSyncEngine.addToSyncSet(syncId, wc);\n    }\n\n    @Override\n    public void onTransactionReady(int syncId, SurfaceControl.Transaction t) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Transaction ready, syncId=%d\", syncId);\n        final IWindowContainerTransactionCallback callback =\n                mTransactionCallbacksByPendingSyncId.get(syncId);\n\n        try {\n            callback.onTransactionReady(syncId, t);\n        } catch (RemoteException e) {\n            // If there's an exception when trying to send the mergedTransaction to the client, we\n            // should immediately apply it here so the transactions aren't lost.\n            t.apply();\n        }\n\n        mTransactionCallbacksByPendingSyncId.remove(syncId);\n    }\n\n    @Override\n    public void registerTransitionPlayer(ITransitionPlayer player) {\n        enforceTaskPermission(\"registerTransitionPlayer()\");\n        final int callerPid = Binder.getCallingPid();\n        final int callerUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final WindowProcessController wpc =\n                        mService.getProcessController(callerPid, callerUid);\n                mTransitionController.registerTransitionPlayer(player, wpc);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ITransitionMetricsReporter getTransitionMetricsReporter() {\n        return mTransitionController.mTransitionMetricsReporter;\n    }\n\n    @Override\n    public IBinder getApplyToken() {\n        enforceTaskPermission(\"getApplyToken()\");\n        return SurfaceControl.Transaction.getDefaultApplyToken();\n    }\n\n    /** Whether the configuration changes are important to report back to an organizer. */\n    static boolean configurationsAreEqualForOrganizer(\n            Configuration newConfig, @Nullable Configuration oldConfig) {\n        if (oldConfig == null) {\n            return false;\n        }\n        int cfgChanges = newConfig.diff(oldConfig);\n        final int winCfgChanges = (cfgChanges & ActivityInfo.CONFIG_WINDOW_CONFIGURATION) != 0\n                ? (int) newConfig.windowConfiguration.diff(oldConfig.windowConfiguration,\n                true /* compareUndefined */) : 0;\n        if ((winCfgChanges & CONTROLLABLE_WINDOW_CONFIGS) == 0) {\n            cfgChanges &= ~ActivityInfo.CONFIG_WINDOW_CONFIGURATION;\n        }\n        return (cfgChanges & CONTROLLABLE_CONFIGS) == 0;\n    }\n\n    /**\n     * Makes sure that the transaction only contains operations that are allowed for the\n     * {@link WindowContainerTransaction#getTaskFragmentOrganizer()}.\n     */\n    private void enforceTaskFragmentOrganizerPermission(@NonNull String func,\n            @NonNull ITaskFragmentOrganizer organizer, @NonNull WindowContainerTransaction t) {\n        // Configuration changes\n        final Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                t.getChanges().entrySet().iterator();\n        while (entries.hasNext()) {\n            final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n            final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n            enforceTaskFragmentConfigChangeAllowed(func, wc, entry.getValue(), organizer);\n        }\n\n        // Hierarchy changes\n        final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n        for (int i = hops.size() - 1; i >= 0; i--) {\n            final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n            final int type = hop.getType();\n            // Check for each type of the operations that are allowed for TaskFragmentOrganizer.\n            switch (type) {\n                case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION:\n                    enforceTaskFragmentOrganized(func, hop.getContainer(), organizer);\n                    if (hop.getTaskFragmentOperation() != null\n                            && hop.getTaskFragmentOperation().getSecondaryFragmentToken() != null) {\n                        enforceTaskFragmentOrganized(func,\n                                hop.getTaskFragmentOperation().getSecondaryFragmentToken(),\n                                organizer);\n                    }\n                    break;\n                case HIERARCHY_OP_TYPE_FINISH_ACTIVITY:\n                    // Allow finish activity if it has the activity token.\n                    break;\n                default:\n                    // Other types of hierarchy changes are not allowed.\n                    String msg = \"Permission Denial: \" + func + \" from pid=\"\n                            + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                            + \" trying to apply a hierarchy change that is not allowed for\"\n                            + \" TaskFragmentOrganizer=\" + organizer;\n                    Slog.w(TAG, msg);\n                    throw new SecurityException(msg);\n            }\n        }\n    }\n\n    /**\n     * Makes sure that the {@link TaskFragment} of the given fragment token is created and organized\n     * by the given {@link ITaskFragmentOrganizer}.\n     */\n    private void enforceTaskFragmentOrganized(@NonNull String func,\n            @NonNull IBinder fragmentToken, @NonNull ITaskFragmentOrganizer organizer) {\n        Objects.requireNonNull(fragmentToken);\n        final TaskFragment tf = mLaunchTaskFragments.get(fragmentToken);\n        // When the TaskFragment is {@code null}, it means that the TaskFragment will be created\n        // later in the same transaction, in which case it will always be organized by the given\n        // organizer.\n        if (tf != null && !tf.hasTaskFragmentOrganizer(organizer)) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify TaskFragment not\"\n                    + \" belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    /**\n     * For config change on {@link TaskFragment}, we only support the following operations:\n     * {@link WindowContainerTransaction#setRelativeBounds(WindowContainerToken, Rect)},\n     * {@link WindowContainerTransaction#setWindowingMode(WindowContainerToken, int)}.\n     */\n    private void enforceTaskFragmentConfigChangeAllowed(@NonNull String func,\n            @Nullable WindowContainer wc, @NonNull WindowContainerTransaction.Change change,\n            @NonNull ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on task fragment that no longer exists\");\n            return;\n        }\n        final TaskFragment tf = wc.asTaskFragment();\n        if (tf == null || !tf.hasTaskFragmentOrganizer(organizer)) {\n            // Only allow to apply changes to TaskFragment that is organized by this organizer.\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify window container\"\n                    + \" not belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n\n        final int changeMask = change.getChangeMask();\n        final int configSetMask = change.getConfigSetMask();\n        final int windowSetMask = change.getWindowSetMask();\n        if (changeMask == 0 && configSetMask == 0 && windowSetMask == 0\n                && change.getWindowingMode() >= 0) {\n            // The change contains only setWindowingMode, which is allowed.\n            return;\n        }\n        if (changeMask != CHANGE_RELATIVE_BOUNDS\n                || configSetMask != ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n                || windowSetMask != WindowConfiguration.WINDOW_CONFIG_BOUNDS) {\n            // None of the change should be requested from a TaskFragment organizer except\n            // setRelativeBounds and setWindowingMode.\n            // For setRelativeBounds, we don't need to check whether it is outside of the Task\n            // bounds, because it is possible that the Task is also resizing, for which we don't\n            // want to throw an exception. The bounds will be adjusted in\n            // TaskFragment#translateRelativeBoundsToAbsoluteBounds.\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply changes of changeMask=\" + changeMask\n                    + \" configSetMask=\" + configSetMask + \" windowSetMask=\" + windowSetMask\n                    + \" to TaskFragment=\" + tf + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private void createTaskFragment(@NonNull TaskFragmentCreationParams creationParams,\n            @Nullable IBinder errorCallbackToken, @NonNull CallerInfo caller,\n            @Nullable Transition transition) {\n        final ActivityRecord ownerActivity =\n                ActivityRecord.forTokenLocked(creationParams.getOwnerToken());\n        final ITaskFragmentOrganizer organizer = ITaskFragmentOrganizer.Stub.asInterface(\n                creationParams.getOrganizer().asBinder());\n\n        if (mLaunchTaskFragments.containsKey(creationParams.getFragmentToken())) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"TaskFragment token must be unique\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerActivity == null || ownerActivity.getTask() == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid ownerToken\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (!ownerActivity.isResizeable()) {\n            final IllegalArgumentException exception = new IllegalArgumentException(\"Not allowed\"\n                    + \" to operate with non-resizable owner Activity\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        // The ownerActivity has to belong to the same app as the target Task.\n        final Task ownerTask = ownerActivity.getTask();\n        if (ownerTask.effectiveUid != ownerActivity.getUid()\n                || ownerTask.effectiveUid != caller.mUid) {\n            final Throwable exception =\n                    new SecurityException(\"Not allowed to operate with the ownerToken while \"\n                            + \"the root activity of the target task belong to the different app\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerTask.inPinnedWindowingMode()) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to create TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        final TaskFragment taskFragment = new TaskFragment(mService,\n                creationParams.getFragmentToken(), true /* createdByOrganizer */);\n        // Set task fragment organizer immediately, since it might have to be notified about further\n        // actions.\n        taskFragment.setTaskFragmentOrganizer(creationParams.getOrganizer(),\n                ownerActivity.getUid(), ownerActivity.info.processName);\n        final int position;\n        if (creationParams.getPairedPrimaryFragmentToken() != null) {\n            // When there is a paired primary TaskFragment, we want to place the new TaskFragment\n            // right above the paired one to make sure there is no other window in between.\n            final TaskFragment pairedPrimaryTaskFragment = getTaskFragment(\n                    creationParams.getPairedPrimaryFragmentToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedPrimaryTaskFragment);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else if (creationParams.getPairedActivityToken() != null) {\n            // When there is a paired Activity, we want to place the new TaskFragment right above\n            // the paired Activity to make sure the Activity position is not changed after reparent.\n            final ActivityRecord pairedActivity = ActivityRecord.forTokenLocked(\n                    creationParams.getPairedActivityToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedActivity);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else {\n            position = POSITION_TOP;\n        }\n        ownerTask.addChild(taskFragment, position);\n        taskFragment.setWindowingMode(creationParams.getWindowingMode());\n        if (!creationParams.getInitialRelativeBounds().isEmpty()) {\n            // Set relative bounds instead of using setBounds. This will avoid unnecessary update in\n            // case the parent has resized since the last time parent info is sent to the organizer.\n            taskFragment.setRelativeEmbeddedBounds(creationParams.getInitialRelativeBounds());\n            // Recompute configuration as the bounds will be calculated based on relative bounds in\n            // TaskFragment#resolveOverrideConfiguration.\n            taskFragment.recomputeConfiguration();\n        }\n        mLaunchTaskFragments.put(creationParams.getFragmentToken(), taskFragment);\n\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n    }\n\n    private int deleteTaskFragment(@NonNull TaskFragment taskFragment,\n            @Nullable Transition transition) {\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n        taskFragment.remove(true /* withTransition */, \"deleteTaskFragment\");\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    @Nullable\n    TaskFragment getTaskFragment(IBinder tfToken) {\n        return mLaunchTaskFragments.get(tfToken);\n    }\n\n    void cleanUpEmbeddedTaskFragment(TaskFragment taskFragment) {\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n    }\n\n    static class CallerInfo {\n        final int mPid;\n        final int mUid;\n\n        CallerInfo() {\n            mPid = Binder.getCallingPid();\n            mUid = Binder.getCallingUid();\n        }\n    }\n\n    void sendTaskFragmentOperationFailure(@NonNull ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken, @Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @NonNull Throwable exception) {\n        if (organizer == null) {\n            throw new IllegalArgumentException(\"Not allowed to operate with invalid organizer\");\n        }\n        mService.mTaskFragmentOrganizerController\n                .onTaskFragmentError(organizer, errorCallbackToken, taskFragment, opType,\n                        exception);\n    }\n\n    private Throwable convertStartFailureToThrowable(int result, Intent intent) {\n        switch (result) {\n            case ActivityManager.START_INTENT_NOT_RESOLVED:\n            case ActivityManager.START_CLASS_NOT_FOUND:\n                return new ActivityNotFoundException(\"No Activity found to handle \" + intent);\n            case ActivityManager.START_PERMISSION_DENIED:\n                return new SecurityException(\"Permission denied and not allowed to start activity \"\n                        + intent);\n            case ActivityManager.START_CANCELED:\n                return new AndroidRuntimeException(\"Activity could not be started for \" + intent\n                        + \" with error code : \" + result);\n            default:\n                return new AndroidRuntimeException(\"Start activity failed with error code : \"\n                        + result + \" when starting \" + intent);\n        }\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.wm;\n\nimport static android.Manifest.permission.START_TASKS_FROM_RECENTS;\nimport static android.app.ActivityManager.isStartResultSuccessful;\nimport static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;\nimport static android.app.WindowConfiguration.WINDOW_CONFIG_BOUNDS;\nimport static android.view.Display.DEFAULT_DISPLAY;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_CREATE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_DELETE_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_ANIMATION_PARAMS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_COMPANION_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_SET_RELATIVE_BOUNDS;\nimport static android.window.TaskFragmentOperation.OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT;\nimport static android.window.TaskFragmentOperation.OP_TYPE_UNKNOWN;\nimport static android.window.WindowContainerTransaction.Change.CHANGE_RELATIVE_BOUNDS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_FINISH_ACTIVITY;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_LAUNCH_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_PENDING_INTENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REMOVE_TASK;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_REPARENT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH;\nimport static android.window.WindowContainerTransaction.HierarchyOp.HIERARCHY_OP_TYPE_START_SHORTCUT;\n\nimport static com.android.internal.protolog.ProtoLogGroup.WM_DEBUG_WINDOW_ORGANIZER;\nimport static com.android.server.wm.ActivityTaskManagerService.enforceTaskPermission;\nimport static com.android.server.wm.ActivityTaskSupervisor.PRESERVE_WINDOWS;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_PINNED_TASK;\nimport static com.android.server.wm.Task.FLAG_FORCE_HIDDEN_FOR_TASK_ORG;\nimport static com.android.server.wm.TaskFragment.EMBEDDING_ALLOWED;\nimport static com.android.server.wm.WindowContainer.POSITION_BOTTOM;\nimport static com.android.server.wm.WindowContainer.POSITION_TOP;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.WindowConfiguration;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Point;\nimport android.graphics.Rect;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.RemoteException;\nimport android.util.AndroidRuntimeException;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.Slog;\nimport android.view.RemoteAnimationAdapter;\nimport android.view.SurfaceControl;\nimport android.view.WindowManager;\nimport android.window.IDisplayAreaOrganizerController;\nimport android.window.ITaskFragmentOrganizer;\nimport android.window.ITaskFragmentOrganizerController;\nimport android.window.ITaskOrganizerController;\nimport android.window.ITransitionMetricsReporter;\nimport android.window.ITransitionPlayer;\nimport android.window.IWindowContainerTransactionCallback;\nimport android.window.IWindowOrganizerController;\nimport android.window.TaskFragmentAnimationParams;\nimport android.window.TaskFragmentCreationParams;\nimport android.window.TaskFragmentOperation;\nimport android.window.WindowContainerToken;\nimport android.window.WindowContainerTransaction;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.protolog.ProtoLogGroup;\nimport com.android.internal.protolog.common.ProtoLog;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.server.LocalServices;\nimport com.android.server.pm.LauncherAppsService.LauncherAppsServiceInternal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.IntSupplier;\n\n/**\n * Server side implementation for the interface for organizing windows\n * @see android.window.WindowOrganizer\n */\nclass WindowOrganizerController extends IWindowOrganizerController.Stub\n        implements BLASTSyncEngine.TransactionReadyListener {\n\n    private static final String TAG = \"WindowOrganizerController\";\n\n    private static final int TRANSACT_EFFECTS_NONE = 0;\n    /** Flag indicating that an applied transaction may have effected lifecycle */\n    private static final int TRANSACT_EFFECTS_CLIENT_CONFIG = 1;\n    private static final int TRANSACT_EFFECTS_LIFECYCLE = 1 << 1;\n\n    /**\n     * Masks specifying which configurations task-organizers can control. Incoming transactions\n     * will be filtered to only include these.\n     */\n    static final int CONTROLLABLE_CONFIGS = ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_SIZE\n            | ActivityInfo.CONFIG_LAYOUT_DIRECTION | ActivityInfo.CONFIG_DENSITY;\n    static final int CONTROLLABLE_WINDOW_CONFIGS = WINDOW_CONFIG_BOUNDS\n            | WindowConfiguration.WINDOW_CONFIG_APP_BOUNDS;\n\n    private final ActivityTaskManagerService mService;\n    private final WindowManagerGlobalLock mGlobalLock;\n\n    private final HashMap<Integer, IWindowContainerTransactionCallback>\n            mTransactionCallbacksByPendingSyncId = new HashMap();\n\n    final TaskOrganizerController mTaskOrganizerController;\n    final DisplayAreaOrganizerController mDisplayAreaOrganizerController;\n    final TaskFragmentOrganizerController mTaskFragmentOrganizerController;\n\n    final TransitionController mTransitionController;\n\n    /**\n     * A Map which manages the relationship between\n     * {@link TaskFragmentCreationParams#getFragmentToken()} and {@link TaskFragment}\n     */\n    @VisibleForTesting\n    final ArrayMap<IBinder, TaskFragment> mLaunchTaskFragments = new ArrayMap<>();\n\n    private final Rect mTmpBounds0 = new Rect();\n    private final Rect mTmpBounds1 = new Rect();\n\n    WindowOrganizerController(ActivityTaskManagerService atm) {\n        mService = atm;\n        mGlobalLock = atm.mGlobalLock;\n        mTaskOrganizerController = new TaskOrganizerController(mService);\n        mDisplayAreaOrganizerController = new DisplayAreaOrganizerController(mService);\n        mTaskFragmentOrganizerController = new TaskFragmentOrganizerController(atm, this);\n        mTransitionController = new TransitionController(atm);\n    }\n\n    TransitionController getTransitionController() {\n        return mTransitionController;\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            throw ActivityTaskManagerService.logAndRethrowRuntimeExceptionOnTransact(TAG, e);\n        }\n    }\n\n    @Override\n    public void applyTransaction(WindowContainerTransaction t) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applyTransaction\");\n        }\n        enforceTaskPermission(\"applyTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                applyTransaction(t, -1 /*syncId*/, null /*transition*/, caller);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int applySyncTransaction(WindowContainerTransaction t,\n            IWindowContainerTransactionCallback callback) {\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null transaction passed to applySyncTransaction\");\n        }\n        enforceTaskPermission(\"applySyncTransaction()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                if (callback == null) {\n                    applyTransaction(t, -1 /* syncId*/, null /*transition*/, caller);\n                    return -1;\n                }\n\n                /**\n                 * If callback is non-null we are looking to synchronize this transaction by\n                 * collecting all the results in to a SurfaceFlinger transaction and then delivering\n                 * that to the given transaction ready callback. See {@link BLASTSyncEngine} for the\n                 * details of the operation. But at a high level we create a sync operation with a\n                 * given ID and an associated callback. Then we notify each WindowContainer in this\n                 * WindowContainer transaction that it is participating in a sync operation with\n                 * that ID. Once everything is notified we tell the BLASTSyncEngine \"setSyncReady\"\n                 * which means that we have added everything to the set. At any point after this,\n                 * all the WindowContainers will eventually finish applying their changes and notify\n                 * the BLASTSyncEngine which will deliver the Transaction to the callback.\n                 */\n                final BLASTSyncEngine.SyncGroup syncGroup = prepareSyncWithOrganizer(callback);\n                final int syncId = syncGroup.mSyncId;\n                if (mTransitionController.isShellTransitionsEnabled()) {\n                    mTransitionController.startLegacySyncOrQueue(syncGroup, (deferred) -> {\n                        applyTransaction(t, syncId, null /* transition */, caller, deferred);\n                        setSyncReady(syncId);\n                    });\n                } else {\n                    if (!mService.mWindowManager.mSyncEngine.hasActiveSync()) {\n                        mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup);\n                        applyTransaction(t, syncId, null /*transition*/, caller);\n                        setSyncReady(syncId);\n                    } else {\n                        // Because the BLAST engine only supports one sync at a time, queue the\n                        // transaction.\n                        mService.mWindowManager.mSyncEngine.queueSyncSet(\n                                () -> mService.mWindowManager.mSyncEngine.startSyncSet(syncGroup),\n                                () -> {\n                                    applyTransaction(t, syncId, null /*transition*/, caller);\n                                    setSyncReady(syncId);\n                                });\n                    }\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public IBinder startNewTransition(int type, @Nullable WindowContainerTransaction t) {\n        return startTransition(type, null /* transitionToken */, t);\n    }\n\n    @Override\n    public void startTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t) {\n        startTransition(-1 /* unused type */, transitionToken, t);\n    }\n\n    private IBinder startTransition(@WindowManager.TransitionType int type,\n            @Nullable IBinder transitionToken, @Nullable WindowContainerTransaction t) {\n        enforceTaskPermission(\"startTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                Transition transition = Transition.fromBinder(transitionToken);\n                if (mTransitionController.getTransitionPlayer() == null && transition == null) {\n                    Slog.w(TAG, \"Using shell transitions API for legacy transitions.\");\n                    if (t == null) {\n                        throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                                + \" compatibility mode with no WCT.\");\n                    }\n                    applyTransaction(t, -1 /* syncId */, null, caller);\n                    return null;\n                }\n                final WindowContainerTransaction wct =\n                        t != null ? t : new WindowContainerTransaction();\n                if (transition == null) {\n                    if (type < 0) {\n                        throw new IllegalArgumentException(\"Can't create transition with no type\");\n                    }\n                    // This is a direct call from shell, so the entire transition lifecycle is\n                    // contained in the provided transaction if provided. Thus, we can setReady\n                    // immediately after apply.\n                    final boolean needsSetReady = t != null;\n                    final Transition nextTransition = new Transition(type, 0 /* flags */,\n                            mTransitionController, mService.mWindowManager.mSyncEngine);\n                    nextTransition.calcParallelCollectType(wct);\n                    mTransitionController.startCollectOrQueue(nextTransition,\n                            (deferred) -> {\n                                nextTransition.start();\n                                nextTransition.mLogger.mStartWCT = wct;\n                                applyTransaction(wct, -1 /* syncId */, nextTransition, caller,\n                                        deferred);\n                                if (needsSetReady) {\n                                    nextTransition.setAllReady();\n                                }\n                            });\n                    return nextTransition.getToken();\n                }\n                // The transition already started collecting before sending a request to shell,\n                // so just start here.\n                if (!transition.isCollecting() && !transition.isForcePlaying()) {\n                    Slog.e(TAG, \"Trying to start a transition that isn't collecting. This probably\"\n                            + \" means Shell took too long to respond to a request. WM State may be\"\n                            + \" incorrect now, please file a bug\");\n                    applyTransaction(wct, -1 /*syncId*/, null /*transition*/, caller);\n                    return transition.getToken();\n                }\n                transition.start();\n                transition.mLogger.mStartWCT = wct;\n                applyTransaction(wct, -1 /*syncId*/, transition, caller);\n                // Since the transition is already provided, it means WMCore is determining the\n                // \"readiness lifecycle\" outside the provided transaction, so don't set ready here.\n                return transition.getToken();\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public int startLegacyTransition(int type, @NonNull RemoteAnimationAdapter adapter,\n            @NonNull IWindowContainerTransactionCallback callback,\n            @NonNull WindowContainerTransaction t) {\n        enforceTaskPermission(\"startLegacyTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        int syncId;\n        try {\n            synchronized (mGlobalLock) {\n                if (type < 0) {\n                    throw new IllegalArgumentException(\"Can't create transition with no type\");\n                }\n                if (mTransitionController.getTransitionPlayer() != null) {\n                    throw new IllegalArgumentException(\"Can't use legacy transitions in\"\n                            + \" when shell transitions are enabled.\");\n                }\n                final DisplayContent dc =\n                        mService.mRootWindowContainer.getDisplayContent(DEFAULT_DISPLAY);\n                if (dc.mAppTransition.isTransitionSet()) {\n                    // a transition already exists, so the callback probably won't be called.\n                    return -1;\n                }\n                adapter.setCallingPidUid(caller.mPid, caller.mUid);\n                dc.prepareAppTransition(type);\n                dc.mAppTransition.overridePendingAppTransitionRemote(adapter, true /* sync */,\n                        false /* isActivityEmbedding */);\n                syncId = startSyncWithOrganizer(callback);\n                applyTransaction(t, syncId, null /* transition */, caller);\n                setSyncReady(syncId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return syncId;\n    }\n\n    @Override\n    public int finishTransition(@NonNull IBinder transitionToken,\n            @Nullable WindowContainerTransaction t,\n            @Nullable IWindowContainerTransactionCallback callback) {\n        enforceTaskPermission(\"finishTransition()\");\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                int syncId = -1;\n                if (t != null && callback != null) {\n                    syncId = startSyncWithOrganizer(callback);\n                }\n                final Transition transition = Transition.fromBinder(transitionToken);\n                // apply the incoming transaction before finish in case it alters the visibility\n                // of the participants.\n                if (t != null) {\n                    // Set the finishing transition before applyTransaction so the visibility\n                    // changes of the transition participants will only set visible-requested\n                    // and still let finishTransition handle the participants.\n                    mTransitionController.mFinishingTransition = transition;\n                    applyTransaction(t, syncId, null /*transition*/, caller, transition);\n                }\n                mTransitionController.finishTransition(transition);\n                mTransitionController.mFinishingTransition = null;\n                if (syncId >= 0) {\n                    setSyncReady(syncId);\n                }\n                return syncId;\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    /**\n     * Applies the {@link WindowContainerTransaction} as a request from\n     * {@link android.window.TaskFragmentOrganizer}.\n     *\n     * @param wct   {@link WindowContainerTransaction} to apply.\n     * @param type  {@link WindowManager.TransitionType} if it needs to start a new transition.\n     * @param shouldApplyIndependently  If {@code true}, the {@code wct} will request a new\n     *                                  transition, which will be queued until the sync engine is\n     *                                  free if there is any other active sync. If {@code false},\n     *                                  the {@code wct} will be directly applied to the active sync.\n     */\n    void applyTaskFragmentTransactionLocked(@NonNull WindowContainerTransaction wct,\n            @WindowManager.TransitionType int type, boolean shouldApplyIndependently) {\n        enforceTaskFragmentOrganizerPermission(\"applyTaskFragmentTransaction()\",\n                Objects.requireNonNull(wct.getTaskFragmentOrganizer()),\n                Objects.requireNonNull(wct));\n        final CallerInfo caller = new CallerInfo();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            if (mTransitionController.getTransitionPlayer() == null) {\n                // No need to worry about transition when Shell transition is not enabled.\n                applyTransaction(wct, -1 /* syncId */, null /* transition */, caller);\n                return;\n            }\n\n            if (mService.mWindowManager.mSyncEngine.hasActiveSync()\n                    && !shouldApplyIndependently) {\n                // Although there is an active sync, we want to apply the transaction now.\n                // TODO(b/232042367) Redesign the organizer update on activity callback so that we\n                // we will know about the transition explicitly.\n                final Transition transition = mTransitionController.getCollectingTransition();\n                if (transition == null) {\n                    // This should rarely happen, and we should try to avoid using\n                    // {@link #applySyncTransaction} with Shell transition.\n                    // We still want to apply and merge the transaction to the active sync\n                    // because {@code shouldApplyIndependently} is {@code false}.\n                    ProtoLog.w(ProtoLogGroup.WM_DEBUG_WINDOW_TRANSITIONS,\n                            \"TaskFragmentTransaction changes are not collected in transition\"\n                                    + \" because there is an ongoing sync for\"\n                                    + \" applySyncTransaction().\");\n                }\n                applyTransaction(wct, -1 /* syncId */, transition, caller);\n                return;\n            }\n\n            final Transition transition = new Transition(type, 0 /* flags */,\n                    mTransitionController, mService.mWindowManager.mSyncEngine);\n            TransitionController.OnStartCollect doApply = (deferred) -> {\n                if (deferred && !mTaskFragmentOrganizerController.isValidTransaction(wct)) {\n                    transition.abort();\n                    return;\n                }\n                if (applyTransaction(wct, -1 /* syncId */, transition, caller, deferred)\n                        == TRANSACT_EFFECTS_NONE && transition.mParticipants.isEmpty()) {\n                    transition.abort();\n                    return;\n                }\n                mTransitionController.requestStartTransition(transition, null /* startTask */,\n                        null /* remoteTransition */, null /* displayChange */);\n                transition.setAllReady();\n            };\n            mTransitionController.startCollectOrQueue(transition, doApply);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller) {\n        return applyTransaction(t, syncId, transition, caller, null /* finishTransition */);\n    }\n\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller, boolean deferred) {\n        if (deferred) {\n            try {\n                return applyTransaction(t, syncId, transition, caller);\n            } catch (RuntimeException e) {\n                // If the transaction is deferred, the caller could be from TransitionController\n                // #tryStartCollectFromQueue that executes on system's worker thread rather than\n                // binder thread. And the operation in the WCT may be outdated that violates the\n                // current state. So catch the exception to avoid crashing the system.\n                Slog.e(TAG, \"Failed to execute deferred applyTransaction\", e);\n            }\n            return TRANSACT_EFFECTS_NONE;\n        }\n        return applyTransaction(t, syncId, transition, caller);\n    }\n\n    /**\n     * @param syncId If non-null, this will be a sync-transaction.\n     * @param transition A transition to collect changes into.\n     * @param caller Info about the calling process.\n     * @param finishTransition The transition that is currently being finished.\n     * @return The effects of the window container transaction.\n     */\n    private int applyTransaction(@NonNull WindowContainerTransaction t, int syncId,\n            @Nullable Transition transition, @NonNull CallerInfo caller,\n            @Nullable Transition finishTransition) {\n        int effects = TRANSACT_EFFECTS_NONE;\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Apply window transaction, syncId=%d\", syncId);\n        mService.deferWindowLayout();\n        mService.mTaskSupervisor.setDeferRootVisibilityUpdate(true /* deferUpdate */);\n        try {\n            if (transition != null) {\n                transition.applyDisplayChangeIfNeeded();\n            }\n            final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n            final int hopSize = hops.size();\n            final ArraySet<WindowContainer<?>> haveConfigChanges = new ArraySet<>();\n            Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                    t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                // Make sure we add to the syncSet before performing\n                // operations so we don't end up splitting effects between the WM\n                // pending transaction and the BLASTSync transaction.\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) transition.collect(wc);\n\n                if ((entry.getValue().getChangeMask()\n                        & WindowContainerTransaction.Change.CHANGE_FORCE_NO_PIP) != 0) {\n                    // Disable entering pip (eg. when recents pretends to finish itself)\n                    if (finishTransition != null) {\n                        finishTransition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    } else if (transition != null) {\n                        transition.setCanPipOnFinish(false /* canPipOnFinish */);\n                    }\n                }\n                // A bit hacky, but we need to detect \"remove PiP\" so that we can \"wrap\" the\n                // setWindowingMode call in force-hidden.\n                boolean forceHiddenForPip = false;\n                if (wc.asTask() != null && wc.inPinnedWindowingMode()\n                        && entry.getValue().getWindowingMode() == WINDOWING_MODE_UNDEFINED) {\n                    // We are in pip and going to undefined. Now search hierarchy ops to determine\n                    // whether we are removing pip or expanding pip.\n                    for (int i = 0; i < hopSize; ++i) {\n                        final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n                        if (hop.getType() != HIERARCHY_OP_TYPE_REORDER) continue;\n                        final WindowContainer hopWc = WindowContainer.fromBinder(\n                                hop.getContainer());\n                        if (!wc.equals(hopWc)) continue;\n                        forceHiddenForPip = !hop.getToTop();\n                    }\n                }\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, true /* set */);\n                    // When removing pip, make sure that onStop is sent to the app ahead of\n                    // onPictureInPictureModeChanged.\n                    // See also PinnedStackTests#testStopBeforeMultiWindowCallbacksOnDismiss\n                    wc.asTask().ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                    wc.asTask().mTaskSupervisor.processStoppingAndFinishingActivities(\n                            null /* launchedActivity */, false /* processPausingActivities */,\n                            \"force-stop-on-removing-pip\");\n                }\n\n                int containerEffect = applyWindowContainerChange(wc, entry.getValue(),\n                        t.getErrorCallbackToken());\n                effects |= containerEffect;\n\n                if (forceHiddenForPip) {\n                    wc.asTask().setForceHidden(FLAG_FORCE_HIDDEN_FOR_PINNED_TASK, false /* set */);\n                }\n\n                // Lifecycle changes will trigger ensureConfig for everything.\n                if ((effects & TRANSACT_EFFECTS_LIFECYCLE) == 0\n                        && (containerEffect & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                    haveConfigChanges.add(wc);\n                }\n            }\n            // Hierarchy changes\n            if (hopSize > 0) {\n                final boolean isInLockTaskMode = mService.isInLockTaskMode();\n                for (int i = 0; i < hopSize; ++i) {\n                    effects |= applyHierarchyOp(hops.get(i), effects, syncId, transition,\n                            isInLockTaskMode, caller, t.getErrorCallbackToken(),\n                            t.getTaskFragmentOrganizer(), finishTransition);\n                }\n            }\n            // Queue-up bounds-change transactions for tasks which are now organized. Do\n            // this after hierarchy ops so we have the final organized state.\n            entries = t.getChanges().entrySet().iterator();\n            while (entries.hasNext()) {\n                final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n                final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    continue;\n                }\n                final Task task = wc.asTask();\n                final Rect surfaceBounds = entry.getValue().getBoundsChangeSurfaceBounds();\n                if (task == null || !task.isAttached() || surfaceBounds == null) {\n                    continue;\n                }\n                if (!task.isOrganized()) {\n                    final Task parent = task.getParent() != null ? task.getParent().asTask() : null;\n                    // Also allow direct children of created-by-organizer tasks to be\n                    // controlled. In the future, these will become organized anyways.\n                    if (parent == null || !parent.mCreatedByOrganizer) {\n                        throw new IllegalArgumentException(\n                                \"Can't manipulate non-organized task surface \" + task);\n                    }\n                }\n                final SurfaceControl.Transaction sft = new SurfaceControl.Transaction();\n                final SurfaceControl sc = task.getSurfaceControl();\n                sft.setPosition(sc, surfaceBounds.left, surfaceBounds.top);\n                if (surfaceBounds.isEmpty()) {\n                    sft.setWindowCrop(sc, null);\n                } else {\n                    sft.setWindowCrop(sc, surfaceBounds.width(), surfaceBounds.height());\n                }\n                task.setMainWindowSizeChangeTransaction(sft);\n            }\n            if ((effects & TRANSACT_EFFECTS_LIFECYCLE) != 0) {\n                mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n                // Already calls ensureActivityConfig\n                mService.mRootWindowContainer.ensureActivitiesVisible(null, 0, PRESERVE_WINDOWS);\n                mService.mRootWindowContainer.resumeFocusedTasksTopActivities();\n            } else if ((effects & TRANSACT_EFFECTS_CLIENT_CONFIG) != 0) {\n                for (int i = haveConfigChanges.size() - 1; i >= 0; --i) {\n                    haveConfigChanges.valueAt(i).forAllActivities(r -> {\n                        r.ensureActivityConfiguration(0, PRESERVE_WINDOWS);\n                    });\n                }\n            }\n\n            if (effects != 0) {\n                mService.mWindowManager.mWindowPlacerLocked.requestTraversal();\n            }\n        } finally {\n            mService.mTaskSupervisor.setDeferRootVisibilityUpdate(false /* deferUpdate */);\n            mService.continueWindowLayout();\n        }\n        return effects;\n    }\n\n    private int applyChanges(@NonNull WindowContainer<?> container,\n            @NonNull WindowContainerTransaction.Change change) {\n        // The \"client\"-facing API should prevent bad changes; however, just in case, sanitize\n        // masks here.\n        final int configMask = change.getConfigSetMask() & CONTROLLABLE_CONFIGS;\n        final int windowMask = change.getWindowSetMask() & CONTROLLABLE_WINDOW_CONFIGS;\n        int effects = TRANSACT_EFFECTS_NONE;\n        final int windowingMode = change.getWindowingMode();\n        if (configMask != 0) {\n            if (windowingMode > -1 && windowingMode != container.getWindowingMode()) {\n                // Special handling for when we are setting a windowingMode in the same transaction.\n                // Setting the windowingMode is going to call onConfigurationChanged so we don't\n                // need it called right now. Additionally, some logic requires everything in the\n                // configuration to change at the same time (ie. surface-freezer requires bounds\n                // and mode to change at the same time).\n                final Configuration c = container.getRequestedOverrideConfiguration();\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n            } else {\n                final Configuration c =\n                        new Configuration(container.getRequestedOverrideConfiguration());\n                c.setTo(change.getConfiguration(), configMask, windowMask);\n                container.onRequestedOverrideConfigurationChanged(c);\n            }\n            effects |= TRANSACT_EFFECTS_CLIENT_CONFIG;\n            if (windowMask != 0 && container.isEmbedded()) {\n                // Changing bounds of the embedded TaskFragments may result in lifecycle changes.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        if ((change.getChangeMask() & WindowContainerTransaction.Change.CHANGE_FOCUSABLE) != 0) {\n            if (container.setFocusable(change.getFocusable())) {\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if (windowingMode > -1) {\n            if (mService.isInLockTaskMode()\n                    && WindowConfiguration.inMultiWindowMode(windowingMode)) {\n                Slog.w(TAG, \"Dropping unsupported request to set multi-window windowing mode\"\n                        + \" during locked task mode.\");\n                return effects;\n            }\n\n            if (windowingMode == WindowConfiguration.WINDOWING_MODE_PINNED) {\n                // Do not directly put the container into PINNED mode as it may not support it or\n                // the app may not want to enter it. Instead, send a signal to request PIP\n                // mode to the app if they wish to support it below in #applyTaskChanges.\n                return effects;\n            }\n\n            final int prevMode = container.getRequestedOverrideWindowingMode();\n            container.setWindowingMode(windowingMode);\n            if (prevMode != container.getWindowingMode()) {\n                // The activity in the container may become focusable or non-focusable due to\n                // windowing modes changes (such as entering or leaving pinned windowing mode),\n                // so also apply the lifecycle effects to this transaction.\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n        return effects;\n    }\n\n    private int applyTaskChanges(Task tr, WindowContainerTransaction.Change c) {\n        int effects = applyChanges(tr, c);\n        final SurfaceControl.Transaction t = c.getBoundsChangeTransaction();\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n            if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                effects = TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_FORCE_TRANSLUCENT) != 0) {\n            tr.setForceTranslucent(c.getForceTranslucent());\n            effects = TRANSACT_EFFECTS_LIFECYCLE;\n        }\n\n        if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_DRAG_RESIZING) != 0) {\n            tr.setDragResizing(c.getDragResizing());\n        }\n\n        final int childWindowingMode = c.getActivityWindowingMode();\n        if (childWindowingMode > -1) {\n            tr.forAllActivities(a -> { a.setWindowingMode(childWindowingMode); });\n        }\n\n        if (t != null) {\n            tr.setMainWindowSizeChangeTransaction(t);\n        }\n\n        Rect enterPipBounds = c.getEnterPipBounds();\n        if (enterPipBounds != null) {\n            tr.mDisplayContent.mPinnedTaskController.setEnterPipBounds(enterPipBounds);\n        }\n\n        if (c.getWindowingMode() == WindowConfiguration.WINDOWING_MODE_PINNED\n                && !tr.inPinnedWindowingMode()) {\n            final ActivityRecord activity = tr.getTopNonFinishingActivity();\n            if (activity != null) {\n                final boolean lastSupportsEnterPipOnTaskSwitch =\n                        activity.supportsEnterPipOnTaskSwitch;\n                // Temporarily force enable enter PIP on task switch so that PIP is requested\n                // regardless of whether the activity is resumed or paused.\n                activity.supportsEnterPipOnTaskSwitch = true;\n                boolean canEnterPip = activity.checkEnterPictureInPictureState(\n                        \"applyTaskChanges\", true /* beforeStopping */);\n                if (canEnterPip) {\n                    canEnterPip = mService.mActivityClientController\n                            .requestPictureInPictureMode(activity);\n                }\n                if (!canEnterPip) {\n                    // Restore the flag to its previous state when the activity cannot enter PIP.\n                    activity.supportsEnterPipOnTaskSwitch = lastSupportsEnterPipOnTaskSwitch;\n                }\n            }\n        }\n\n        return effects;\n    }\n\n    private int applyDisplayAreaChanges(DisplayArea displayArea,\n            WindowContainerTransaction.Change c) {\n        final int[] effects = new int[1];\n        effects[0] = applyChanges(displayArea, c);\n\n        if ((c.getChangeMask()\n                & WindowContainerTransaction.Change.CHANGE_IGNORE_ORIENTATION_REQUEST) != 0) {\n            if (displayArea.setIgnoreOrientationRequest(c.getIgnoreOrientationRequest())) {\n                effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n            }\n        }\n\n        displayArea.forAllTasks(task -> {\n            Task tr = (Task) task;\n            if ((c.getChangeMask() & WindowContainerTransaction.Change.CHANGE_HIDDEN) != 0) {\n                if (tr.setForceHidden(FLAG_FORCE_HIDDEN_FOR_TASK_ORG, c.getHidden())) {\n                    effects[0] |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n            }\n        });\n\n        return effects[0];\n    }\n\n    private int applyTaskFragmentChanges(@NonNull TaskFragment taskFragment,\n            @NonNull WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        if (taskFragment.isEmbeddedTaskFragmentInPip()) {\n            // No override from organizer for embedded TaskFragment in a PIP Task.\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        // When the TaskFragment is resized, we may want to create a change transition for it, for\n        // which we want to defer the surface update until we determine whether or not to start\n        // change transition.\n        mTmpBounds0.set(taskFragment.getBounds());\n        mTmpBounds1.set(taskFragment.getRelativeEmbeddedBounds());\n        taskFragment.deferOrganizedTaskFragmentSurfaceUpdate();\n        final Rect relBounds = c.getRelativeBounds();\n        if (relBounds != null) {\n            // Make sure the requested bounds satisfied the min dimensions requirement.\n            adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(taskFragment, relBounds,\n                    errorCallbackToken);\n\n            // For embedded TaskFragment, the organizer set the bounds in parent coordinate to\n            // prevent flicker in case there is a racing condition between the parent bounds changed\n            // and the organizer request.\n            final Rect parentBounds = taskFragment.getParent().getBounds();\n            // Convert relative bounds to screen space.\n            final Rect absBounds = taskFragment.translateRelativeBoundsToAbsoluteBounds(relBounds,\n                    parentBounds);\n            c.getConfiguration().windowConfiguration.setBounds(absBounds);\n            taskFragment.setRelativeEmbeddedBounds(relBounds);\n        }\n        final int effects = applyChanges(taskFragment, c);\n        if (taskFragment.shouldStartChangeTransition(mTmpBounds0, mTmpBounds1)) {\n            taskFragment.initializeChangeTransition(mTmpBounds0);\n        }\n        taskFragment.continueOrganizedTaskFragmentSurfaceUpdate();\n        return effects;\n    }\n\n    /**\n     * Adjusts the requested relative bounds on {@link TaskFragment} to make sure it satisfies the\n     * activity min dimensions.\n     */\n    private void adjustTaskFragmentRelativeBoundsForMinDimensionsIfNeeded(\n            @NonNull TaskFragment taskFragment, @NonNull Rect inOutRelativeBounds,\n            @Nullable IBinder errorCallbackToken) {\n        if (inOutRelativeBounds.isEmpty()) {\n            return;\n        }\n        final Point minDimensions = taskFragment.calculateMinDimension();\n        if (inOutRelativeBounds.width() < minDimensions.x\n                || inOutRelativeBounds.height() < minDimensions.y) {\n            // Notify organizer about the request failure.\n            final Throwable exception = new SecurityException(\"The requested relative bounds:\"\n                    + inOutRelativeBounds + \" does not satisfy minimum dimensions:\"\n                    + minDimensions);\n            sendTaskFragmentOperationFailure(taskFragment.getTaskFragmentOrganizer(),\n                    errorCallbackToken, taskFragment, OP_TYPE_SET_RELATIVE_BOUNDS, exception);\n\n            // Reset to match parent bounds.\n            inOutRelativeBounds.setEmpty();\n        }\n    }\n\n    private int applyHierarchyOp(WindowContainerTransaction.HierarchyOp hop, int effects,\n            int syncId, @Nullable Transition transition, boolean isInLockTaskMode,\n            @NonNull CallerInfo caller, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer, @Nullable Transition finishTransition) {\n        final int type = hop.getType();\n        switch (type) {\n            case HIERARCHY_OP_TYPE_REMOVE_TASK: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || wc.asTask() == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to remove invalid task: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                task.remove(true, \"Applying remove task Hierarchy Op\");\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch root to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (task.getTaskDisplayArea() == null) {\n                    throw new IllegalArgumentException(\"Cannot set a task without display area as \"\n                            + \"launch root: \" + wc);\n                } else {\n                    task.getDisplayArea().setLaunchRootTask(task,\n                            hop.getWindowingModes(), hop.getActivityTypes());\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_LAUNCH_ADJACENT_FLAG_ROOT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to set launch adjacent to a detached container: \" + wc);\n                    break;\n                }\n                final Task task = wc.asTask();\n                final boolean clearRoot = hop.getToTop();\n                if (task == null) {\n                    throw new IllegalArgumentException(\"Cannot set non-task as launch root: \" + wc);\n                } else if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-organized task as adjacent flag root: \" + wc);\n                } else if (task.getAdjacentTaskFragment() == null && !clearRoot) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set non-adjacent task as adjacent flag root: \" + wc);\n                }\n\n                task.getDisplayArea().setLaunchAdjacentFlagRootTask(clearRoot ? null : task);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ADJACENT_ROOTS: {\n                effects |= setAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CLEAR_ADJACENT_ROOTS: {\n                effects |= clearAdjacentRootsHierarchyOp(hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_CHILDREN_TASKS_REPARENT: {\n                effects |= reparentChildrenTasksHierarchyOp(hop, transition, syncId,\n                        isInLockTaskMode);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_FINISH_ACTIVITY: {\n                final ActivityRecord activity = ActivityRecord.forTokenLocked(hop.getContainer());\n                if (activity == null || activity.finishing) {\n                    break;\n                }\n                if (activity.isVisible() || activity.isVisibleRequested()) {\n                    // Prevent the transition from being executed too early if the activity is\n                    // visible.\n                    activity.finishIfPossible(\"finish-activity-op\", false /* oomAdj */);\n                } else {\n                    activity.destroyIfPossible(\"finish-activity-op\");\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_LAUNCH_TASK: {\n                mService.mAmInternal.enforceCallingPermission(START_TASKS_FROM_RECENTS,\n                        \"launchTask HierarchyOp\");\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final int taskId = launchOpts.getInt(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                launchOpts.remove(WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_TASK_ID);\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(launchOpts, caller.mPid, caller.mUid);\n                waitAsyncStart(() -> mService.mTaskSupervisor.startActivityFromRecents(\n                        caller.mPid, caller.mUid, taskId, safeOptions));\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REORDER:\n            case HIERARCHY_OP_TYPE_REPARENT: {\n                final WindowContainer wc = WindowContainer.fromBinder(hop.getContainer());\n                if (wc == null || !wc.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on detached container: \" + wc);\n                    break;\n                }\n                // There is no use case to ask the reparent operation in lock-task mode now, so keep\n                // skipping this operation as usual.\n                if (isInLockTaskMode && type == HIERARCHY_OP_TYPE_REPARENT) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    break;\n                }\n                if (isLockTaskModeViolation(wc.getParent(), wc.asTask(), isInLockTaskMode)) {\n                    break;\n                }\n                if (syncId >= 0) {\n                    addToSyncSet(syncId, wc);\n                }\n                if (transition != null) {\n                    transition.collect(wc);\n                    if (hop.isReparent()) {\n                        if (wc.getParent() != null) {\n                            // Collect the current parent. It's visibility may change as\n                            // a result of this reparenting.\n                            transition.collect(wc.getParent());\n                        }\n                        if (hop.getNewParent() != null) {\n                            final WindowContainer parentWc =\n                                    WindowContainer.fromBinder(hop.getNewParent());\n                            if (parentWc == null) {\n                                Slog.e(TAG, \"Can't resolve parent window from token\");\n                                break;\n                            }\n                            transition.collect(parentWc);\n                        }\n                    }\n                }\n                effects |= sanitizeAndApplyHierarchyOp(wc, hop);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION: {\n                effects |= applyTaskFragmentOperation(hop, transition, isInLockTaskMode, caller,\n                        errorCallbackToken, organizer);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_PENDING_INTENT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                ActivityOptions activityOptions = launchOpts != null\n                        ? new ActivityOptions(launchOpts) : null;\n                if (activityOptions != null && activityOptions.getTransientLaunch()\n                        && mService.isCallerRecents(hop.getPendingIntent().getCreatorUid())) {\n                    if (mService.getActivityStartController().startExistingRecentsIfPossible(\n                            hop.getActivityIntent(), activityOptions)) {\n                        // Start recents successfully.\n                        break;\n                    }\n                }\n\n                String resolvedType = hop.getActivityIntent() != null\n                        ? hop.getActivityIntent().resolveTypeIfNeeded(\n                        mService.mContext.getContentResolver())\n                        : null;\n\n                if (hop.getPendingIntent().isActivity()) {\n                    // Set the context display id as preferred for this activity launches, so that\n                    // it can land on caller's display. Or just brought the task to front at the\n                    // display where it was on since it has higher preference.\n                    if (activityOptions == null) {\n                        activityOptions = ActivityOptions.makeBasic();\n                    }\n                    activityOptions.setCallerDisplayId(DEFAULT_DISPLAY);\n                }\n                final Bundle options = activityOptions != null ? activityOptions.toBundle() : null;\n                int res = waitAsyncStart(() -> mService.mAmInternal.sendIntentSender(\n                        hop.getPendingIntent().getTarget(),\n                        hop.getPendingIntent().getWhitelistToken(), 0 /* code */,\n                        hop.getActivityIntent(), resolvedType, null /* finishReceiver */,\n                        null /* requiredPermission */, options));\n                if (ActivityManager.isStartResultSuccessful(res)) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            default: {\n                // The other operations may change task order so they are skipped while in lock\n                // task mode. The above operations are still allowed because they don't move\n                // tasks. And it may be necessary such as clearing launch root after entering\n                // lock task mode.\n                if (isInLockTaskMode) {\n                    Slog.w(TAG, \"Skip applying hierarchy operation \" + hop\n                            + \" while in lock task mode\");\n                    return effects;\n                }\n            }\n        }\n\n        switch (type) {\n            case HIERARCHY_OP_TYPE_START_SHORTCUT: {\n                final Bundle launchOpts = hop.getLaunchOptions();\n                final String callingPackage = launchOpts.getString(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n                launchOpts.remove(\n                        WindowContainerTransaction.HierarchyOp.LAUNCH_KEY_SHORTCUT_CALLING_PACKAGE);\n\n                final LauncherAppsServiceInternal launcherApps = LocalServices.getService(\n                        LauncherAppsServiceInternal.class);\n\n                final boolean success = launcherApps.startShortcut(caller.mUid, caller.mPid,\n                        callingPackage, hop.getShortcutInfo().getPackage(), null /* featureId */,\n                        hop.getShortcutInfo().getId(), null /* sourceBounds */, launchOpts,\n                        hop.getShortcutInfo().getUserId());\n                if (success) {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case HIERARCHY_OP_TYPE_RESTORE_TRANSIENT_ORDER: {\n                if (finishTransition == null) break;\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) break;\n                final Task thisTask = container.asActivityRecord() != null\n                        ? container.asActivityRecord().getTask() : container.asTask();\n                if (thisTask == null) break;\n                final Task restoreAt = finishTransition.getTransientLaunchRestoreTarget(container);\n                if (restoreAt == null) break;\n                final TaskDisplayArea taskDisplayArea = thisTask.getTaskDisplayArea();\n                taskDisplayArea.moveRootTaskBehindRootTask(thisTask.getRootTask(), restoreAt);\n                break;\n            }\n            case HIERARCHY_OP_TYPE_ADD_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to add local insets source provider on unknown: \"\n                            + container);\n                    break;\n                }\n                container.addLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_REMOVE_INSETS_FRAME_PROVIDER: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null) {\n                    Slog.e(TAG, \"Attempt to remove local insets source provider from unknown: \"\n                                    + container);\n                    break;\n                }\n                container.removeLocalInsetsFrameProvider(hop.getInsetsFrameProvider());\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_ALWAYS_ON_TOP: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                if (container == null || container.asDisplayArea() == null\n                        || !container.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached display area: \"\n                            + container);\n                    break;\n                }\n                container.setAlwaysOnTop(hop.isAlwaysOnTop());\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case HIERARCHY_OP_TYPE_SET_REPARENT_LEAF_TASK_IF_RELAUNCH: {\n                final WindowContainer container = WindowContainer.fromBinder(hop.getContainer());\n                final Task task = container != null ? container.asTask() : null;\n                if (task == null || !task.isAttached()) {\n                    Slog.e(TAG, \"Attempt to operate on unknown or detached container: \"\n                            + container);\n                    break;\n                }\n                if (!task.mCreatedByOrganizer) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-organized task : \" + task);\n                }\n                if (!task.isRootTask()) {\n                    throw new UnsupportedOperationException(\n                            \"Cannot set reparent leaf task flag on non-root task : \" + task);\n                }\n                task.setReparentLeafTaskIfRelaunch(hop.isReparentLeafTaskIfRelaunch());\n                break;\n            }\n        }\n        return effects;\n    }\n\n    /**\n     * Applies change set through {@link WindowContainerTransaction#addTaskFragmentOperation}.\n     * @return an int to represent the transaction effects, such as {@link #TRANSACT_EFFECTS_NONE},\n     *         {@link #TRANSACT_EFFECTS_LIFECYCLE} or {@link #TRANSACT_EFFECTS_CLIENT_CONFIG}.\n     */\n    private int applyTaskFragmentOperation(@NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, boolean isInLockTaskMode, @NonNull CallerInfo caller,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        if (!validateTaskFragmentOperation(hop, errorCallbackToken, organizer)) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final int opType = operation.getOpType();\n\n        int effects = TRANSACT_EFFECTS_NONE;\n        switch (opType) {\n            case OP_TYPE_CREATE_TASK_FRAGMENT: {\n                final TaskFragmentCreationParams taskFragmentCreationParams =\n                        operation.getTaskFragmentCreationParams();\n                if (taskFragmentCreationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentCreationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                createTaskFragment(taskFragmentCreationParams, errorCallbackToken, caller,\n                        transition);\n                break;\n            }\n            case OP_TYPE_DELETE_TASK_FRAGMENT: {\n                if (isInLockTaskMode) {\n                    final ActivityRecord bottomActivity = taskFragment.getActivity(\n                            a -> !a.finishing, false /* traverseTopToBottom */);\n                    if (bottomActivity != null\n                            && mService.getLockTaskController().activityBlockedFromFinish(\n                            bottomActivity)) {\n                        Slog.w(TAG, \"Skip removing TaskFragment due in lock task mode.\");\n                        sendTaskFragmentOperationFailure(organizer, errorCallbackToken,\n                                taskFragment, opType, new IllegalStateException(\n                                        \"Not allow to delete task fragment in lock task mode.\"));\n                        break;\n                    }\n                }\n                effects |= deleteTaskFragment(taskFragment, transition);\n                break;\n            }\n            case OP_TYPE_START_ACTIVITY_IN_TASK_FRAGMENT: {\n                final IBinder callerActivityToken = operation.getActivityToken();\n                final Intent activityIntent = operation.getActivityIntent();\n                final Bundle activityOptions = operation.getBundle();\n                final SafeActivityOptions safeOptions =\n                        SafeActivityOptions.fromBundle(activityOptions, caller.mPid, caller.mUid);\n                final int result = mService.getActivityStartController()\n                        .startActivityInTaskFragment(taskFragment, activityIntent, safeOptions,\n                                callerActivityToken, caller.mUid, caller.mPid,\n                                errorCallbackToken);\n                if (!isStartResultSuccessful(result)) {\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, convertStartFailureToThrowable(result, activityIntent));\n                } else {\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n                break;\n            }\n            case OP_TYPE_REPARENT_ACTIVITY_TO_TASK_FRAGMENT: {\n                final IBinder activityToken = operation.getActivityToken();\n                ActivityRecord activity = ActivityRecord.forTokenLocked(activityToken);\n                if (activity == null) {\n                    // The token may be a temporary token if the activity doesn't belong to\n                    // the organizer process.\n                    activity = mTaskFragmentOrganizerController\n                            .getReparentActivityFromTemporaryToken(organizer, activityToken);\n                }\n                if (activity == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"Not allowed to operate with invalid activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.isAllowedToEmbedActivity(activity) != EMBEDDING_ALLOWED) {\n                    final Throwable exception = new SecurityException(\n                            \"The task fragment is not allowed to embed the given activity.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getTask() != activity.getTask()) {\n                    final Throwable exception = new SecurityException(\"The reparented activity is\"\n                            + \" not in the same Task as the target TaskFragment.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (transition != null) {\n                    transition.collect(activity);\n                    if (activity.getParent() != null) {\n                        // Collect the current parent. Its visibility may change as a result of\n                        // this reparenting.\n                        transition.collect(activity.getParent());\n                    }\n                    transition.collect(taskFragment);\n                }\n                activity.reparent(taskFragment, POSITION_TOP);\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                break;\n            }\n            case OP_TYPE_SET_ADJACENT_TASK_FRAGMENTS: {\n                final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment secondaryTaskFragment =\n                        mLaunchTaskFragments.get(secondaryFragmentToken);\n                if (secondaryTaskFragment == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"SecondaryFragmentToken must be set for setAdjacentTaskFragments.\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                if (taskFragment.getAdjacentTaskFragment() != secondaryTaskFragment) {\n                    // Only have lifecycle effect if the adjacent changed.\n                    taskFragment.setAdjacentTaskFragment(secondaryTaskFragment);\n                    effects |= TRANSACT_EFFECTS_LIFECYCLE;\n                }\n\n                final Bundle bundle = hop.getLaunchOptions();\n                final WindowContainerTransaction.TaskFragmentAdjacentParams adjacentParams =\n                        bundle != null\n                                ? new WindowContainerTransaction.TaskFragmentAdjacentParams(bundle)\n                                : null;\n                taskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelayPrimaryLastActivityRemoval());\n                secondaryTaskFragment.setDelayLastActivityRemoval(adjacentParams != null\n                        && adjacentParams.shouldDelaySecondaryLastActivityRemoval());\n                break;\n            }\n            case OP_TYPE_CLEAR_ADJACENT_TASK_FRAGMENTS: {\n                final TaskFragment adjacentTaskFragment = taskFragment.getAdjacentTaskFragment();\n                if (adjacentTaskFragment == null) {\n                    break;\n                }\n                taskFragment.resetAdjacentTaskFragment();\n                effects |= TRANSACT_EFFECTS_LIFECYCLE;\n\n                // Clear the focused app if the focused app is no longer visible after reset the\n                // adjacent TaskFragments.\n                final ActivityRecord focusedApp = taskFragment.getDisplayContent().mFocusedApp;\n                final TaskFragment focusedTaskFragment = focusedApp != null\n                        ? focusedApp.getTaskFragment()\n                        : null;\n                if ((focusedTaskFragment == taskFragment\n                        || focusedTaskFragment == adjacentTaskFragment)\n                        && !focusedTaskFragment.shouldBeVisible(null /* starting */)) {\n                    focusedTaskFragment.getDisplayContent().setFocusedApp(null /* newFocus */);\n                }\n                break;\n            }\n            case OP_TYPE_REQUEST_FOCUS_ON_TASK_FRAGMENT: {\n                final ActivityRecord curFocus = taskFragment.getDisplayContent().mFocusedApp;\n                if (curFocus != null && curFocus.getTaskFragment() == taskFragment) {\n                    Slog.d(TAG, \"The requested TaskFragment already has the focus.\");\n                    break;\n                }\n                if (curFocus != null && curFocus.getTask() != taskFragment.getTask()) {\n                    Slog.d(TAG, \"The Task of the requested TaskFragment doesn't have focus.\");\n                    break;\n                }\n                final ActivityRecord targetFocus = taskFragment.getTopResumedActivity();\n                if (targetFocus == null) {\n                    Slog.d(TAG, \"There is no resumed activity in the requested TaskFragment.\");\n                    break;\n                }\n                taskFragment.getDisplayContent().setFocusedApp(targetFocus);\n                break;\n            }\n            case OP_TYPE_SET_COMPANION_TASK_FRAGMENT: {\n                final IBinder companionFragmentToken = operation.getSecondaryFragmentToken();\n                final TaskFragment companionTaskFragment = companionFragmentToken != null\n                        ? mLaunchTaskFragments.get(companionFragmentToken)\n                        : null;\n                taskFragment.setCompanionTaskFragment(companionTaskFragment);\n                break;\n            }\n            case OP_TYPE_SET_ANIMATION_PARAMS: {\n                final TaskFragmentAnimationParams animationParams = operation.getAnimationParams();\n                if (animationParams == null) {\n                    final Throwable exception = new IllegalArgumentException(\n                            \"TaskFragmentAnimationParams must be non-null\");\n                    sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                            opType, exception);\n                    break;\n                }\n                taskFragment.setAnimationParams(animationParams);\n                break;\n            }\n        }\n        return effects;\n    }\n\n    private boolean validateTaskFragmentOperation(\n            @NonNull WindowContainerTransaction.HierarchyOp hop,\n            @Nullable IBinder errorCallbackToken, @Nullable ITaskFragmentOrganizer organizer) {\n        final TaskFragmentOperation operation = hop.getTaskFragmentOperation();\n        final IBinder fragmentToken = hop.getContainer();\n        final TaskFragment taskFragment = mLaunchTaskFragments.get(fragmentToken);\n        if (operation == null) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"TaskFragmentOperation must be non-null\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    OP_TYPE_UNKNOWN, exception);\n            return false;\n        }\n        final int opType = operation.getOpType();\n        if (opType == OP_TYPE_CREATE_TASK_FRAGMENT) {\n            // No need to check TaskFragment.\n            return true;\n        }\n\n        if (!validateTaskFragment(taskFragment, opType, errorCallbackToken, organizer)) {\n            return false;\n        }\n\n        final IBinder secondaryFragmentToken = operation.getSecondaryFragmentToken();\n        return secondaryFragmentToken == null\n                || validateTaskFragment(mLaunchTaskFragments.get(secondaryFragmentToken), opType,\n                errorCallbackToken, organizer);\n    }\n\n    private boolean validateTaskFragment(@Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @Nullable IBinder errorCallbackToken,\n            @Nullable ITaskFragmentOrganizer organizer) {\n        if (taskFragment == null || !taskFragment.isAttached()) {\n            // TaskFragment doesn't exist.\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on invalid fragment tokens opType=\" + opType);\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        if (taskFragment.isEmbeddedTaskFragmentInPip()\n                && (opType != OP_TYPE_DELETE_TASK_FRAGMENT\n                // When the Task enters PiP before the organizer removes the empty TaskFragment, we\n                // should allow it to delete the TaskFragment for cleanup.\n                || taskFragment.getTopNonFinishingActivity() != null)) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to apply operation on PIP TaskFragment\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, taskFragment,\n                    opType, exception);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Post and wait for the result of the activity start to prevent potential deadlock against\n     * {@link WindowManagerGlobalLock}.\n     */\n    private int waitAsyncStart(IntSupplier startActivity) {\n        final Integer[] starterResult = {null};\n        final Handler handler = (Looper.myLooper() == mService.mH.getLooper())\n                // uncommon case where a queued transaction is trying to start an activity. We can't\n                // post to our own thread and wait (otherwise we deadlock), so use anim thread\n                // instead (which is 1 higher priority).\n                ? mService.mWindowManager.mAnimationHandler\n                // Otherwise just put it on main handler\n                : mService.mH;\n        handler.post(() -> {\n            try {\n                starterResult[0] = startActivity.getAsInt();\n            } catch (Throwable t) {\n                starterResult[0] = ActivityManager.START_CANCELED;\n                Slog.w(TAG, t);\n            }\n            synchronized (mGlobalLock) {\n                mGlobalLock.notifyAll();\n            }\n        });\n        while (starterResult[0] == null) {\n            try {\n                mGlobalLock.wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        return starterResult[0];\n    }\n\n    private int sanitizeAndApplyHierarchyOp(WindowContainer container,\n            WindowContainerTransaction.HierarchyOp hop) {\n        final Task task = container.asTask();\n        if (task == null) {\n            throw new IllegalArgumentException(\"Invalid container in hierarchy op\");\n        }\n        final DisplayContent dc = task.getDisplayContent();\n        if (dc == null) {\n            Slog.w(TAG, \"Container is no longer attached: \" + task);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        final Task as = task;\n\n        if (hop.isReparent()) {\n            final boolean isNonOrganizedRootableTask =\n                    task.isRootTask() || task.getParent().asTask().mCreatedByOrganizer;\n            if (isNonOrganizedRootableTask) {\n                WindowContainer newParent = hop.getNewParent() == null\n                        ? dc.getDefaultTaskDisplayArea()\n                        : WindowContainer.fromBinder(hop.getNewParent());\n                if (newParent == null) {\n                    Slog.e(TAG, \"Can't resolve parent window from token\");\n                    return TRANSACT_EFFECTS_NONE;\n                }\n                if (task.getParent() != newParent) {\n                    if (newParent.asTaskDisplayArea() != null) {\n                        // For now, reparenting to displayarea is different from other reparents...\n                        as.reparent(newParent.asTaskDisplayArea(), hop.getToTop());\n                    } else if (newParent.asTask() != null) {\n                        if (newParent.inMultiWindowMode() && task.isLeafTask()) {\n                            if (newParent.inPinnedWindowingMode()) {\n                                Slog.w(TAG, \"Can't support moving a task to another PIP window...\"\n                                        + \" newParent=\" + newParent + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                            if (!task.supportsMultiWindowInDisplayArea(\n                                    newParent.asTask().getDisplayArea())) {\n                                Slog.w(TAG, \"Can't support task that doesn't support multi-window\"\n                                        + \" mode in multi-window mode... newParent=\" + newParent\n                                        + \" task=\" + task);\n                                return TRANSACT_EFFECTS_NONE;\n                            }\n                        }\n                        task.reparent((Task) newParent,\n                                hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                                false /*moveParents*/, \"sanitizeAndApplyHierarchyOp\");\n                    } else {\n                        throw new RuntimeException(\"Can only reparent task to another task or\"\n                                + \" taskDisplayArea, but not \" + newParent);\n                    }\n                } else {\n                    final Task rootTask = (Task) (\n                            (newParent != null && !(newParent instanceof TaskDisplayArea))\n                                    ? newParent : task.getRootTask());\n                    as.getDisplayArea().positionChildAt(\n                            hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM, rootTask,\n                            false /* includingParents */);\n                }\n            } else {\n                throw new RuntimeException(\"Reparenting leaf Tasks is not supported now. \" + task);\n            }\n        } else {\n            task.getParent().positionChildAt(\n                    hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                    task, false /* includingParents */);\n        }\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private boolean isLockTaskModeViolation(WindowContainer parent, Task task,\n            boolean isInLockTaskMode) {\n        if (!isInLockTaskMode || parent == null || task == null) {\n            return false;\n        }\n        final LockTaskController lockTaskController = mService.getLockTaskController();\n        boolean taskViolation = lockTaskController.isLockTaskModeViolation(task);\n        if (!taskViolation && parent.asTask() != null) {\n            taskViolation = lockTaskController.isLockTaskModeViolation(parent.asTask());\n        }\n        if (taskViolation) {\n            Slog.w(TAG, \"Can't support the operation since in lock task mode violation. \"\n                    + \" Task: \" + task + \" Parent : \" + parent);\n        }\n        return taskViolation;\n    }\n\n    private int reparentChildrenTasksHierarchyOp(WindowContainerTransaction.HierarchyOp hop,\n            @Nullable Transition transition, int syncId, boolean isInLockTaskMode) {\n        WindowContainer<?> currentParent = hop.getContainer() != null\n                ? WindowContainer.fromBinder(hop.getContainer()) : null;\n        WindowContainer newParent = hop.getNewParent() != null\n                ? WindowContainer.fromBinder(hop.getNewParent()) : null;\n        if (currentParent == null && newParent == null) {\n            throw new IllegalArgumentException(\"reparentChildrenTasksHierarchyOp: \" + hop);\n        } else if (currentParent == null) {\n            currentParent = newParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        } else if (newParent == null) {\n            newParent = currentParent.asTask().getDisplayContent().getDefaultTaskDisplayArea();\n        }\n\n        if (currentParent == newParent) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp parent not changing: \" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!currentParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp currentParent detached=\"\n                    + currentParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (!newParent.isAttached()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent detached=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n        if (newParent.inPinnedWindowingMode()) {\n            Slog.e(TAG, \"reparentChildrenTasksHierarchyOp newParent in PIP=\"\n                    + newParent + \" hop=\" + hop);\n            return TRANSACT_EFFECTS_NONE;\n        }\n\n        final boolean newParentInMultiWindow = newParent.inMultiWindowMode();\n        final TaskDisplayArea newParentTda = newParent.asTask() != null\n                ? newParent.asTask().getDisplayArea()\n                : newParent.asTaskDisplayArea();\n        final WindowContainer finalCurrentParent = currentParent;\n        final WindowContainer finalNewParent = newParent;\n        Slog.i(TAG, \"reparentChildrenTasksHierarchyOp\"\n                + \" currentParent=\" + currentParent + \" newParent=\" + newParent + \" hop=\" + hop);\n\n        // We want to collect the tasks first before re-parenting to avoid array shifting on us.\n        final ArrayList<Task> tasksToReparent = new ArrayList<>();\n\n        currentParent.forAllTasks(task -> {\n            Slog.i(TAG, \" Processing task=\" + task);\n            final boolean reparent;\n            if (task.mCreatedByOrganizer || task.getParent() != finalCurrentParent) {\n                // We only care about non-organized task that are direct children of the thing we\n                // are reparenting from.\n                return false;\n            }\n            if (newParentInMultiWindow && !task.supportsMultiWindowInDisplayArea(newParentTda)) {\n                Slog.e(TAG, \"reparentChildrenTasksHierarchyOp non-resizeable task to multi window,\"\n                        + \" task=\" + task);\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getActivityTypes())\n                    && !ArrayUtils.contains(hop.getActivityTypes(), task.getActivityType())) {\n                return false;\n            }\n            if (!ArrayUtils.isEmpty(hop.getWindowingModes())\n                    && !ArrayUtils.contains(hop.getWindowingModes(), task.getWindowingMode())) {\n                return false;\n            }\n            if (isLockTaskModeViolation(finalNewParent, task, isInLockTaskMode)) {\n                return false;\n            }\n\n            if (hop.getToTop()) {\n                tasksToReparent.add(0, task);\n            } else {\n                tasksToReparent.add(task);\n            }\n            return hop.getReparentTopOnly() && tasksToReparent.size() == 1;\n        });\n\n        final int count = tasksToReparent.size();\n        for (int i = 0; i < count; ++i) {\n            final Task task = tasksToReparent.get(i);\n            if (syncId >= 0) {\n                addToSyncSet(syncId, task);\n            }\n            if (transition != null) transition.collect(task);\n\n            if (newParent instanceof TaskDisplayArea) {\n                // For now, reparenting to display area is different from other reparents...\n                task.reparent((TaskDisplayArea) newParent, hop.getToTop());\n            } else {\n                task.reparent((Task) newParent,\n                        hop.getToTop() ? POSITION_TOP : POSITION_BOTTOM,\n                        false /*moveParents*/, \"processChildrenTaskReparentHierarchyOp\");\n            }\n        }\n\n        if (transition != null) transition.collect(newParent);\n\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int setAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root1 = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        final TaskFragment root2 =\n                WindowContainer.fromBinder(hop.getAdjacentRoot()).asTaskFragment();\n        if (!root1.mCreatedByOrganizer || !root2.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"setAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root1=\" + root1 + \" root2=\" + root2);\n        }\n        if (root1.getAdjacentTaskFragment() == root2) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root1.setAdjacentTaskFragment(root2);\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private int clearAdjacentRootsHierarchyOp(WindowContainerTransaction.HierarchyOp hop) {\n        final TaskFragment root = WindowContainer.fromBinder(hop.getContainer()).asTaskFragment();\n        if (!root.mCreatedByOrganizer) {\n            throw new IllegalArgumentException(\"clearAdjacentRootsHierarchyOp: Not created by\"\n                    + \" organizer root=\" + root);\n        }\n        if (root.getAdjacentTaskFragment() == null) {\n            return TRANSACT_EFFECTS_NONE;\n        }\n        root.resetAdjacentTaskFragment();\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    private void sanitizeWindowContainer(WindowContainer wc) {\n        if (!(wc instanceof TaskFragment) && !(wc instanceof DisplayArea)) {\n            throw new RuntimeException(\"Invalid token in task fragment or displayArea transaction\");\n        }\n    }\n\n    private int applyWindowContainerChange(WindowContainer wc,\n            WindowContainerTransaction.Change c, @Nullable IBinder errorCallbackToken) {\n        sanitizeWindowContainer(wc);\n        if (wc.asDisplayArea() != null) {\n            return applyDisplayAreaChanges(wc.asDisplayArea(), c);\n        } else if (wc.asTask() != null) {\n            return applyTaskChanges(wc.asTask(), c);\n        } else if (wc.asTaskFragment() != null && wc.asTaskFragment().isEmbedded()) {\n            return applyTaskFragmentChanges(wc.asTaskFragment(), c, errorCallbackToken);\n        } else {\n            return applyChanges(wc, c);\n        }\n    }\n\n    @Override\n    public ITaskOrganizerController getTaskOrganizerController() {\n        enforceTaskPermission(\"getTaskOrganizerController()\");\n        return mTaskOrganizerController;\n    }\n\n    @Override\n    public IDisplayAreaOrganizerController getDisplayAreaOrganizerController() {\n        enforceTaskPermission(\"getDisplayAreaOrganizerController()\");\n        return mDisplayAreaOrganizerController;\n    }\n\n    @Override\n    public ITaskFragmentOrganizerController getTaskFragmentOrganizerController() {\n        return mTaskFragmentOrganizerController;\n    }\n\n    /**\n     * This will prepare a {@link BLASTSyncEngine.SyncGroup} for the organizer to track, but the\n     * {@link BLASTSyncEngine.SyncGroup} may not be active until the {@link BLASTSyncEngine} is\n     * free.\n     */\n    private BLASTSyncEngine.SyncGroup prepareSyncWithOrganizer(\n            IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = mService.mWindowManager.mSyncEngine\n                .prepareSyncSet(this, \"Organizer\");\n        mTransactionCallbacksByPendingSyncId.put(s.mSyncId, callback);\n        return s;\n    }\n\n    @VisibleForTesting\n    int startSyncWithOrganizer(IWindowContainerTransactionCallback callback) {\n        final BLASTSyncEngine.SyncGroup s = prepareSyncWithOrganizer(callback);\n        mService.mWindowManager.mSyncEngine.startSyncSet(s);\n        return s.mSyncId;\n    }\n\n    @VisibleForTesting\n    void setSyncReady(int id) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Set sync ready, syncId=%d\", id);\n        mService.mWindowManager.mSyncEngine.setReady(id);\n    }\n\n    @VisibleForTesting\n    void addToSyncSet(int syncId, WindowContainer wc) {\n        mService.mWindowManager.mSyncEngine.addToSyncSet(syncId, wc);\n    }\n\n    @Override\n    public void onTransactionReady(int syncId, SurfaceControl.Transaction t) {\n        ProtoLog.v(WM_DEBUG_WINDOW_ORGANIZER, \"Transaction ready, syncId=%d\", syncId);\n        final IWindowContainerTransactionCallback callback =\n                mTransactionCallbacksByPendingSyncId.get(syncId);\n\n        try {\n            callback.onTransactionReady(syncId, t);\n        } catch (RemoteException e) {\n            // If there's an exception when trying to send the mergedTransaction to the client, we\n            // should immediately apply it here so the transactions aren't lost.\n            t.apply();\n        }\n\n        mTransactionCallbacksByPendingSyncId.remove(syncId);\n    }\n\n    @Override\n    public void registerTransitionPlayer(ITransitionPlayer player) {\n        enforceTaskPermission(\"registerTransitionPlayer()\");\n        final int callerPid = Binder.getCallingPid();\n        final int callerUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            synchronized (mGlobalLock) {\n                final WindowProcessController wpc =\n                        mService.getProcessController(callerPid, callerUid);\n                mTransitionController.registerTransitionPlayer(player, wpc);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    @Override\n    public ITransitionMetricsReporter getTransitionMetricsReporter() {\n        return mTransitionController.mTransitionMetricsReporter;\n    }\n\n    @Override\n    public IBinder getApplyToken() {\n        enforceTaskPermission(\"getApplyToken()\");\n        return SurfaceControl.Transaction.getDefaultApplyToken();\n    }\n\n    /** Whether the configuration changes are important to report back to an organizer. */\n    static boolean configurationsAreEqualForOrganizer(\n            Configuration newConfig, @Nullable Configuration oldConfig) {\n        if (oldConfig == null) {\n            return false;\n        }\n        int cfgChanges = newConfig.diff(oldConfig);\n        final int winCfgChanges = (cfgChanges & ActivityInfo.CONFIG_WINDOW_CONFIGURATION) != 0\n                ? (int) newConfig.windowConfiguration.diff(oldConfig.windowConfiguration,\n                true /* compareUndefined */) : 0;\n        if ((winCfgChanges & CONTROLLABLE_WINDOW_CONFIGS) == 0) {\n            cfgChanges &= ~ActivityInfo.CONFIG_WINDOW_CONFIGURATION;\n        }\n        return (cfgChanges & CONTROLLABLE_CONFIGS) == 0;\n    }\n\n    /**\n     * Makes sure that the transaction only contains operations that are allowed for the\n     * {@link WindowContainerTransaction#getTaskFragmentOrganizer()}.\n     */\n    private void enforceTaskFragmentOrganizerPermission(@NonNull String func,\n            @NonNull ITaskFragmentOrganizer organizer, @NonNull WindowContainerTransaction t) {\n        // Configuration changes\n        final Iterator<Map.Entry<IBinder, WindowContainerTransaction.Change>> entries =\n                t.getChanges().entrySet().iterator();\n        while (entries.hasNext()) {\n            final Map.Entry<IBinder, WindowContainerTransaction.Change> entry = entries.next();\n            final WindowContainer wc = WindowContainer.fromBinder(entry.getKey());\n            enforceTaskFragmentConfigChangeAllowed(func, wc, entry.getValue(), organizer);\n        }\n\n        // Hierarchy changes\n        final List<WindowContainerTransaction.HierarchyOp> hops = t.getHierarchyOps();\n        for (int i = hops.size() - 1; i >= 0; i--) {\n            final WindowContainerTransaction.HierarchyOp hop = hops.get(i);\n            final int type = hop.getType();\n            // Check for each type of the operations that are allowed for TaskFragmentOrganizer.\n            switch (type) {\n                case HIERARCHY_OP_TYPE_ADD_TASK_FRAGMENT_OPERATION:\n                    enforceTaskFragmentOrganized(func, hop.getContainer(), organizer);\n                    if (hop.getTaskFragmentOperation() != null\n                            && hop.getTaskFragmentOperation().getSecondaryFragmentToken() != null) {\n                        enforceTaskFragmentOrganized(func,\n                                hop.getTaskFragmentOperation().getSecondaryFragmentToken(),\n                                organizer);\n                    }\n                    break;\n                case HIERARCHY_OP_TYPE_FINISH_ACTIVITY:\n                    // Allow finish activity if it has the activity token.\n                    break;\n                default:\n                    // Other types of hierarchy changes are not allowed.\n                    String msg = \"Permission Denial: \" + func + \" from pid=\"\n                            + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                            + \" trying to apply a hierarchy change that is not allowed for\"\n                            + \" TaskFragmentOrganizer=\" + organizer;\n                    Slog.w(TAG, msg);\n                    throw new SecurityException(msg);\n            }\n        }\n    }\n\n    /**\n     * Makes sure that the {@link TaskFragment} of the given fragment token is created and organized\n     * by the given {@link ITaskFragmentOrganizer}.\n     */\n    private void enforceTaskFragmentOrganized(@NonNull String func,\n            @NonNull IBinder fragmentToken, @NonNull ITaskFragmentOrganizer organizer) {\n        Objects.requireNonNull(fragmentToken);\n        final TaskFragment tf = mLaunchTaskFragments.get(fragmentToken);\n        // When the TaskFragment is {@code null}, it means that the TaskFragment will be created\n        // later in the same transaction, in which case it will always be organized by the given\n        // organizer.\n        if (tf != null && !tf.hasTaskFragmentOrganizer(organizer)) {\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify TaskFragment not\"\n                    + \" belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    /**\n     * For config change on {@link TaskFragment}, we only support the following operations:\n     * {@link WindowContainerTransaction#setRelativeBounds(WindowContainerToken, Rect)},\n     * {@link WindowContainerTransaction#setWindowingMode(WindowContainerToken, int)}.\n     */\n    private void enforceTaskFragmentConfigChangeAllowed(@NonNull String func,\n            @Nullable WindowContainer wc, @NonNull WindowContainerTransaction.Change change,\n            @NonNull ITaskFragmentOrganizer organizer) {\n        if (wc == null) {\n            Slog.e(TAG, \"Attempt to operate on task fragment that no longer exists\");\n            return;\n        }\n        final TaskFragment tf = wc.asTaskFragment();\n        if (tf == null || !tf.hasTaskFragmentOrganizer(organizer)) {\n            // Only allow to apply changes to TaskFragment that is organized by this organizer.\n            String msg = \"Permission Denial: \" + func + \" from pid=\" + Binder.getCallingPid()\n                    + \", uid=\" + Binder.getCallingUid() + \" trying to modify window container\"\n                    + \" not belonging to the TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n\n        final int changeMask = change.getChangeMask();\n        final int configSetMask = change.getConfigSetMask();\n        final int windowSetMask = change.getWindowSetMask();\n        if (changeMask == 0 && configSetMask == 0 && windowSetMask == 0\n                && change.getWindowingMode() >= 0) {\n            // The change contains only setWindowingMode, which is allowed.\n            return;\n        }\n        if (changeMask != CHANGE_RELATIVE_BOUNDS\n                || configSetMask != ActivityInfo.CONFIG_WINDOW_CONFIGURATION\n                || windowSetMask != WindowConfiguration.WINDOW_CONFIG_BOUNDS) {\n            // None of the change should be requested from a TaskFragment organizer except\n            // setRelativeBounds and setWindowingMode.\n            // For setRelativeBounds, we don't need to check whether it is outside of the Task\n            // bounds, because it is possible that the Task is also resizing, for which we don't\n            // want to throw an exception. The bounds will be adjusted in\n            // TaskFragment#translateRelativeBoundsToAbsoluteBounds.\n            String msg = \"Permission Denial: \" + func + \" from pid=\"\n                    + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid()\n                    + \" trying to apply changes of changeMask=\" + changeMask\n                    + \" configSetMask=\" + configSetMask + \" windowSetMask=\" + windowSetMask\n                    + \" to TaskFragment=\" + tf + \" TaskFragmentOrganizer=\" + organizer;\n            Slog.w(TAG, msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private void createTaskFragment(@NonNull TaskFragmentCreationParams creationParams,\n            @Nullable IBinder errorCallbackToken, @NonNull CallerInfo caller,\n            @Nullable Transition transition) {\n        final ActivityRecord ownerActivity =\n                ActivityRecord.forTokenLocked(creationParams.getOwnerToken());\n        final ITaskFragmentOrganizer organizer = ITaskFragmentOrganizer.Stub.asInterface(\n                creationParams.getOrganizer().asBinder());\n\n        if (mLaunchTaskFragments.containsKey(creationParams.getFragmentToken())) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"TaskFragment token must be unique\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerActivity == null || ownerActivity.getTask() == null) {\n            final Throwable exception =\n                    new IllegalArgumentException(\"Not allowed to operate with invalid ownerToken\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (!ownerActivity.isResizeable()) {\n            final IllegalArgumentException exception = new IllegalArgumentException(\"Not allowed\"\n                    + \" to operate with non-resizable owner Activity\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        // The ownerActivity has to belong to the same app as the target Task.\n        final Task ownerTask = ownerActivity.getTask();\n        if (ownerTask.effectiveUid != ownerActivity.getUid()\n                || ownerTask.effectiveUid != caller.mUid) {\n            final Throwable exception =\n                    new SecurityException(\"Not allowed to operate with the ownerToken while \"\n                            + \"the root activity of the target task belong to the different app\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        if (ownerTask.inPinnedWindowingMode()) {\n            final Throwable exception = new IllegalArgumentException(\n                    \"Not allowed to create TaskFragment in PIP Task\");\n            sendTaskFragmentOperationFailure(organizer, errorCallbackToken, null /* taskFragment */,\n                    OP_TYPE_CREATE_TASK_FRAGMENT, exception);\n            return;\n        }\n        final TaskFragment taskFragment = new TaskFragment(mService,\n                creationParams.getFragmentToken(), true /* createdByOrganizer */);\n        // Set task fragment organizer immediately, since it might have to be notified about further\n        // actions.\n        taskFragment.setTaskFragmentOrganizer(creationParams.getOrganizer(),\n                ownerActivity.getUid(), ownerActivity.info.processName);\n        final int position;\n        if (creationParams.getPairedPrimaryFragmentToken() != null) {\n            // When there is a paired primary TaskFragment, we want to place the new TaskFragment\n            // right above the paired one to make sure there is no other window in between.\n            final TaskFragment pairedPrimaryTaskFragment = getTaskFragment(\n                    creationParams.getPairedPrimaryFragmentToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedPrimaryTaskFragment);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else if (creationParams.getPairedActivityToken() != null) {\n            // When there is a paired Activity, we want to place the new TaskFragment right above\n            // the paired Activity to make sure the Activity position is not changed after reparent.\n            final ActivityRecord pairedActivity = ActivityRecord.forTokenLocked(\n                    creationParams.getPairedActivityToken());\n            final int pairedPosition = ownerTask.mChildren.indexOf(pairedActivity);\n            position = pairedPosition != -1 ? pairedPosition + 1 : POSITION_TOP;\n        } else {\n            position = POSITION_TOP;\n        }\n        ownerTask.addChild(taskFragment, position);\n        taskFragment.setWindowingMode(creationParams.getWindowingMode());\n        if (!creationParams.getInitialRelativeBounds().isEmpty()) {\n            // Set relative bounds instead of using setBounds. This will avoid unnecessary update in\n            // case the parent has resized since the last time parent info is sent to the organizer.\n            taskFragment.setRelativeEmbeddedBounds(creationParams.getInitialRelativeBounds());\n            // Recompute configuration as the bounds will be calculated based on relative bounds in\n            // TaskFragment#resolveOverrideConfiguration.\n            taskFragment.recomputeConfiguration();\n        }\n        mLaunchTaskFragments.put(creationParams.getFragmentToken(), taskFragment);\n\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n    }\n\n    private int deleteTaskFragment(@NonNull TaskFragment taskFragment,\n            @Nullable Transition transition) {\n        if (transition != null) transition.collectExistenceChange(taskFragment);\n\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n        taskFragment.remove(true /* withTransition */, \"deleteTaskFragment\");\n        return TRANSACT_EFFECTS_LIFECYCLE;\n    }\n\n    @Nullable\n    TaskFragment getTaskFragment(IBinder tfToken) {\n        return mLaunchTaskFragments.get(tfToken);\n    }\n\n    void cleanUpEmbeddedTaskFragment(TaskFragment taskFragment) {\n        mLaunchTaskFragments.remove(taskFragment.getFragmentToken());\n    }\n\n    static class CallerInfo {\n        final int mPid;\n        final int mUid;\n\n        CallerInfo() {\n            mPid = Binder.getCallingPid();\n            mUid = Binder.getCallingUid();\n        }\n    }\n\n    void sendTaskFragmentOperationFailure(@NonNull ITaskFragmentOrganizer organizer,\n            @Nullable IBinder errorCallbackToken, @Nullable TaskFragment taskFragment,\n            @TaskFragmentOperation.OperationType int opType, @NonNull Throwable exception) {\n        if (organizer == null) {\n            throw new IllegalArgumentException(\"Not allowed to operate with invalid organizer\");\n        }\n        mService.mTaskFragmentOrganizerController\n                .onTaskFragmentError(organizer, errorCallbackToken, taskFragment, opType,\n                        exception);\n    }\n\n    private Throwable convertStartFailureToThrowable(int result, Intent intent) {\n        switch (result) {\n            case ActivityManager.START_INTENT_NOT_RESOLVED:\n            case ActivityManager.START_CLASS_NOT_FOUND:\n                return new ActivityNotFoundException(\"No Activity found to handle \" + intent);\n            case ActivityManager.START_PERMISSION_DENIED:\n                return new SecurityException(\"Permission denied and not allowed to start activity \"\n                        + intent);\n            case ActivityManager.START_CANCELED:\n                return new AndroidRuntimeException(\"Activity could not be started for \" + intent\n                        + \" with error code : \" + result);\n            default:\n                return new AndroidRuntimeException(\"Start activity failed with error code : \"\n                        + result + \" when starting \" + intent);\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9989,
      "normalized_edit_similarity": 0.9971,
      "token_level_edit_distance": 20,
      "codebert_score": {
        "precision": 0.9721,
        "recall": 0.9722,
        "f1": 0.9721,
        "f3": 0.9721
      },
      "token_count_upstream": 7909,
      "token_count_downstream": 7916,
      "token_count_total": 15825,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-364026473",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "llm_patched_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "ground_truth_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9934,
      "normalized_edit_similarity": 0.9997,
      "token_level_edit_distance": 1,
      "codebert_score": {
        "precision": 0.9805,
        "recall": 0.9806,
        "f1": 0.9805,
        "f3": 0.9806
      },
      "token_count_upstream": 4670,
      "token_count_downstream": 4704,
      "token_count_total": 9374,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-364027038",
    "downstream_version": "14",
    "file_name": "system/stack/gatt/gatt_sr.cc",
    "llm_patched_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "ground_truth_code": "/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9934,
      "normalized_edit_similarity": 0.9997,
      "token_level_edit_distance": 1,
      "codebert_score": {
        "precision": 0.9805,
        "recall": 0.9806,
        "f1": 0.9805,
        "f3": 0.9806
      },
      "token_count_upstream": 4670,
      "token_count_downstream": 4704,
      "token_count_total": 9374,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-352542820",
    "downstream_version": "14",
    "file_name": "src/com/android/settings/users/UserSettings.java",
    "llm_patched_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    UserManager.isMultipleAdminEnabled(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(UserHandle.USER_SYSTEM);\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to system user\");\n                switchToUserId(UserHandle.USER_SYSTEM);\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (mUserCaps.mUserSwitcherEnabled) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            // Only current user will be displayed in case of multi-user switch is disabled\n            users = List.of(mUserManager.getUserInfo(context.getUserId()));\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n                if (user.isAdmin()) {\n                    pref.setSummary(R.string.user_admin);\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (mUserCaps.mUserSwitcherEnabled) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser && !mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.clear();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n                && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    UserManager.isMultipleAdminEnabled(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(UserHandle.USER_SYSTEM);\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to system user\");\n                switchToUserId(UserHandle.USER_SYSTEM);\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (mUserCaps.mUserSwitcherEnabled) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            // Only current user will be displayed in case of multi-user switch is disabled\n            users = List.of(mUserManager.getUserInfo(context.getUserId()));\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n                if (user.isAdmin()) {\n                    pref.setSummary(R.string.user_admin);\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (mUserCaps.mUserSwitcherEnabled) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser && !mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.clear();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9994,
      "normalized_edit_similarity": 0.9996,
      "token_level_edit_distance": 1,
      "codebert_score": {
        "precision": 0.9812,
        "recall": 0.9812,
        "f1": 0.9812,
        "f3": 0.9812
      },
      "token_count_upstream": 4699,
      "token_count_downstream": 4699,
      "token_count_total": 9398,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-289375038",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "llm_patched_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": 1.0,
      "token_level_edit_distance": 0,
      "codebert_score": {
        "precision": 1.0,
        "recall": 1.0,
        "f1": 1.0,
        "f3": 1.0
      },
      "token_count_upstream": 15700,
      "token_count_downstream": 15700,
      "token_count_total": 31400,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-289811388",
    "downstream_version": "14",
    "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
    "llm_patched_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n\n            // If the device is now unbonded, remove its permissions.\n            // BondStateMachine.convertHalState() converts HAL state to BluetoothDevice state.\n            if (BondStateMachine.convertHalState(newState) == BOND_NONE) {\n                mService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n                mService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n                mService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9984,
      "normalized_edit_similarity": 0.9862,
      "token_level_edit_distance": 81,
      "codebert_score": {
        "precision": 0.9722,
        "recall": 0.9718,
        "f1": 0.972,
        "f3": 0.9719
      },
      "token_count_upstream": 15733,
      "token_count_downstream": 15700,
      "token_count_total": 31433,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-375623125",
    "downstream_version": "14",
    "file_name": "services/core/java/com/android/server/appop/AppOpsService.java",
    "llm_patched_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    @VisibleForTesting\n    public AppOpsService(File recentAccessesFile, File storageFile, Handler handler,\n            Context context) {\n        mContext = context;\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n        mAppOpsCheckingService = new AppOpsCheckingServiceTracingDecorator(\n                new AppOpsCheckingServiceImpl(\n                        storageFile, this, handler, context,  mSwitchedOps));\n        //mAppOpsCheckingService = new AppOpsCheckingServiceLoggingDecorator(\n        //        LocalServices.getService(AppOpsCheckingServiceInterface.class));\n        mAppOpsRestrictions = new AppOpsRestrictionsImpl(context, handler, mAppOpsCheckingService);\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mStorageFile = new AtomicFile(storageFile, \"appops_legacy\");\n        mRecentAccessesFile = new AtomicFile(recentAccessesFile, \"appops_accesses\");\n\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        // To migrate storageFile to recentAccessesFile, these reads must be called in this order.\n        readRecentAccesses();\n        mAppOpsCheckingService.readState();\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n        LocalManagerRegistry.addManager(AppOpsManagerLocal.class, new AppOpsManagerLocalImpl());\n    }\n\n    /** Handler for work when packages are updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mAppOpsCheckingService.systemReady();\n        initializeUidStates();\n\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        getUserManagerInternal().addUserLifecycleListener(\n                new UserManagerInternal.UserLifecycleListener() {\n                    @Override\n                    public void onUserCreated(UserInfo user, Object token) {\n                        initializeUserUidStates(user.id);\n                    }\n\n                    // onUserRemoved handled by #removeUser\n                });\n\n        getPackageManagerInternal().getPackageList(\n                new PackageManagerInternal.PackageListObserver() {\n                    @Override\n                    public void onPackageAdded(String packageName, int appId) {\n                        PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                                PackageManager.GET_PERMISSIONS, Process.myUid(),\n                                mContext.getUserId());\n                        boolean isSamplingTarget = isSamplingTarget(pi);\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            if (isSamplingTarget) {\n                                mRarelyUsedPackages.add(packageName);\n                            }\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                UidState uidState = getUidStateLocked(uid, true);\n                                if (!uidState.pkgOps.containsKey(packageName)) {\n                                    uidState.pkgOps.put(packageName,\n                                            new Ops(packageName, uidState));\n                                }\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onPackageRemoved(String packageName, int appId) {\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                packageRemovedLocked(uid, packageName);\n                            }\n                        }\n                    }\n                });\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<OnOpModeChangedListener> onModeChangedListeners;\n                    synchronized (AppOpsService.this) {\n                        onModeChangedListeners =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (onModeChangedListeners == null) {\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(onModeChangedListeners, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Initialize uid state objects for state contained in the checking service.\n     */\n    @VisibleForTesting\n    void initializeUidStates() {\n        UserManagerInternal umi = getUserManagerInternal();\n        synchronized (this) {\n            int[] userIds = umi.getUserIds();\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                         getPackageManagerLocal().withUnfilteredSnapshot()) {\n                Map<String, PackageState> packageStates = snapshot.getPackageStates();\n                for (int i = 0; i < userIds.length; i++) {\n                    int userId = userIds[i];\n                    initializeUserUidStatesLocked(userId, packageStates);\n                }\n            }\n        }\n    }\n\n    private void initializeUserUidStates(int userId) {\n        synchronized (this) {\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                    getPackageManagerLocal().withUnfilteredSnapshot()) {\n                initializeUserUidStatesLocked(userId, snapshot.getPackageStates());\n            }\n        }\n    }\n\n    private void initializeUserUidStatesLocked(int userId, Map<String,\n            PackageState> packageStates) {\n        for (Map.Entry<String, PackageState> entry : packageStates.entrySet()) {\n            int appId = entry.getValue().getAppId();\n            String packageName = entry.getKey();\n\n            initializePackageUidStateLocked(userId, appId, packageName);\n        }\n    }\n\n    /*\n      Be careful not to clear any existing data; only want to add objects that don't already exist.\n     */\n    private void initializePackageUidStateLocked(int userId, int appId, String packageName) {\n        int uid = UserHandle.getUid(userId, appId);\n        UidState uidState = getUidStateLocked(uid, true);\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        SparseIntArray packageModes =\n                mAppOpsCheckingService.getNonDefaultPackageModes(packageName, userId);\n        for (int k = 0; k < packageModes.size(); k++) {\n            int code = packageModes.keyAt(k);\n\n            if (ops.indexOfKey(code) < 0) {\n                ops.put(code, new Op(uidState, packageName, code, uid));\n            }\n        }\n\n        uidState.evalForegroundOps();\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    @VisibleForTesting\n    void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            packageRemovedLocked(uid, packageName);\n        }\n    }\n\n    @GuardedBy(\"this\")\n    private void packageRemovedLocked(int uid, String packageName) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        Ops removedOps = null;\n\n        // Remove any package state if such.\n        removedOps = uidState.pkgOps.remove(packageName);\n        mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n\n        if (removedOps != null) {\n            scheduleFastWriteLocked();\n\n            final int numOps = removedOps.size();\n            for (int opNum = 0; opNum < numOps; opNum++) {\n                final Op op = removedOps.valueAt(opNum);\n\n                final int numAttributions = op.mAttributions.size();\n                for (int attributionNum = 0; attributionNum < numAttributions;\n                        attributionNum++) {\n                    AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                    while (attributedOp.isRunning()) {\n                        attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                    }\n                    while (attributedOp.isPaused()) {\n                        attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.get(uid).clear();\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    // The callback method from AppOpsUidStateTracker\n    private void onUidStateChanged(int uid, int state, boolean foregroundModeMayChange) {\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, true);\n\n            if (uidState != null && foregroundModeMayChange && uidState.hasForegroundWatchers) {\n                for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                    if (!uidState.foregroundOps.valueAt(fgi)) {\n                        continue;\n                    }\n                    final int code = uidState.foregroundOps.keyAt(fgi);\n\n                    if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)\n                            && uidState.getUidMode(code) == AppOpsManager.MODE_FOREGROUND) {\n                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                AppOpsService::notifyOpChangedForAllPkgsInUid,\n                                this, code, uidState.uid, true, null));\n                    } else if (!uidState.pkgOps.isEmpty()) {\n                        final ArraySet<OnOpModeChangedListener> listenerSet =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (listenerSet != null) {\n                            for (int cbi = listenerSet.size() - 1; cbi >= 0; cbi--) {\n                                final OnOpModeChangedListener listener = listenerSet.valueAt(cbi);\n                                if ((listener.getFlags()\n                                        & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                        || !listener.isWatchingUid(uidState.uid)) {\n                                    continue;\n                                }\n                                for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                    final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                    if (op == null) {\n                                        continue;\n                                    }\n                                    if (op.getMode() == AppOpsManager.MODE_FOREGROUND) {\n                                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                                AppOpsService::notifyOpChanged,\n                                                this, listenerSet.valueAt(cbi), code, uidState.uid,\n                                                uidState.pkgOps.keyAt(pkgi)));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (uidState != null) {\n                int numPkgs = uidState.pkgOps.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = 0; attributionNum < numAttributions;\n                                attributionNum++) {\n                            AttributedOp attributedOp = op.mAttributions.valueAt(\n                                    attributionNum);\n\n                            attributedOp.onUidStateChanged(state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify the proc state or capability has changed for a certain UID.\n     */\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            getUidStateTracker().updateUidProcState(uid, procState, capability);\n            if (!mUidStates.contains(uid)) {\n                UidState uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n                onUidStateChanged(uid,\n                        AppOpsUidStateTracker.processStateToUidState(procState), false);\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeRecentAccesses();\n        }\n        mAppOpsCheckingService.shutdown();\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid())\n                == PackageManager.PERMISSION_GRANTED;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j = 0; j < pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                    continue;\n                }\n                resOps.add(getOpEntryForResult(curOp));\n            }\n        } else {\n            for (int j = 0; j < ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                        continue;\n                    }\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n        if (opModes == null) {\n            return null;\n        }\n\n        int opModeCount = opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = opModes.keyAt(i);\n                resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        // We get to access everything\n        final int callingPid = Binder.getCallingPid();\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        final int callingUid = Binder.getCallingUid();\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, callingPid,\n                callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        mAppOpsCheckingService.writeState();\n        mAppOpsCheckingService.readState();\n    }\n\n    @VisibleForTesting\n    void readState() {\n        mAppOpsCheckingService.readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                op.setMode(AppOpsManager.opToDefaultMode(op.op));\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        mAppOpsCheckingService.removePackage(ops.packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n            }\n            if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                previousMode = uidState.getUidMode(code);\n            } else {\n                // doesn't look right but is legacy behavior.\n                previousMode = MODE_DEFAULT;\n            }\n\n            if (!uidState.setUidMode(code, mode)) {\n                return;\n            }\n            uidState.evalForegroundOps();\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        ModeCallback listenerToIgnore = callbackToIgnore != null\n                ? mModeWatchers.get(callbackToIgnore.asBinder()) : null;\n        mAppOpsCheckingService.notifyOpChangedForAllPkgsInUid(code, uid, onlyForeground,\n                listenerToIgnore);\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        ArraySet<OnOpModeChangedListener> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot setMode: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot setMode\", e);\n            }\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.getMode() != mode) {\n                    previousMode = op.getMode();\n                    op.setMode(mode);\n\n                    if (uidState != null) {\n                        uidState.evalForegroundOps();\n                    }\n                    ArraySet<OnOpModeChangedListener> cbs =\n                            mAppOpsCheckingService.getOpModeChangedListeners(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mAppOpsCheckingService.getPackageModeChangedListeners(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<OnOpModeChangedListener> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final OnOpModeChangedListener callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(OnOpModeChangedListener callback, int code,\n            int uid, String packageName) {\n        mAppOpsCheckingService.notifyOpChanged(callback, code, uid, packageName);\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode,\n            ArraySet<OnOpModeChangedListener> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            OnOpModeChangedListener cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            int newMode = isUidOpGrantedByRole(uidState.uid, code) ? MODE_ALLOWED :\n                                    AppOpsManager.opToDefaultMode(code);\n                            uidState.setUidMode(code, newMode);\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode,\n                                        mAppOpsCheckingService.getOpModeChangedListeners(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mAppOpsCheckingService\n                                                .getPackageModeChangedListeners(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)) {\n                            int previousMode = curOp.getMode();\n                            int newMode = isPackageOpGrantedByRole(packageName, uidState.uid,\n                                    curOp.op) ? MODE_ALLOWED : AppOpsManager.opToDefaultMode(\n                                    curOp.op);\n                            if (previousMode == newMode) {\n                                continue;\n                            }\n                            curOp.setMode(newMode);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode,\n                                    mAppOpsCheckingService.getOpModeChangedListeners(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mAppOpsCheckingService\n                                            .getPackageModeChangedListeners(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                        mAppOpsCheckingService.removePackage(packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps();\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<OnOpModeChangedListener, ArrayList<ChangeRec>> ent\n                    : callbacks.entrySet()) {\n                OnOpModeChangedListener cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean isUidOpGrantedByRole(int uid, int code) {\n        if (!AppOpsManager.opIsUidAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            // Permissions are managed by UIDs, but unfortunately a package name is required in API.\n            String packageName = ArrayUtils.firstOrNull(packageManager.getPackagesForUid(uid));\n            if (packageName == null) {\n                return false;\n            }\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean isPackageOpGrantedByRole(@NonNull String packageName, int uid, int code) {\n        if (!AppOpsManager.opIsPackageAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName = packageName != null\n                && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(callingUid));\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                mAppOpsCheckingService.startWatchingOpModeChanged(cb, switchOp);\n            }\n            if (mayWatchPackageName) {\n                mAppOpsCheckingService.startWatchingPackageModeChanged(cb, packageName);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                mAppOpsCheckingService.removeListener(cb);\n            }\n\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot checkOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot checkOperation\", e);\n            }\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null\n                    && uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                final int rawMode = uidState.getUidMode(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.getMode() : op.uidState.evalMode(op.op, op.getMode());\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveNonAppUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return getPackageManagerInternal().getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, userId);\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))\n                || !isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot noteOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot noteOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.getState(), flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState.getState(),\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, OP_RECEIVE_AMBIENT_TRIGGER_AUDIO and\n        // OP_RECORD_AUDIO_SANDBOXED which we use only for attribution purposes and not as a check,\n        // also make sure that the caller is allowed to access the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        int result = MODE_DEFAULT;\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO\n                || code == OP_RECORD_AUDIO_SANDBOXED) {\n            result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        // As a special case for OP_CAMERA_SANDBOXED.\n        if (code == OP_CAMERA_SANDBOXED) {\n            result = checkOperation(OP_CAMERA, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot startOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot startOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return null;\n        }\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot finishOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot finishOperation\", e);\n            }\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        if (AppOpsManager.shouldForceCollectNoteForOp(opCode)) {\n            return true;\n        }\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private boolean isIncomingPackageValid(@Nullable String packageName, @UserIdInt int userId) {\n        final int callingUid = Binder.getCallingUid();\n        // Handle the special UIDs that don't have actual packages (audioserver, cameraserver, etc).\n        if (packageName == null || isSpecialPackage(callingUid, packageName)) {\n            return true;\n        }\n\n        // If the package doesn't exist, #verifyAndGetBypass would throw a SecurityException in\n        // the end. Although that exception would be caught and return, we could make it return\n        // early.\n        if (!isPackageExisted(packageName)) {\n            return false;\n        }\n\n        if (getPackageManagerInternal().filterAppAccess(packageName, callingUid, userId)) {\n            Slog.w(TAG, packageName + \" not found from \" + callingUid);\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            // if there is a next attribution source, it must be trusted, as well.\n            if (attributionSource.getNext() == null\n                    || attributionSource.getNext().isTrusted(mContext)) {\n                return true;\n            }\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        }\n\n        return uidState;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            getUidStateTracker().updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        if (mPackageManagerInternal == null) {\n            throw new IllegalStateException(\"PackageManagerInternal not loaded\");\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * @return {@link PackageManagerLocal}\n     */\n    private @NonNull PackageManagerLocal getPackageManagerLocal() {\n        if (mPackageManagerLocal == null) {\n            mPackageManagerLocal = LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n        if (mPackageManagerLocal == null) {\n            throw new IllegalStateException(\"PackageManagerLocal not loaded\");\n        }\n\n        return mPackageManagerLocal;\n    }\n\n    /**\n     * @return {@link UserManagerInternal}\n     */\n    private @NonNull UserManagerInternal getUserManagerInternal() {\n        if (mUserManagerInternal == null) {\n            mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);\n        }\n        if (mUserManagerInternal == null) {\n            throw new IllegalStateException(\"UserManagerInternal not loaded\");\n        }\n\n        return mUserManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull PackageState packageState) {\n        return new RestrictionBypass(packageState.getAppId() == Process.SYSTEM_UID,\n                packageState.isPrivileged(), mContext.checkPermission(\n                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1,\n                packageState.getAppId()) == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n                false);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    uid = pm.getPackageUidAsUser(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0), UserHandle.getUserId(uid));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && !uidState.pkgOps.isEmpty()) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable, non-app uids\n        int nonAppUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            nonAppUid = Process.SHELL_UID;\n        } else {\n            nonAppUid = resolveNonAppUid(packageName);\n        }\n        if (nonAppUid != Process.INVALID_UID) {\n            if (nonAppUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                                + \".\");\n                }\n                String otherUidMessage =\n                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName\n                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            // We only allow bypassing the attribution tag verification if the proxy is a\n            // system app (or is null), in order to prevent abusive apps clogging the appops\n            // system with unlimited attribution tags via proxy calls.\n            boolean proxyIsSystemAppOrNull = true;\n            if (proxyPackageName != null) {\n                int proxyAppId = UserHandle.getAppId(proxyUid);\n                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n                    proxyIsSystemAppOrNull =\n                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                }\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        int pkgUid = nonAppUid;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            var pkgState = pmInt.getPackageStateInternal(packageName);\n            var pkg = pkgState == null ? null : pkgState.getAndroidPackage();\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, pkgState.getAppId());\n                bypass = getBypassforPackage(pkgState);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            if (!suppressErrorLogs) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            }\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Read recent accesses from persistence (mRecentAccessesFile).\n     * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n     * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n     * If neither file exists, there's nothing to migrate.\n     */\n    private void readRecentAccesses() {\n        if (!mRecentAccessesFile.exists()) {\n            readRecentAccesses(mStorageFile);\n        } else {\n            readRecentAccesses(mRecentAccessesFile);\n        }\n    }\n\n    private void readRecentAccesses(AtomicFile file) {\n        synchronized (file) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = file.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + file.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                mAppOpsCheckingService.clearAllModes();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        // Parse next until we reach the start or end\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            // uid tag may be present during migration, don't print warning.\n                            XmlUtils.skipCurrentTag(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                        mAppOpsCheckingService.clearAllModes();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    @VisibleForTesting\n    void writeRecentAccesses() {\n        synchronized (mRecentAccessesFile) {\n            FileOutputStream stream;\n            try {\n                stream = mRecentAccessesFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mRecentAccessesFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mRecentAccessesFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveNonAppUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n        pw.println(\"  --uid-state-changes\");\n        pw.println(\"    Include logs about uid state changes.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                AttributedOp.InProgressStartOpEvent event =\n                        attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.mNumUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        boolean dumpUidStateChangeLogs = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n        boolean dumpAll = false;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                    dumpAll = true;\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else if (\"--uid-state-changes\".equals(arg)) {\n                    dumpUidStateChangeLogs = true;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n\n            if (!dumpHistory) {\n                needSep |= mAppOpsCheckingService.dumpListeners(dumpOp, dumpUid, dumpPackage, pw);\n            }\n\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i = 0; i < mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.getWatchingUid())) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (opModes != null\n                            && opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).getMode() == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                uidState.dump(pw, nowElapsed);\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.getMode()) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.getMode()));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj == null\n                                    ? AppOpsManager.opToDefaultMode(switchOp) : switchObj.getMode();\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            boolean showUserRestrictions = !(dumpMode < 0 && !dumpWatchers && !dumpHistory);\n            mAppOpsRestrictions.dumpRestrictions(pw, dumpOp, dumpPackage, showUserRestrictions);\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n\n            if (dumpAll || dumpUidStateChangeLogs) {\n                pw.println();\n                pw.println(\"Uid State Changes Event Log:\");\n                getUidStateTracker().dumpEvents(pw);\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.getMode() != MODE_ALLOWED && op.getMode() != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n                            .bypass;\n                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n                            Context.DEVICE_ID_DEFAULT, bypass, false)) {\n                        // Only resume if there are no other restrictions remaining on this op\n                        attrOp.resume();\n                    }\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<OnOpModeChangedListener> modeChangedListenerSet;\n        synchronized (this) {\n            modeChangedListenerSet = mAppOpsCheckingService.getOpModeChangedListeners(code);\n            if (modeChangedListenerSet == null) {\n                return;\n            }\n        }\n\n        notifyOpChanged(modeChangedListenerSet,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return false;\n        }\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"this\")\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.valueAt(i).clear();\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveNonAppUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return Process.INVALID_UID;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n                    restricted, excludedPackageTags);\n        }\n\n        public boolean hasRestriction(int code, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n                    attributionTag, isCheckOp);\n        }\n\n        public void removeUser(int userId) {\n            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n        }\n\n        public boolean isDefault() {\n            return !mAppOpsRestrictions.hasUserRestrictions(token);\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mAppOpsRestrictions.clearUserRestrictions(token);\n                mOpUserRestrictions.remove(token);\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n        }\n\n        boolean hasRestriction(int code) {\n            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n        }\n\n        boolean isDefault() {\n            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n        }\n\n        @Override\n        public void binderDied() {\n            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n            mOpGlobalRestrictions.remove(mToken);\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n        @Override\n        public boolean isUidInForeground(int uid) {\n            synchronized (AppOpsService.this) {\n                return mUidStateTracker.isUidInForeground(uid);\n            }\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appop;\n\nimport static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;\nimport static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;\nimport static android.app.AppOpsManager.CALL_BACK_ON_SWITCHED_OP;\nimport static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;\nimport static android.app.AppOpsManager.FILTER_BY_OP_NAMES;\nimport static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;\nimport static android.app.AppOpsManager.FILTER_BY_UID;\nimport static android.app.AppOpsManager.HISTORY_FLAG_GET_ATTRIBUTION_CHAINS;\nimport static android.app.AppOpsManager.HistoricalOpsRequestFilter;\nimport static android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME;\nimport static android.app.AppOpsManager.MODE_ALLOWED;\nimport static android.app.AppOpsManager.MODE_DEFAULT;\nimport static android.app.AppOpsManager.MODE_ERRORED;\nimport static android.app.AppOpsManager.MODE_FOREGROUND;\nimport static android.app.AppOpsManager.MODE_IGNORED;\nimport static android.app.AppOpsManager.OP_CAMERA;\nimport static android.app.AppOpsManager.OP_CAMERA_SANDBOXED;\nimport static android.app.AppOpsManager.OP_FLAGS_ALL;\nimport static android.app.AppOpsManager.OP_FLAG_SELF;\nimport static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;\nimport static android.app.AppOpsManager.OP_NONE;\nimport static android.app.AppOpsManager.OP_PLAY_AUDIO;\nimport static android.app.AppOpsManager.OP_RECEIVE_AMBIENT_TRIGGER_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_HOTWORD;\nimport static android.app.AppOpsManager.OP_RECORD_AUDIO_SANDBOXED;\nimport static android.app.AppOpsManager.OP_VIBRATE;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_FAILED;\nimport static android.app.AppOpsManager.OnOpStartedListener.START_TYPE_STARTED;\nimport static android.app.AppOpsManager.OpEventProxyInfo;\nimport static android.app.AppOpsManager.RestrictionBypass;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_RARELY_USED;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM;\nimport static android.app.AppOpsManager.SAMPLING_STRATEGY_UNIFORM_OPS;\nimport static android.app.AppOpsManager.SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE;\nimport static android.app.AppOpsManager._NUM_OP;\nimport static android.app.AppOpsManager.extractFlagsFromKey;\nimport static android.app.AppOpsManager.extractUidStateFromKey;\nimport static android.app.AppOpsManager.modeToName;\nimport static android.app.AppOpsManager.opAllowSystemBypassRestriction;\nimport static android.app.AppOpsManager.opRestrictsRead;\nimport static android.app.AppOpsManager.opToName;\nimport static android.app.AppOpsManager.opToPublicName;\nimport static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;\nimport static android.content.pm.PermissionInfo.PROTECTION_FLAG_APPOP;\n\nimport static com.android.server.appop.AppOpsService.ModeCallback.ALL_OPS;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManager.AttributedOpEntry;\nimport android.app.AppOpsManager.AttributionFlags;\nimport android.app.AppOpsManager.HistoricalOps;\nimport android.app.AppOpsManager.Mode;\nimport android.app.AppOpsManager.OpEntry;\nimport android.app.AppOpsManager.OpFlags;\nimport android.app.AppOpsManagerInternal;\nimport android.app.AppOpsManagerInternal.CheckOpsDelegate;\nimport android.app.AsyncNotedAppOp;\nimport android.app.RuntimeAppOpAccessMessage;\nimport android.app.SyncNotedAppOp;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PermissionInfo;\nimport android.content.pm.UserInfo;\nimport android.database.ContentObserver;\nimport android.hardware.camera2.CameraDevice.CAMERA_AUDIO_RESTRICTION;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.HandlerExecutor;\nimport android.os.IBinder;\nimport android.os.PackageTagsList;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ServiceManager;\nimport android.os.ShellCallback;\nimport android.os.ShellCommand;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManagerInternal;\nimport android.permission.PermissionManager;\nimport android.provider.Settings;\nimport android.util.ArrayMap;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.KeyValueListParser;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.TimeUtils;\nimport android.util.Xml;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.Immutable;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.IAppOpsActiveCallback;\nimport com.android.internal.app.IAppOpsAsyncNotedCallback;\nimport com.android.internal.app.IAppOpsCallback;\nimport com.android.internal.app.IAppOpsNotedCallback;\nimport com.android.internal.app.IAppOpsService;\nimport com.android.internal.app.IAppOpsStartedCallback;\nimport com.android.internal.app.MessageSamplingConfig;\nimport com.android.internal.compat.IPlatformCompat;\nimport com.android.internal.os.Clock;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.Preconditions;\nimport com.android.internal.util.XmlUtils;\nimport com.android.internal.util.function.pooled.PooledLambda;\nimport com.android.modules.utils.TypedXmlPullParser;\nimport com.android.modules.utils.TypedXmlSerializer;\nimport com.android.server.LocalManagerRegistry;\nimport com.android.server.LocalServices;\nimport com.android.server.LockGuard;\nimport com.android.server.SystemServerInitThreadPool;\nimport com.android.server.SystemServiceManager;\nimport com.android.server.pm.PackageList;\nimport com.android.server.pm.PackageManagerLocal;\nimport com.android.server.pm.UserManagerInternal;\nimport com.android.server.pm.pkg.AndroidPackage;\nimport com.android.server.pm.pkg.PackageState;\nimport com.android.server.pm.pkg.component.ParsedAttribution;\nimport com.android.server.policy.AppOpsPolicy;\n\nimport dalvik.annotation.optimization.NeverCompile;\n\nimport libcore.util.EmptyArray;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Consumer;\n\npublic class AppOpsService extends IAppOpsService.Stub {\n    static final String TAG = \"AppOps\";\n    static final boolean DEBUG = false;\n\n    /**\n     * Used for data access validation collection, we wish to only log a specific access once\n     */\n    private final ArraySet<NoteOpTrace> mNoteOpCallerStacktraces = new ArraySet<>();\n\n    /**\n     * Version of the mRecentAccessesFile.\n     * Increment by one every time an upgrade step is added at boot, none currently exists.\n     */\n    private static final int CURRENT_VERSION = 1;\n\n    // Write at most every 30 minutes.\n    static final long WRITE_DELAY = DEBUG ? 1000 : 30*60*1000;\n\n    // Constant meaning that any UID should be matched when dispatching callbacks\n    private static final int UID_ANY = -2;\n\n    private static final int[] OPS_RESTRICTED_ON_SUSPEND = {\n            OP_PLAY_AUDIO,\n            OP_RECORD_AUDIO,\n            OP_CAMERA,\n            OP_VIBRATE,\n    };\n\n    private static final int MAX_UNFORWARDED_OPS = 10;\n    private static final int MAX_UNUSED_POOLED_OBJECTS = 3;\n    private static final int RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS = 300000;\n\n    final Context mContext;\n    final AtomicFile mStorageFile;\n    final AtomicFile mRecentAccessesFile;\n    private final @Nullable File mNoteOpCallerStacktracesFile;\n    final Handler mHandler;\n\n    /**\n     * Pool for {@link AttributedOp.OpEventProxyInfoPool} to avoid to constantly reallocate new\n     * objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.OpEventProxyInfoPool mOpEventProxyInfoPool =\n            new AttributedOp.OpEventProxyInfoPool(MAX_UNUSED_POOLED_OBJECTS);\n\n    /**\n     * Pool for {@link AttributedOp.InProgressStartOpEventPool} to avoid to constantly reallocate\n     * new objects\n     */\n    @GuardedBy(\"this\")\n    final AttributedOp.InProgressStartOpEventPool mInProgressStartOpEventPool =\n            new AttributedOp.InProgressStartOpEventPool(mOpEventProxyInfoPool,\n                    MAX_UNUSED_POOLED_OBJECTS);\n\n    private final AppOpsManagerInternalImpl mAppOpsManagerInternal\n            = new AppOpsManagerInternalImpl();\n    @Nullable private final DevicePolicyManagerInternal dpmi =\n            LocalServices.getService(DevicePolicyManagerInternal.class);\n\n    private final IPlatformCompat mPlatformCompat = IPlatformCompat.Stub.asInterface(\n            ServiceManager.getService(Context.PLATFORM_COMPAT_SERVICE));\n\n    /**\n     * Registered callbacks, called from {@link #collectAsyncNotedOp}.\n     *\n     * <p>(package name, uid) -> callbacks\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, RemoteCallbackList<IAppOpsAsyncNotedCallback>>\n            mAsyncOpWatchers = new ArrayMap<>();\n\n    /**\n     * Async note-ops collected from {@link #collectAsyncNotedOp} that have not been delivered to a\n     * callback yet.\n     *\n     * <p>(package name, uid) -> list&lt;ops&gt;\n     *\n     * @see #getAsyncNotedOpsKey(String, int)\n     */\n    @GuardedBy(\"this\")\n    private final ArrayMap<Pair<String, Integer>, ArrayList<AsyncNotedAppOp>>\n            mUnforwardedAsyncNotedOps = new ArrayMap<>();\n\n    boolean mWriteNoteOpsScheduled;\n\n    boolean mWriteScheduled;\n    boolean mFastWriteScheduled;\n    final Runnable mWriteRunner = new Runnable() {\n        public void run() {\n            synchronized (AppOpsService.this) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {\n                    @Override protected Void doInBackground(Void... params) {\n                        writeRecentAccesses();\n                        return null;\n                    }\n                };\n                task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);\n            }\n        }\n    };\n\n    @GuardedBy(\"this\")\n    @VisibleForTesting\n    final SparseArray<UidState> mUidStates = new SparseArray<>();\n\n    volatile @NonNull HistoricalRegistry mHistoricalRegistry = new HistoricalRegistry(this);\n\n    /*\n     * These are app op restrictions imposed per user from various parties.\n     */\n    private final ArrayMap<IBinder, ClientUserRestrictionState> mOpUserRestrictions =\n            new ArrayMap<>();\n\n    /*\n     * These are app op restrictions imposed globally from various parties within the system.\n     */\n    private final ArrayMap<IBinder, ClientGlobalRestrictionState> mOpGlobalRestrictions =\n            new ArrayMap<>();\n\n    SparseIntArray mProfileOwners;\n\n    private volatile CheckOpsDelegateDispatcher mCheckOpsDelegateDispatcher =\n            new CheckOpsDelegateDispatcher(/*policy*/ null, /*delegate*/ null);\n\n    /**\n      * Reverse lookup for {@link AppOpsManager#opToSwitch(int)}. Initialized once and never\n      * changed\n      */\n    private final SparseArray<int[]> mSwitchedOps = new SparseArray<>();\n\n    private ActivityManagerInternal mActivityManagerInternal;\n\n    /** Package sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private String mSampledPackage = null;\n\n    /** Appop sampled for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mSampledAppOpCode = OP_NONE;\n\n    /** Maximum distance for appop to be considered for message collection in the current session */\n    @GuardedBy(\"this\")\n    private int mAcceptableLeftDistance = 0;\n\n    /** Number of messages collected for sampled package and appop in the current session */\n    @GuardedBy(\"this\")\n    private float mMessagesCollectedCount;\n\n    /** List of rarely used packages priorities for message collection */\n    @GuardedBy(\"this\")\n    private ArraySet<String> mRarelyUsedPackages = new ArraySet<>();\n\n    /** Sampling strategy used for current session */\n    @GuardedBy(\"this\")\n    @AppOpsManager.SamplingStrategy\n    private int mSamplingStrategy;\n\n    /** Last runtime permission access message collected and ready for reporting */\n    @GuardedBy(\"this\")\n    private RuntimeAppOpAccessMessage mCollectedRuntimePermissionMessage;\n\n    /** Package Manager internal. Access via {@link #getPackageManagerInternal()} */\n    private @Nullable PackageManagerInternal mPackageManagerInternal;\n\n    /** Package Manager local. Access via {@link #getPackageManagerLocal()} */\n    private @Nullable PackageManagerLocal mPackageManagerLocal;\n\n    /** User Manager internal. Access via {@link #getUserManagerInternal()} */\n    private @Nullable UserManagerInternal mUserManagerInternal;\n\n    /** Interface for app-op modes.*/\n    @VisibleForTesting\n    AppOpsCheckingServiceInterface mAppOpsCheckingService;\n\n    /** Interface for app-op restrictions.*/\n    @VisibleForTesting AppOpsRestrictions mAppOpsRestrictions;\n\n    private AppOpsUidStateTracker mUidStateTracker;\n\n    /** Hands the definition of foreground and uid states */\n    @GuardedBy(\"this\")\n    public AppOpsUidStateTracker getUidStateTracker() {\n        if (mUidStateTracker == null) {\n            mUidStateTracker = new AppOpsUidStateTrackerImpl(\n                    LocalServices.getService(ActivityManagerInternal.class),\n                    mHandler,\n                    r -> {\n                        synchronized (AppOpsService.this) {\n                            r.run();\n                        }\n                    },\n                    Clock.SYSTEM_CLOCK, mConstants);\n\n            mUidStateTracker.addUidStateChangedCallback(new HandlerExecutor(mHandler),\n                    this::onUidStateChanged);\n        }\n        return mUidStateTracker;\n    }\n\n    /**\n     * All times are in milliseconds. These constants are kept synchronized with the system\n     * global Settings. Any access to this class or its fields should be done while\n     * holding the AppOpsService lock.\n     */\n    final class Constants extends ContentObserver {\n\n        /**\n         * How long we want for a drop in uid state from top to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_TOP_STATE_SETTLE_TIME\n         */\n        public long TOP_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from foreground to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_FG_SERVICE_STATE_SETTLE_TIME\n         */\n        public long FG_SERVICE_STATE_SETTLE_TIME;\n\n        /**\n         * How long we want for a drop in uid state from background to settle before applying it.\n         * @see Settings.Global#APP_OPS_CONSTANTS\n         * @see AppOpsManager#KEY_BG_STATE_SETTLE_TIME\n         */\n        public long BG_STATE_SETTLE_TIME;\n\n        private final KeyValueListParser mParser = new KeyValueListParser(',');\n        private ContentResolver mResolver;\n\n        public Constants(Handler handler) {\n            super(handler);\n            updateConstants();\n        }\n\n        public void startMonitoring(ContentResolver resolver) {\n            mResolver = resolver;\n            mResolver.registerContentObserver(\n                    Settings.Global.getUriFor(Settings.Global.APP_OPS_CONSTANTS),\n                    false, this);\n            updateConstants();\n        }\n\n        @Override\n        public void onChange(boolean selfChange, Uri uri) {\n            updateConstants();\n        }\n\n        private void updateConstants() {\n            String value = mResolver != null ? Settings.Global.getString(mResolver,\n                    Settings.Global.APP_OPS_CONSTANTS) : \"\";\n\n            synchronized (AppOpsService.this) {\n                try {\n                    mParser.setString(value);\n                } catch (IllegalArgumentException e) {\n                    // Failed to parse the settings string, log this and move on\n                    // with defaults.\n                    Slog.e(TAG, \"Bad app ops settings\", e);\n                }\n                TOP_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_TOP_STATE_SETTLE_TIME, 5 * 1000L);\n                FG_SERVICE_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_FG_SERVICE_STATE_SETTLE_TIME, 5 * 1000L);\n                BG_STATE_SETTLE_TIME = mParser.getDurationMillis(\n                        KEY_BG_STATE_SETTLE_TIME, 1 * 1000L);\n            }\n        }\n\n        void dump(PrintWriter pw) {\n            pw.println(\"  Settings:\");\n\n            pw.print(\"    \"); pw.print(KEY_TOP_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(TOP_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_FG_SERVICE_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(FG_SERVICE_STATE_SETTLE_TIME, pw);\n            pw.println();\n            pw.print(\"    \"); pw.print(KEY_BG_STATE_SETTLE_TIME); pw.print(\"=\");\n            TimeUtils.formatDuration(BG_STATE_SETTLE_TIME, pw);\n            pw.println();\n        }\n    }\n\n    @VisibleForTesting\n    final Constants mConstants;\n\n    @VisibleForTesting\n    final class UidState {\n        public final int uid;\n\n        @NonNull\n        public final ArrayMap<String, Ops> pkgOps = new ArrayMap<>();\n\n        // true indicates there is an interested observer, false there isn't but it has such an op\n        //TODO: Move foregroundOps and hasForegroundWatchers into the AppOpsServiceInterface.\n        public SparseBooleanArray foregroundOps;\n        public boolean hasForegroundWatchers;\n\n        public UidState(int uid) {\n            this.uid = uid;\n        }\n\n        public void clear() {\n            mAppOpsCheckingService.removeUid(uid);\n            for (int i = 0; i < pkgOps.size(); i++) {\n                String packageName = pkgOps.keyAt(i);\n                mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            }\n        }\n\n        // Functions for uid mode access and manipulation.\n        public SparseIntArray getNonDefaultUidModes() {\n            return mAppOpsCheckingService.getNonDefaultUidModes(uid);\n        }\n\n        public int getUidMode(int op) {\n            return mAppOpsCheckingService.getUidMode(uid, op);\n        }\n\n        public boolean setUidMode(int op, int mode) {\n            return mAppOpsCheckingService.setUidMode(uid, op, mode);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        int evalMode(int op, int mode) {\n            return getUidStateTracker().evalMode(uid, op, mode);\n        }\n\n        public void evalForegroundOps() {\n            foregroundOps = null;\n            foregroundOps = mAppOpsCheckingService.evalForegroundUidOps(uid, foregroundOps);\n            for (int i = pkgOps.size() - 1; i >= 0; i--) {\n                foregroundOps = mAppOpsCheckingService\n                        .evalForegroundPackageOps(pkgOps.valueAt(i).packageName, foregroundOps,\n                                UserHandle.getUserId(uid));\n            }\n            hasForegroundWatchers = false;\n            if (foregroundOps != null) {\n                for (int i = 0;  i < foregroundOps.size(); i++) {\n                    if (foregroundOps.valueAt(i)) {\n                        hasForegroundWatchers = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public int getState() {\n            return getUidStateTracker().getUidState(uid);\n        }\n\n        @SuppressWarnings(\"GuardedBy\")\n        public void dump(PrintWriter pw, long nowElapsed) {\n            getUidStateTracker().dumpUidState(pw, uid, nowElapsed);\n        }\n    }\n\n    final static class Ops extends SparseArray<Op> {\n        final String packageName;\n        final UidState uidState;\n\n        /**\n         * The restriction properties of the package. If {@code null} it could not have been read\n         * yet and has to be refreshed.\n         */\n        @Nullable RestrictionBypass bypass;\n\n        /** Lazily populated cache of attributionTags of this package */\n        final @NonNull ArraySet<String> knownAttributionTags = new ArraySet<>();\n\n        /**\n         * Lazily populated cache of <b>valid</b> attributionTags of this package, a set smaller\n         * than or equal to {@link #knownAttributionTags}.\n         */\n        final @NonNull ArraySet<String> validAttributionTags = new ArraySet<>();\n\n        Ops(String _packageName, UidState _uidState) {\n            packageName = _packageName;\n            uidState = _uidState;\n        }\n    }\n\n    /** Returned from {@link #verifyAndGetBypass(int, String, String, int, String, boolean)}. */\n    private static final class PackageVerificationResult {\n\n        final RestrictionBypass bypass;\n        final boolean isAttributionTagValid;\n\n        PackageVerificationResult(RestrictionBypass bypass, boolean isAttributionTagValid) {\n            this.bypass = bypass;\n            this.isAttributionTagValid = isAttributionTagValid;\n        }\n    }\n\n    final class Op {\n        int op;\n        int uid;\n        final UidState uidState;\n        final @NonNull String packageName;\n\n        /** attributionTag -> AttributedOp */\n        final ArrayMap<String, AttributedOp> mAttributions = new ArrayMap<>(1);\n\n        Op(UidState uidState, String packageName, int op, int uid) {\n            this.op = op;\n            this.uid = uid;\n            this.uidState = uidState;\n            this.packageName = packageName;\n        }\n\n        @Mode int getMode() {\n            return mAppOpsCheckingService.getPackageMode(packageName, this.op,\n                    UserHandle.getUserId(this.uid));\n        }\n        void setMode(@Mode int mode) {\n            mAppOpsCheckingService.setPackageMode(packageName, this.op, mode,\n                    UserHandle.getUserId(this.uid));\n        }\n\n        void removeAttributionsWithNoTime() {\n            for (int i = mAttributions.size() - 1; i >= 0; i--) {\n                if (!mAttributions.valueAt(i).hasAnyTime()) {\n                    mAttributions.removeAt(i);\n                }\n            }\n        }\n\n        private @NonNull AttributedOp getOrCreateAttribution(@NonNull Op parent,\n                @Nullable String attributionTag) {\n            AttributedOp attributedOp;\n\n            attributedOp = mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                attributedOp = new AttributedOp(AppOpsService.this, attributionTag, parent);\n                mAttributions.put(attributionTag, attributedOp);\n            }\n\n            return attributedOp;\n        }\n\n        @NonNull OpEntry createEntryLocked() {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AppOpsManager.AttributedOpEntry> attributionEntries =\n                    new ArrayMap<>(numAttributions);\n            for (int i = 0; i < numAttributions; i++) {\n                attributionEntries.put(mAttributions.keyAt(i),\n                        mAttributions.valueAt(i).createAttributedOpEntryLocked());\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        @NonNull OpEntry createSingleAttributionEntryLocked(@Nullable String attributionTag) {\n            final int numAttributions = mAttributions.size();\n\n            final ArrayMap<String, AttributedOpEntry> attributionEntries = new ArrayMap<>(1);\n            for (int i = 0; i < numAttributions; i++) {\n                if (Objects.equals(mAttributions.keyAt(i), attributionTag)) {\n                    attributionEntries.put(mAttributions.keyAt(i),\n                            mAttributions.valueAt(i).createAttributedOpEntryLocked());\n                    break;\n                }\n            }\n\n            return new OpEntry(op, getMode(), attributionEntries);\n        }\n\n        boolean isRunning() {\n            final int numAttributions = mAttributions.size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (mAttributions.valueAt(i).isRunning()) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    final ArrayMap<IBinder, ModeCallback> mModeWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<ActiveCallback>> mActiveWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<StartedCallback>> mStartedWatchers = new ArrayMap<>();\n    final ArrayMap<IBinder, SparseArray<NotedCallback>> mNotedWatchers = new ArrayMap<>();\n    final AudioRestrictionManager mAudioRestrictionManager = new AudioRestrictionManager();\n\n    final class ModeCallback extends OnOpModeChangedListener implements DeathRecipient  {\n        /** If mWatchedOpCode==ALL_OPS notify for ops affected by the switch-op */\n        public static final int ALL_OPS = -2;\n\n        // Need to keep this only because stopWatchingMode needs an IAppOpsCallback.\n        // Otherwise we can just use the IBinder object.\n        private final IAppOpsCallback mCallback;\n\n        ModeCallback(IAppOpsCallback callback, int watchingUid, int flags, int watchedOpCode,\n                int callingUid, int callingPid) {\n            super(watchingUid, flags, watchedOpCode, callingUid, callingPid);\n            this.mCallback = callback;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ModeCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, getWatchingUid());\n            sb.append(\" flags=0x\");\n            sb.append(Integer.toHexString(getFlags()));\n            switch (getWatchedOpCode()) {\n                case OP_NONE:\n                    break;\n                case ALL_OPS:\n                    sb.append(\" op=(all)\");\n                    break;\n                default:\n                    sb.append(\" op=\");\n                    sb.append(opToName(getWatchedOpCode()));\n                    break;\n            }\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, getCallingUid());\n            sb.append(\" pid=\");\n            sb.append(getCallingPid());\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void unlinkToDeath() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingMode(mCallback);\n        }\n\n        @Override\n        public void onOpModeChanged(int op, int uid, String packageName) throws RemoteException {\n            mCallback.opChanged(op, uid, packageName);\n        }\n    }\n\n    final class ActiveCallback implements DeathRecipient {\n        final IAppOpsActiveCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        ActiveCallback(IAppOpsActiveCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"ActiveCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingActive(mCallback);\n        }\n    }\n\n    final class StartedCallback implements DeathRecipient {\n        final IAppOpsStartedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        StartedCallback(IAppOpsStartedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"StartedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingStarted(mCallback);\n        }\n    }\n\n    final class NotedCallback implements DeathRecipient {\n        final IAppOpsNotedCallback mCallback;\n        final int mWatchingUid;\n        final int mCallingUid;\n        final int mCallingPid;\n\n        NotedCallback(IAppOpsNotedCallback callback, int watchingUid, int callingUid,\n                int callingPid) {\n            mCallback = callback;\n            mWatchingUid = watchingUid;\n            mCallingUid = callingUid;\n            mCallingPid = callingPid;\n            try {\n                mCallback.asBinder().linkToDeath(this, 0);\n            } catch (RemoteException e) {\n                /*ignored*/\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder(128);\n            sb.append(\"NotedCallback{\");\n            sb.append(Integer.toHexString(System.identityHashCode(this)));\n            sb.append(\" watchinguid=\");\n            UserHandle.formatUid(sb, mWatchingUid);\n            sb.append(\" from uid=\");\n            UserHandle.formatUid(sb, mCallingUid);\n            sb.append(\" pid=\");\n            sb.append(mCallingPid);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        void destroy() {\n            mCallback.asBinder().unlinkToDeath(this, 0);\n        }\n\n        @Override\n        public void binderDied() {\n            stopWatchingNoted(mCallback);\n        }\n    }\n\n    /**\n     * Call {@link AttributedOp#onClientDeath attributedOp.onClientDeath(clientId)}.\n     */\n    static void onClientDeath(@NonNull AttributedOp attributedOp,\n            @NonNull IBinder clientId) {\n        attributedOp.onClientDeath(clientId);\n    }\n\n\n    /**\n     * Loads the OpsValidation file results into a hashmap {@link #mNoteOpCallerStacktraces}\n     * so that we do not log the same operation twice between instances\n     */\n    private void readNoteOpCallerStackTraces() {\n        try {\n            if (!mNoteOpCallerStacktracesFile.exists()) {\n                mNoteOpCallerStacktracesFile.createNewFile();\n                return;\n            }\n\n            try (Scanner read = new Scanner(mNoteOpCallerStacktracesFile)) {\n                read.useDelimiter(\"\\\\},\");\n                while (read.hasNext()) {\n                    String jsonOps = read.next();\n                    mNoteOpCallerStacktraces.add(NoteOpTrace.fromJson(jsonOps));\n                }\n            }\n        } catch (Exception e) {\n            Slog.e(TAG, \"Cannot parse traces noteOps\", e);\n        }\n    }\n\n    @VisibleForTesting\n    public AppOpsService(File recentAccessesFile, File storageFile, Handler handler,\n            Context context) {\n        mContext = context;\n\n        for (int switchedCode = 0; switchedCode < _NUM_OP; switchedCode++) {\n            int switchCode = AppOpsManager.opToSwitch(switchedCode);\n            mSwitchedOps.put(switchCode,\n                    ArrayUtils.appendInt(mSwitchedOps.get(switchCode), switchedCode));\n        }\n        mAppOpsCheckingService = new AppOpsCheckingServiceTracingDecorator(\n                new AppOpsCheckingServiceImpl(\n                        storageFile, this, handler, context,  mSwitchedOps));\n        //mAppOpsCheckingService = new AppOpsCheckingServiceLoggingDecorator(\n        //        LocalServices.getService(AppOpsCheckingServiceInterface.class));\n        mAppOpsRestrictions = new AppOpsRestrictionsImpl(context, handler, mAppOpsCheckingService);\n\n        LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);\n        mStorageFile = new AtomicFile(storageFile, \"appops_legacy\");\n        mRecentAccessesFile = new AtomicFile(recentAccessesFile, \"appops_accesses\");\n\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            mNoteOpCallerStacktracesFile = new File(SystemServiceManager.ensureSystemDir(),\n                    \"noteOpStackTraces.json\");\n            readNoteOpCallerStackTraces();\n        } else {\n            mNoteOpCallerStacktracesFile = null;\n        }\n        mHandler = handler;\n        mConstants = new Constants(mHandler);\n        // To migrate storageFile to recentAccessesFile, these reads must be called in this order.\n        readRecentAccesses();\n        mAppOpsCheckingService.readState();\n    }\n\n    public void publish() {\n        ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());\n        LocalServices.addService(AppOpsManagerInternal.class, mAppOpsManagerInternal);\n        LocalManagerRegistry.addManager(AppOpsManagerLocal.class, new AppOpsManagerLocalImpl());\n    }\n\n    /** Handler for work when packages are updated */\n    private BroadcastReceiver mOnPackageUpdatedReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            String pkgName = intent.getData().getEncodedSchemeSpecificPart();\n            int uid = intent.getIntExtra(Intent.EXTRA_UID, Process.INVALID_UID);\n\n            if (action.equals(Intent.ACTION_PACKAGE_REPLACED)) {\n                AndroidPackage pkg = getPackageManagerInternal().getPackage(pkgName);\n                if (pkg == null) {\n                    return;\n                }\n\n                ArrayMap<String, String> dstAttributionTags = new ArrayMap<>();\n                ArraySet<String> attributionTags = new ArraySet<>();\n                attributionTags.add(null);\n                if (pkg.getAttributions() != null) {\n                    int numAttributions = pkg.getAttributions().size();\n                    for (int attributionNum = 0; attributionNum < numAttributions;\n                            attributionNum++) {\n                        ParsedAttribution attribution = pkg.getAttributions().get(attributionNum);\n                        attributionTags.add(attribution.getTag());\n\n                        int numInheritFrom = attribution.getInheritFrom().size();\n                        for (int inheritFromNum = 0; inheritFromNum < numInheritFrom;\n                                inheritFromNum++) {\n                            dstAttributionTags.put(attribution.getInheritFrom().get(inheritFromNum),\n                                    attribution.getTag());\n                        }\n                    }\n                }\n\n                synchronized (AppOpsService.this) {\n                    UidState uidState = mUidStates.get(uid);\n                    if (uidState == null) {\n                        return;\n                    }\n\n                    Ops ops = uidState.pkgOps.get(pkgName);\n                    if (ops == null) {\n                        return;\n                    }\n\n                    // Reset cached package properties to re-initialize when needed\n                    ops.bypass = null;\n                    ops.knownAttributionTags.clear();\n\n                    // Merge data collected for removed attributions into their successor\n                    // attributions\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = numAttributions - 1; attributionNum >= 0;\n                                attributionNum--) {\n                            String attributionTag = op.mAttributions.keyAt(attributionNum);\n\n                            if (attributionTags.contains(attributionTag)) {\n                                // attribution still exist after upgrade\n                                continue;\n                            }\n\n                            String newAttributionTag = dstAttributionTags.get(attributionTag);\n\n                            AttributedOp newAttributedOp = op.getOrCreateAttribution(op,\n                                    newAttributionTag);\n                            newAttributedOp.add(op.mAttributions.valueAt(attributionNum));\n                            op.mAttributions.removeAt(attributionNum);\n\n                            scheduleFastWriteLocked();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    public void systemReady() {\n        mAppOpsCheckingService.systemReady();\n        initializeUidStates();\n\n        mConstants.startMonitoring(mContext.getContentResolver());\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n\n        IntentFilter packageUpdateFilter = new IntentFilter();\n        packageUpdateFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);\n        packageUpdateFilter.addDataScheme(\"package\");\n\n        mContext.registerReceiverAsUser(mOnPackageUpdatedReceiver, UserHandle.ALL,\n                packageUpdateFilter, null, null);\n\n        synchronized (this) {\n            for (int uidNum = mUidStates.size() - 1; uidNum >= 0; uidNum--) {\n                int uid = mUidStates.keyAt(uidNum);\n                UidState uidState = mUidStates.valueAt(uidNum);\n\n                String[] pkgsInUid = getPackagesForUid(uidState.uid);\n                if (ArrayUtils.isEmpty(pkgsInUid)) {\n                    uidState.clear();\n                    mUidStates.removeAt(uidNum);\n                    scheduleFastWriteLocked();\n                    continue;\n                }\n\n                ArrayMap<String, Ops> pkgs = uidState.pkgOps;\n\n                int numPkgs = pkgs.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    String pkg = pkgs.keyAt(pkgNum);\n\n                    String action;\n                    if (!ArrayUtils.contains(pkgsInUid, pkg)) {\n                        action = Intent.ACTION_PACKAGE_REMOVED;\n                    } else {\n                        action = Intent.ACTION_PACKAGE_REPLACED;\n                    }\n\n                    SystemServerInitThreadPool.submit(\n                            () -> mOnPackageUpdatedReceiver.onReceive(mContext, new Intent(action)\n                                    .setData(Uri.fromParts(\"package\", pkg, null))\n                                    .putExtra(Intent.EXTRA_UID, uid)),\n                            \"Update app-ops uidState in case package \" + pkg + \" changed\");\n                }\n            }\n        }\n\n        getUserManagerInternal().addUserLifecycleListener(\n                new UserManagerInternal.UserLifecycleListener() {\n                    @Override\n                    public void onUserCreated(UserInfo user, Object token) {\n                        initializeUserUidStates(user.id);\n                    }\n\n                    // onUserRemoved handled by #removeUser\n                });\n\n        getPackageManagerInternal().getPackageList(\n                new PackageManagerInternal.PackageListObserver() {\n                    @Override\n                    public void onPackageAdded(String packageName, int appId) {\n                        PackageInfo pi = getPackageManagerInternal().getPackageInfo(packageName,\n                                PackageManager.GET_PERMISSIONS, Process.myUid(),\n                                mContext.getUserId());\n                        boolean isSamplingTarget = isSamplingTarget(pi);\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            if (isSamplingTarget) {\n                                mRarelyUsedPackages.add(packageName);\n                            }\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                UidState uidState = getUidStateLocked(uid, true);\n                                if (!uidState.pkgOps.containsKey(packageName)) {\n                                    uidState.pkgOps.put(packageName,\n                                            new Ops(packageName, uidState));\n                                }\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onPackageRemoved(String packageName, int appId) {\n                        int[] userIds = getUserManagerInternal().getUserIds();\n                        synchronized (AppOpsService.this) {\n                            for (int i = 0; i < userIds.length; i++) {\n                                int uid = UserHandle.getUid(userIds[i], appId);\n                                packageRemovedLocked(uid, packageName);\n                            }\n                        }\n                    }\n                });\n\n        final IntentFilter packageSuspendFilter = new IntentFilter();\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        packageSuspendFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int[] changedUids = intent.getIntArrayExtra(Intent.EXTRA_CHANGED_UID_LIST);\n                final String[] changedPkgs = intent.getStringArrayExtra(\n                        Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                for (int code : OPS_RESTRICTED_ON_SUSPEND) {\n                    ArraySet<OnOpModeChangedListener> onModeChangedListeners;\n                    synchronized (AppOpsService.this) {\n                        onModeChangedListeners =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (onModeChangedListeners == null) {\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < changedUids.length; i++) {\n                        final int changedUid = changedUids[i];\n                        final String changedPkg = changedPkgs[i];\n                        // We trust packagemanager to insert matching uid and packageNames in the\n                        // extras\n                        notifyOpChanged(onModeChangedListeners, code, changedUid, changedPkg);\n                    }\n                }\n            }\n        }, UserHandle.ALL, packageSuspendFilter, null, null);\n\n        mHandler.postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                List<String> packageNames = getPackageListAndResample();\n                initializeRarelyUsedPackagesList(new ArraySet<>(packageNames));\n            }\n        }, RARELY_USED_PACKAGES_INITIALIZATION_DELAY_MILLIS);\n\n        getPackageManagerInternal().setExternalSourcesPolicy(\n                new PackageManagerInternal.ExternalSourcesPolicy() {\n                    @Override\n                    public int getPackageTrustedToInstallApps(String packageName, int uid) {\n                        int appOpMode = checkOperation(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                                uid, packageName);\n                        switch (appOpMode) {\n                            case AppOpsManager.MODE_ALLOWED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_TRUSTED;\n                            case AppOpsManager.MODE_ERRORED:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_BLOCKED;\n                            default:\n                                return PackageManagerInternal.ExternalSourcesPolicy.USER_DEFAULT;\n                        }\n                    }\n                });\n\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n    }\n\n    /**\n     * Initialize uid state objects for state contained in the checking service.\n     */\n    @VisibleForTesting\n    void initializeUidStates() {\n        UserManagerInternal umi = getUserManagerInternal();\n        synchronized (this) {\n            int[] userIds = umi.getUserIds();\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                         getPackageManagerLocal().withUnfilteredSnapshot()) {\n                Map<String, PackageState> packageStates = snapshot.getPackageStates();\n                for (int i = 0; i < userIds.length; i++) {\n                    int userId = userIds[i];\n                    initializeUserUidStatesLocked(userId, packageStates);\n                }\n            }\n        }\n    }\n\n    private void initializeUserUidStates(int userId) {\n        synchronized (this) {\n            try (PackageManagerLocal.UnfilteredSnapshot snapshot =\n                    getPackageManagerLocal().withUnfilteredSnapshot()) {\n                initializeUserUidStatesLocked(userId, snapshot.getPackageStates());\n            }\n        }\n    }\n\n    private void initializeUserUidStatesLocked(int userId, Map<String,\n            PackageState> packageStates) {\n        for (Map.Entry<String, PackageState> entry : packageStates.entrySet()) {\n            int appId = entry.getValue().getAppId();\n            String packageName = entry.getKey();\n\n            initializePackageUidStateLocked(userId, appId, packageName);\n        }\n    }\n\n    /*\n      Be careful not to clear any existing data; only want to add objects that don't already exist.\n     */\n    private void initializePackageUidStateLocked(int userId, int appId, String packageName) {\n        int uid = UserHandle.getUid(userId, appId);\n        UidState uidState = getUidStateLocked(uid, true);\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        SparseIntArray packageModes =\n                mAppOpsCheckingService.getNonDefaultPackageModes(packageName, userId);\n        for (int k = 0; k < packageModes.size(); k++) {\n            int code = packageModes.keyAt(k);\n\n            if (ops.indexOfKey(code) < 0) {\n                ops.put(code, new Op(uidState, packageName, code, uid));\n            }\n        }\n\n        uidState.evalForegroundOps();\n    }\n\n    /**\n     * Sets a policy for handling app ops.\n     *\n     * @param policy The policy.\n     */\n    public void setAppOpsPolicy(@Nullable CheckOpsDelegate policy) {\n        final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n        final CheckOpsDelegate delegate = (oldDispatcher != null)\n                ? oldDispatcher.mCheckOpsDelegate : null;\n        mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n    }\n\n    @VisibleForTesting\n    void packageRemoved(int uid, String packageName) {\n        synchronized (this) {\n            packageRemovedLocked(uid, packageName);\n        }\n    }\n\n    @GuardedBy(\"this\")\n    private void packageRemovedLocked(int uid, String packageName) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        Ops removedOps = null;\n\n        // Remove any package state if such.\n        removedOps = uidState.pkgOps.remove(packageName);\n        mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n\n        if (removedOps != null) {\n            scheduleFastWriteLocked();\n\n            final int numOps = removedOps.size();\n            for (int opNum = 0; opNum < numOps; opNum++) {\n                final Op op = removedOps.valueAt(opNum);\n\n                final int numAttributions = op.mAttributions.size();\n                for (int attributionNum = 0; attributionNum < numAttributions;\n                        attributionNum++) {\n                    AttributedOp attributedOp = op.mAttributions.valueAt(attributionNum);\n\n                    while (attributedOp.isRunning()) {\n                        attributedOp.finished(attributedOp.mInProgressEvents.keyAt(0));\n                    }\n                    while (attributedOp.isPaused()) {\n                        attributedOp.finished(attributedOp.mPausedInProgressEvents.keyAt(0));\n                    }\n                }\n            }\n        }\n\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::clearHistory,\n                    mHistoricalRegistry, uid, packageName));\n    }\n\n    public void uidRemoved(int uid) {\n        synchronized (this) {\n            if (mUidStates.indexOfKey(uid) >= 0) {\n                mUidStates.get(uid).clear();\n                mUidStates.remove(uid);\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    // The callback method from AppOpsUidStateTracker\n    private void onUidStateChanged(int uid, int state, boolean foregroundModeMayChange) {\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, true);\n\n            if (uidState != null && foregroundModeMayChange && uidState.hasForegroundWatchers) {\n                for (int fgi = uidState.foregroundOps.size() - 1; fgi >= 0; fgi--) {\n                    if (!uidState.foregroundOps.valueAt(fgi)) {\n                        continue;\n                    }\n                    final int code = uidState.foregroundOps.keyAt(fgi);\n\n                    if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)\n                            && uidState.getUidMode(code) == AppOpsManager.MODE_FOREGROUND) {\n                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                AppOpsService::notifyOpChangedForAllPkgsInUid,\n                                this, code, uidState.uid, true, null));\n                    } else if (!uidState.pkgOps.isEmpty()) {\n                        final ArraySet<OnOpModeChangedListener> listenerSet =\n                                mAppOpsCheckingService.getOpModeChangedListeners(code);\n                        if (listenerSet != null) {\n                            for (int cbi = listenerSet.size() - 1; cbi >= 0; cbi--) {\n                                final OnOpModeChangedListener listener = listenerSet.valueAt(cbi);\n                                if ((listener.getFlags()\n                                        & AppOpsManager.WATCH_FOREGROUND_CHANGES) == 0\n                                        || !listener.isWatchingUid(uidState.uid)) {\n                                    continue;\n                                }\n                                for (int pkgi = uidState.pkgOps.size() - 1; pkgi >= 0; pkgi--) {\n                                    final Op op = uidState.pkgOps.valueAt(pkgi).get(code);\n                                    if (op == null) {\n                                        continue;\n                                    }\n                                    if (op.getMode() == AppOpsManager.MODE_FOREGROUND) {\n                                        mHandler.sendMessage(PooledLambda.obtainMessage(\n                                                AppOpsService::notifyOpChanged,\n                                                this, listenerSet.valueAt(cbi), code, uidState.uid,\n                                                uidState.pkgOps.keyAt(pkgi)));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (uidState != null) {\n                int numPkgs = uidState.pkgOps.size();\n                for (int pkgNum = 0; pkgNum < numPkgs; pkgNum++) {\n                    Ops ops = uidState.pkgOps.valueAt(pkgNum);\n\n                    int numOps = ops.size();\n                    for (int opNum = 0; opNum < numOps; opNum++) {\n                        Op op = ops.valueAt(opNum);\n\n                        int numAttributions = op.mAttributions.size();\n                        for (int attributionNum = 0; attributionNum < numAttributions;\n                                attributionNum++) {\n                            AttributedOp attributedOp = op.mAttributions.valueAt(\n                                    attributionNum);\n\n                            attributedOp.onUidStateChanged(state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Notify the proc state or capability has changed for a certain UID.\n     */\n    public void updateUidProcState(int uid, int procState,\n            @ActivityManager.ProcessCapability int capability) {\n        synchronized (this) {\n            getUidStateTracker().updateUidProcState(uid, procState, capability);\n            if (!mUidStates.contains(uid)) {\n                UidState uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n                onUidStateChanged(uid,\n                        AppOpsUidStateTracker.processStateToUidState(procState), false);\n            }\n        }\n    }\n\n    public void shutdown() {\n        Slog.w(TAG, \"Writing app ops before shutdown...\");\n        boolean doWrite = false;\n        synchronized (this) {\n            if (mWriteScheduled) {\n                mWriteScheduled = false;\n                mFastWriteScheduled = false;\n                mHandler.removeCallbacks(mWriteRunner);\n                doWrite = true;\n            }\n        }\n        if (doWrite) {\n            writeRecentAccesses();\n        }\n        mAppOpsCheckingService.shutdown();\n        if (AppOpsManager.NOTE_OP_COLLECTION_ENABLED && mWriteNoteOpsScheduled) {\n            writeNoteOps();\n        }\n        mHistoricalRegistry.shutdown();\n    }\n\n    private ArrayList<AppOpsManager.OpEntry> collectOps(Ops pkgOps, int[] ops) {\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        boolean shouldReturnRestrictedAppOps = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid())\n                == PackageManager.PERMISSION_GRANTED;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int j = 0; j < pkgOps.size(); j++) {\n                Op curOp = pkgOps.valueAt(j);\n                if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                    continue;\n                }\n                resOps.add(getOpEntryForResult(curOp));\n            }\n        } else {\n            for (int j = 0; j < ops.length; j++) {\n                Op curOp = pkgOps.get(ops[j]);\n                if (curOp != null) {\n                    if (opRestrictsRead(curOp.op) && !shouldReturnRestrictedAppOps) {\n                        continue;\n                    }\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(getOpEntryForResult(curOp));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    @Nullable\n    private ArrayList<AppOpsManager.OpEntry> collectUidOps(@NonNull UidState uidState,\n            @Nullable int[] ops) {\n        final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n        if (opModes == null) {\n            return null;\n        }\n\n        int opModeCount = opModes.size();\n        if (opModeCount == 0) {\n            return null;\n        }\n        ArrayList<AppOpsManager.OpEntry> resOps = null;\n        if (ops == null) {\n            resOps = new ArrayList<>();\n            for (int i = 0; i < opModeCount; i++) {\n                int code = opModes.keyAt(i);\n                resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n            }\n        } else {\n            for (int j=0; j<ops.length; j++) {\n                int code = ops[j];\n                if (opModes.indexOfKey(code) >= 0) {\n                    if (resOps == null) {\n                        resOps = new ArrayList<>();\n                    }\n                    resOps.add(new OpEntry(code, opModes.get(code), Collections.emptyMap()));\n                }\n            }\n        }\n        return resOps;\n    }\n\n    private static @NonNull OpEntry getOpEntryForResult(@NonNull Op op) {\n        return op.createEntryLocked();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getPackagesForOps(int[] ops) {\n        final int callingUid = Binder.getCallingUid();\n        final boolean hasAllPackageAccess = mContext.checkPermission(\n                Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(),\n                Binder.getCallingUid(), null) == PackageManager.PERMISSION_GRANTED;\n        ArrayList<AppOpsManager.PackageOps> res = null;\n        synchronized (this) {\n            final int uidStateCount = mUidStates.size();\n            for (int i = 0; i < uidStateCount; i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n                ArrayMap<String, Ops> packages = uidState.pkgOps;\n                final int packageCount = packages.size();\n                for (int j = 0; j < packageCount; j++) {\n                    Ops pkgOps = packages.valueAt(j);\n                    ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n                    if (resOps != null) {\n                        if (res == null) {\n                            res = new ArrayList<>();\n                        }\n                        AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                                pkgOps.packageName, pkgOps.uidState.uid, resOps);\n                        // Caller can always see their packages and with a permission all.\n                        if (hasAllPackageAccess || callingUid == pkgOps.uidState.uid) {\n                            res.add(resPackage);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getOpsForPackage(int uid, String packageName,\n            int[] ops) {\n        enforceGetAppOpsStatsPermissionIfNeeded(uid,packageName);\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return Collections.emptyList();\n        }\n        synchronized (this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null,\n                    /* edit */ false);\n            if (pkgOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectOps(pkgOps, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    pkgOps.packageName, pkgOps.uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void enforceGetAppOpsStatsPermissionIfNeeded(int uid, String packageName) {\n        // We get to access everything\n        final int callingPid = Binder.getCallingPid();\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        // Apps can access their own data\n        final int callingUid = Binder.getCallingUid();\n        if (uid == callingUid && packageName != null\n                && checkPackage(uid, packageName) == MODE_ALLOWED) {\n            return;\n        }\n        // Otherwise, you need a permission...\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, callingPid,\n                callingUid, null);\n    }\n\n    /**\n     * Verify that historical appop request arguments are valid.\n     */\n    private void ensureHistoricalOpRequestIsValid(int uid, String packageName,\n            String attributionTag, List<String> opNames, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags) {\n        if ((filter & FILTER_BY_UID) != 0) {\n            Preconditions.checkArgument(uid != Process.INVALID_UID);\n        } else {\n            Preconditions.checkArgument(uid == Process.INVALID_UID);\n        }\n\n        if ((filter & FILTER_BY_PACKAGE_NAME) != 0) {\n            Objects.requireNonNull(packageName);\n        } else {\n            Preconditions.checkArgument(packageName == null);\n        }\n\n        if ((filter & FILTER_BY_ATTRIBUTION_TAG) == 0) {\n            Preconditions.checkArgument(attributionTag == null);\n        }\n\n        if ((filter & FILTER_BY_OP_NAMES) != 0) {\n            Objects.requireNonNull(opNames);\n        } else {\n            Preconditions.checkArgument(opNames == null);\n        }\n\n        Preconditions.checkFlagsArgument(filter,\n                FILTER_BY_UID | FILTER_BY_PACKAGE_NAME | FILTER_BY_ATTRIBUTION_TAG\n                        | FILTER_BY_OP_NAMES);\n        Preconditions.checkArgumentNonnegative(beginTimeMillis);\n        Preconditions.checkArgument(endTimeMillis > beginTimeMillis);\n        Preconditions.checkFlagsArgument(flags, OP_FLAGS_ALL);\n    }\n\n    @Override\n    public void getHistoricalOps(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        PackageManager pm = mContext.getPackageManager();\n\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isSelfRequest = (filter & FILTER_BY_UID) != 0 && uid == Binder.getCallingUid();\n        if (!isSelfRequest) {\n            boolean isCallerInstrumented =\n                    ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n            boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n            boolean isCallerPermissionController;\n            try {\n                isCallerPermissionController = pm.getPackageUidAsUser(\n                        mContext.getPackageManager().getPermissionControllerPackageName(), 0,\n                        UserHandle.getUserId(Binder.getCallingUid()))\n                        == Binder.getCallingUid();\n            } catch (PackageManager.NameNotFoundException doesNotHappen) {\n                return;\n            }\n\n            boolean doesCallerHavePermission = mContext.checkPermission(\n                    android.Manifest.permission.GET_HISTORICAL_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid())\n                    == PackageManager.PERMISSION_GRANTED;\n\n            if (!isCallerSystem && !isCallerInstrumented && !isCallerPermissionController\n                    && !doesCallerHavePermission) {\n                mHandler.post(() -> callback.sendResult(new Bundle()));\n                return;\n            }\n\n            mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n        }\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                        new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOps,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void getHistoricalOpsFromDiskRaw(int uid, String packageName, String attributionTag,\n            List<String> opNames, int dataType, int filter, long beginTimeMillis,\n            long endTimeMillis, int flags, RemoteCallback callback) {\n        ensureHistoricalOpRequestIsValid(uid, packageName, attributionTag, opNames, filter,\n                beginTimeMillis, endTimeMillis, flags);\n        Objects.requireNonNull(callback, \"callback cannot be null\");\n\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"getHistoricalOps\");\n\n        final String[] opNamesArray = (opNames != null)\n                ? opNames.toArray(new String[opNames.size()]) : null;\n\n        Set<String> attributionChainExemptPackages = null;\n        if ((dataType & HISTORY_FLAG_GET_ATTRIBUTION_CHAINS) != 0) {\n            attributionChainExemptPackages =\n                    PermissionManager.getIndicatorExemptedPackages(mContext);\n        }\n\n        final String[] chainExemptPkgArray = attributionChainExemptPackages != null\n                ? attributionChainExemptPackages.toArray(\n                new String[attributionChainExemptPackages.size()]) : null;\n\n        // Must not hold the appops lock\n        mHandler.post(PooledLambda.obtainRunnable(HistoricalRegistry::getHistoricalOpsFromDiskRaw,\n                mHistoricalRegistry, uid, packageName, attributionTag, opNamesArray, dataType,\n                filter, beginTimeMillis, endTimeMillis, flags, chainExemptPkgArray,\n                callback).recycleOnUse());\n    }\n\n    @Override\n    public void reloadNonHistoricalState() {\n        mContext.enforcePermission(Manifest.permission.MANAGE_APPOPS,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"reloadNonHistoricalState\");\n        mAppOpsCheckingService.writeState();\n        mAppOpsCheckingService.readState();\n    }\n\n    @VisibleForTesting\n    void readState() {\n        mAppOpsCheckingService.readState();\n    }\n\n    @Override\n    public List<AppOpsManager.PackageOps> getUidOps(int uid, int[] ops) {\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.OpEntry> resOps = collectUidOps(uidState, ops);\n            if (resOps == null) {\n                return null;\n            }\n            ArrayList<AppOpsManager.PackageOps> res = new ArrayList<AppOpsManager.PackageOps>();\n            AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps(\n                    null, uidState.uid, resOps);\n            res.add(resPackage);\n            return res;\n        }\n    }\n\n    private void pruneOpLocked(Op op, int uid, String packageName) {\n        op.removeAttributionsWithNoTime();\n\n        if (op.mAttributions.isEmpty()) {\n            Ops ops = getOpsLocked(uid, packageName, null, false, null, /* edit */ false);\n            if (ops != null) {\n                ops.remove(op.op);\n                op.setMode(AppOpsManager.opToDefaultMode(op.op));\n                if (ops.size() <= 0) {\n                    UidState uidState = ops.uidState;\n                    ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n                    if (pkgOps != null) {\n                        pkgOps.remove(ops.packageName);\n                        mAppOpsCheckingService.removePackage(ops.packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n            }\n        }\n    }\n\n    private void enforceManageAppOpsModes(int callingPid, int callingUid, int targetUid) {\n        if (callingPid == Process.myPid()) {\n            return;\n        }\n        final int callingUser = UserHandle.getUserId(callingUid);\n        synchronized (this) {\n            if (mProfileOwners != null && mProfileOwners.get(callingUser, -1) == callingUid) {\n                if (targetUid >= 0 && callingUser == UserHandle.getUserId(targetUid)) {\n                    // Profile owners are allowed to change modes but only for apps\n                    // within their user.\n                    return;\n                }\n            }\n        }\n        mContext.enforcePermission(android.Manifest.permission.MANAGE_APP_OPS_MODES,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    @Override\n    public void setUidMode(int code, int uid, int mode) {\n        setUidMode(code, uid, mode, null);\n    }\n\n    private void setUidMode(int code, int uid, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        if (DEBUG) {\n            Slog.i(TAG, \"uid \" + uid + \" OP_\" + opToName(code) + \" := \" + modeToName(mode)\n                    + \" by uid \" + Binder.getCallingUid());\n        }\n\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        code = AppOpsManager.opToSwitch(code);\n\n        if (permissionPolicyCallback == null) {\n            updatePermissionRevokedCompat(uid, code, mode);\n        }\n\n        int previousMode;\n        synchronized (this) {\n            final int defaultMode = AppOpsManager.opToDefaultMode(code);\n\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState == null) {\n                if (mode == defaultMode) {\n                    return;\n                }\n                uidState = new UidState(uid);\n                mUidStates.put(uid, uidState);\n            }\n            if (uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                previousMode = uidState.getUidMode(code);\n            } else {\n                // doesn't look right but is legacy behavior.\n                previousMode = MODE_DEFAULT;\n            }\n\n            if (!uidState.setUidMode(code, mode)) {\n                return;\n            }\n            uidState.evalForegroundOps();\n            if (mode != MODE_ERRORED && mode != previousMode) {\n                updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n            }\n        }\n\n        notifyOpChangedForAllPkgsInUid(code, uid, false, permissionPolicyCallback);\n        notifyOpChangedSync(code, uid, null, mode, previousMode);\n    }\n\n    /**\n     * Notify that an op changed for all packages in an uid.\n     *\n     * @param code The op that changed\n     * @param uid The uid the op was changed for\n     * @param onlyForeground Only notify watchers that watch for foreground changes\n     */\n    private void notifyOpChangedForAllPkgsInUid(int code, int uid, boolean onlyForeground,\n            @Nullable IAppOpsCallback callbackToIgnore) {\n        ModeCallback listenerToIgnore = callbackToIgnore != null\n                ? mModeWatchers.get(callbackToIgnore.asBinder()) : null;\n        mAppOpsCheckingService.notifyOpChangedForAllPkgsInUid(code, uid, onlyForeground,\n                listenerToIgnore);\n    }\n\n    private void updatePermissionRevokedCompat(int uid, int switchCode, int mode) {\n        PackageManager packageManager = mContext.getPackageManager();\n        if (packageManager == null) {\n            // This can only happen during early boot. At this time the permission state and appop\n            // state are in sync\n            return;\n        }\n\n        String[] packageNames = packageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return;\n        }\n        String packageName = packageNames[0];\n\n        int[] ops = mSwitchedOps.get(switchCode);\n        for (int code : ops) {\n            String permissionName = AppOpsManager.opToPermission(code);\n            if (permissionName == null) {\n                continue;\n            }\n\n            if (packageManager.checkPermission(permissionName, packageName)\n                    != PackageManager.PERMISSION_GRANTED) {\n                continue;\n            }\n\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = packageManager.getPermissionInfo(permissionName, 0);\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n                continue;\n            }\n\n            if (!permissionInfo.isRuntime()) {\n                continue;\n            }\n\n            boolean supportsRuntimePermissions = getPackageManagerInternal()\n                    .getUidTargetSdkVersion(uid) >= Build.VERSION_CODES.M;\n\n            UserHandle user = UserHandle.getUserHandleForUid(uid);\n            boolean isRevokedCompat;\n            if (permissionInfo.backgroundPermission != null) {\n                if (packageManager.checkPermission(permissionInfo.backgroundPermission, packageName)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    boolean isBackgroundRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n\n                    if (isBackgroundRevokedCompat && supportsRuntimePermissions) {\n                        Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                                + \" permission state, this is discouraged and you should revoke the\"\n                                + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                                + switchCode + \", mode=\" + mode + \", permission=\"\n                                + permissionInfo.backgroundPermission);\n                    }\n\n                    final long identity = Binder.clearCallingIdentity();\n                    try {\n                        packageManager.updatePermissionFlags(permissionInfo.backgroundPermission,\n                                packageName, PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,\n                                isBackgroundRevokedCompat\n                                        ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n                    } finally {\n                        Binder.restoreCallingIdentity(identity);\n                    }\n                }\n\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED\n                        && mode != AppOpsManager.MODE_FOREGROUND;\n            } else {\n                isRevokedCompat = mode != AppOpsManager.MODE_ALLOWED;\n            }\n\n            if (isRevokedCompat && supportsRuntimePermissions) {\n                Slog.w(TAG, \"setUidMode() called with a mode inconsistent with runtime\"\n                        + \" permission state, this is discouraged and you should revoke the\"\n                        + \" runtime permission instead: uid=\" + uid + \", switchCode=\"\n                        + switchCode + \", mode=\" + mode + \", permission=\" + permissionName);\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                packageManager.updatePermissionFlags(permissionName, packageName,\n                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, isRevokedCompat\n                                ? PackageManager.FLAG_PERMISSION_REVOKED_COMPAT : 0, user);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    private void notifyOpChangedSync(int code, int uid, @NonNull String packageName, int mode,\n            int previousMode) {\n        final StorageManagerInternal storageManagerInternal =\n                LocalServices.getService(StorageManagerInternal.class);\n        if (storageManagerInternal != null) {\n            storageManagerInternal.onAppOpsChanged(code, uid, packageName, mode, previousMode);\n        }\n    }\n\n    /**\n     * Sets the mode for a certain op and uid.\n     *\n     * @param code The op code to set\n     * @param uid The UID for which to set\n     * @param packageName The package for which to set\n     * @param mode The new mode to set\n     */\n    @Override\n    public void setMode(int code, int uid, @NonNull String packageName, int mode) {\n        setMode(code, uid, packageName, mode, null);\n    }\n\n    void setMode(int code, int uid, @NonNull String packageName, int mode,\n            @Nullable IAppOpsCallback permissionPolicyCallback) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        ArraySet<OnOpModeChangedListener> repCbs = null;\n        code = AppOpsManager.opToSwitch(code);\n\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot setMode: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot setMode\", e);\n            }\n            return;\n        }\n\n        int previousMode = MODE_DEFAULT;\n        synchronized (this) {\n            UidState uidState = getUidStateLocked(uid, false);\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ true);\n            if (op != null) {\n                if (op.getMode() != mode) {\n                    previousMode = op.getMode();\n                    op.setMode(mode);\n\n                    if (uidState != null) {\n                        uidState.evalForegroundOps();\n                    }\n                    ArraySet<OnOpModeChangedListener> cbs =\n                            mAppOpsCheckingService.getOpModeChangedListeners(code);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    cbs = mAppOpsCheckingService.getPackageModeChangedListeners(packageName);\n                    if (cbs != null) {\n                        if (repCbs == null) {\n                            repCbs = new ArraySet<>();\n                        }\n                        repCbs.addAll(cbs);\n                    }\n                    if (repCbs != null && permissionPolicyCallback != null) {\n                        repCbs.remove(mModeWatchers.get(permissionPolicyCallback.asBinder()));\n                    }\n                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {\n                        // If going into the default mode, prune this op\n                        // if there is nothing else interesting in it.\n                        pruneOpLocked(op, uid, packageName);\n                    }\n                    scheduleFastWriteLocked();\n                    if (mode != MODE_ERRORED) {\n                        updateStartedOpModeForUidLocked(code, mode == MODE_IGNORED, uid);\n                    }\n                }\n            }\n        }\n        if (repCbs != null) {\n            mHandler.sendMessage(PooledLambda.obtainMessage(\n                    AppOpsService::notifyOpChanged,\n                    this, repCbs, code, uid, packageName));\n        }\n\n        notifyOpChangedSync(code, uid, packageName, mode, previousMode);\n    }\n\n    private void notifyOpChanged(ArraySet<OnOpModeChangedListener> callbacks, int code,\n            int uid, String packageName) {\n        for (int i = 0; i < callbacks.size(); i++) {\n            final OnOpModeChangedListener callback = callbacks.valueAt(i);\n            notifyOpChanged(callback, code, uid, packageName);\n        }\n    }\n\n    private void notifyOpChanged(OnOpModeChangedListener callback, int code,\n            int uid, String packageName) {\n        mAppOpsCheckingService.notifyOpChanged(callback, code, uid, packageName);\n    }\n\n    private static ArrayList<ChangeRec> addChange(ArrayList<ChangeRec> reports,\n            int op, int uid, String packageName, int previousMode) {\n        boolean duplicate = false;\n        if (reports == null) {\n            reports = new ArrayList<>();\n        } else {\n            final int reportCount = reports.size();\n            for (int j = 0; j < reportCount; j++) {\n                ChangeRec report = reports.get(j);\n                if (report.op == op && report.pkg.equals(packageName)) {\n                    duplicate = true;\n                    break;\n                }\n            }\n        }\n        if (!duplicate) {\n            reports.add(new ChangeRec(op, uid, packageName, previousMode));\n        }\n\n        return reports;\n    }\n\n    private static HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> addCallbacks(\n            HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks,\n            int op, int uid, String packageName, int previousMode,\n            ArraySet<OnOpModeChangedListener> cbs) {\n        if (cbs == null) {\n            return callbacks;\n        }\n        if (callbacks == null) {\n            callbacks = new HashMap<>();\n        }\n        final int N = cbs.size();\n        for (int i=0; i<N; i++) {\n            OnOpModeChangedListener cb = cbs.valueAt(i);\n            ArrayList<ChangeRec> reports = callbacks.get(cb);\n            ArrayList<ChangeRec> changed = addChange(reports, op, uid, packageName, previousMode);\n            if (changed != reports) {\n                callbacks.put(cb, changed);\n            }\n        }\n        return callbacks;\n    }\n\n    static final class ChangeRec {\n        final int op;\n        final int uid;\n        final String pkg;\n        final int previous_mode;\n\n        ChangeRec(int _op, int _uid, String _pkg, int _previous_mode) {\n            op = _op;\n            uid = _uid;\n            pkg = _pkg;\n            previous_mode = _previous_mode;\n        }\n    }\n\n    @Override\n    public void resetAllModes(int reqUserId, String reqPackageName) {\n        final int callingPid = Binder.getCallingPid();\n        final int callingUid = Binder.getCallingUid();\n        reqUserId = ActivityManager.handleIncomingUser(callingPid, callingUid, reqUserId,\n                true, true, \"resetAllModes\", null);\n\n        int reqUid = -1;\n        if (reqPackageName != null) {\n            try {\n                reqUid = AppGlobals.getPackageManager().getPackageUid(\n                        reqPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, reqUserId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n\n        enforceManageAppOpsModes(callingPid, callingUid, reqUid);\n\n        HashMap<OnOpModeChangedListener, ArrayList<ChangeRec>> callbacks = null;\n        ArrayList<ChangeRec> allChanges = new ArrayList<>();\n        synchronized (this) {\n            boolean changed = false;\n            for (int i = mUidStates.size() - 1; i >= 0; i--) {\n                UidState uidState = mUidStates.valueAt(i);\n\n                SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                if (opModes != null && (uidState.uid == reqUid || reqUid == -1)) {\n                    final int uidOpCount = opModes.size();\n                    for (int j = uidOpCount - 1; j >= 0; j--) {\n                        final int code = opModes.keyAt(j);\n                        if (AppOpsManager.opAllowsReset(code)) {\n                            int previousMode = opModes.valueAt(j);\n                            int newMode = isUidOpGrantedByRole(uidState.uid, code) ? MODE_ALLOWED :\n                                    AppOpsManager.opToDefaultMode(code);\n                            uidState.setUidMode(code, newMode);\n                            for (String packageName : getPackagesForUid(uidState.uid)) {\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode,\n                                        mAppOpsCheckingService.getOpModeChangedListeners(code));\n                                callbacks = addCallbacks(callbacks, code, uidState.uid, packageName,\n                                        previousMode, mAppOpsCheckingService\n                                                .getPackageModeChangedListeners(packageName));\n\n                                allChanges = addChange(allChanges, code, uidState.uid,\n                                        packageName, previousMode);\n                            }\n                        }\n                    }\n                }\n\n                if (uidState.pkgOps.isEmpty()) {\n                    continue;\n                }\n\n                if (reqUserId != UserHandle.USER_ALL\n                        && reqUserId != UserHandle.getUserId(uidState.uid)) {\n                    // Skip any ops for a different user\n                    continue;\n                }\n\n                Map<String, Ops> packages = uidState.pkgOps;\n                Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();\n                boolean uidChanged = false;\n                while (it.hasNext()) {\n                    Map.Entry<String, Ops> ent = it.next();\n                    String packageName = ent.getKey();\n                    if (reqPackageName != null && !reqPackageName.equals(packageName)) {\n                        // Skip any ops for a different package\n                        continue;\n                    }\n                    Ops pkgOps = ent.getValue();\n                    for (int j=pkgOps.size()-1; j>=0; j--) {\n                        Op curOp = pkgOps.valueAt(j);\n                        if (shouldDeferResetOpToDpm(curOp.op)) {\n                            deferResetOpToDpm(curOp.op, reqPackageName, reqUserId);\n                            continue;\n                        }\n                        if (AppOpsManager.opAllowsReset(curOp.op)) {\n                            int previousMode = curOp.getMode();\n                            int newMode = isPackageOpGrantedByRole(packageName, uidState.uid,\n                                    curOp.op) ? MODE_ALLOWED : AppOpsManager.opToDefaultMode(\n                                    curOp.op);\n                            if (previousMode == newMode) {\n                                continue;\n                            }\n                            curOp.setMode(newMode);\n                            changed = true;\n                            uidChanged = true;\n                            final int uid = curOp.uidState.uid;\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode,\n                                    mAppOpsCheckingService.getOpModeChangedListeners(curOp.op));\n                            callbacks = addCallbacks(callbacks, curOp.op, uid, packageName,\n                                    previousMode, mAppOpsCheckingService\n                                            .getPackageModeChangedListeners(packageName));\n\n                            allChanges = addChange(allChanges, curOp.op, uid, packageName,\n                                    previousMode);\n                            curOp.removeAttributionsWithNoTime();\n                            if (curOp.mAttributions.isEmpty()) {\n                                pkgOps.removeAt(j);\n                            }\n                        }\n                    }\n                    if (pkgOps.size() == 0) {\n                        it.remove();\n                        mAppOpsCheckingService.removePackage(packageName,\n                                UserHandle.getUserId(uidState.uid));\n                    }\n                }\n                if (uidChanged) {\n                    uidState.evalForegroundOps();\n                }\n            }\n\n            if (changed) {\n                scheduleFastWriteLocked();\n            }\n        }\n        if (callbacks != null) {\n            for (Map.Entry<OnOpModeChangedListener, ArrayList<ChangeRec>> ent\n                    : callbacks.entrySet()) {\n                OnOpModeChangedListener cb = ent.getKey();\n                ArrayList<ChangeRec> reports = ent.getValue();\n                for (int i=0; i<reports.size(); i++) {\n                    ChangeRec rep = reports.get(i);\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyOpChanged,\n                            this, cb, rep.op, rep.uid, rep.pkg));\n                }\n            }\n        }\n\n        int numChanges = allChanges.size();\n        for (int i = 0; i < numChanges; i++) {\n            ChangeRec change = allChanges.get(i);\n            notifyOpChangedSync(change.op, change.uid, change.pkg,\n                    AppOpsManager.opToDefaultMode(change.op), change.previous_mode);\n        }\n    }\n\n    private boolean isUidOpGrantedByRole(int uid, int code) {\n        if (!AppOpsManager.opIsUidAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            // Permissions are managed by UIDs, but unfortunately a package name is required in API.\n            String packageName = ArrayUtils.firstOrNull(packageManager.getPackagesForUid(uid));\n            if (packageName == null) {\n                return false;\n            }\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean isPackageOpGrantedByRole(@NonNull String packageName, int uid, int code) {\n        if (!AppOpsManager.opIsPackageAppOpPermission(code)) {\n            return false;\n        }\n        PackageManager packageManager = mContext.getPackageManager();\n        long token = Binder.clearCallingIdentity();\n        try {\n            int permissionFlags = packageManager.getPermissionFlags(AppOpsManager.opToPermission(\n                    code), packageName, UserHandle.getUserHandleForUid(uid));\n            return (permissionFlags & PackageManager.FLAG_PERMISSION_GRANTED_BY_ROLE) != 0;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private boolean shouldDeferResetOpToDpm(int op) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        return dpmi != null && dpmi.supportsResetOp(op);\n    }\n\n    /** Assumes {@link #shouldDeferResetOpToDpm(int)} is true. */\n    private void deferResetOpToDpm(int op, String packageName, @UserIdInt int userId) {\n        // TODO(b/174582385): avoid special-casing app-op resets by migrating app-op permission\n        //  pre-grants to a role-based mechanism or another general-purpose mechanism.\n        dpmi.resetOp(op, packageName, userId);\n    }\n\n    private void evalAllForegroundOpsLocked() {\n        for (int uidi = mUidStates.size() - 1; uidi >= 0; uidi--) {\n            final UidState uidState = mUidStates.valueAt(uidi);\n            if (uidState.foregroundOps != null) {\n                uidState.evalForegroundOps();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingMode(int op, String packageName, IAppOpsCallback callback) {\n        startWatchingModeWithFlags(op, packageName, 0, callback);\n    }\n\n    @Override\n    public void startWatchingModeWithFlags(int op, String packageName, int flags,\n            IAppOpsCallback callback) {\n        int watchedUid = -1;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        // TODO: should have a privileged permission to protect this.\n        // Also, if the caller has requested WATCH_FOREGROUND_CHANGES, should we require\n        // the USAGE_STATS permission since this can provide information about when an\n        // app is in the foreground?\n        Preconditions.checkArgumentInRange(op, AppOpsManager.OP_NONE,\n                AppOpsManager._NUM_OP - 1, \"Invalid op code: \" + op);\n        if (callback == null) {\n            return;\n        }\n        final boolean mayWatchPackageName = packageName != null\n                && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(callingUid));\n        synchronized (this) {\n            int switchOp = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op;\n\n            int notifiedOps;\n            if ((flags & CALL_BACK_ON_SWITCHED_OP) == 0) {\n                if (op == OP_NONE) {\n                    notifiedOps = ALL_OPS;\n                } else {\n                    notifiedOps = op;\n                }\n            } else {\n                notifiedOps = switchOp;\n            }\n\n            ModeCallback cb = mModeWatchers.get(callback.asBinder());\n            if (cb == null) {\n                cb = new ModeCallback(callback, watchedUid, flags, notifiedOps, callingUid,\n                        callingPid);\n                mModeWatchers.put(callback.asBinder(), cb);\n            }\n            if (switchOp != AppOpsManager.OP_NONE) {\n                mAppOpsCheckingService.startWatchingOpModeChanged(cb, switchOp);\n            }\n            if (mayWatchPackageName) {\n                mAppOpsCheckingService.startWatchingPackageModeChanged(cb, packageName);\n            }\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    @Override\n    public void stopWatchingMode(IAppOpsCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            ModeCallback cb = mModeWatchers.remove(callback.asBinder());\n            if (cb != null) {\n                cb.unlinkToDeath();\n                mAppOpsCheckingService.removeListener(cb);\n            }\n\n            evalAllForegroundOpsLocked();\n        }\n    }\n\n    public CheckOpsDelegate getAppOpsServiceDelegate() {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher dispatcher = mCheckOpsDelegateDispatcher;\n            return (dispatcher != null) ? dispatcher.getCheckOpsDelegate() : null;\n        }\n    }\n\n    public void setAppOpsServiceDelegate(CheckOpsDelegate delegate) {\n        synchronized (AppOpsService.this) {\n            final CheckOpsDelegateDispatcher oldDispatcher = mCheckOpsDelegateDispatcher;\n            final CheckOpsDelegate policy = (oldDispatcher != null) ? oldDispatcher.mPolicy : null;\n            mCheckOpsDelegateDispatcher = new CheckOpsDelegateDispatcher(policy, delegate);\n        }\n    }\n\n    @Override\n    public int checkOperationRaw(int code, int uid, String packageName,\n            @Nullable String attributionTag) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, attributionTag,\n                true /*raw*/);\n    }\n\n    @Override\n    public int checkOperation(int code, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkOperation(code, uid, packageName, null,\n                false /*raw*/);\n    }\n\n    private int checkOperationImpl(int code, int uid, String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        return checkOperationUnchecked(code, uid, resolvedPackageName, attributionTag, raw);\n    }\n\n    /**\n     * Get the mode of an app-op.\n     *\n     * @param code The code of the op\n     * @param uid The uid of the package the op belongs to\n     * @param packageName The package the op belongs to\n     * @param raw If the raw state of eval-ed state should be checked.\n     *\n     * @return The mode of the op\n     */\n    private @Mode int checkOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean raw) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, null);\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot checkOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot checkOperation\", e);\n            }\n            return AppOpsManager.opToDefaultMode(code);\n        }\n\n        if (isOpRestrictedDueToSuspend(code, packageName, uid)) {\n            return AppOpsManager.MODE_IGNORED;\n        }\n        synchronized (this) {\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, true)) {\n                return AppOpsManager.MODE_IGNORED;\n            }\n            code = AppOpsManager.opToSwitch(code);\n            UidState uidState = getUidStateLocked(uid, false);\n            if (uidState != null\n                    && uidState.getUidMode(code) != AppOpsManager.opToDefaultMode(code)) {\n                final int rawMode = uidState.getUidMode(code);\n                return raw ? rawMode : uidState.evalMode(code, rawMode);\n            }\n            Op op = getOpLocked(code, uid, packageName, null, false, pvr.bypass, /* edit */ false);\n            if (op == null) {\n                return AppOpsManager.opToDefaultMode(code);\n            }\n            return raw ? op.getMode() : op.uidState.evalMode(op.op, op.getMode());\n        }\n    }\n\n    @Override\n    public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n        return mCheckOpsDelegateDispatcher.checkAudioOperation(code, usage, uid, packageName);\n    }\n\n    private int checkAudioOperationImpl(int code, int usage, int uid, String packageName) {\n        final int mode = mAudioRestrictionManager.checkAudioOperation(\n                code, usage, uid, packageName);\n        if (mode != AppOpsManager.MODE_ALLOWED) {\n            return mode;\n        }\n        return checkOperation(code, uid, packageName);\n    }\n\n    @Override\n    public void setAudioRestriction(int code, int usage, int uid, int mode,\n            String[] exceptionPackages) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), uid);\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n\n        mAudioRestrictionManager.setZenModeAudioRestriction(\n                code, usage, uid, mode, exceptionPackages);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n    }\n\n\n    @Override\n    public void setCameraAudioRestriction(@CAMERA_AUDIO_RESTRICTION int mode) {\n        enforceManageAppOpsModes(Binder.getCallingPid(), Binder.getCallingUid(), -1);\n\n        mAudioRestrictionManager.setCameraAudioRestriction(mode);\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_PLAY_AUDIO, UID_ANY));\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyWatchersOfChange, this,\n                AppOpsManager.OP_VIBRATE, UID_ANY));\n    }\n\n    @Override\n    public int checkPackage(int uid, String packageName) {\n        Objects.requireNonNull(packageName);\n        try {\n            verifyAndGetBypass(uid, packageName, null, Process.INVALID_UID, null, true);\n            // When the caller is the system, it's possible that the packageName is the special\n            // one (e.g., \"root\") which isn't actually existed.\n            if (resolveNonAppUid(packageName) == uid\n                    || (isPackageExisted(packageName)\n                            && !filterAppAccessUnlocked(packageName, UserHandle.getUserId(uid)))) {\n                return AppOpsManager.MODE_ALLOWED;\n            }\n            return AppOpsManager.MODE_ERRORED;\n        } catch (SecurityException ignored) {\n            return AppOpsManager.MODE_ERRORED;\n        }\n    }\n\n    private boolean isPackageExisted(String packageName) {\n        return getPackageManagerInternal().getPackageStateInternal(packageName) != null;\n    }\n\n    /**\n     * This method will check with PackageManager to determine if the package provided should\n     * be visible to the {@link Binder#getCallingUid()}.\n     *\n     * NOTE: This must not be called while synchronized on {@code this} to avoid dead locks\n     */\n    private boolean filterAppAccessUnlocked(String packageName, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        return LocalServices.getService(PackageManagerInternal.class)\n                .filterAppAccess(packageName, callingUid, userId);\n    }\n\n    @Override\n    public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        return mCheckOpsDelegateDispatcher.noteProxyOperation(code, attributionSource,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation);\n    }\n\n    private SyncNotedAppOp noteProxyOperationImpl(int code, AttributionSource attributionSource,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))\n                || !isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        String resolveProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolveProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code,\n                    proxiedAttributionTag, proxiedPackageName);\n        }\n\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame;\n\n        if (!skipProxyOperation) {\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyReturn = noteOperationUnchecked(code, proxyUid,\n                    resolveProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, !isProxyTrusted, \"proxy \" + message, shouldCollectMessage);\n            if (proxyReturn.getOpMode() != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(proxyReturn.getOpMode(), code, proxiedAttributionTag,\n                        proxiedPackageName);\n            }\n        }\n\n        String resolveProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolveProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n        return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolveProxyPackageName, proxyAttributionTag,\n                proxiedFlags, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    @Override\n    public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n            String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage) {\n        return mCheckOpsDelegateDispatcher.noteOperation(code, uid, packageName,\n                attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationImpl(int code, int uid, @Nullable String packageName,\n            @Nullable String attributionTag, boolean shouldCollectAsyncNotedOp,\n            @Nullable String message, boolean shouldCollectMessage) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n        return noteOperationUnchecked(code, uid, resolvedPackageName, attributionTag,\n                Process.INVALID_UID, null, null, AppOpsManager.OP_FLAG_SELF,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n    }\n\n    private SyncNotedAppOp noteOperationUnchecked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, int proxyUid, String proxyPackageName,\n            @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            boolean wasNull = attributionTag == null;\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot noteOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot noteOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                if (DEBUG) Slog.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \"flags: \" +\n                        AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            if (attributedOp.isRunning()) {\n                Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \"\n                        + code + \" startTime of in progress event=\"\n                        + attributedOp.mInProgressEvents.valueAt(0).getStartTime());\n            }\n\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            final UidState uidState = ops.uidState;\n            if (isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass, false)) {\n                attributedOp.rejected(uidState.getState(), flags);\n                scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        AppOpsManager.MODE_IGNORED);\n                return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                        packageName);\n            }\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (uidMode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: uid reject #\" + uidMode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            uidMode);\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED) {\n                    if (DEBUG) Slog.d(TAG, \"noteOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    attributedOp.rejected(uidState.getState(), flags);\n                    scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                            mode);\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) {\n                Slog.d(TAG,\n                        \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \"\n                                + packageName + (attributionTag == null ? \"\"\n                                : \".\" + attributionTag) + \" flags: \"\n                                + AppOpsManager.flagsToString(flags));\n            }\n            scheduleOpNotedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                    AppOpsManager.MODE_ALLOWED);\n            attributedOp.accessed(proxyUid, proxyPackageName, proxyAttributionTag,\n                    uidState.getState(),\n                    flags);\n\n            if (shouldCollectAsyncNotedOp) {\n                collectAsyncNotedOp(uid, packageName, code, attributionTag, flags, message,\n                        shouldCollectMessage);\n            }\n\n            return new SyncNotedAppOp(AppOpsManager.MODE_ALLOWED, code, attributionTag,\n                    packageName);\n        }\n    }\n\n    // TODO moltmann: Allow watching for attribution ops\n    @Override\n    public void startWatchingActive(int[] ops, IAppOpsActiveCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        if (ops != null) {\n            Preconditions.checkArrayElementsInRange(ops, 0,\n                    AppOpsManager._NUM_OP - 1, \"Invalid op code in: \" + Arrays.toString(ops));\n        }\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            SparseArray<ActiveCallback> callbacks = mActiveWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mActiveWatchers.put(callback.asBinder(), callbacks);\n            }\n            final ActiveCallback activeCallback = new ActiveCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, activeCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingActive(IAppOpsActiveCallback callback) {\n        if (callback == null) {\n            return;\n        }\n        synchronized (this) {\n            final SparseArray<ActiveCallback> activeCallbacks =\n                    mActiveWatchers.remove(callback.asBinder());\n            if (activeCallbacks == null) {\n                return;\n            }\n            final int callbackCount = activeCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                activeCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingStarted(int[] ops, @NonNull IAppOpsStartedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            SparseArray<StartedCallback> callbacks = mStartedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mStartedWatchers.put(callback.asBinder(), callbacks);\n            }\n\n            final StartedCallback startedCallback = new StartedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, startedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingStarted(IAppOpsStartedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n\n        synchronized (this) {\n            final SparseArray<StartedCallback> startedCallbacks =\n                    mStartedWatchers.remove(callback.asBinder());\n            if (startedCallbacks == null) {\n                return;\n            }\n\n            final int callbackCount = startedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                startedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    @Override\n    public void startWatchingNoted(@NonNull int[] ops, @NonNull IAppOpsNotedCallback callback) {\n        int watchedUid = Process.INVALID_UID;\n        final int callingUid = Binder.getCallingUid();\n        final int callingPid = Binder.getCallingPid();\n        if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                != PackageManager.PERMISSION_GRANTED) {\n            watchedUid = callingUid;\n        }\n        Preconditions.checkArgument(!ArrayUtils.isEmpty(ops), \"Ops cannot be null or empty\");\n        Preconditions.checkArrayElementsInRange(ops, 0, AppOpsManager._NUM_OP - 1,\n                \"Invalid op code in: \" + Arrays.toString(ops));\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            SparseArray<NotedCallback> callbacks = mNotedWatchers.get(callback.asBinder());\n            if (callbacks == null) {\n                callbacks = new SparseArray<>();\n                mNotedWatchers.put(callback.asBinder(), callbacks);\n            }\n            final NotedCallback notedCallback = new NotedCallback(callback, watchedUid,\n                    callingUid, callingPid);\n            for (int op : ops) {\n                callbacks.put(op, notedCallback);\n            }\n        }\n    }\n\n    @Override\n    public void stopWatchingNoted(IAppOpsNotedCallback callback) {\n        Objects.requireNonNull(callback, \"Callback cannot be null\");\n        synchronized (this) {\n            final SparseArray<NotedCallback> notedCallbacks =\n                    mNotedWatchers.remove(callback.asBinder());\n            if (notedCallbacks == null) {\n                return;\n            }\n            final int callbackCount = notedCallbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                notedCallbacks.valueAt(i).destroy();\n            }\n        }\n    }\n\n    /**\n     * Collect an {@link AsyncNotedAppOp}.\n     *\n     * @param uid The uid the op was noted for\n     * @param packageName The package the op was noted for\n     * @param opCode The code of the op noted\n     * @param attributionTag attribution tag the op was noted for\n     * @param message The message for the op noting\n     */\n    private void collectAsyncNotedOp(int uid, @NonNull String packageName, int opCode,\n            @Nullable String attributionTag, @OpFlags int flags, @NonNull String message,\n            boolean shouldCollectMessage) {\n        Objects.requireNonNull(message);\n\n        int callingUid = Binder.getCallingUid();\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            synchronized (this) {\n                Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n                RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n                AsyncNotedAppOp asyncNotedOp = new AsyncNotedAppOp(opCode, callingUid,\n                        attributionTag, message, System.currentTimeMillis());\n                final boolean[] wasNoteForwarded = {false};\n\n                if ((flags & (OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED)) != 0\n                        && shouldCollectMessage) {\n                    reportRuntimeAppOpAccessMessageAsyncLocked(uid, packageName, opCode,\n                            attributionTag, message);\n                }\n\n                if (callbacks != null) {\n                    callbacks.broadcast((cb) -> {\n                        try {\n                            cb.opNoted(asyncNotedOp);\n                            wasNoteForwarded[0] = true;\n                        } catch (RemoteException e) {\n                            Slog.e(TAG,\n                                    \"Could not forward noteOp of \" + opCode + \" to \" + packageName\n                                            + \"/\" + uid + \"(\" + attributionTag + \")\", e);\n                        }\n                    });\n                }\n\n                if (!wasNoteForwarded[0]) {\n                    ArrayList<AsyncNotedAppOp> unforwardedOps = mUnforwardedAsyncNotedOps.get(key);\n                    if (unforwardedOps == null) {\n                        unforwardedOps = new ArrayList<>(1);\n                        mUnforwardedAsyncNotedOps.put(key, unforwardedOps);\n                    }\n\n                    unforwardedOps.add(asyncNotedOp);\n                    if (unforwardedOps.size() > MAX_UNFORWARDED_OPS) {\n                        unforwardedOps.remove(0);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Compute a key to be used in {@link #mAsyncOpWatchers} and {@link #mUnforwardedAsyncNotedOps}\n     *\n     * @param packageName The package name of the app\n     * @param uid The uid of the app\n     *\n     * @return They key uniquely identifying the app\n     */\n    private @NonNull Pair<String, Integer> getAsyncNotedOpsKey(@NonNull String packageName,\n            int uid) {\n        return new Pair<>(packageName, uid);\n    }\n\n    @Override\n    public void startWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks == null) {\n                callbacks = new RemoteCallbackList<IAppOpsAsyncNotedCallback>() {\n                    @Override\n                    public void onCallbackDied(IAppOpsAsyncNotedCallback callback) {\n                        synchronized (AppOpsService.this) {\n                            if (getRegisteredCallbackCount() == 0) {\n                                mAsyncOpWatchers.remove(key);\n                            }\n                        }\n                    }\n                };\n                mAsyncOpWatchers.put(key, callbacks);\n            }\n\n            callbacks.register(callback);\n        }\n    }\n\n    @Override\n    public void stopWatchingAsyncNoted(String packageName, IAppOpsAsyncNotedCallback callback) {\n        Objects.requireNonNull(packageName);\n        Objects.requireNonNull(callback);\n\n        int uid = Binder.getCallingUid();\n        Pair<String, Integer> key = getAsyncNotedOpsKey(packageName, uid);\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            RemoteCallbackList<IAppOpsAsyncNotedCallback> callbacks = mAsyncOpWatchers.get(key);\n            if (callbacks != null) {\n                callbacks.unregister(callback);\n                if (callbacks.getRegisteredCallbackCount() == 0) {\n                    mAsyncOpWatchers.remove(key);\n                }\n            }\n        }\n    }\n\n    @Override\n    public List<AsyncNotedAppOp> extractAsyncOps(String packageName) {\n        Objects.requireNonNull(packageName);\n\n        int uid = Binder.getCallingUid();\n\n        verifyAndGetBypass(uid, packageName, null);\n\n        synchronized (this) {\n            return mUnforwardedAsyncNotedOps.remove(getAsyncNotedOpsKey(packageName, uid));\n        }\n    }\n\n    @Override\n    public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n            String message, boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startOperation(token, code, uid, packageName,\n                attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, attributionFlags, attributionChainId);\n    }\n\n    private SyncNotedAppOp startOperationImpl(@NonNull IBinder clientId, int code, int uid,\n            @Nullable String packageName, @Nullable String attributionTag,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @NonNull String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, attributionTag,\n                    packageName);\n        }\n\n        // As a special case for OP_RECORD_AUDIO_HOTWORD, OP_RECEIVE_AMBIENT_TRIGGER_AUDIO and\n        // OP_RECORD_AUDIO_SANDBOXED which we use only for attribution purposes and not as a check,\n        // also make sure that the caller is allowed to access the data gated by OP_RECORD_AUDIO.\n        //\n        // TODO: Revert this change before Android 12.\n        int result = MODE_DEFAULT;\n        if (code == OP_RECORD_AUDIO_HOTWORD || code == OP_RECEIVE_AMBIENT_TRIGGER_AUDIO\n                || code == OP_RECORD_AUDIO_SANDBOXED) {\n            result = checkOperation(OP_RECORD_AUDIO, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n        // As a special case for OP_CAMERA_SANDBOXED.\n        if (code == OP_CAMERA_SANDBOXED) {\n            result = checkOperation(OP_CAMERA, uid, packageName);\n            // Check result\n            if (result != AppOpsManager.MODE_ALLOWED) {\n                return new SyncNotedAppOp(result, code, attributionTag, packageName);\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, uid, packageName, attributionTag,\n                Process.INVALID_UID, null, null, OP_FLAG_SELF, startIfModeDefault,\n                shouldCollectAsyncNotedOp, message, shouldCollectMessage, attributionFlags,\n                attributionChainId, /*dryRun*/ false);\n    }\n\n    @Override\n    public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n            boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n            boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n            @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n        return mCheckOpsDelegateDispatcher.startProxyOperation(clientId, code, attributionSource,\n                startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlags,\n                attributionChainId);\n    }\n\n    private SyncNotedAppOp startProxyOperationImpl(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n            boolean shouldCollectMessage, boolean skipProxyOperation, @AttributionFlags\n            int proxyAttributionFlags, @AttributionFlags int proxiedAttributionFlags,\n            int attributionChainId) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        boolean isCallerTrusted = isCallerAndAttributionTrusted(attributionSource);\n        skipProxyOperation = isCallerTrusted && skipProxyOperation;\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final boolean isChainTrusted = isCallerTrusted\n                && attributionChainId != ATTRIBUTION_CHAIN_ID_NONE\n                && ((proxyAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0\n                || (proxiedAttributionFlags & ATTRIBUTION_FLAG_TRUSTED) != 0);\n        final boolean isSelfBlame = Binder.getCallingUid() == proxiedUid;\n        final boolean isProxyTrusted = mContext.checkPermission(\n                Manifest.permission.UPDATE_APP_OPS_STATS, -1, proxyUid)\n                == PackageManager.PERMISSION_GRANTED || isSelfBlame\n                || isChainTrusted;\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return new SyncNotedAppOp(AppOpsManager.MODE_IGNORED, code, proxiedAttributionTag,\n                    proxiedPackageName);\n        }\n\n        final int proxiedFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXIED\n                : AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED;\n\n        if (!skipProxyOperation) {\n            // Test if the proxied operation will succeed before starting the proxy operation\n            final SyncNotedAppOp testProxiedOp = startOperationUnchecked(clientId, code,\n                    proxiedUid, resolvedProxiedPackageName, proxiedAttributionTag, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, proxiedFlags, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    proxiedAttributionFlags, attributionChainId, /*dryRun*/ true);\n            if (!shouldStartForMode(testProxiedOp.getOpMode(), startIfModeDefault)) {\n                return testProxiedOp;\n            }\n\n            final int proxyFlags = isProxyTrusted ? AppOpsManager.OP_FLAG_TRUSTED_PROXY\n                    : AppOpsManager.OP_FLAG_UNTRUSTED_PROXY;\n\n            final SyncNotedAppOp proxyAppOp = startOperationUnchecked(clientId, code, proxyUid,\n                    resolvedProxyPackageName, proxyAttributionTag, Process.INVALID_UID, null, null,\n                    proxyFlags, startIfModeDefault, !isProxyTrusted, \"proxy \" + message,\n                    shouldCollectMessage, proxyAttributionFlags, attributionChainId,\n                    /*dryRun*/ false);\n            if (!shouldStartForMode(proxyAppOp.getOpMode(), startIfModeDefault)) {\n                return proxyAppOp;\n            }\n        }\n\n        return startOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag, proxyUid, resolvedProxyPackageName, proxyAttributionTag,\n                proxiedFlags, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                shouldCollectMessage, proxiedAttributionFlags, attributionChainId,\n                /*dryRun*/ false);\n    }\n\n    private boolean shouldStartForMode(int mode, boolean startIfModeDefault) {\n        return (mode == MODE_ALLOWED || (mode == MODE_DEFAULT && startIfModeDefault));\n    }\n\n    private SyncNotedAppOp startOperationUnchecked(IBinder clientId, int code, int uid,\n            @NonNull String packageName, @Nullable String attributionTag, int proxyUid,\n            String proxyPackageName, @Nullable String proxyAttributionTag, @OpFlags int flags,\n            boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, @Nullable String message,\n            boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n            int attributionChainId, boolean dryRun) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot startOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot startOperation\", e);\n            }\n            return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                    packageName);\n        }\n        if (proxyAttributionTag != null\n                && !isAttributionTagDefined(packageName, proxyPackageName, proxyAttributionTag)) {\n            proxyAttributionTag = null;\n        }\n\n        boolean isRestricted = false;\n        int startType = START_TYPE_FAILED;\n        synchronized (this) {\n            final Ops ops = getOpsLocked(uid, packageName, attributionTag,\n                    pvr.isAttributionTagValid, pvr.bypass, /* edit */ true);\n            if (ops == null) {\n                if (!dryRun) {\n                    scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                            flags, AppOpsManager.MODE_IGNORED, startType, attributionFlags,\n                            attributionChainId);\n                }\n                if (DEBUG) Slog.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid\n                        + \" package \" + packageName + \" flags: \"\n                        + AppOpsManager.flagsToString(flags));\n                return new SyncNotedAppOp(AppOpsManager.MODE_ERRORED, code, attributionTag,\n                        packageName);\n            }\n            final Op op = getOpLocked(ops, code, uid, true);\n            final AttributedOp attributedOp = op.getOrCreateAttribution(op, attributionTag);\n            final UidState uidState = ops.uidState;\n            isRestricted = isOpRestrictedLocked(uid, code, packageName, attributionTag, pvr.bypass,\n                    false);\n            final int switchCode = AppOpsManager.opToSwitch(code);\n            // If there is a non-default per UID policy (we set UID op mode only if\n            // non-default) it takes over, otherwise use the per package policy.\n            if (uidState.getUidMode(switchCode) != AppOpsManager.opToDefaultMode(switchCode)) {\n                final int uidMode = uidState.evalMode(code, uidState.getUidMode(switchCode));\n                if (!shouldStartForMode(uidMode, startIfModeDefault)) {\n                    if (DEBUG) {\n                        Slog.d(TAG, \"startOperation: uid reject #\" + uidMode + \" for code \"\n                                + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                                + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    }\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, uidMode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(uidMode, code, attributionTag, packageName);\n                }\n            } else {\n                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, uid, true)\n                        : op;\n                final int mode = switchOp.uidState.evalMode(switchOp.op, switchOp.getMode());\n                if (mode != AppOpsManager.MODE_ALLOWED\n                        && (!startIfModeDefault || mode != MODE_DEFAULT)) {\n                    if (DEBUG) Slog.d(TAG, \"startOperation: reject #\" + mode + \" for code \"\n                            + switchCode + \" (\" + code + \") uid \" + uid + \" package \"\n                            + packageName + \" flags: \" + AppOpsManager.flagsToString(flags));\n                    if (!dryRun) {\n                        attributedOp.rejected(uidState.getState(), flags);\n                        scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag,\n                                flags, mode, startType, attributionFlags, attributionChainId);\n                    }\n                    return new SyncNotedAppOp(mode, code, attributionTag, packageName);\n                }\n            }\n            if (DEBUG) Slog.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid\n                    + \" package \" + packageName + \" restricted: \" + isRestricted\n                    + \" flags: \" + AppOpsManager.flagsToString(flags));\n            if (!dryRun) {\n                try {\n                    if (isRestricted) {\n                        attributedOp.createPaused(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                    } else {\n                        attributedOp.started(clientId, proxyUid, proxyPackageName,\n                                proxyAttributionTag, uidState.getState(), flags,\n                                attributionFlags, attributionChainId);\n                        startType = START_TYPE_STARTED;\n                    }\n                } catch (RemoteException e) {\n                    throw new RuntimeException(e);\n                }\n                scheduleOpStartedIfNeededLocked(code, uid, packageName, attributionTag, flags,\n                        isRestricted ? MODE_IGNORED : MODE_ALLOWED, startType, attributionFlags,\n                        attributionChainId);\n            }\n        }\n\n        if (shouldCollectAsyncNotedOp && !dryRun && !isRestricted) {\n            collectAsyncNotedOp(uid, packageName, code, attributionTag, AppOpsManager.OP_FLAG_SELF,\n                    message, shouldCollectMessage);\n        }\n\n        return new SyncNotedAppOp(isRestricted ? MODE_IGNORED : MODE_ALLOWED, code, attributionTag,\n                packageName);\n    }\n\n    @Override\n    public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        mCheckOpsDelegateDispatcher.finishOperation(clientId, code, uid, packageName,\n                attributionTag);\n    }\n\n    private void finishOperationImpl(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        verifyIncomingUid(uid);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return;\n        }\n\n        String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return;\n        }\n\n        finishOperationUnchecked(clientId, code, uid, resolvedPackageName, attributionTag);\n    }\n\n    @Override\n    public void finishProxyOperation(@NonNull IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        mCheckOpsDelegateDispatcher.finishProxyOperation(clientId, code, attributionSource,\n                skipProxyOperation);\n    }\n\n    private Void finishProxyOperationImpl(IBinder clientId, int code,\n            @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n        final int proxyUid = attributionSource.getUid();\n        final String proxyPackageName = attributionSource.getPackageName();\n        final String proxyAttributionTag = attributionSource.getAttributionTag();\n        final int proxiedUid = attributionSource.getNextUid();\n        final String proxiedPackageName = attributionSource.getNextPackageName();\n        final String proxiedAttributionTag = attributionSource.getNextAttributionTag();\n\n        skipProxyOperation = skipProxyOperation\n                && isCallerAndAttributionTrusted(attributionSource);\n\n        verifyIncomingProxyUid(attributionSource);\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(proxyPackageName, UserHandle.getUserId(proxyUid))\n                || !isIncomingPackageValid(proxiedPackageName, UserHandle.getUserId(proxiedUid))) {\n            return null;\n        }\n\n        String resolvedProxyPackageName = AppOpsManager.resolvePackageName(proxyUid,\n                proxyPackageName);\n        if (resolvedProxyPackageName == null) {\n            return null;\n        }\n\n        if (!skipProxyOperation) {\n            finishOperationUnchecked(clientId, code, proxyUid, resolvedProxyPackageName,\n                    proxyAttributionTag);\n        }\n\n        String resolvedProxiedPackageName = AppOpsManager.resolvePackageName(proxiedUid,\n                proxiedPackageName);\n        if (resolvedProxiedPackageName == null) {\n            return null;\n        }\n\n        finishOperationUnchecked(clientId, code, proxiedUid, resolvedProxiedPackageName,\n                proxiedAttributionTag);\n\n        return null;\n    }\n\n    private void finishOperationUnchecked(IBinder clientId, int code, int uid, String packageName,\n            String attributionTag) {\n        PackageVerificationResult pvr;\n        try {\n            pvr = verifyAndGetBypass(uid, packageName, attributionTag);\n            if (!pvr.isAttributionTagValid) {\n                attributionTag = null;\n            }\n        } catch (SecurityException e) {\n            if (Process.isIsolated(uid)) {\n                Slog.e(TAG, \"Cannot finishOperation: isolated process\");\n            } else {\n                Slog.e(TAG, \"Cannot finishOperation\", e);\n            }\n            return;\n        }\n\n        synchronized (this) {\n            Op op = getOpLocked(code, uid, packageName, attributionTag, pvr.isAttributionTagValid,\n                    pvr.bypass, /* edit */ true);\n            if (op == null) {\n                Slog.e(TAG, \"Operation not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n            final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n            if (attributedOp == null) {\n                Slog.e(TAG, \"Attribution not found: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n                return;\n            }\n\n            if (attributedOp.isRunning() || attributedOp.isPaused()) {\n                attributedOp.finished(clientId);\n            } else {\n                Slog.e(TAG, \"Operation not started: uid=\" + uid + \" pkg=\" + packageName + \"(\"\n                        + attributionTag + \") op=\" + AppOpsManager.opToName(code));\n            }\n        }\n    }\n\n    void scheduleOpActiveChangedIfNeededLocked(int code, int uid, @NonNull\n            String packageName, @Nullable String attributionTag, boolean active, @AttributionFlags\n            int attributionFlags, int attributionChainId) {\n        ArraySet<ActiveCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mActiveWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<ActiveCallback> callbacks = mActiveWatchers.valueAt(i);\n            ActiveCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpActiveChanged,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, active,\n                attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpActiveChanged(ArraySet<ActiveCallback> callbacks,\n            int code, int uid, @NonNull String packageName, @Nullable String attributionTag,\n            boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {\n        // There are features watching for mode changes such as window manager\n        // and location manager which are in our process. The callbacks in these\n        // features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final ActiveCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opActiveChanged(code, uid, packageName, attributionTag,\n                            active, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    void scheduleOpStartedIfNeededLocked(int code, int uid, String pkgName,\n            String attributionTag, @OpFlags int flags, @Mode int result,\n            @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        ArraySet<StartedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mStartedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<StartedCallback> callbacks = mStartedWatchers.valueAt(i);\n\n            StartedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpStarted,\n                this, dispatchedCallbacks, code, uid, pkgName, attributionTag, flags,\n                result, startedType, attributionFlags, attributionChainId));\n    }\n\n    private void notifyOpStarted(ArraySet<StartedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result, @AppOpsManager.OnOpStartedListener.StartedType int startedType,\n            @AttributionFlags int attributionFlags, int attributionChainId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final StartedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opStarted(code, uid, packageName, attributionTag, flags,\n                            result, startedType, attributionFlags, attributionChainId);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void scheduleOpNotedIfNeededLocked(int code, int uid, String packageName,\n            String attributionTag, @OpFlags int flags, @Mode int result) {\n        ArraySet<NotedCallback> dispatchedCallbacks = null;\n        final int callbackListCount = mNotedWatchers.size();\n        for (int i = 0; i < callbackListCount; i++) {\n            final SparseArray<NotedCallback> callbacks = mNotedWatchers.valueAt(i);\n            final NotedCallback callback = callbacks.get(code);\n            if (callback != null) {\n                if (callback.mWatchingUid >= 0 && callback.mWatchingUid != uid) {\n                    continue;\n                }\n                if (dispatchedCallbacks == null) {\n                    dispatchedCallbacks = new ArraySet<>();\n                }\n                dispatchedCallbacks.add(callback);\n            }\n        }\n        if (dispatchedCallbacks == null) {\n            return;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::notifyOpChecked,\n                this, dispatchedCallbacks, code, uid, packageName, attributionTag, flags,\n                result));\n    }\n\n    private void notifyOpChecked(ArraySet<NotedCallback> callbacks,\n            int code, int uid, String packageName, String attributionTag, @OpFlags int flags,\n            @Mode int result) {\n        // There are features watching for checks in our process. The callbacks in\n        // these features may require permissions our remote caller does not have.\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int callbackCount = callbacks.size();\n            for (int i = 0; i < callbackCount; i++) {\n                final NotedCallback callback = callbacks.valueAt(i);\n                try {\n                    if (shouldIgnoreCallback(code, callback.mCallingPid, callback.mCallingUid)) {\n                        continue;\n                    }\n                    callback.mCallback.opNoted(code, uid, packageName, attributionTag, flags,\n                            result);\n                } catch (RemoteException e) {\n                    /* do nothing */\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public int permissionToOpCode(String permission) {\n        if (permission == null) {\n            return AppOpsManager.OP_NONE;\n        }\n        return AppOpsManager.permissionToOpCode(permission);\n    }\n\n    @Override\n    public boolean shouldCollectNotes(int opCode) {\n        Preconditions.checkArgumentInRange(opCode, 0, _NUM_OP - 1, \"opCode\");\n\n        if (AppOpsManager.shouldForceCollectNoteForOp(opCode)) {\n            return true;\n        }\n\n        String perm = AppOpsManager.opToPermission(opCode);\n        if (perm == null) {\n            return false;\n        }\n\n        PermissionInfo permInfo;\n        try {\n            permInfo = mContext.getPackageManager().getPermissionInfo(perm, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            return false;\n        }\n\n        return permInfo.getProtection() == PROTECTION_DANGEROUS\n                || (permInfo.getProtectionFlags() & PROTECTION_FLAG_APPOP) != 0;\n    }\n\n    private void verifyIncomingProxyUid(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        if (attributionSource.isTrusted(mContext)) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private void verifyIncomingUid(int uid) {\n        if (uid == Binder.getCallingUid()) {\n            return;\n        }\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        }\n        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n    }\n\n    private boolean shouldIgnoreCallback(int op, int watcherPid, int watcherUid) {\n        // If it's a restricted read op, ignore it if watcher doesn't have manage ops permission,\n        // as watcher should not use this to signal if the value is changed.\n        return opRestrictsRead(op) && mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                watcherPid, watcherUid) != PackageManager.PERMISSION_GRANTED;\n    }\n\n    private void verifyIncomingOp(int op) {\n        if (op >= 0 && op < AppOpsManager._NUM_OP) {\n            // Enforce privileged appops permission if it's a restricted read op.\n            if (opRestrictsRead(op)) {\n                if (!(mContext.checkPermission(Manifest.permission.MANAGE_APPOPS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.GET_APP_OPS_STATS,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED || mContext.checkPermission(\n                        Manifest.permission.MANAGE_APP_OPS_MODES,\n                        Binder.getCallingPid(), Binder.getCallingUid())\n                        == PackageManager.PERMISSION_GRANTED)) {\n                    throw new SecurityException(\"verifyIncomingOp: uid \" + Binder.getCallingUid()\n                            + \" does not have any of {MANAGE_APPOPS, GET_APP_OPS_STATS, \"\n                            + \"MANAGE_APP_OPS_MODES}\");\n                }\n            }\n            return;\n        }\n        throw new IllegalArgumentException(\"Bad operation #\" + op);\n    }\n\n    private boolean isIncomingPackageValid(@Nullable String packageName, @UserIdInt int userId) {\n        final int callingUid = Binder.getCallingUid();\n        // Handle the special UIDs that don't have actual packages (audioserver, cameraserver, etc).\n        if (packageName == null || isSpecialPackage(callingUid, packageName)) {\n            return true;\n        }\n\n        // If the package doesn't exist, #verifyAndGetBypass would throw a SecurityException in\n        // the end. Although that exception would be caught and return, we could make it return\n        // early.\n        if (!isPackageExisted(packageName)) {\n            return false;\n        }\n\n        if (getPackageManagerInternal().filterAppAccess(packageName, callingUid, userId)) {\n            Slog.w(TAG, packageName + \" not found from \" + callingUid);\n            return false;\n        }\n\n        return true;\n    }\n\n    private boolean isSpecialPackage(int callingUid, @Nullable String packageName) {\n        final String resolvedPackage = AppOpsManager.resolvePackageName(callingUid, packageName);\n        return callingUid == Process.SYSTEM_UID\n                || resolveNonAppUid(resolvedPackage) != Process.INVALID_UID;\n    }\n\n    private boolean isCallerAndAttributionTrusted(@NonNull AttributionSource attributionSource) {\n        if (attributionSource.getUid() != Binder.getCallingUid()\n                && attributionSource.isTrusted(mContext)) {\n            // if there is a next attribution source, it must be trusted, as well.\n            if (attributionSource.getNext() == null\n                    || attributionSource.getNext().isTrusted(mContext)) {\n                return true;\n            }\n        }\n        return mContext.checkPermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    private @Nullable UidState getUidStateLocked(int uid, boolean edit) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            if (!edit) {\n                return null;\n            }\n            uidState = new UidState(uid);\n            mUidStates.put(uid, uidState);\n        }\n\n        return uidState;\n    }\n\n    private void updateAppWidgetVisibility(SparseArray<String> uidPackageNames, boolean visible) {\n        synchronized (this) {\n            getUidStateTracker().updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n    }\n\n    /**\n     * @return {@link PackageManagerInternal}\n     */\n    private @NonNull PackageManagerInternal getPackageManagerInternal() {\n        if (mPackageManagerInternal == null) {\n            mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        }\n        if (mPackageManagerInternal == null) {\n            throw new IllegalStateException(\"PackageManagerInternal not loaded\");\n        }\n\n        return mPackageManagerInternal;\n    }\n\n    /**\n     * @return {@link PackageManagerLocal}\n     */\n    private @NonNull PackageManagerLocal getPackageManagerLocal() {\n        if (mPackageManagerLocal == null) {\n            mPackageManagerLocal = LocalManagerRegistry.getManager(PackageManagerLocal.class);\n        }\n        if (mPackageManagerLocal == null) {\n            throw new IllegalStateException(\"PackageManagerLocal not loaded\");\n        }\n\n        return mPackageManagerLocal;\n    }\n\n    /**\n     * @return {@link UserManagerInternal}\n     */\n    private @NonNull UserManagerInternal getUserManagerInternal() {\n        if (mUserManagerInternal == null) {\n            mUserManagerInternal = LocalServices.getService(UserManagerInternal.class);\n        }\n        if (mUserManagerInternal == null) {\n            throw new IllegalStateException(\"UserManagerInternal not loaded\");\n        }\n\n        return mUserManagerInternal;\n    }\n\n    /**\n     * Create a restriction description matching the properties of the package.\n     *\n     * @param pkg The package to create the restriction description for\n     *\n     * @return The restriction matching the package\n     */\n    private RestrictionBypass getBypassforPackage(@NonNull PackageState packageState) {\n        return new RestrictionBypass(packageState.getAppId() == Process.SYSTEM_UID,\n                packageState.isPrivileged(), mContext.checkPermission(\n                android.Manifest.permission.EXEMPT_FROM_AUDIO_RECORD_RESTRICTIONS, -1,\n                packageState.getAppId()) == PackageManager.PERMISSION_GRANTED);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, Process.INVALID_UID, null);\n    }\n\n    /**\n     * @see #verifyAndGetBypass(int, String, String, int, String, boolean)\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName) {\n        return verifyAndGetBypass(uid, packageName, attributionTag, proxyUid, proxyPackageName,\n                false);\n    }\n\n    /**\n     * Verify that package belongs to uid and return the {@link RestrictionBypass bypass\n     * description} for the package, along with a boolean indicating whether the attribution tag is\n     * valid.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The package the might belong to the uid\n     * @param attributionTag attribution tag or {@code null} if no need to verify\n     * @param proxyUid The proxy uid, from which the attribution tag is to be pulled\n     * @param proxyPackageName The proxy package, from which the attribution tag may be pulled\n     * @param suppressErrorLogs Whether to print to logcat about nonmatching parameters\n     *\n     * @return PackageVerificationResult containing {@link RestrictionBypass} and whether the\n     *         attribution tag is valid\n     */\n    private @NonNull PackageVerificationResult verifyAndGetBypass(int uid, String packageName,\n            @Nullable String attributionTag, int proxyUid, @Nullable String proxyPackageName,\n            boolean suppressErrorLogs) {\n        if (uid == Process.ROOT_UID) {\n            // For backwards compatibility, don't check package name for root UID.\n            return new PackageVerificationResult(null,\n                    /* isAttributionTagValid */ true);\n        }\n        if (Process.isSdkSandboxUid(uid)) {\n            // SDK sandbox processes run in their own UID range, but their associated\n            // UID for checks should always be the UID of the package implementing SDK sandbox\n            // service.\n            // TODO: We will need to modify the callers of this function instead, so\n            // modifications and checks against the app ops state are done with the\n            // correct UID.\n            try {\n                final PackageManager pm = mContext.getPackageManager();\n                final String supplementalPackageName = pm.getSdkSandboxPackageName();\n                if (Objects.equals(packageName, supplementalPackageName)) {\n                    uid = pm.getPackageUidAsUser(supplementalPackageName,\n                            PackageManager.PackageInfoFlags.of(0), UserHandle.getUserId(uid));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                // Shouldn't happen for the supplemental package\n                e.printStackTrace();\n            }\n        }\n\n\n        // Do not check if uid/packageName/attributionTag is already known.\n        synchronized (this) {\n            UidState uidState = mUidStates.get(uid);\n            if (uidState != null && !uidState.pkgOps.isEmpty()) {\n                Ops ops = uidState.pkgOps.get(packageName);\n\n                if (ops != null && (attributionTag == null || ops.knownAttributionTags.contains(\n                        attributionTag)) && ops.bypass != null) {\n                    return new PackageVerificationResult(ops.bypass,\n                            ops.validAttributionTags.contains(attributionTag));\n                }\n            }\n        }\n\n        int callingUid = Binder.getCallingUid();\n\n        // Allow any attribution tag for resolvable, non-app uids\n        int nonAppUid;\n        if (Objects.equals(packageName, \"com.android.shell\")) {\n            // Special case for the shell which is a package but should be able\n            // to bypass app attribution tag restrictions.\n            nonAppUid = Process.SHELL_UID;\n        } else {\n            nonAppUid = resolveNonAppUid(packageName);\n        }\n        if (nonAppUid != Process.INVALID_UID) {\n            if (nonAppUid != UserHandle.getAppId(uid)) {\n                if (!suppressErrorLogs) {\n                    Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                                + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid\n                                + \".\");\n                }\n                String otherUidMessage =\n                            DEBUG ? \" but it is really \" + nonAppUid : \" but it is not\";\n                throw new SecurityException(\"Specified package \\\"\" + packageName\n                            + \"\\\" under uid \" +  UserHandle.getAppId(uid) + otherUidMessage);\n            }\n            // We only allow bypassing the attribution tag verification if the proxy is a\n            // system app (or is null), in order to prevent abusive apps clogging the appops\n            // system with unlimited attribution tags via proxy calls.\n            boolean proxyIsSystemAppOrNull = true;\n            if (proxyPackageName != null) {\n                int proxyAppId = UserHandle.getAppId(proxyUid);\n                if (proxyAppId >= Process.FIRST_APPLICATION_UID) {\n                    proxyIsSystemAppOrNull =\n                            mPackageManagerInternal.isSystemPackage(proxyPackageName);\n                }\n            }\n            return new PackageVerificationResult(RestrictionBypass.UNRESTRICTED,\n                    /* isAttributionTagValid */ proxyIsSystemAppOrNull);\n        }\n\n        int userId = UserHandle.getUserId(uid);\n        RestrictionBypass bypass = null;\n        boolean isAttributionTagValid = false;\n\n        int pkgUid = nonAppUid;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n            var pkgState = pmInt.getPackageStateInternal(packageName);\n            var pkg = pkgState == null ? null : pkgState.getAndroidPackage();\n            if (pkg != null) {\n                isAttributionTagValid = isAttributionInPackage(pkg, attributionTag);\n                pkgUid = UserHandle.getUid(userId, pkgState.getAppId());\n                bypass = getBypassforPackage(pkgState);\n            }\n            if (!isAttributionTagValid) {\n                AndroidPackage proxyPkg = proxyPackageName != null\n                        ? pmInt.getPackage(proxyPackageName) : null;\n                // Re-check in proxy.\n                isAttributionTagValid = isAttributionInPackage(proxyPkg, attributionTag);\n                String msg;\n                if (pkg != null && isAttributionTagValid) {\n                    msg = \"attributionTag \" + attributionTag + \" declared in manifest of the proxy\"\n                            + \" package \" + proxyPackageName + \", this is not advised\";\n                } else if (pkg != null) {\n                    msg = \"attributionTag \" + attributionTag + \" not declared in manifest of \"\n                            + packageName;\n                } else {\n                    msg = \"package \" + packageName + \" not found, can't check for \"\n                            + \"attributionTag \" + attributionTag;\n                }\n\n                try {\n                    if (!mPlatformCompat.isChangeEnabledByPackageName(\n                            SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE, packageName,\n                            userId) || !mPlatformCompat.isChangeEnabledByUid(\n                                    SECURITY_EXCEPTION_ON_INVALID_ATTRIBUTION_TAG_CHANGE,\n                            callingUid)) {\n                        // Do not override tags if overriding is not enabled for this package\n                        isAttributionTagValid = true;\n                    }\n                    Slog.e(TAG, msg);\n                } catch (RemoteException neverHappens) {\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        if (pkgUid != uid) {\n            if (!suppressErrorLogs) {\n                Slog.e(TAG, \"Bad call made by uid \" + callingUid + \". \"\n                        + \"Package \\\"\" + packageName + \"\\\" does not belong to uid \" + uid + \".\");\n            }\n            String otherUidMessage = DEBUG ? \" but it is really \" + pkgUid : \" but it is not\";\n            throw new SecurityException(\"Specified package \\\"\" + packageName + \"\\\" under uid \" + uid\n                    + otherUidMessage);\n        }\n\n        return new PackageVerificationResult(bypass, isAttributionTagValid);\n    }\n\n    private boolean isAttributionInPackage(@Nullable AndroidPackage pkg,\n            @Nullable String attributionTag) {\n        if (pkg == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        if (pkg.getAttributions() != null) {\n            int numAttributions = pkg.getAttributions().size();\n            for (int i = 0; i < numAttributions; i++) {\n                if (pkg.getAttributions().get(i).getTag().equals(attributionTag)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks to see if the attribution tag is defined in either package or proxyPackage.\n     * This method is intended for ProxyAttributionTag validation and returns false\n     * if it does not exist in either one of them.\n     *\n     * @param packageName Name of the package\n     * @param proxyPackageName Name of the proxy package\n     * @param attributionTag attribution tag to be checked\n     *\n     * @return boolean specifying if attribution tag is valid or not\n     */\n    private boolean isAttributionTagDefined(@Nullable String packageName,\n                                            @Nullable String proxyPackageName,\n                                            @Nullable String attributionTag) {\n        if (packageName == null) {\n            return false;\n        } else if (attributionTag == null) {\n            return true;\n        }\n        PackageManagerInternal pmInt = LocalServices.getService(PackageManagerInternal.class);\n        if (proxyPackageName != null) {\n            AndroidPackage proxyPkg = pmInt.getPackage(proxyPackageName);\n            if (proxyPkg != null && isAttributionInPackage(proxyPkg, attributionTag)) {\n                return true;\n            }\n        }\n        AndroidPackage pkg = pmInt.getPackage(packageName);\n        return isAttributionInPackage(pkg, attributionTag);\n    }\n\n    /**\n     * Get (and potentially create) ops.\n     *\n     * @param uid The uid the package belongs to\n     * @param packageName The name of the package\n     * @param attributionTag attribution tag\n     * @param isAttributionTagValid whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit If an ops does not exist, create the ops?\n\n     * @return The ops\n     */\n    private Ops getOpsLocked(int uid, String packageName, @Nullable String attributionTag,\n            boolean isAttributionTagValid, @Nullable RestrictionBypass bypass, boolean edit) {\n        UidState uidState = getUidStateLocked(uid, edit);\n        if (uidState == null) {\n            return null;\n        }\n\n        Ops ops = uidState.pkgOps.get(packageName);\n        if (ops == null) {\n            if (!edit) {\n                return null;\n            }\n            ops = new Ops(packageName, uidState);\n            uidState.pkgOps.put(packageName, ops);\n        }\n\n        if (edit) {\n            if (bypass != null) {\n                ops.bypass = bypass;\n            }\n\n            if (attributionTag != null) {\n                ops.knownAttributionTags.add(attributionTag);\n                if (isAttributionTagValid) {\n                    ops.validAttributionTags.add(attributionTag);\n                } else {\n                    ops.validAttributionTags.remove(attributionTag);\n                }\n            }\n        }\n\n        return ops;\n    }\n\n    private void scheduleWriteLocked() {\n        if (!mWriteScheduled) {\n            mWriteScheduled = true;\n            mHandler.postDelayed(mWriteRunner, WRITE_DELAY);\n        }\n    }\n\n    private void scheduleFastWriteLocked() {\n        if (!mFastWriteScheduled) {\n            mWriteScheduled = true;\n            mFastWriteScheduled = true;\n            mHandler.removeCallbacks(mWriteRunner);\n            mHandler.postDelayed(mWriteRunner, 10*1000);\n        }\n    }\n\n    /**\n     * Get the state of an op for a uid.\n     *\n     * @param code The code of the op\n     * @param uid The uid the of the package\n     * @param packageName The package name for which to get the state for\n     * @param attributionTag The attribution tag\n     * @param isAttributionTagValid Whether the given attribution tag is valid\n     * @param bypass When to bypass certain op restrictions (can be null if edit == false)\n     * @param edit Iff {@code true} create the {@link Op} object if not yet created\n     *\n     * @return The {@link Op state} of the op\n     */\n    private @Nullable Op getOpLocked(int code, int uid, @NonNull String packageName,\n            @Nullable String attributionTag, boolean isAttributionTagValid,\n            @Nullable RestrictionBypass bypass, boolean edit) {\n        Ops ops = getOpsLocked(uid, packageName, attributionTag, isAttributionTagValid, bypass,\n                edit);\n        if (ops == null) {\n            return null;\n        }\n        return getOpLocked(ops, code, uid, edit);\n    }\n\n    private Op getOpLocked(Ops ops, int code, int uid, boolean edit) {\n        Op op = ops.get(code);\n        if (op == null) {\n            if (!edit) {\n                return null;\n            }\n            op = new Op(ops.uidState, ops.packageName, code, uid);\n            ops.put(code, op);\n        }\n        if (edit) {\n            scheduleWriteLocked();\n        }\n        return op;\n    }\n\n    private boolean isOpRestrictedDueToSuspend(int code, String packageName, int uid) {\n        if (!ArrayUtils.contains(OPS_RESTRICTED_ON_SUSPEND, code)) {\n            return false;\n        }\n        final PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        return pmi.isPackageSuspended(packageName, UserHandle.getUserId(uid));\n    }\n\n    private boolean isOpRestrictedLocked(int uid, int code, String packageName,\n            String attributionTag, @Nullable RestrictionBypass appBypass, boolean isCheckOp) {\n        int restrictionSetCount = mOpGlobalRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code)) {\n                return true;\n            }\n        }\n\n        int userHandle = UserHandle.getUserId(uid);\n        restrictionSetCount = mOpUserRestrictions.size();\n\n        for (int i = 0; i < restrictionSetCount; i++) {\n            // For each client, check that the given op is not restricted, or that the given\n            // package is exempt from the restriction.\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);\n            if (restrictionState.hasRestriction(code, packageName, attributionTag, userHandle,\n                    isCheckOp)) {\n                RestrictionBypass opBypass = opAllowSystemBypassRestriction(code);\n                if (opBypass != null) {\n                    // If we are the system, bypass user restrictions for certain codes\n                    synchronized (this) {\n                        if (opBypass.isSystemUid && appBypass != null && appBypass.isSystemUid) {\n                            return false;\n                        }\n                        if (opBypass.isPrivileged && appBypass != null && appBypass.isPrivileged) {\n                            return false;\n                        }\n                        if (opBypass.isRecordAudioRestrictionExcept && appBypass != null\n                                && appBypass.isRecordAudioRestrictionExcept) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Read recent accesses from persistence (mRecentAccessesFile).\n     * If there is no mRecentAccessesFile yet, we'll need migrate from mStorageFile: first read from\n     * mStorageFile, then all subsequent reads/writes will use mRecentAccessesFile.\n     * If neither file exists, there's nothing to migrate.\n     */\n    private void readRecentAccesses() {\n        if (!mRecentAccessesFile.exists()) {\n            readRecentAccesses(mStorageFile);\n        } else {\n            readRecentAccesses(mRecentAccessesFile);\n        }\n    }\n\n    private void readRecentAccesses(AtomicFile file) {\n        synchronized (file) {\n            synchronized (this) {\n                FileInputStream stream;\n                try {\n                    stream = file.openRead();\n                } catch (FileNotFoundException e) {\n                    Slog.i(TAG, \"No existing app ops \" + file.getBaseFile() + \"; starting empty\");\n                    return;\n                }\n                boolean success = false;\n                mUidStates.clear();\n                mAppOpsCheckingService.clearAllModes();\n                try {\n                    TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n                    int type;\n                    while ((type = parser.next()) != XmlPullParser.START_TAG\n                            && type != XmlPullParser.END_DOCUMENT) {\n                        // Parse next until we reach the start or end\n                    }\n\n                    if (type != XmlPullParser.START_TAG) {\n                        throw new IllegalStateException(\"no start tag found\");\n                    }\n\n                    int outerDepth = parser.getDepth();\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                            continue;\n                        }\n\n                        String tagName = parser.getName();\n                        if (tagName.equals(\"pkg\")) {\n                            readPackage(parser);\n                        } else if (tagName.equals(\"uid\")) {\n                            // uid tag may be present during migration, don't print warning.\n                            XmlUtils.skipCurrentTag(parser);\n                        } else {\n                            Slog.w(TAG, \"Unknown element under <app-ops>: \"\n                                    + parser.getName());\n                            XmlUtils.skipCurrentTag(parser);\n                        }\n                    }\n\n                    success = true;\n                } catch (IllegalStateException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NullPointerException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (NumberFormatException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (XmlPullParserException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } catch (IndexOutOfBoundsException e) {\n                    Slog.w(TAG, \"Failed parsing \" + e);\n                } finally {\n                    if (!success) {\n                        mUidStates.clear();\n                        mAppOpsCheckingService.clearAllModes();\n                    }\n                    try {\n                        stream.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n    }\n\n    private void readPackage(TypedXmlPullParser parser)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        String pkgName = parser.getAttributeValue(null, \"n\");\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n\n            String tagName = parser.getName();\n            if (tagName.equals(\"uid\")) {\n                readUid(parser, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readUid(TypedXmlPullParser parser, String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int uid = parser.getAttributeInt(null, \"n\");\n        final UidState uidState = getUidStateLocked(uid, true);\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"op\")) {\n                readOp(parser, uidState, pkgName);\n            } else {\n                Slog.w(TAG, \"Unknown element under <pkg>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n    }\n\n    private void readAttributionOp(TypedXmlPullParser parser, @NonNull Op parent,\n            @Nullable String attribution)\n            throws NumberFormatException, IOException, XmlPullParserException {\n        final AttributedOp attributedOp = parent.getOrCreateAttribution(parent, attribution);\n\n        final long key = parser.getAttributeLong(null, \"n\");\n        final int uidState = extractUidStateFromKey(key);\n        final int opFlags = extractFlagsFromKey(key);\n\n        final long accessTime = parser.getAttributeLong(null, \"t\", 0);\n        final long rejectTime = parser.getAttributeLong(null, \"r\", 0);\n        final long accessDuration = parser.getAttributeLong(null, \"d\", -1);\n        final String proxyPkg = XmlUtils.readStringAttribute(parser, \"pp\");\n        final int proxyUid = parser.getAttributeInt(null, \"pu\", Process.INVALID_UID);\n        final String proxyAttributionTag = XmlUtils.readStringAttribute(parser, \"pc\");\n\n        if (accessTime > 0) {\n            attributedOp.accessed(accessTime, accessDuration, proxyUid, proxyPkg,\n                    proxyAttributionTag, uidState, opFlags);\n        }\n        if (rejectTime > 0) {\n            attributedOp.rejected(rejectTime, uidState, opFlags);\n        }\n    }\n\n    private void readOp(TypedXmlPullParser parser,\n            @NonNull UidState uidState, @NonNull String pkgName)\n            throws NumberFormatException, XmlPullParserException, IOException {\n        int opCode = parser.getAttributeInt(null, \"n\");\n        Op op = new Op(uidState, pkgName, opCode, uidState.uid);\n\n        int outerDepth = parser.getDepth();\n        int type;\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                continue;\n            }\n            String tagName = parser.getName();\n            if (tagName.equals(\"st\")) {\n                readAttributionOp(parser, op, XmlUtils.readStringAttribute(parser, \"id\"));\n            } else {\n                Slog.w(TAG, \"Unknown element under <op>: \"\n                        + parser.getName());\n                XmlUtils.skipCurrentTag(parser);\n            }\n        }\n\n        Ops ops = uidState.pkgOps.get(pkgName);\n        if (ops == null) {\n            ops = new Ops(pkgName, uidState);\n            uidState.pkgOps.put(pkgName, ops);\n        }\n        ops.put(op.op, op);\n    }\n\n    @VisibleForTesting\n    void writeRecentAccesses() {\n        synchronized (mRecentAccessesFile) {\n            FileOutputStream stream;\n            try {\n                stream = mRecentAccessesFile.startWrite();\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state: \" + e);\n                return;\n            }\n\n            List<AppOpsManager.PackageOps> allOps = getPackagesForOps(null);\n\n            try {\n                TypedXmlSerializer out = Xml.resolveSerializer(stream);\n                out.startDocument(null, true);\n                out.startTag(null, \"app-ops\");\n                out.attributeInt(null, \"v\", CURRENT_VERSION);\n\n                if (allOps != null) {\n                    String lastPkg = null;\n                    for (int i=0; i<allOps.size(); i++) {\n                        AppOpsManager.PackageOps pkg = allOps.get(i);\n                        if (!Objects.equals(pkg.getPackageName(), lastPkg)) {\n                            if (lastPkg != null) {\n                                out.endTag(null, \"pkg\");\n                            }\n                            lastPkg = pkg.getPackageName();\n                            if (lastPkg != null) {\n                                out.startTag(null, \"pkg\");\n                                out.attribute(null, \"n\", lastPkg);\n                            }\n                        }\n                        out.startTag(null, \"uid\");\n                        out.attributeInt(null, \"n\", pkg.getUid());\n                        List<AppOpsManager.OpEntry> ops = pkg.getOps();\n                        for (int j=0; j<ops.size(); j++) {\n                            AppOpsManager.OpEntry op = ops.get(j);\n                            out.startTag(null, \"op\");\n                            out.attributeInt(null, \"n\", op.getOp());\n                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {\n                                out.attributeInt(null, \"m\", op.getMode());\n                            }\n\n                            for (String attributionTag : op.getAttributedOpEntries().keySet()) {\n                                final AttributedOpEntry attribution =\n                                        op.getAttributedOpEntries().get(attributionTag);\n\n                                final ArraySet<Long> keys = attribution.collectKeys();\n\n                                final int keyCount = keys.size();\n                                for (int k = 0; k < keyCount; k++) {\n                                    final long key = keys.valueAt(k);\n\n                                    final int uidState = AppOpsManager.extractUidStateFromKey(key);\n                                    final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n                                    final long accessTime = attribution.getLastAccessTime(uidState,\n                                            uidState, flags);\n                                    final long rejectTime = attribution.getLastRejectTime(uidState,\n                                            uidState, flags);\n                                    final long accessDuration = attribution.getLastDuration(\n                                            uidState, uidState, flags);\n                                    // Proxy information for rejections is not backed up\n                                    final OpEventProxyInfo proxy = attribution.getLastProxyInfo(\n                                            uidState, uidState, flags);\n\n                                    if (accessTime <= 0 && rejectTime <= 0 && accessDuration <= 0\n                                            && proxy == null) {\n                                        continue;\n                                    }\n\n                                    String proxyPkg = null;\n                                    String proxyAttributionTag = null;\n                                    int proxyUid = Process.INVALID_UID;\n                                    if (proxy != null) {\n                                        proxyPkg = proxy.getPackageName();\n                                        proxyAttributionTag = proxy.getAttributionTag();\n                                        proxyUid = proxy.getUid();\n                                    }\n\n                                    out.startTag(null, \"st\");\n                                    if (attributionTag != null) {\n                                        out.attribute(null, \"id\", attributionTag);\n                                    }\n                                    out.attributeLong(null, \"n\", key);\n                                    if (accessTime > 0) {\n                                        out.attributeLong(null, \"t\", accessTime);\n                                    }\n                                    if (rejectTime > 0) {\n                                        out.attributeLong(null, \"r\", rejectTime);\n                                    }\n                                    if (accessDuration > 0) {\n                                        out.attributeLong(null, \"d\", accessDuration);\n                                    }\n                                    if (proxyPkg != null) {\n                                        out.attribute(null, \"pp\", proxyPkg);\n                                    }\n                                    if (proxyAttributionTag != null) {\n                                        out.attribute(null, \"pc\", proxyAttributionTag);\n                                    }\n                                    if (proxyUid >= 0) {\n                                        out.attributeInt(null, \"pu\", proxyUid);\n                                    }\n                                    out.endTag(null, \"st\");\n                                }\n                            }\n\n                            out.endTag(null, \"op\");\n                        }\n                        out.endTag(null, \"uid\");\n                    }\n                    if (lastPkg != null) {\n                        out.endTag(null, \"pkg\");\n                    }\n                }\n\n                out.endTag(null, \"app-ops\");\n                out.endDocument();\n                mRecentAccessesFile.finishWrite(stream);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to write state, restoring backup.\", e);\n                mRecentAccessesFile.failWrite(stream);\n            }\n        }\n        mHistoricalRegistry.writeAndClearDiscreteHistory();\n    }\n\n    static class Shell extends ShellCommand {\n        final IAppOpsService mInterface;\n        final AppOpsService mInternal;\n\n        int userId = UserHandle.USER_SYSTEM;\n        String packageName;\n        String attributionTag;\n        String opStr;\n        String modeStr;\n        int op;\n        int mode;\n        int packageUid;\n        int nonpackageUid;\n        final static Binder sBinder = new Binder();\n        IBinder mToken;\n        boolean targetsUid;\n\n        Shell(IAppOpsService iface, AppOpsService internal) {\n            mInterface = iface;\n            mInternal = internal;\n            mToken = AppOpsManager.getClientId();\n        }\n\n        @Override\n        public int onCommand(String cmd) {\n            return onShellCommand(this, cmd);\n        }\n\n        @Override\n        public void onHelp() {\n            PrintWriter pw = getOutPrintWriter();\n            dumpCommandHelp(pw);\n        }\n\n        static private int strOpToOp(String op, PrintWriter err) {\n            try {\n                return AppOpsManager.strOpToOp(op);\n            } catch (IllegalArgumentException e) {\n            }\n            try {\n                return Integer.parseInt(op);\n            } catch (NumberFormatException e) {\n            }\n            try {\n                return AppOpsManager.strDebugOpToOp(op);\n            } catch (IllegalArgumentException e) {\n                err.println(\"Error: \" + e.getMessage());\n                return -1;\n            }\n        }\n\n        static int strModeToMode(String modeStr, PrintWriter err) {\n            for (int i = AppOpsManager.MODE_NAMES.length - 1; i >= 0; i--) {\n                if (AppOpsManager.MODE_NAMES[i].equals(modeStr)) {\n                    return i;\n                }\n            }\n            try {\n                return Integer.parseInt(modeStr);\n            } catch (NumberFormatException e) {\n            }\n            err.println(\"Error: Mode \" + modeStr + \" is not valid\");\n            return -1;\n        }\n\n        int parseUserOpMode(int defMode, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            opStr = null;\n            modeStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else {\n                    if (opStr == null) {\n                        opStr = argument;\n                    } else if (modeStr == null) {\n                        modeStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (opStr == null) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            op = strOpToOp(opStr, err);\n            if (op < 0) {\n                return -1;\n            }\n            if (modeStr != null) {\n                if ((mode=strModeToMode(modeStr, err)) < 0) {\n                    return -1;\n                }\n            } else {\n                mode = defMode;\n            }\n            return 0;\n        }\n\n        int parseUserPackageOp(boolean reqOp, PrintWriter err) throws RemoteException {\n            userId = UserHandle.USER_CURRENT;\n            packageName = null;\n            opStr = null;\n            for (String argument; (argument = getNextArg()) != null;) {\n                if (\"--user\".equals(argument)) {\n                    userId = UserHandle.parseUserArg(getNextArgRequired());\n                } else if (\"--uid\".equals(argument)) {\n                    targetsUid = true;\n                } else if (\"--attribution\".equals(argument)) {\n                    attributionTag = getNextArgRequired();\n                } else {\n                    if (packageName == null) {\n                        packageName = argument;\n                    } else if (opStr == null) {\n                        opStr = argument;\n                        break;\n                    }\n                }\n            }\n            if (packageName == null) {\n                err.println(\"Error: Package name not specified.\");\n                return -1;\n            } else if (opStr == null && reqOp) {\n                err.println(\"Error: Operation not specified.\");\n                return -1;\n            }\n            if (opStr != null) {\n                op = strOpToOp(opStr, err);\n                if (op < 0) {\n                    return -1;\n                }\n            } else {\n                op = AppOpsManager.OP_NONE;\n            }\n            if (userId == UserHandle.USER_CURRENT) {\n                userId = ActivityManager.getCurrentUser();\n            }\n            nonpackageUid = -1;\n            try {\n                nonpackageUid = Integer.parseInt(packageName);\n            } catch (NumberFormatException e) {\n            }\n            if (nonpackageUid == -1 && packageName.length() > 1 && packageName.charAt(0) == 'u'\n                    && packageName.indexOf('.') < 0) {\n                int i = 1;\n                while (i < packageName.length() && packageName.charAt(i) >= '0'\n                        && packageName.charAt(i) <= '9') {\n                    i++;\n                }\n                if (i > 1 && i < packageName.length()) {\n                    String userStr = packageName.substring(1, i);\n                    try {\n                        int user = Integer.parseInt(userStr);\n                        char type = packageName.charAt(i);\n                        i++;\n                        int startTypeVal = i;\n                        while (i < packageName.length() && packageName.charAt(i) >= '0'\n                                && packageName.charAt(i) <= '9') {\n                            i++;\n                        }\n                        if (i > startTypeVal) {\n                            String typeValStr = packageName.substring(startTypeVal, i);\n                            try {\n                                int typeVal = Integer.parseInt(typeValStr);\n                                if (type == 'a') {\n                                    nonpackageUid = UserHandle.getUid(user,\n                                            typeVal + Process.FIRST_APPLICATION_UID);\n                                } else if (type == 's') {\n                                    nonpackageUid = UserHandle.getUid(user, typeVal);\n                                }\n                            } catch (NumberFormatException e) {\n                            }\n                        }\n                    } catch (NumberFormatException e) {\n                    }\n                }\n            }\n            if (nonpackageUid != -1) {\n                packageName = null;\n            } else {\n                packageUid = resolveNonAppUid(packageName);\n                if (packageUid < 0) {\n                    packageUid = AppGlobals.getPackageManager().getPackageUid(packageName,\n                            PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n                }\n                if (packageUid < 0) {\n                    err.println(\"Error: No UID for \" + packageName + \" in user \" + userId);\n                    return -1;\n                }\n            }\n            return 0;\n        }\n    }\n\n    @Override public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        (new Shell(this, this)).exec(this, in, out, err, args, callback, resultReceiver);\n    }\n\n    static void dumpCommandHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) commands:\");\n        pw.println(\"  help\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  start [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Starts a given operation for a particular application.\");\n        pw.println(\"  stop [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"<OP> \");\n        pw.println(\"    Stops a given operation for a particular application.\");\n        pw.println(\"  set [--user <USER_ID>] <[--uid] PACKAGE | UID> <OP> <MODE>\");\n        pw.println(\"    Set the mode for a particular application and operation.\");\n        pw.println(\"  get [--user <USER_ID>] [--attribution <ATTRIBUTION_TAG>] <PACKAGE | UID> \"\n                + \"[<OP>]\");\n        pw.println(\"    Return the mode for a particular application and optional operation.\");\n        pw.println(\"  query-op [--user <USER_ID>] <OP> [<MODE>]\");\n        pw.println(\"    Print all packages that currently have the given op in the given mode.\");\n        pw.println(\"  reset [--user <USER_ID>] [<PACKAGE>]\");\n        pw.println(\"    Reset the given application or all applications to default modes.\");\n        pw.println(\"  write-settings\");\n        pw.println(\"    Immediately write pending changes to storage.\");\n        pw.println(\"  read-settings\");\n        pw.println(\"    Read the last written settings, replacing current state in RAM.\");\n        pw.println(\"  options:\");\n        pw.println(\"    <PACKAGE> an Android package name or its UID if prefixed by --uid\");\n        pw.println(\"    <OP>      an AppOps operation.\");\n        pw.println(\"    <MODE>    one of allow, ignore, deny, or default\");\n        pw.println(\"    <USER_ID> the user id under which the package is installed. If --user is\");\n        pw.println(\"              not specified, the current user is assumed.\");\n    }\n\n    static int onShellCommand(Shell shell, String cmd) {\n        if (cmd == null) {\n            return shell.handleDefaultCommands(cmd);\n        }\n        PrintWriter pw = shell.getOutPrintWriter();\n        PrintWriter err = shell.getErrPrintWriter();\n        try {\n            switch (cmd) {\n                case \"set\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    String modeStr = shell.getNextArg();\n                    if (modeStr == null) {\n                        err.println(\"Error: Mode not specified.\");\n                        return -1;\n                    }\n\n                    final int mode = shell.strModeToMode(modeStr, err);\n                    if (mode < 0) {\n                        return -1;\n                    }\n\n                    if (!shell.targetsUid && shell.packageName != null) {\n                        shell.mInterface.setMode(shell.op, shell.packageUid, shell.packageName,\n                                mode);\n                    } else if (shell.targetsUid && shell.packageName != null) {\n                        try {\n                            final int uid = shell.mInternal.mContext.getPackageManager()\n                                    .getPackageUidAsUser(shell.packageName, shell.userId);\n                            shell.mInterface.setUidMode(shell.op, uid, mode);\n                        } catch (PackageManager.NameNotFoundException e) {\n                            return -1;\n                        }\n                    } else {\n                        shell.mInterface.setUidMode(shell.op, shell.nonpackageUid, mode);\n                    }\n                    return 0;\n                }\n                case \"get\": {\n                    int res = shell.parseUserPackageOp(false, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    List<AppOpsManager.PackageOps> ops = new ArrayList<>();\n                    if (shell.packageName != null) {\n                        // Uid mode overrides package mode, so make sure it's also reported\n                        List<AppOpsManager.PackageOps> r = shell.mInterface.getUidOps(\n                                shell.packageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                        r = shell.mInterface.getOpsForPackage(\n                                shell.packageUid, shell.packageName,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                        if (r != null) {\n                            ops.addAll(r);\n                        }\n                    } else {\n                        ops = shell.mInterface.getUidOps(\n                                shell.nonpackageUid,\n                                shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);\n                    }\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        if (shell.op > AppOpsManager.OP_NONE && shell.op < AppOpsManager._NUM_OP) {\n                            pw.println(\"Default mode: \" + AppOpsManager.modeToName(\n                                    AppOpsManager.opToDefaultMode(shell.op)));\n                        }\n                        return 0;\n                    }\n                    final long now = System.currentTimeMillis();\n                    for (int i=0; i<ops.size(); i++) {\n                        AppOpsManager.PackageOps packageOps = ops.get(i);\n                        if (packageOps.getPackageName() == null) {\n                            pw.print(\"Uid mode: \");\n                        }\n                        List<AppOpsManager.OpEntry> entries = packageOps.getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            pw.print(AppOpsManager.opToName(ent.getOp()));\n                            pw.print(\": \");\n                            pw.print(AppOpsManager.modeToName(ent.getMode()));\n                            if (shell.attributionTag == null) {\n                                if (ent.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; time=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastAccessTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; rejectTime=\");\n                                    TimeUtils.formatDuration(\n                                            now - ent.getLastRejectTime(OP_FLAGS_ALL), pw);\n                                    pw.print(\" ago\");\n                                }\n                                if (ent.isRunning()) {\n                                    pw.print(\" (running)\");\n                                } else if (ent.getLastDuration(OP_FLAGS_ALL) != -1) {\n                                    pw.print(\"; duration=\");\n                                    TimeUtils.formatDuration(ent.getLastDuration(OP_FLAGS_ALL), pw);\n                                }\n                            } else {\n                                final AppOpsManager.AttributedOpEntry attributionEnt =\n                                        ent.getAttributedOpEntries().get(shell.attributionTag);\n                                if (attributionEnt != null) {\n                                    if (attributionEnt.getLastAccessTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; time=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastAccessTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.getLastRejectTime(OP_FLAGS_ALL) != -1) {\n                                        pw.print(\"; rejectTime=\");\n                                        TimeUtils.formatDuration(\n                                                now - attributionEnt.getLastRejectTime(\n                                                        OP_FLAGS_ALL), pw);\n                                        pw.print(\" ago\");\n                                    }\n                                    if (attributionEnt.isRunning()) {\n                                        pw.print(\" (running)\");\n                                    } else if (attributionEnt.getLastDuration(OP_FLAGS_ALL)\n                                            != -1) {\n                                        pw.print(\"; duration=\");\n                                        TimeUtils.formatDuration(\n                                                attributionEnt.getLastDuration(OP_FLAGS_ALL), pw);\n                                    }\n                                }\n                            }\n                            pw.println();\n                        }\n                    }\n                    return 0;\n                }\n                case \"query-op\": {\n                    int res = shell.parseUserOpMode(AppOpsManager.MODE_IGNORED, err);\n                    if (res < 0) {\n                        return res;\n                    }\n                    List<AppOpsManager.PackageOps> ops = shell.mInterface.getPackagesForOps(\n                            new int[] {shell.op});\n                    if (ops == null || ops.size() <= 0) {\n                        pw.println(\"No operations.\");\n                        return 0;\n                    }\n                    for (int i=0; i<ops.size(); i++) {\n                        final AppOpsManager.PackageOps pkg = ops.get(i);\n                        boolean hasMatch = false;\n                        final List<AppOpsManager.OpEntry> entries = ops.get(i).getOps();\n                        for (int j=0; j<entries.size(); j++) {\n                            AppOpsManager.OpEntry ent = entries.get(j);\n                            if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {\n                                hasMatch = true;\n                                break;\n                            }\n                        }\n                        if (hasMatch) {\n                            pw.println(pkg.getPackageName());\n                        }\n                    }\n                    return 0;\n                }\n                case \"reset\": {\n                    String packageName = null;\n                    int userId = UserHandle.USER_CURRENT;\n                    for (String argument; (argument = shell.getNextArg()) != null;) {\n                        if (\"--user\".equals(argument)) {\n                            String userStr = shell.getNextArgRequired();\n                            userId = UserHandle.parseUserArg(userStr);\n                        } else {\n                            if (packageName == null) {\n                                packageName = argument;\n                            } else {\n                                err.println(\"Error: Unsupported argument: \" + argument);\n                                return -1;\n                            }\n                        }\n                    }\n\n                    if (userId == UserHandle.USER_CURRENT) {\n                        userId = ActivityManager.getCurrentUser();\n                    }\n\n                    shell.mInterface.resetAllModes(userId, packageName);\n                    pw.print(\"Reset all modes for: \");\n                    if (userId == UserHandle.USER_ALL) {\n                        pw.print(\"all users\");\n                    } else {\n                        pw.print(\"user \"); pw.print(userId);\n                    }\n                    pw.print(\", \");\n                    if (packageName == null) {\n                        pw.println(\"all packages\");\n                    } else {\n                        pw.print(\"package \"); pw.println(packageName);\n                    }\n                    return 0;\n                }\n                case \"write-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        synchronized (shell.mInternal) {\n                            shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);\n                        }\n                        shell.mInternal.writeRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.writeState();\n                        pw.println(\"Current settings written.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"read-settings\": {\n                    shell.mInternal.enforceManageAppOpsModes(Binder.getCallingPid(),\n                            Binder.getCallingUid(), -1);\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        shell.mInternal.readRecentAccesses();\n                        shell.mInternal.mAppOpsCheckingService.readState();\n                        pw.println(\"Last settings read.\");\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                    return 0;\n                }\n                case \"start\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.startOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag, true, true,\n                                \"appops start shell command\", true,\n                                AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR, ATTRIBUTION_CHAIN_ID_NONE);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                case \"stop\": {\n                    int res = shell.parseUserPackageOp(true, err);\n                    if (res < 0) {\n                        return res;\n                    }\n\n                    if (shell.packageName != null) {\n                        shell.mInterface.finishOperation(shell.mToken, shell.op, shell.packageUid,\n                                shell.packageName, shell.attributionTag);\n                    } else {\n                        return -1;\n                    }\n                    return 0;\n                }\n                default:\n                    return shell.handleDefaultCommands(cmd);\n            }\n        } catch (RemoteException e) {\n            pw.println(\"Remote exception: \" + e);\n        }\n        return -1;\n    }\n\n    private void dumpHelp(PrintWriter pw) {\n        pw.println(\"AppOps service (appops) dump options:\");\n        pw.println(\"  -h\");\n        pw.println(\"    Print this help text.\");\n        pw.println(\"  --op [OP]\");\n        pw.println(\"    Limit output to data associated with the given app op code.\");\n        pw.println(\"  --mode [MODE]\");\n        pw.println(\"    Limit output to data associated with the given app op mode.\");\n        pw.println(\"  --package [PACKAGE]\");\n        pw.println(\"    Limit output to data associated with the given package name.\");\n        pw.println(\"  --attributionTag [attributionTag]\");\n        pw.println(\"    Limit output to data associated with the given attribution tag.\");\n        pw.println(\"  --include-discrete [n]\");\n        pw.println(\"    Include discrete ops limited to n per dimension. Use zero for no limit.\");\n        pw.println(\"  --watchers\");\n        pw.println(\"    Only output the watcher sections.\");\n        pw.println(\"  --history\");\n        pw.println(\"    Only output history.\");\n        pw.println(\"  --uid-state-changes\");\n        pw.println(\"    Include logs about uid state changes.\");\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, @Nullable String filterAttributionTag,\n            @HistoricalOpsRequestFilter int filter, long nowElapsed, @NonNull Op op, long now,\n            @NonNull SimpleDateFormat sdf, @NonNull Date date, @NonNull String prefix) {\n        final int numAttributions = op.mAttributions.size();\n        for (int i = 0; i < numAttributions; i++) {\n            if ((filter & FILTER_BY_ATTRIBUTION_TAG) != 0 && !Objects.equals(\n                    op.mAttributions.keyAt(i), filterAttributionTag)) {\n                continue;\n            }\n\n            pw.print(prefix + op.mAttributions.keyAt(i) + \"=[\\n\");\n            dumpStatesLocked(pw, nowElapsed, op, op.mAttributions.keyAt(i), now, sdf, date,\n                    prefix + \"  \");\n            pw.print(prefix + \"]\\n\");\n        }\n    }\n\n    private void dumpStatesLocked(@NonNull PrintWriter pw, long nowElapsed, @NonNull Op op,\n            @Nullable String attributionTag, long now, @NonNull SimpleDateFormat sdf,\n            @NonNull Date date, @NonNull String prefix) {\n\n        final AttributedOpEntry entry = op.createSingleAttributionEntryLocked(\n                attributionTag).getAttributedOpEntries().get(attributionTag);\n\n        final ArraySet<Long> keys = entry.collectKeys();\n\n        final int keyCount = keys.size();\n        for (int k = 0; k < keyCount; k++) {\n            final long key = keys.valueAt(k);\n\n            final int uidState = AppOpsManager.extractUidStateFromKey(key);\n            final int flags = AppOpsManager.extractFlagsFromKey(key);\n\n            final long accessTime = entry.getLastAccessTime(uidState, uidState, flags);\n            final long rejectTime = entry.getLastRejectTime(uidState, uidState, flags);\n            final long accessDuration = entry.getLastDuration(uidState, uidState, flags);\n            final OpEventProxyInfo proxy = entry.getLastProxyInfo(uidState, uidState, flags);\n\n            String proxyPkg = null;\n            String proxyAttributionTag = null;\n            int proxyUid = Process.INVALID_UID;\n            if (proxy != null) {\n                proxyPkg = proxy.getPackageName();\n                proxyAttributionTag = proxy.getAttributionTag();\n                proxyUid = proxy.getUid();\n            }\n\n            if (accessTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Access: \");\n                pw.print(AppOpsManager.keyToString(key));\n                pw.print(\" \");\n                date.setTime(accessTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(accessTime - now, pw);\n                pw.print(\")\");\n                if (accessDuration > 0) {\n                    pw.print(\" duration=\");\n                    TimeUtils.formatDuration(accessDuration, pw);\n                }\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n\n            if (rejectTime > 0) {\n                pw.print(prefix);\n                pw.print(\"Reject: \");\n                pw.print(AppOpsManager.keyToString(key));\n                date.setTime(rejectTime);\n                pw.print(sdf.format(date));\n                pw.print(\" (\");\n                TimeUtils.formatDuration(rejectTime - now, pw);\n                pw.print(\")\");\n                if (proxyUid >= 0) {\n                    pw.print(\" proxy[\");\n                    pw.print(\"uid=\");\n                    pw.print(proxyUid);\n                    pw.print(\", pkg=\");\n                    pw.print(proxyPkg);\n                    pw.print(\", attributionTag=\");\n                    pw.print(proxyAttributionTag);\n                    pw.print(\"]\");\n                }\n                pw.println();\n            }\n        }\n\n        final AttributedOp attributedOp = op.mAttributions.get(attributionTag);\n        if (attributedOp.isRunning()) {\n            long earliestElapsedTime = Long.MAX_VALUE;\n            long maxNumStarts = 0;\n            int numInProgressEvents = attributedOp.mInProgressEvents.size();\n            for (int i = 0; i < numInProgressEvents; i++) {\n                AttributedOp.InProgressStartOpEvent event =\n                        attributedOp.mInProgressEvents.valueAt(i);\n\n                earliestElapsedTime = Math.min(earliestElapsedTime, event.getStartElapsedTime());\n                maxNumStarts = Math.max(maxNumStarts, event.mNumUnfinishedStarts);\n            }\n\n            pw.print(prefix + \"Running start at: \");\n            TimeUtils.formatDuration(nowElapsed - earliestElapsedTime, pw);\n            pw.println();\n\n            if (maxNumStarts > 1) {\n                pw.print(prefix + \"startNesting=\");\n                pw.println(maxNumStarts);\n            }\n        }\n    }\n\n    @NeverCompile // Avoid size overhead of debugging code.\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;\n\n        int dumpOp = OP_NONE;\n        String dumpPackage = null;\n        String dumpAttributionTag = null;\n        int dumpUid = Process.INVALID_UID;\n        int dumpMode = -1;\n        boolean dumpWatchers = false;\n        // TODO ntmyren: Remove the dumpHistory and dumpFilter\n        boolean dumpHistory = false;\n        boolean includeDiscreteOps = false;\n        boolean dumpUidStateChangeLogs = false;\n        int nDiscreteOps = 10;\n        @HistoricalOpsRequestFilter int dumpFilter = 0;\n        boolean dumpAll = false;\n\n        if (args != null) {\n            for (int i = 0; i < args.length; i++) {\n                String arg = args[i];\n                if (\"-h\".equals(arg)) {\n                    dumpHelp(pw);\n                    return;\n                } else if (\"-a\".equals(arg)) {\n                    // dump all data\n                    dumpAll = true;\n                } else if (\"--op\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --op option\");\n                        return;\n                    }\n                    dumpOp = Shell.strOpToOp(args[i], pw);\n                    dumpFilter |= FILTER_BY_OP_NAMES;\n                    if (dumpOp < 0) {\n                        return;\n                    }\n                } else if (\"--package\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --package option\");\n                        return;\n                    }\n                    dumpPackage = args[i];\n                    dumpFilter |= FILTER_BY_PACKAGE_NAME;\n                    try {\n                        dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage,\n                                PackageManager.MATCH_KNOWN_PACKAGES | PackageManager.MATCH_INSTANT,\n                                0);\n                    } catch (RemoteException e) {\n                    }\n                    if (dumpUid < 0) {\n                        pw.println(\"Unknown package: \" + dumpPackage);\n                        return;\n                    }\n                    dumpUid = UserHandle.getAppId(dumpUid);\n                    dumpFilter |= FILTER_BY_UID;\n                } else if (\"--attributionTag\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --attributionTag option\");\n                        return;\n                    }\n                    dumpAttributionTag = args[i];\n                    dumpFilter |= FILTER_BY_ATTRIBUTION_TAG;\n                } else if (\"--mode\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --mode option\");\n                        return;\n                    }\n                    dumpMode = Shell.strModeToMode(args[i], pw);\n                    if (dumpMode < 0) {\n                        return;\n                    }\n                } else if (\"--watchers\".equals(arg)) {\n                    dumpWatchers = true;\n                } else if (\"--include-discrete\".equals(arg)) {\n                    i++;\n                    if (i >= args.length) {\n                        pw.println(\"No argument for --include-discrete option\");\n                        return;\n                    }\n                    try {\n                        nDiscreteOps = Integer.valueOf(args[i]);\n                    } catch (NumberFormatException e) {\n                        pw.println(\"Wrong parameter: \" + args[i]);\n                        return;\n                    }\n                    includeDiscreteOps = true;\n                } else if (\"--history\".equals(arg)) {\n                    dumpHistory = true;\n                } else if (arg.length() > 0 && arg.charAt(0) == '-') {\n                    pw.println(\"Unknown option: \" + arg);\n                    return;\n                } else if (\"--uid-state-changes\".equals(arg)) {\n                    dumpUidStateChangeLogs = true;\n                } else {\n                    pw.println(\"Unknown command: \" + arg);\n                    return;\n                }\n            }\n        }\n\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        final Date date = new Date();\n        synchronized (this) {\n            pw.println(\"Current AppOps Service state:\");\n            if (!dumpHistory && !dumpWatchers) {\n                mConstants.dump(pw);\n            }\n            pw.println();\n            final long now = System.currentTimeMillis();\n            final long nowElapsed = SystemClock.elapsedRealtime();\n            final long nowUptime = SystemClock.uptimeMillis();\n            boolean needSep = false;\n            if (dumpFilter == 0 && dumpMode < 0 && mProfileOwners != null && !dumpWatchers\n                    && !dumpHistory) {\n                pw.println(\"  Profile owners:\");\n                for (int poi = 0; poi < mProfileOwners.size(); poi++) {\n                    pw.print(\"    User #\");\n                    pw.print(mProfileOwners.keyAt(poi));\n                    pw.print(\": \");\n                    UserHandle.formatUid(pw, mProfileOwners.valueAt(poi));\n                    pw.println();\n                }\n                pw.println();\n            }\n\n            if (!dumpHistory) {\n                needSep |= mAppOpsCheckingService.dumpListeners(dumpOp, dumpUid, dumpPackage, pw);\n            }\n\n            if (mModeWatchers.size() > 0 && dumpOp < 0 && !dumpHistory) {\n                boolean printedHeader = false;\n                for (int i = 0; i < mModeWatchers.size(); i++) {\n                    final ModeCallback cb = mModeWatchers.valueAt(i);\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.getWatchingUid())) {\n                        continue;\n                    }\n                    needSep = true;\n                    if (!printedHeader) {\n                        pw.println(\"  All op mode watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(mModeWatchers.keyAt(i))));\n                    pw.print(\": \"); pw.println(cb);\n                }\n            }\n            if (mActiveWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mActiveWatchers.size(); watcherNum++) {\n                    final SparseArray<ActiveCallback> activeWatchers =\n                            mActiveWatchers.valueAt(watcherNum);\n                    if (activeWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final ActiveCallback cb = activeWatchers.valueAt(0);\n                    if (dumpOp >= 0 && activeWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op active watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mActiveWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = activeWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(activeWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mStartedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n\n                final int watchersSize = mStartedWatchers.size();\n                for (int watcherNum = 0; watcherNum < watchersSize; watcherNum++) {\n                    final SparseArray<StartedCallback> startedWatchers =\n                            mStartedWatchers.valueAt(watcherNum);\n                    if (startedWatchers.size() <= 0) {\n                        continue;\n                    }\n\n                    final StartedCallback cb = startedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && startedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n\n                    if (!printedHeader) {\n                        pw.println(\"  All op started watchers:\");\n                        printedHeader = true;\n                    }\n\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mStartedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n\n                    pw.print(\"        [\");\n                    final int opCount = startedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n\n                        pw.print(AppOpsManager.opToName(startedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mNotedWatchers.size() > 0 && dumpMode < 0) {\n                needSep = true;\n                boolean printedHeader = false;\n                for (int watcherNum = 0; watcherNum < mNotedWatchers.size(); watcherNum++) {\n                    final SparseArray<NotedCallback> notedWatchers =\n                            mNotedWatchers.valueAt(watcherNum);\n                    if (notedWatchers.size() <= 0) {\n                        continue;\n                    }\n                    final NotedCallback cb = notedWatchers.valueAt(0);\n                    if (dumpOp >= 0 && notedWatchers.indexOfKey(dumpOp) < 0) {\n                        continue;\n                    }\n                    if (dumpPackage != null\n                            && dumpUid != UserHandle.getAppId(cb.mWatchingUid)) {\n                        continue;\n                    }\n                    if (!printedHeader) {\n                        pw.println(\"  All op noted watchers:\");\n                        printedHeader = true;\n                    }\n                    pw.print(\"    \");\n                    pw.print(Integer.toHexString(System.identityHashCode(\n                            mNotedWatchers.keyAt(watcherNum))));\n                    pw.println(\" ->\");\n                    pw.print(\"        [\");\n                    final int opCount = notedWatchers.size();\n                    for (int opNum = 0; opNum < opCount; opNum++) {\n                        if (opNum > 0) {\n                            pw.print(' ');\n                        }\n                        pw.print(AppOpsManager.opToName(notedWatchers.keyAt(opNum)));\n                        if (opNum < opCount - 1) {\n                            pw.print(',');\n                        }\n                    }\n                    pw.println(\"]\");\n                    pw.print(\"        \");\n                    pw.println(cb);\n                }\n            }\n            if (mAudioRestrictionManager.hasActiveRestrictions() && dumpOp < 0\n                    && dumpPackage != null && dumpMode < 0 && !dumpWatchers) {\n                needSep = mAudioRestrictionManager.dump(pw) || needSep;\n            }\n            if (needSep) {\n                pw.println();\n            }\n            for (int i=0; i<mUidStates.size(); i++) {\n                UidState uidState = mUidStates.valueAt(i);\n                final SparseIntArray opModes = uidState.getNonDefaultUidModes();\n                final ArrayMap<String, Ops> pkgOps = uidState.pkgOps;\n\n                if (dumpWatchers || dumpHistory) {\n                    continue;\n                }\n                if (dumpOp >= 0 || dumpPackage != null || dumpMode >= 0) {\n                    boolean hasOp = dumpOp < 0 || (opModes != null\n                            && opModes.indexOfKey(dumpOp) >= 0);\n                    boolean hasPackage = dumpPackage == null || dumpUid == mUidStates.keyAt(i);\n                    boolean hasMode = dumpMode < 0;\n                    if (!hasMode && opModes != null) {\n                        for (int opi = 0; !hasMode && opi < opModes.size(); opi++) {\n                            if (opModes.valueAt(opi) == dumpMode) {\n                                hasMode = true;\n                            }\n                        }\n                    }\n                    if (pkgOps != null) {\n                        for (int pkgi = 0;\n                                 (!hasOp || !hasPackage || !hasMode) && pkgi < pkgOps.size();\n                                 pkgi++) {\n                            Ops ops = pkgOps.valueAt(pkgi);\n                            if (!hasOp && ops != null && ops.indexOfKey(dumpOp) >= 0) {\n                                hasOp = true;\n                            }\n                            if (!hasMode) {\n                                for (int opi = 0; !hasMode && opi < ops.size(); opi++) {\n                                    if (ops.valueAt(opi).getMode() == dumpMode) {\n                                        hasMode = true;\n                                    }\n                                }\n                            }\n                            if (!hasPackage && dumpPackage.equals(ops.packageName)) {\n                                hasPackage = true;\n                            }\n                        }\n                    }\n                    if (uidState.foregroundOps != null && !hasOp) {\n                        if (uidState.foregroundOps.indexOfKey(dumpOp) > 0) {\n                            hasOp = true;\n                        }\n                    }\n                    if (!hasOp || !hasPackage || !hasMode) {\n                        continue;\n                    }\n                }\n\n                pw.print(\"  Uid \"); UserHandle.formatUid(pw, uidState.uid); pw.println(\":\");\n                uidState.dump(pw, nowElapsed);\n                if (uidState.foregroundOps != null && (dumpMode < 0\n                        || dumpMode == AppOpsManager.MODE_FOREGROUND)) {\n                    pw.println(\"    foregroundOps:\");\n                    for (int j = 0; j < uidState.foregroundOps.size(); j++) {\n                        if (dumpOp >= 0 && dumpOp != uidState.foregroundOps.keyAt(j)) {\n                            continue;\n                        }\n                        pw.print(\"      \");\n                        pw.print(AppOpsManager.opToName(uidState.foregroundOps.keyAt(j)));\n                        pw.print(\": \");\n                        pw.println(uidState.foregroundOps.valueAt(j) ? \"WATCHER\" : \"SILENT\");\n                    }\n                    pw.print(\"    hasForegroundWatchers=\");\n                    pw.println(uidState.hasForegroundWatchers);\n                }\n                needSep = true;\n\n                if (opModes != null) {\n                    final int opModeCount = opModes.size();\n                    for (int j = 0; j < opModeCount; j++) {\n                        final int code = opModes.keyAt(j);\n                        final int mode = opModes.valueAt(j);\n                        if (dumpOp >= 0 && dumpOp != code) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != mode) {\n                            continue;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(code));\n                        pw.print(\": mode=\"); pw.println(AppOpsManager.modeToName(mode));\n                    }\n                }\n\n                if (pkgOps == null) {\n                    continue;\n                }\n\n                for (int pkgi = 0; pkgi < pkgOps.size(); pkgi++) {\n                    final Ops ops = pkgOps.valueAt(pkgi);\n                    if (dumpPackage != null && !dumpPackage.equals(ops.packageName)) {\n                        continue;\n                    }\n                    boolean printedPackage = false;\n                    for (int j=0; j<ops.size(); j++) {\n                        final Op op = ops.valueAt(j);\n                        final int opCode = op.op;\n                        if (dumpOp >= 0 && dumpOp != opCode) {\n                            continue;\n                        }\n                        if (dumpMode >= 0 && dumpMode != op.getMode()) {\n                            continue;\n                        }\n                        if (!printedPackage) {\n                            pw.print(\"    Package \"); pw.print(ops.packageName); pw.println(\":\");\n                            printedPackage = true;\n                        }\n                        pw.print(\"      \"); pw.print(AppOpsManager.opToName(opCode));\n                        pw.print(\" (\"); pw.print(AppOpsManager.modeToName(op.getMode()));\n                        final int switchOp = AppOpsManager.opToSwitch(opCode);\n                        if (switchOp != opCode) {\n                            pw.print(\" / switch \");\n                            pw.print(AppOpsManager.opToName(switchOp));\n                            final Op switchObj = ops.get(switchOp);\n                            int mode = switchObj == null\n                                    ? AppOpsManager.opToDefaultMode(switchOp) : switchObj.getMode();\n                            pw.print(\"=\"); pw.print(AppOpsManager.modeToName(mode));\n                        }\n                        pw.println(\"): \");\n                        dumpStatesLocked(pw, dumpAttributionTag, dumpFilter, nowElapsed, op, now,\n                                sdf, date, \"        \");\n                    }\n                }\n            }\n            if (needSep) {\n                pw.println();\n            }\n\n            boolean showUserRestrictions = !(dumpMode < 0 && !dumpWatchers && !dumpHistory);\n            mAppOpsRestrictions.dumpRestrictions(pw, dumpOp, dumpPackage, showUserRestrictions);\n\n            if (!dumpHistory && !dumpWatchers) {\n                pw.println();\n                if (mCheckOpsDelegateDispatcher.mPolicy != null\n                        && mCheckOpsDelegateDispatcher.mPolicy instanceof AppOpsPolicy) {\n                    AppOpsPolicy policy = (AppOpsPolicy) mCheckOpsDelegateDispatcher.mPolicy;\n                    policy.dumpTags(pw);\n                } else {\n                    pw.println(\"  AppOps policy not set.\");\n                }\n            }\n\n            if (dumpAll || dumpUidStateChangeLogs) {\n                pw.println();\n                pw.println(\"Uid State Changes Event Log:\");\n                getUidStateTracker().dumpEvents(pw);\n            }\n        }\n\n        // Must not hold the appops lock\n        if (dumpHistory && !dumpWatchers) {\n            mHistoricalRegistry.dump(\"  \", pw, dumpUid, dumpPackage, dumpAttributionTag, dumpOp,\n                    dumpFilter);\n        }\n        if (includeDiscreteOps) {\n            pw.println(\"Discrete accesses: \");\n            mHistoricalRegistry.dumpDiscreteData(pw, dumpUid, dumpPackage, dumpAttributionTag,\n                    dumpFilter, dumpOp, sdf, date, \"  \", nDiscreteOps);\n        }\n    }\n\n    @Override\n    public void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) {\n        checkSystemUid(\"setUserRestrictions\");\n        Objects.requireNonNull(restrictions);\n        Objects.requireNonNull(token);\n        for (int i = 0; i < AppOpsManager._NUM_OP; i++) {\n            String restriction = AppOpsManager.opToRestriction(i);\n            if (restriction != null) {\n                setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token,\n                        userHandle, null);\n            }\n        }\n    }\n\n    @Override\n    public void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle,\n            PackageTagsList excludedPackageTags) {\n        if (Binder.getCallingPid() != Process.myPid()) {\n            mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,\n                    Binder.getCallingPid(), Binder.getCallingUid(), null);\n        }\n        if (userHandle != UserHandle.getCallingUserId()) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED\n                && mContext.checkCallingOrSelfPermission(Manifest.permission\n                    .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {\n                throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\"\n                        + \" INTERACT_ACROSS_USERS to interact cross user \");\n            }\n        }\n        verifyIncomingOp(code);\n        Objects.requireNonNull(token);\n        setUserRestrictionNoCheck(code, restricted, token, userHandle, excludedPackageTags);\n    }\n\n    private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token,\n            int userHandle, PackageTagsList excludedPackageTags) {\n        synchronized (AppOpsService.this) {\n            ClientUserRestrictionState restrictionState = mOpUserRestrictions.get(token);\n\n            if (restrictionState == null) {\n                try {\n                    restrictionState = new ClientUserRestrictionState(token);\n                } catch (RemoteException e) {\n                    return;\n                }\n                mOpUserRestrictions.put(token, restrictionState);\n            }\n\n            if (restrictionState.setRestriction(code, restricted, excludedPackageTags,\n                    userHandle)) {\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::notifyWatchersOfChange, this, code, UID_ANY));\n                mHandler.sendMessage(PooledLambda.obtainMessage(\n                        AppOpsService::updateStartedOpModeForUser, this, code, restricted,\n                        userHandle));\n            }\n\n            if (restrictionState.isDefault()) {\n                mOpUserRestrictions.remove(token);\n                restrictionState.destroy();\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUser(int code, boolean restricted, int userId) {\n        synchronized (AppOpsService.this) {\n            int numUids = mUidStates.size();\n            for (int uidNum = 0; uidNum < numUids; uidNum++) {\n                int uid = mUidStates.keyAt(uidNum);\n                if (userId != UserHandle.USER_ALL && UserHandle.getUserId(uid) != userId) {\n                    continue;\n                }\n                updateStartedOpModeForUidLocked(code, restricted, uid);\n            }\n        }\n    }\n\n    private void updateStartedOpModeForUidLocked(int code, boolean restricted, int uid) {\n        UidState uidState = mUidStates.get(uid);\n        if (uidState == null) {\n            return;\n        }\n\n        int numPkgOps = uidState.pkgOps.size();\n        for (int pkgNum = 0; pkgNum < numPkgOps; pkgNum++) {\n            Ops ops = uidState.pkgOps.valueAt(pkgNum);\n            Op op = ops != null ? ops.get(code) : null;\n            if (op == null || (op.getMode() != MODE_ALLOWED && op.getMode() != MODE_FOREGROUND)) {\n                continue;\n            }\n            int numAttrTags = op.mAttributions.size();\n            for (int attrNum = 0; attrNum < numAttrTags; attrNum++) {\n                AttributedOp attrOp = op.mAttributions.valueAt(attrNum);\n                if (restricted && attrOp.isRunning()) {\n                    attrOp.pause();\n                } else if (attrOp.isPaused()) {\n                    RestrictionBypass bypass = verifyAndGetBypass(uid, ops.packageName, attrOp.tag)\n                            .bypass;\n                    if (!isOpRestrictedLocked(uid, code, ops.packageName, attrOp.tag,\n                            bypass, false)) {\n                        // Only resume if there are no other restrictions remaining on this op\n                        attrOp.resume();\n                    }\n                }\n            }\n        }\n    }\n\n    private void notifyWatchersOfChange(int code, int uid) {\n        final ArraySet<OnOpModeChangedListener> modeChangedListenerSet;\n        synchronized (this) {\n            modeChangedListenerSet = mAppOpsCheckingService.getOpModeChangedListeners(code);\n            if (modeChangedListenerSet == null) {\n                return;\n            }\n        }\n\n        notifyOpChanged(modeChangedListenerSet,  code, uid, null);\n    }\n\n    @Override\n    public void removeUser(int userHandle) throws RemoteException {\n        checkSystemUid(\"removeUser\");\n        synchronized (AppOpsService.this) {\n            final int tokenCount = mOpUserRestrictions.size();\n            for (int i = tokenCount - 1; i >= 0; i--) {\n                ClientUserRestrictionState opRestrictions = mOpUserRestrictions.valueAt(i);\n                opRestrictions.removeUser(userHandle);\n            }\n            removeUidsForUserLocked(userHandle);\n        }\n    }\n\n    @Override\n    public boolean isOperationActive(int code, int uid, String packageName) {\n        if (Binder.getCallingUid() != uid) {\n            if (mContext.checkCallingOrSelfPermission(Manifest.permission.WATCH_APPOPS)\n                    != PackageManager.PERMISSION_GRANTED) {\n                return false;\n            }\n        }\n        verifyIncomingOp(code);\n        if (!isIncomingPackageValid(packageName, UserHandle.getUserId(uid))) {\n            return false;\n        }\n\n        final String resolvedPackageName = AppOpsManager.resolvePackageName(uid, packageName);\n        if (resolvedPackageName == null) {\n            return false;\n        }\n        // TODO moltmann: Allow to check for attribution op activeness\n        synchronized (AppOpsService.this) {\n            Ops pkgOps = getOpsLocked(uid, resolvedPackageName, null, false, null, false);\n            if (pkgOps == null) {\n                return false;\n            }\n\n            Op op = pkgOps.get(code);\n            if (op == null) {\n                return false;\n            }\n\n            return op.isRunning();\n        }\n    }\n\n    @Override\n    public boolean isProxying(int op, @NonNull String proxyPackageName,\n            @NonNull String proxyAttributionTag, int proxiedUid,\n            @NonNull String proxiedPackageName) {\n        Objects.requireNonNull(proxyPackageName);\n        Objects.requireNonNull(proxiedPackageName);\n        final long callingUid = Binder.getCallingUid();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final List<AppOpsManager.PackageOps> packageOps = getOpsForPackage(proxiedUid,\n                    proxiedPackageName, new int[] {op});\n            if (packageOps == null || packageOps.isEmpty()) {\n                return false;\n            }\n            final List<OpEntry> opEntries = packageOps.get(0).getOps();\n            if (opEntries.isEmpty()) {\n                return false;\n            }\n            final OpEntry opEntry = opEntries.get(0);\n            if (!opEntry.isRunning()) {\n                return false;\n            }\n            final OpEventProxyInfo proxyInfo = opEntry.getLastProxyInfo(\n                    OP_FLAG_TRUSTED_PROXIED | AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED);\n            return proxyInfo != null && callingUid == proxyInfo.getUid()\n                    && proxyPackageName.equals(proxyInfo.getPackageName())\n                    && Objects.equals(proxyAttributionTag, proxyInfo.getAttributionTag());\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void resetPackageOpsNoHistory(@NonNull String packageName) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetPackageOpsNoHistory\");\n        synchronized (AppOpsService.this) {\n            final int uid = mPackageManagerInternal.getPackageUid(packageName, 0,\n                    UserHandle.getCallingUserId());\n            if (uid == Process.INVALID_UID) {\n                return;\n            }\n            UidState uidState = mUidStates.get(uid);\n            if (uidState == null) {\n                return;\n            }\n            Ops removedOps = uidState.pkgOps.remove(packageName);\n            mAppOpsCheckingService.removePackage(packageName, UserHandle.getUserId(uid));\n            if (removedOps != null) {\n                scheduleFastWriteLocked();\n            }\n        }\n    }\n\n    @Override\n    public void setHistoryParameters(@AppOpsManager.HistoricalMode int mode,\n            long baseSnapshotInterval, int compressionStep) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"setHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.setHistoryParameters(mode, baseSnapshotInterval, compressionStep);\n    }\n\n    @Override\n    public void offsetHistory(long offsetMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"offsetHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.offsetHistory(offsetMillis);\n        mHistoricalRegistry.offsetDiscreteHistory(offsetMillis);\n    }\n\n    @Override\n    public void addHistoricalOps(HistoricalOps ops) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"addHistoricalOps\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.addHistoricalOps(ops);\n    }\n\n    @Override\n    public void resetHistoryParameters() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"resetHistoryParameters\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.resetHistoryParameters();\n    }\n\n    @Override\n    public void clearHistory() {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"clearHistory\");\n        // Must not hold the appops lock\n        mHistoricalRegistry.clearAllHistory();\n    }\n\n    @Override\n    public void rebootHistory(long offlineDurationMillis) {\n        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_APPOPS,\n                \"rebootHistory\");\n\n        Preconditions.checkArgument(offlineDurationMillis >= 0);\n\n        // Must not hold the appops lock\n        mHistoricalRegistry.shutdown();\n\n        if (offlineDurationMillis > 0) {\n            SystemClock.sleep(offlineDurationMillis);\n        }\n\n        mHistoricalRegistry = new HistoricalRegistry(mHistoricalRegistry);\n        mHistoricalRegistry.systemReady(mContext.getContentResolver());\n        mHistoricalRegistry.persistPendingHistory();\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (including stack trace)\n     *\n     * @param packageName The package which reported the op\n     * @param notedAppOp contains code of op and attributionTag provided by developer\n     * @param message Message describing AppOp access (can be stack trace)\n     *\n     * @return Config for future sampling to reduce amount of reporting\n     */\n    @Override\n    public MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(\n            String packageName, SyncNotedAppOp notedAppOp, String message) {\n        int uid = Binder.getCallingUid();\n        Objects.requireNonNull(packageName);\n        synchronized (this) {\n            switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n            if (!packageName.equals(mSampledPackage)) {\n                return new MessageSamplingConfig(OP_NONE, 0,\n                        Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n            }\n\n            Objects.requireNonNull(notedAppOp);\n            Objects.requireNonNull(message);\n\n            reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName,\n                    AppOpsManager.strOpToOp(notedAppOp.getOp()),\n                    notedAppOp.getAttributionTag(), message);\n\n            return new MessageSamplingConfig(mSampledAppOpCode, mAcceptableLeftDistance,\n                    Instant.now().plus(1, ChronoUnit.HOURS).toEpochMilli());\n        }\n    }\n\n    /**\n     * Report runtime access to AppOp together with message (entry point for reporting\n     * asynchronous access)\n     * @param uid Uid of the package which reported the op\n     * @param packageName The package which reported the op\n     * @param opCode Code of AppOp\n     * @param attributionTag FeautreId of AppOp reported\n     * @param message Message describing AppOp access (can be stack trace)\n     */\n    private void reportRuntimeAppOpAccessMessageAsyncLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        switchPackageIfBootTimeOrRarelyUsedLocked(packageName);\n        if (!Objects.equals(mSampledPackage, packageName)) {\n            return;\n        }\n        reportRuntimeAppOpAccessMessageInternalLocked(uid, packageName, opCode, attributionTag,\n                message);\n    }\n\n    /**\n     * Decides whether reported message is within the range of watched AppOps and picks it for\n     * reporting uniformly at random across all received messages.\n     */\n    private void reportRuntimeAppOpAccessMessageInternalLocked(int uid,\n            @NonNull String packageName, int opCode, @Nullable String attributionTag,\n            @NonNull String message) {\n        int newLeftDistance = AppOpsManager.leftCircularDistance(opCode,\n                mSampledAppOpCode, _NUM_OP);\n\n        if (mAcceptableLeftDistance < newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            return;\n        }\n\n        if (mAcceptableLeftDistance > newLeftDistance\n                && mSamplingStrategy != SAMPLING_STRATEGY_UNIFORM_OPS) {\n            mAcceptableLeftDistance = newLeftDistance;\n            mMessagesCollectedCount = 0.0f;\n        }\n\n        mMessagesCollectedCount += 1.0f;\n        if (ThreadLocalRandom.current().nextFloat() <= 1.0f / mMessagesCollectedCount) {\n            mCollectedRuntimePermissionMessage = new RuntimeAppOpAccessMessage(uid, opCode,\n                    packageName, attributionTag, message, mSamplingStrategy);\n        }\n        return;\n    }\n\n    /** Pulls current AppOps access report and resamples package and app op to watch */\n    @Override\n    public @Nullable RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage() {\n        ActivityManagerInternal ami = LocalServices.getService(ActivityManagerInternal.class);\n        boolean isCallerInstrumented =\n                ami.getInstrumentationSourceUid(Binder.getCallingUid()) != Process.INVALID_UID;\n        boolean isCallerSystem = Binder.getCallingPid() == Process.myPid();\n        if (!isCallerSystem && !isCallerInstrumented) {\n            return null;\n        }\n        mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS,\n                Binder.getCallingPid(), Binder.getCallingUid(), null);\n        RuntimeAppOpAccessMessage result;\n        synchronized (this) {\n            result = mCollectedRuntimePermissionMessage;\n            mCollectedRuntimePermissionMessage = null;\n        }\n        mHandler.sendMessage(PooledLambda.obtainMessage(\n                AppOpsService::getPackageListAndResample,\n                this));\n        return result;\n    }\n\n    /**\n     * Checks if package is in the list of rarely used package and starts watching the new package\n     * to collect incoming message or if collection is happening in first minutes since boot.\n     * @param packageName\n     */\n    private void switchPackageIfBootTimeOrRarelyUsedLocked(@NonNull String packageName) {\n        if (mSampledPackage == null) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_BOOT_TIME_SAMPLING;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        } else if (mRarelyUsedPackages.contains(packageName)) {\n            mRarelyUsedPackages.remove(packageName);\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_RARELY_USED;\n                resampleAppOpForPackageLocked(packageName, true);\n            }\n        }\n    }\n\n    /** Obtains package list and resamples package and appop to watch. */\n    private List<String> getPackageListAndResample() {\n        List<String> packageNames = getPackageNamesForSampling();\n        synchronized (this) {\n            resamplePackageAndAppOpLocked(packageNames);\n        }\n        return packageNames;\n    }\n\n    /** Resamples package and appop to watch from the list provided. */\n    private void resamplePackageAndAppOpLocked(@NonNull List<String> packageNames) {\n        if (!packageNames.isEmpty()) {\n            if (ThreadLocalRandom.current().nextFloat() < 0.5f) {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), true);\n            } else {\n                mSamplingStrategy = SAMPLING_STRATEGY_UNIFORM_OPS;\n                resampleAppOpForPackageLocked(packageNames.get(\n                        ThreadLocalRandom.current().nextInt(packageNames.size())), false);\n            }\n        }\n    }\n\n    /** Resamples appop for the chosen package and initializes sampling state */\n    private void resampleAppOpForPackageLocked(@NonNull String packageName, boolean pickOp) {\n        mMessagesCollectedCount = 0.0f;\n        mSampledAppOpCode = pickOp ? ThreadLocalRandom.current().nextInt(_NUM_OP) : OP_NONE;\n        mAcceptableLeftDistance = _NUM_OP - 1;\n        mSampledPackage = packageName;\n    }\n\n    /**\n     * Creates list of rarely used packages - packages which were not used over last week or\n     * which declared but did not use permissions over last week.\n     *  */\n    private void initializeRarelyUsedPackagesList(@NonNull ArraySet<String> candidates) {\n        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);\n        List<String> runtimeAppOpsList = getRuntimeAppOpsList();\n        AppOpsManager.HistoricalOpsRequest histOpsRequest =\n                new AppOpsManager.HistoricalOpsRequest.Builder(\n                        Math.max(Instant.now().minus(7, ChronoUnit.DAYS).toEpochMilli(), 0),\n                        Long.MAX_VALUE).setOpNames(runtimeAppOpsList).setFlags(\n                        OP_FLAG_SELF | OP_FLAG_TRUSTED_PROXIED).build();\n        appOps.getHistoricalOps(histOpsRequest, AsyncTask.THREAD_POOL_EXECUTOR,\n                new Consumer<HistoricalOps>() {\n                    @Override\n                    public void accept(HistoricalOps histOps) {\n                        int uidCount = histOps.getUidCount();\n                        for (int uidIdx = 0; uidIdx < uidCount; uidIdx++) {\n                            final AppOpsManager.HistoricalUidOps uidOps = histOps.getUidOpsAt(\n                                    uidIdx);\n                            int pkgCount = uidOps.getPackageCount();\n                            for (int pkgIdx = 0; pkgIdx < pkgCount; pkgIdx++) {\n                                String packageName = uidOps.getPackageOpsAt(\n                                        pkgIdx).getPackageName();\n                                if (!candidates.contains(packageName)) {\n                                    continue;\n                                }\n                                AppOpsManager.HistoricalPackageOps packageOps =\n                                        uidOps.getPackageOpsAt(pkgIdx);\n                                if (packageOps.getOpCount() != 0) {\n                                    candidates.remove(packageName);\n                                }\n                            }\n                        }\n                        synchronized (this) {\n                            int numPkgs = mRarelyUsedPackages.size();\n                            for (int i = 0; i < numPkgs; i++) {\n                                candidates.add(mRarelyUsedPackages.valueAt(i));\n                            }\n                            mRarelyUsedPackages = candidates;\n                        }\n                    }\n                });\n    }\n\n    /** List of app ops related to runtime permissions */\n    private List<String> getRuntimeAppOpsList() {\n        ArrayList<String> result = new ArrayList();\n        for (int i = 0; i < _NUM_OP; i++) {\n            if (shouldCollectNotes(i)) {\n                result.add(opToPublicName(i));\n            }\n        }\n        return result;\n    }\n\n    /** Returns list of packages to be used for package sampling */\n    private @NonNull List<String> getPackageNamesForSampling() {\n        List<String> packageNames = new ArrayList<>();\n        PackageManagerInternal packageManagerInternal = LocalServices.getService(\n                PackageManagerInternal.class);\n        PackageList packages = packageManagerInternal.getPackageList();\n        for (String packageName : packages.getPackageNames()) {\n            PackageInfo pkg = packageManagerInternal.getPackageInfo(packageName,\n                    PackageManager.GET_PERMISSIONS, Process.myUid(), mContext.getUserId());\n            if (isSamplingTarget(pkg)) {\n                packageNames.add(pkg.packageName);\n            }\n        }\n        return packageNames;\n    }\n\n    /** Checks whether package should be included in sampling pool */\n    private boolean isSamplingTarget(@Nullable PackageInfo pkg) {\n        if (pkg == null) {\n            return false;\n        }\n        String[] requestedPermissions = pkg.requestedPermissions;\n        if (requestedPermissions == null) {\n            return false;\n        }\n        for (String permission : requestedPermissions) {\n            PermissionInfo permissionInfo;\n            try {\n                permissionInfo = mContext.getPackageManager().getPermissionInfo(permission, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n                continue;\n            }\n            if (permissionInfo.getProtection() == PROTECTION_DANGEROUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @GuardedBy(\"this\")\n    private void removeUidsForUserLocked(int userHandle) {\n        for (int i = mUidStates.size() - 1; i >= 0; --i) {\n            final int uid = mUidStates.keyAt(i);\n            if (UserHandle.getUserId(uid) == userHandle) {\n                mUidStates.valueAt(i).clear();\n                mUidStates.removeAt(i);\n            }\n        }\n    }\n\n    private void checkSystemUid(String function) {\n        int uid = Binder.getCallingUid();\n        if (uid != Process.SYSTEM_UID) {\n            throw new SecurityException(function + \" must by called by the system\");\n        }\n    }\n\n    private static int resolveNonAppUid(String packageName)  {\n        if (packageName == null) {\n            return Process.INVALID_UID;\n        }\n        switch (packageName) {\n            case \"root\":\n                return Process.ROOT_UID;\n            case \"shell\":\n            case \"dumpstate\":\n                return Process.SHELL_UID;\n            case \"media\":\n                return Process.MEDIA_UID;\n            case \"audioserver\":\n                return Process.AUDIOSERVER_UID;\n            case \"cameraserver\":\n                return Process.CAMERASERVER_UID;\n        }\n        return Process.INVALID_UID;\n    }\n\n    private static String[] getPackagesForUid(int uid) {\n        String[] packageNames = null;\n\n        // Very early during boot the package manager is not yet or not yet fully started. At this\n        // time there are no packages yet.\n        if (AppGlobals.getPackageManager() != null) {\n            try {\n                packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        }\n        if (packageNames == null) {\n            return EmptyArray.STRING;\n        }\n        return packageNames;\n    }\n\n    private final class ClientUserRestrictionState implements DeathRecipient {\n        private final IBinder token;\n\n        ClientUserRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.token = token;\n        }\n\n        public boolean setRestriction(int code, boolean restricted,\n                PackageTagsList excludedPackageTags, int userId) {\n            return mAppOpsRestrictions.setUserRestriction(token, userId, code,\n                    restricted, excludedPackageTags);\n        }\n\n        public boolean hasRestriction(int code, String packageName, String attributionTag,\n                int userId, boolean isCheckOp) {\n            return mAppOpsRestrictions.getUserRestriction(token, userId, code, packageName,\n                    attributionTag, isCheckOp);\n        }\n\n        public void removeUser(int userId) {\n            mAppOpsRestrictions.clearUserRestrictions(token, userId);\n        }\n\n        public boolean isDefault() {\n            return !mAppOpsRestrictions.hasUserRestrictions(token);\n        }\n\n        @Override\n        public void binderDied() {\n            synchronized (AppOpsService.this) {\n                mAppOpsRestrictions.clearUserRestrictions(token);\n                mOpUserRestrictions.remove(token);\n                destroy();\n            }\n        }\n\n        public void destroy() {\n            token.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class ClientGlobalRestrictionState implements DeathRecipient {\n        final IBinder mToken;\n\n        ClientGlobalRestrictionState(IBinder token)\n                throws RemoteException {\n            token.linkToDeath(this, 0);\n            this.mToken = token;\n        }\n\n        boolean setRestriction(int code, boolean restricted) {\n            return mAppOpsRestrictions.setGlobalRestriction(mToken, code, restricted);\n        }\n\n        boolean hasRestriction(int code) {\n            return mAppOpsRestrictions.getGlobalRestriction(mToken, code);\n        }\n\n        boolean isDefault() {\n            return !mAppOpsRestrictions.hasGlobalRestrictions(mToken);\n        }\n\n        @Override\n        public void binderDied() {\n            mAppOpsRestrictions.clearGlobalRestrictions(mToken);\n            mOpGlobalRestrictions.remove(mToken);\n            destroy();\n        }\n\n        void destroy() {\n            mToken.unlinkToDeath(this, 0);\n        }\n    }\n\n    private final class AppOpsManagerLocalImpl implements AppOpsManagerLocal {\n        @Override\n        public boolean isUidInForeground(int uid) {\n            synchronized (AppOpsService.this) {\n                return mUidStateTracker.isUidInForeground(uid);\n            }\n        }\n    }\n\n    private final class AppOpsManagerInternalImpl extends AppOpsManagerInternal {\n        @Override public void setDeviceAndProfileOwners(SparseIntArray owners) {\n            synchronized (AppOpsService.this) {\n                mProfileOwners = owners;\n            }\n        }\n\n        @Override\n        public void updateAppWidgetVisibility(SparseArray<String> uidPackageNames,\n                boolean visible) {\n            AppOpsService.this.updateAppWidgetVisibility(uidPackageNames, visible);\n        }\n\n        @Override\n        public void setUidModeFromPermissionPolicy(int code, int uid, int mode,\n                @Nullable IAppOpsCallback callback) {\n            setUidMode(code, uid, mode, callback);\n        }\n\n        @Override\n        public void setModeFromPermissionPolicy(int code, int uid, @NonNull String packageName,\n                int mode, @Nullable IAppOpsCallback callback) {\n            setMode(code, uid, packageName, mode, callback);\n        }\n\n\n        @Override\n        public void setGlobalRestriction(int code, boolean restricted, IBinder token) {\n            if (Binder.getCallingPid() != Process.myPid()) {\n                // TODO instead of this enforcement put in AppOpsManagerInternal\n                throw new SecurityException(\"Only the system can set global restrictions\");\n            }\n\n            synchronized (AppOpsService.this) {\n                ClientGlobalRestrictionState restrictionState = mOpGlobalRestrictions.get(token);\n\n                if (restrictionState == null) {\n                    try {\n                        restrictionState = new ClientGlobalRestrictionState(token);\n                    } catch (RemoteException  e) {\n                        return;\n                    }\n                    mOpGlobalRestrictions.put(token, restrictionState);\n                }\n\n                if (restrictionState.setRestriction(code, restricted)) {\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::notifyWatchersOfChange, AppOpsService.this, code,\n                            UID_ANY));\n                    mHandler.sendMessage(PooledLambda.obtainMessage(\n                            AppOpsService::updateStartedOpModeForUser, AppOpsService.this,\n                            code, restricted, UserHandle.USER_ALL));\n                }\n\n                if (restrictionState.isDefault()) {\n                    mOpGlobalRestrictions.remove(token);\n                    restrictionState.destroy();\n                }\n            }\n        }\n\n        @Override\n        public int getOpRestrictionCount(int code, UserHandle user, String pkg,\n                String attributionTag) {\n            int number = 0;\n            synchronized (AppOpsService.this) {\n                int numRestrictions = mOpUserRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpUserRestrictions.valueAt(i)\n                            .hasRestriction(code, pkg, attributionTag, user.getIdentifier(),\n                                    false)) {\n                        number++;\n                    }\n                }\n\n                numRestrictions = mOpGlobalRestrictions.size();\n                for (int i = 0; i < numRestrictions; i++) {\n                    if (mOpGlobalRestrictions.valueAt(i).hasRestriction(code)) {\n                        number++;\n                    }\n                }\n            }\n\n            return number;\n        }\n    }\n\n    /**\n     * Async task for writing note op stack trace, op code, package name and version to file\n     * More specifically, writes all the collected ops from {@link #mNoteOpCallerStacktraces}\n     */\n    private void writeNoteOps() {\n        synchronized (this) {\n            mWriteNoteOpsScheduled = false;\n        }\n        synchronized (mNoteOpCallerStacktracesFile) {\n            try (FileWriter writer = new FileWriter(mNoteOpCallerStacktracesFile)) {\n                int numTraces = mNoteOpCallerStacktraces.size();\n                for (int i = 0; i < numTraces; i++) {\n                    // Writing json formatted string into file\n                    writer.write(mNoteOpCallerStacktraces.valueAt(i).asJson());\n                    // Comma separation, so we can wrap the entire log as a JSON object\n                    // when all results are collected\n                    writer.write(\",\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to load opsValidation file for FileWriter\", e);\n            }\n        }\n    }\n\n    /**\n     * This class represents a NoteOp Trace object amd contains the necessary fields that will\n     * be written to file to use for permissions data validation in JSON format\n     */\n    @Immutable\n    static class NoteOpTrace {\n        static final String STACKTRACE = \"stackTrace\";\n        static final String OP = \"op\";\n        static final String PACKAGENAME = \"packageName\";\n        static final String VERSION = \"version\";\n\n        private final @NonNull String mStackTrace;\n        private final int mOp;\n        private final @Nullable String mPackageName;\n        private final long mVersion;\n\n        /**\n         * Initialize a NoteOp object using a JSON object containing the necessary fields\n         *\n         * @param jsonTrace JSON object represented as a string\n         *\n         * @return NoteOpTrace object initialized with JSON fields\n         */\n        static NoteOpTrace fromJson(String jsonTrace) {\n            try {\n                // Re-add closing bracket which acted as a delimiter by the reader\n                JSONObject obj = new JSONObject(jsonTrace.concat(\"}\"));\n                return new NoteOpTrace(obj.getString(STACKTRACE), obj.getInt(OP),\n                        obj.getString(PACKAGENAME), obj.getLong(VERSION));\n            } catch (JSONException e) {\n                // Swallow error, only meant for logging ops, should not affect flow of the code\n                Slog.e(TAG, \"Error constructing NoteOpTrace object \"\n                        + \"JSON trace format incorrect\", e);\n                return null;\n            }\n        }\n\n        NoteOpTrace(String stackTrace, int op, String packageName, long version) {\n            mStackTrace = stackTrace;\n            mOp = op;\n            mPackageName = packageName;\n            mVersion = version;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            NoteOpTrace that = (NoteOpTrace) o;\n            return mOp == that.mOp\n                    && mVersion == that.mVersion\n                    && mStackTrace.equals(that.mStackTrace)\n                    && Objects.equals(mPackageName, that.mPackageName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(mStackTrace, mOp, mPackageName, mVersion);\n        }\n\n        /**\n         * The object is formatted as a JSON object and returned as a String\n         *\n         * @return JSON formatted string\n         */\n        public String asJson() {\n            return  \"{\"\n                    + \"\\\"\" + STACKTRACE + \"\\\":\\\"\" + mStackTrace.replace(\"\\n\", \"\\\\n\")\n                    + '\\\"' + \",\\\"\" + OP + \"\\\":\" + mOp\n                    + \",\\\"\" + PACKAGENAME + \"\\\":\\\"\" + mPackageName + '\\\"'\n                    + \",\\\"\" + VERSION + \"\\\":\" + mVersion\n                    + '}';\n        }\n    }\n\n    /**\n     * Collects noteOps, noteProxyOps and startOps from AppOpsManager and writes it into a file\n     * which will be used for permissions data validation, the given parameters to this method\n     * will be logged in json format\n     *\n     * @param stackTrace stacktrace from the most recent call in AppOpsManager\n     * @param op op code\n     * @param packageName package making call\n     * @param version android version for this call\n     */\n    @Override\n    public void collectNoteOpCallsForValidation(String stackTrace, int op, String packageName,\n            long version) {\n        if (!AppOpsManager.NOTE_OP_COLLECTION_ENABLED) {\n            return;\n        }\n\n        Objects.requireNonNull(stackTrace);\n        Preconditions.checkArgument(op >= 0);\n        Preconditions.checkArgument(op < AppOpsManager._NUM_OP);\n\n        NoteOpTrace noteOpTrace = new NoteOpTrace(stackTrace, op, packageName, version);\n\n        boolean noteOpSetWasChanged;\n        synchronized (this) {\n            noteOpSetWasChanged = mNoteOpCallerStacktraces.add(noteOpTrace);\n            if (noteOpSetWasChanged && !mWriteNoteOpsScheduled) {\n                mWriteNoteOpsScheduled = true;\n                mHandler.postDelayed(PooledLambda.obtainRunnable((that) -> {\n                    AsyncTask.execute(() -> {\n                        that.writeNoteOps();\n                    });\n                }, this), 2500);\n            }\n        }\n    }\n\n    @Immutable\n    private final class CheckOpsDelegateDispatcher {\n        private final @Nullable CheckOpsDelegate mPolicy;\n        private final @Nullable CheckOpsDelegate mCheckOpsDelegate;\n\n        CheckOpsDelegateDispatcher(@Nullable CheckOpsDelegate policy,\n                @Nullable CheckOpsDelegate checkOpsDelegate) {\n            mPolicy = policy;\n            mCheckOpsDelegate = checkOpsDelegate;\n        }\n\n        public @NonNull CheckOpsDelegate getCheckOpsDelegate() {\n            return mCheckOpsDelegate;\n        }\n\n        public int checkOperation(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            this::checkDelegateOperationImpl);\n                } else {\n                    return mPolicy.checkOperation(code, uid, packageName, attributionTag, raw,\n                            AppOpsService.this::checkOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateOperationImpl(code, uid, packageName, attributionTag, raw);\n            }\n            return checkOperationImpl(code, uid, packageName, attributionTag, raw);\n        }\n\n        private int checkDelegateOperationImpl(int code, int uid, String packageName,\n                @Nullable String attributionTag, boolean raw) {\n            return mCheckOpsDelegate.checkOperation(code, uid, packageName, attributionTag, raw,\n                    AppOpsService.this::checkOperationImpl);\n        }\n\n        public int checkAudioOperation(int code, int usage, int uid, String packageName) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            this::checkDelegateAudioOperationImpl);\n                } else {\n                    return mPolicy.checkAudioOperation(code, usage, uid, packageName,\n                            AppOpsService.this::checkAudioOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return checkDelegateAudioOperationImpl(code, usage, uid, packageName);\n            }\n            return checkAudioOperationImpl(code, usage, uid, packageName);\n        }\n\n        private int checkDelegateAudioOperationImpl(int code, int usage, int uid,\n                String packageName) {\n            return mCheckOpsDelegate.checkAudioOperation(code, usage, uid, packageName,\n                    AppOpsService.this::checkAudioOperationImpl);\n        }\n\n        public SyncNotedAppOp noteOperation(int code, int uid, String packageName,\n                String attributionTag, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            this::noteDelegateOperationImpl);\n                } else {\n                    return mPolicy.noteOperation(code, uid, packageName, attributionTag,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            AppOpsService.this::noteOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateOperationImpl(code, uid, packageName,\n                        attributionTag, shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n            }\n            return noteOperationImpl(code, uid, packageName, attributionTag,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage);\n        }\n\n        private SyncNotedAppOp noteDelegateOperationImpl(int code, int uid,\n                @Nullable String packageName, @Nullable String featureId,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage) {\n            return mCheckOpsDelegate.noteOperation(code, uid, packageName, featureId,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    AppOpsService.this::noteOperationImpl);\n        }\n\n        public SyncNotedAppOp noteProxyOperation(int code, AttributionSource attributionSource,\n                boolean shouldCollectAsyncNotedOp, @Nullable String message,\n                boolean shouldCollectMessage, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, this::noteDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.noteProxyOperation(code, attributionSource,\n                            shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                            skipProxyOperation, AppOpsService.this::noteProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return noteDelegateProxyOperationImpl(code,\n                        attributionSource, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation);\n            }\n            return noteProxyOperationImpl(code, attributionSource, shouldCollectAsyncNotedOp,\n                    message, shouldCollectMessage,skipProxyOperation);\n        }\n\n        private SyncNotedAppOp noteDelegateProxyOperationImpl(int code,\n                @NonNull AttributionSource attributionSource, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation) {\n            return mCheckOpsDelegate.noteProxyOperation(code, attributionSource,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    AppOpsService.this::noteProxyOperationImpl);\n        }\n\n        public SyncNotedAppOp startOperation(IBinder token, int code, int uid,\n                @Nullable String packageName, @NonNull String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp,\n                @Nullable String message, boolean shouldCollectMessage,\n                @AttributionFlags int attributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startOperation(token, code, uid, packageName,\n                            attributionTag, startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            this::startDelegateOperationImpl);\n                } else {\n                    return mPolicy.startOperation(token, code, uid, packageName, attributionTag,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, attributionFlags, attributionChainId,\n                            AppOpsService.this::startOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateOperationImpl(token, code, uid, packageName, attributionTag,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, attributionFlags, attributionChainId);\n            }\n            return startOperationImpl(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateOperationImpl(IBinder token, int code, int uid,\n                @Nullable String packageName, @Nullable String attributionTag,\n                boolean startIfModeDefault, boolean shouldCollectAsyncNotedOp, String message,\n                boolean shouldCollectMessage, @AttributionFlags int attributionFlags,\n                int attributionChainId) {\n            return mCheckOpsDelegate.startOperation(token, code, uid, packageName, attributionTag,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    attributionFlags, attributionChainId, AppOpsService.this::startOperationImpl);\n        }\n\n        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlags, int attributionChainId) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            this::startDelegateProxyOperationImpl);\n                } else {\n                    return mPolicy.startProxyOperation(clientId, code, attributionSource,\n                            startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                            proxiedAttributionFlags, attributionChainId,\n                            AppOpsService.this::startProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                return startDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        startIfModeDefault, shouldCollectAsyncNotedOp, message,\n                        shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,\n                        proxiedAttributionFlags, attributionChainId);\n            }\n            return startProxyOperationImpl(clientId, code, attributionSource, startIfModeDefault,\n                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,\n                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);\n        }\n\n        private SyncNotedAppOp startDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,\n                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,\n                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,\n                @AttributionFlags int proxiedAttributionFlsgs, int attributionChainId) {\n            return mCheckOpsDelegate.startProxyOperation(clientId, code, attributionSource,\n                    startIfModeDefault, shouldCollectAsyncNotedOp, message, shouldCollectMessage,\n                    skipProxyOperation, proxyAttributionFlags, proxiedAttributionFlsgs,\n                    attributionChainId, AppOpsService.this::startProxyOperationImpl);\n        }\n\n        public void finishOperation(IBinder clientId, int code, int uid, String packageName,\n                String attributionTag) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            this::finishDelegateOperationImpl);\n                } else {\n                    mPolicy.finishOperation(clientId, code, uid, packageName, attributionTag,\n                            AppOpsService.this::finishOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateOperationImpl(clientId, code, uid, packageName, attributionTag);\n            } else {\n                finishOperationImpl(clientId, code, uid, packageName, attributionTag);\n            }\n        }\n\n        private void finishDelegateOperationImpl(IBinder clientId, int code, int uid,\n                String packageName, String attributionTag) {\n            mCheckOpsDelegate.finishOperation(clientId, code, uid, packageName, attributionTag,\n                    AppOpsService.this::finishOperationImpl);\n        }\n\n        public void finishProxyOperation(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            if (mPolicy != null) {\n                if (mCheckOpsDelegate != null) {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, this::finishDelegateProxyOperationImpl);\n                } else {\n                    mPolicy.finishProxyOperation(clientId, code, attributionSource,\n                            skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n                }\n            } else if (mCheckOpsDelegate != null) {\n                finishDelegateProxyOperationImpl(clientId, code, attributionSource,\n                        skipProxyOperation);\n            } else {\n                finishProxyOperationImpl(clientId, code, attributionSource, skipProxyOperation);\n            }\n        }\n\n        private Void finishDelegateProxyOperationImpl(@NonNull IBinder clientId, int code,\n                @NonNull AttributionSource attributionSource, boolean skipProxyOperation) {\n            mCheckOpsDelegate.finishProxyOperation(clientId, code, attributionSource,\n                    skipProxyOperation, AppOpsService.this::finishProxyOperationImpl);\n            return null;\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 1.0,
      "normalized_edit_similarity": "skipped",
      "token_level_edit_distance": 5,
      "codebert_score": {
        "precision": 0.9907,
        "recall": 0.9907,
        "f1": 0.9907,
        "f3": 0.9907
      },
      "token_count_upstream": 21712,
      "token_count_downstream": 21712,
      "token_count_total": 43424,
      "cosine_similarity_openai": "skipped"
    }
  },
  {
    "cve_id": "ASB-A-353240784",
    "downstream_version": "14",
    "file_name": "services/appwidget/java/com/android/server/appwidget/AppWidgetServiceImpl.java",
    "llm_patched_code": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(@NonNull final HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}",
    "ground_truth_code": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.appwidget;\n\nimport static android.content.Context.KEYGUARD_SERVICE;\nimport static android.content.Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;\nimport static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;\nimport static android.content.res.Resources.ID_NULL;\n\nimport static com.android.server.pm.PackageManagerService.PLATFORM_PACKAGE_NAME;\n\nimport android.annotation.UserIdInt;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.AlarmManager;\nimport android.app.AppGlobals;\nimport android.app.AppOpsManager;\nimport android.app.AppOpsManagerInternal;\nimport android.app.IApplicationThread;\nimport android.app.IServiceConnection;\nimport android.app.KeyguardManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.admin.DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener;\nimport android.app.usage.UsageEvents;\nimport android.app.usage.UsageStatsManagerInternal;\nimport android.appwidget.AppWidgetManager;\nimport android.appwidget.AppWidgetManagerInternal;\nimport android.appwidget.AppWidgetProviderInfo;\nimport android.appwidget.PendingHostUpdate;\nimport android.content.BroadcastReceiver;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.Intent.FilterComparison;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.LauncherApps;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ServiceInfo;\nimport android.content.pm.ShortcutServiceInternal;\nimport android.content.pm.SuspendDialogInfo;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.graphics.Point;\nimport android.graphics.drawable.Icon;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.appwidget.AppWidgetServiceDumpProto;\nimport android.service.appwidget.WidgetProto;\nimport android.text.TextUtils;\nimport android.util.ArraySet;\nimport android.util.AtomicFile;\nimport android.util.AttributeSet;\nimport android.util.IntArray;\nimport android.util.LongSparseArray;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\nimport android.util.SparseIntArray;\nimport android.util.SparseLongArray;\nimport android.util.TypedValue;\nimport android.util.TypedXmlPullParser;\nimport android.util.TypedXmlSerializer;\nimport android.util.Xml;\nimport android.util.proto.ProtoOutputStream;\nimport android.view.Display;\nimport android.view.View;\nimport android.widget.RemoteViews;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.app.SuspendedAppActivity;\nimport com.android.internal.app.UnlaunchableAppActivity;\nimport com.android.internal.appwidget.IAppWidgetHost;\nimport com.android.internal.appwidget.IAppWidgetService;\nimport com.android.internal.os.BackgroundThread;\nimport com.android.internal.os.SomeArgs;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.widget.IRemoteViewsFactory;\nimport com.android.server.LocalServices;\nimport com.android.server.WidgetBackupProvider;\n\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass AppWidgetServiceImpl extends IAppWidgetService.Stub implements WidgetBackupProvider,\n        OnCrossProfileWidgetProvidersChangeListener {\n    private static final String TAG = \"AppWidgetServiceImpl\";\n\n    private static boolean DEBUG = false;\n\n    private static final String OLD_KEYGUARD_HOST_PACKAGE = \"android\";\n    private static final String NEW_KEYGUARD_HOST_PACKAGE = \"com.android.keyguard\";\n    private static final int KEYGUARD_HOST_ID = 0x4b455947;\n\n    private static final String STATE_FILENAME = \"appwidgets.xml\";\n\n    private static final int MIN_UPDATE_PERIOD = DEBUG ? 0 : 30 * 60 * 1000; // 30 minutes\n\n    private static final int TAG_UNDEFINED = -1;\n\n    private static final int UNKNOWN_UID = -1;\n\n    private static final int UNKNOWN_USER_ID = -10;\n\n    // Bump if the stored widgets need to be upgraded.\n    private static final int CURRENT_VERSION = 1;\n\n    // Every widget update request is associated which an increasing sequence number. This is\n    // used to verify which request has successfully been received by the host.\n    private static final AtomicLong UPDATE_COUNTER = new AtomicLong();\n\n    // Hard limit of number of hosts an app can create, note that the app that hosts the widgets\n    // can have multiple instances of {@link AppWidgetHost}, typically in respect to different\n    // surfaces in the host app.\n    // @see AppWidgetHost\n    // @see AppWidgetHost#mHostId\n    private static final int MAX_NUMBER_OF_HOSTS_PER_PACKAGE = 20;\n    // Hard limit of number of widgets can be pinned by a host.\n    private static final int MAX_NUMBER_OF_WIDGETS_PER_HOST = 200;\n\n    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Received broadcast: \" + action + \" on user \" + userId);\n            }\n\n            switch (action) {\n                case Intent.ACTION_MANAGED_PROFILE_AVAILABLE:\n                case Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE:\n                    synchronized (mLock) {\n                        reloadWidgetsMaskedState(userId);\n                    }\n                    break;\n                case Intent.ACTION_PACKAGES_SUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, true, getSendingUserId());\n                    break;\n                case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    updateWidgetPackageSuspensionMaskedState(intent, false, getSendingUserId());\n                    break;\n                default:\n                    onPackageBroadcastReceived(intent, getSendingUserId());\n                    break;\n            }\n        }\n    };\n\n    // Manages persistent references to RemoteViewsServices from different App Widgets.\n    private final HashMap<Pair<Integer, FilterComparison>, HashSet<Integer>>\n            mRemoteViewsServicesAppWidgets = new HashMap<>();\n\n    private final Object mLock = new Object();\n\n    private final ArrayList<Widget> mWidgets = new ArrayList<>();\n    private final ArrayList<Host> mHosts = new ArrayList<>();\n    private final ArrayList<Provider> mProviders = new ArrayList<>();\n\n    private final ArraySet<Pair<Integer, String>> mPackagesWithBindWidgetPermission =\n            new ArraySet<>();\n\n    private final SparseBooleanArray mLoadedUserIds = new SparseBooleanArray();\n\n    private final Object mWidgetPackagesLock = new Object();\n    private final SparseArray<ArraySet<String>> mWidgetPackages = new SparseArray<>();\n\n    private BackupRestoreController mBackupRestoreController;\n\n    private final Context mContext;\n\n    private IPackageManager mPackageManager;\n    private AlarmManager mAlarmManager;\n    private UserManager mUserManager;\n    private AppOpsManager mAppOpsManager;\n    private KeyguardManager mKeyguardManager;\n    private DevicePolicyManagerInternal mDevicePolicyManagerInternal;\n    private PackageManagerInternal mPackageManagerInternal;\n    private ActivityManagerInternal mActivityManagerInternal;\n    private AppOpsManagerInternal mAppOpsManagerInternal;\n    private UsageStatsManagerInternal mUsageStatsManagerInternal;\n\n    private SecurityPolicy mSecurityPolicy;\n\n    private Handler mSaveStateHandler;\n    private Handler mCallbackHandler;\n\n    private final SparseIntArray mNextAppWidgetIds = new SparseIntArray();\n\n    private boolean mSafeMode;\n    private int mMaxWidgetBitmapMemory;\n\n    AppWidgetServiceImpl(Context context) {\n        mContext = context;\n    }\n\n    public void onStart() {\n        mPackageManager = AppGlobals.getPackageManager();\n        mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);\n        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);\n        mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);\n        mKeyguardManager = (KeyguardManager) mContext.getSystemService(KEYGUARD_SERVICE);\n        mDevicePolicyManagerInternal = LocalServices.getService(DevicePolicyManagerInternal.class);\n        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);\n        mSaveStateHandler = BackgroundThread.getHandler();\n        mCallbackHandler = new CallbackHandler(mContext.getMainLooper());\n        mBackupRestoreController = new BackupRestoreController();\n        mSecurityPolicy = new SecurityPolicy();\n\n        computeMaximumWidgetBitmapMemory();\n        registerBroadcastReceiver();\n        registerOnCrossProfileProvidersChangedListener();\n\n        LocalServices.addService(AppWidgetManagerInternal.class, new AppWidgetManagerLocal());\n    }\n\n    void systemServicesReady() {\n        mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);\n        mAppOpsManagerInternal = LocalServices.getService(AppOpsManagerInternal.class);\n        mUsageStatsManagerInternal = LocalServices.getService(UsageStatsManagerInternal.class);\n    }\n\n    private void computeMaximumWidgetBitmapMemory() {\n        Display display = mContext.getDisplayNoVerify();\n        Point size = new Point();\n        display.getRealSize(size);\n        // Cap memory usage at 1.5 times the size of the display\n        // 1.5 * 4 bytes/pixel * w * h ==> 6 * w * h\n        mMaxWidgetBitmapMemory = 6 * size.x * size.y;\n    }\n\n    private void registerBroadcastReceiver() {\n        // Register for broadcasts about package install, etc., so we can\n        // update the provider list.\n        IntentFilter packageFilter = new IntentFilter();\n        packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);\n        packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        packageFilter.addDataScheme(\"package\");\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                packageFilter, null, null);\n\n        // Register for events related to sdcard installation.\n        IntentFilter sdFilter = new IntentFilter();\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);\n        sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                sdFilter, null, null);\n\n        IntentFilter offModeFilter = new IntentFilter();\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE);\n        offModeFilter.addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                offModeFilter, null, null);\n\n        IntentFilter suspendPackageFilter = new IntentFilter();\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_SUSPENDED);\n        suspendPackageFilter.addAction(Intent.ACTION_PACKAGES_UNSUSPENDED);\n        mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL,\n                suspendPackageFilter, null, null);\n    }\n\n    private void registerOnCrossProfileProvidersChangedListener() {\n        // The device policy is an optional component.\n        if (mDevicePolicyManagerInternal != null) {\n            mDevicePolicyManagerInternal.addOnCrossProfileWidgetProvidersChangeListener(this);\n        }\n    }\n\n    public void setSafeMode(boolean safeMode) {\n        mSafeMode = safeMode;\n    }\n\n    private void onPackageBroadcastReceived(Intent intent, int userId) {\n        final String action = intent.getAction();\n        boolean added = false;\n        boolean changed = false;\n        boolean componentsModified = false;\n\n        final String pkgList[];\n        switch (action) {\n            case Intent.ACTION_PACKAGES_SUSPENDED:\n            case Intent.ACTION_PACKAGES_UNSUSPENDED:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                changed = true;\n                break;\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:\n                added = true;\n                // Follow through\n            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:\n                pkgList = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n                break;\n            default: {\n                Uri uri = intent.getData();\n                if (uri == null) {\n                    return;\n                }\n                String pkgName = uri.getSchemeSpecificPart();\n                if (pkgName == null) {\n                    return;\n                }\n                pkgList = new String[] { pkgName };\n                added = Intent.ACTION_PACKAGE_ADDED.equals(action);\n                changed = Intent.ACTION_PACKAGE_CHANGED.equals(action);\n            }\n        }\n        if (pkgList == null || pkgList.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            if (!mUserManager.isUserUnlockingOrUnlocked(userId) ||\n                    isProfileWithLockedParent(userId)) {\n                return;\n            }\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            Bundle extras = intent.getExtras();\n\n            if (added || changed) {\n                final boolean newPackageAdded = added && (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                for (String pkgName : pkgList) {\n                    // Fix up the providers - add/remove/update.\n                    componentsModified |= updateProvidersForPackageLocked(pkgName, userId, null);\n\n                    // ... and see if these are hosts we've been awaiting.\n                    // NOTE: We are backing up and restoring only the owner.\n                    // TODO: http://b/22388012\n                    if (newPackageAdded && userId == UserHandle.USER_SYSTEM) {\n                        final int uid = getUidForPackage(pkgName, userId);\n                        if (uid >= 0 ) {\n                            resolveHostUidLocked(pkgName, uid);\n                        }\n                    }\n                }\n            } else {\n                // If the package is being updated, we'll receive a PACKAGE_ADDED\n                // shortly, otherwise it is removed permanently.\n                final boolean packageRemovedPermanently = (extras == null\n                        || !extras.getBoolean(Intent.EXTRA_REPLACING, false));\n\n                if (packageRemovedPermanently) {\n                    for (String pkgName : pkgList) {\n                        componentsModified |= removeHostsAndProvidersForPackageLocked(\n                                pkgName, userId);\n                    }\n                }\n            }\n\n            if (componentsModified) {\n                saveGroupStateAsync(userId);\n\n                // If the set of providers has been modified, notify each active AppWidgetHost\n                scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                // Possibly notify any new components of widget id changes\n                mBackupRestoreController.widgetComponentsChanged(userId);\n            }\n        }\n    }\n\n    /**\n     * Reload all widgets' masked state for the given user and its associated profiles, including\n     * due to user not being available and package suspension.\n     * userId must be the group parent.\n     */\n    void reloadWidgetsMaskedStateForGroup(int userId) {\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            return;\n        }\n        synchronized (mLock) {\n            reloadWidgetsMaskedState(userId);\n            int[] profileIds = mUserManager.getEnabledProfileIds(userId);\n            for (int profileId : profileIds) {\n                reloadWidgetsMaskedState(profileId);\n            }\n        }\n    }\n\n    private void reloadWidgetsMaskedState(int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            UserInfo user  = mUserManager.getUserInfo(userId);\n\n            boolean lockedProfile = !mUserManager.isUserUnlockingOrUnlocked(userId);\n            boolean quietProfile = user.isQuietModeEnabled();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != userId) {\n                    continue;\n                }\n\n                boolean changed = provider.setMaskedByLockedProfileLocked(lockedProfile);\n                changed |= provider.setMaskedByQuietProfileLocked(quietProfile);\n                try {\n                    boolean suspended;\n                    try {\n                        suspended = mPackageManager.isPackageSuspendedForUser(\n                                provider.id.componentName.getPackageName(), provider.getUserId());\n                    } catch (IllegalArgumentException ex) {\n                        // Package not found.\n                        suspended = false;\n                    }\n                    changed |= provider.setMaskedBySuspendedPackageLocked(suspended);\n                } catch (RemoteException e) {\n                    Slog.e(TAG, \"Failed to query application info\", e);\n                }\n                if (changed) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * Incrementally update the masked state due to package suspension state.\n     */\n    private void updateWidgetPackageSuspensionMaskedState(Intent intent, boolean suspended,\n            int profileId) {\n        String[] packagesArray = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);\n        if (packagesArray == null) {\n            return;\n        }\n        Set<String> packages = new ArraySet<>(Arrays.asList(packagesArray));\n        synchronized (mLock) {\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                int providerUserId = provider.getUserId();\n                if (providerUserId != profileId\n                        || !packages.contains(provider.id.componentName.getPackageName())) {\n                    continue;\n                }\n                if (provider.setMaskedBySuspendedPackageLocked(suspended)) {\n                    if (provider.isMaskedLocked()) {\n                        maskWidgetsViewsLocked(provider, null);\n                    } else {\n                        unmaskWidgetsViewsLocked(provider);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Mask the target widget belonging to the specified provider, or all active widgets\n     * of the provider if target widget == null.\n     */\n    private void maskWidgetsViewsLocked(Provider provider, Widget targetWidget) {\n        final int widgetCount = provider.widgets.size();\n        if (widgetCount == 0) {\n            return;\n        }\n        RemoteViews views = new RemoteViews(mContext.getPackageName(),\n                R.layout.work_widget_mask_view);\n        ApplicationInfo appInfo = provider.info.providerInfo.applicationInfo;\n        final int appUserId = provider.getUserId();\n        boolean showBadge;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final Intent onClickIntent;\n\n            if (provider.maskedBySuspendedPackage) {\n                showBadge = mUserManager.hasBadge(appUserId);\n                final String suspendingPackage = mPackageManagerInternal.getSuspendingPackage(\n                        appInfo.packageName, appUserId);\n                if (PLATFORM_PACKAGE_NAME.equals(suspendingPackage)) {\n                    onClickIntent = mDevicePolicyManagerInternal.createShowAdminSupportIntent(\n                            appUserId, true);\n                } else {\n                    final SuspendDialogInfo dialogInfo =\n                            mPackageManagerInternal.getSuspendedDialogInfo(\n                                    appInfo.packageName, suspendingPackage, appUserId);\n                    // onUnsuspend is null because we don't want to start any activity on\n                    // unsuspending from a suspended widget.\n                    onClickIntent = SuspendedAppActivity.createSuspendedAppInterceptIntent(\n                            appInfo.packageName, suspendingPackage, dialogInfo, null, null,\n                            appUserId);\n                }\n            } else if (provider.maskedByQuietProfile) {\n                showBadge = true;\n                onClickIntent = UnlaunchableAppActivity.createInQuietModeDialogIntent(appUserId);\n            } else /* provider.maskedByLockedProfile */ {\n                showBadge = true;\n                onClickIntent = mKeyguardManager\n                        .createConfirmDeviceCredentialIntent(null, null, appUserId);\n                if (onClickIntent != null) {\n                    onClickIntent.setFlags(\n                            FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n                }\n            }\n\n            if (onClickIntent != null) {\n                views.setOnClickPendingIntent(android.R.id.background,\n                        PendingIntent.getActivity(mContext, 0, onClickIntent,\n                                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE));\n            }\n\n            Icon icon = appInfo.icon != 0\n                    ? Icon.createWithResource(appInfo.packageName, appInfo.icon)\n                    : Icon.createWithResource(mContext, android.R.drawable.sym_def_app_icon);\n            views.setImageViewIcon(R.id.work_widget_app_icon, icon);\n            if (!showBadge) {\n                views.setViewVisibility(R.id.work_widget_badge_icon, View.INVISIBLE);\n            }\n\n            for (int j = 0; j < widgetCount; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (targetWidget != null && targetWidget != widget) continue;\n                if (widget.replaceWithMaskedViewsLocked(views)) {\n                    scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void unmaskWidgetsViewsLocked(Provider provider) {\n        final int widgetCount = provider.widgets.size();\n        for (int j = 0; j < widgetCount; j++) {\n            Widget widget = provider.widgets.get(j);\n            if (widget.clearMaskedViewsLocked()) {\n                scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n            }\n        }\n    }\n\n    private void resolveHostUidLocked(String pkg, int uid) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.uid == UNKNOWN_UID && pkg.equals(host.id.packageName)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"host \" + host.id + \" resolved to uid \" + uid);\n                }\n                host.id = new HostId(uid, host.id.hostId, host.id.packageName);\n                return;\n            }\n        }\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId) {\n        ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ true );\n    }\n\n    private void ensureGroupStateLoadedLocked(int userId, boolean enforceUserUnlockingOrUnlocked) {\n        if (enforceUserUnlockingOrUnlocked && !isUserRunningAndUnlocked(userId)) {\n            throw new IllegalStateException(\n                    \"User \" + userId + \" must be unlocked for widgets to be available\");\n        }\n        if (enforceUserUnlockingOrUnlocked && isProfileWithLockedParent(userId)) {\n            throw new IllegalStateException(\n                    \"Profile \" + userId + \" must have unlocked parent\");\n        }\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        IntArray newIds = new IntArray(1);\n        for (int profileId : profileIds) {\n            if (!mLoadedUserIds.get(profileId)) {\n                mLoadedUserIds.put(profileId, true);\n                newIds.add(profileId);\n            }\n        }\n        if (newIds.size() <= 0) {\n            return;\n        }\n        final int[] newProfileIds = newIds.toArray();\n        clearProvidersAndHostsTagsLocked();\n\n        loadGroupWidgetProvidersLocked(newProfileIds);\n        loadGroupStateLocked(newProfileIds);\n    }\n\n    private boolean isUserRunningAndUnlocked(@UserIdInt int userId) {\n        return mUserManager.isUserUnlockingOrUnlocked(userId);\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, pw)) return;\n\n        synchronized (mLock) {\n            if (args.length > 0 && \"--proto\".equals(args[0])) {\n                dumpProto(fd);\n            } else {\n                dumpInternalLocked(pw);\n            }\n        }\n    }\n\n    private void dumpProto(FileDescriptor fd) {\n        Slog.i(TAG, \"dump proto for \" + mWidgets.size() + \" widgets\");\n\n        ProtoOutputStream proto = new ProtoOutputStream(fd);\n        int N = mWidgets.size();\n        for (int i=0; i < N; i++) {\n            dumpProtoWidget(proto, mWidgets.get(i));\n        }\n        proto.flush();\n    }\n\n    private void dumpProtoWidget(ProtoOutputStream proto, Widget widget) {\n        if (widget.host == null || widget.provider == null) {\n            Slog.d(TAG, \"skip dumping widget because host or provider is null: widget.host=\"\n                + widget.host + \" widget.provider=\"  + widget.provider);\n            return;\n        }\n        long token = proto.start(AppWidgetServiceDumpProto.WIDGETS);\n        proto.write(WidgetProto.IS_CROSS_PROFILE,\n            widget.host.getUserId() != widget.provider.getUserId());\n        proto.write(WidgetProto.IS_HOST_STOPPED, widget.host.callbacks == null);\n        proto.write(WidgetProto.HOST_PACKAGE, widget.host.id.packageName);\n        proto.write(WidgetProto.PROVIDER_PACKAGE, widget.provider.id.componentName.getPackageName());\n        proto.write(WidgetProto.PROVIDER_CLASS, widget.provider.id.componentName.getClassName());\n        if (widget.options != null) {\n            proto.write(WidgetProto.RESTORE_COMPLETED,\n                    widget.options.getBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED));\n            proto.write(WidgetProto.MIN_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 0));\n            proto.write(WidgetProto.MIN_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 0));\n            proto.write(WidgetProto.MAX_WIDTH,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 0));\n            proto.write(WidgetProto.MAX_HEIGHT,\n                widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 0));\n        }\n        proto.end(token);\n    }\n\n    private void dumpInternalLocked(PrintWriter pw) {\n        int N = mProviders.size();\n        pw.println(\"Providers:\");\n        for (int i = 0; i < N; i++) {\n            dumpProviderLocked(mProviders.get(i), i, pw);\n        }\n\n        N = mWidgets.size();\n        pw.println(\" \");\n        pw.println(\"Widgets:\");\n        for (int i = 0; i < N; i++) {\n            dumpWidget(mWidgets.get(i), i, pw);\n        }\n\n        N = mHosts.size();\n        pw.println(\" \");\n        pw.println(\"Hosts:\");\n        for (int i = 0; i < N; i++) {\n            dumpHost(mHosts.get(i), i, pw);\n        }\n\n        N = mPackagesWithBindWidgetPermission.size();\n        pw.println(\" \");\n        pw.println(\"Grants:\");\n        for (int i = 0; i < N; i++) {\n            Pair<Integer, String> grant = mPackagesWithBindWidgetPermission.valueAt(i);\n            dumpGrant(grant, i, pw);\n        }\n    }\n\n    @Override\n    public ParceledListSlice<PendingHostUpdate> startListening(IAppWidgetHost callbacks,\n            String callingPackage, int hostId, int[] appWidgetIds) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"startListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n            host.callbacks = callbacks;\n\n            long updateSequenceNo = UPDATE_COUNTER.incrementAndGet();\n            int N = appWidgetIds.length;\n            ArrayList<PendingHostUpdate> outUpdates = new ArrayList<>(N);\n            LongSparseArray<PendingHostUpdate> updatesMap = new LongSparseArray<>();\n            for (int i = 0; i < N; i++) {\n                updatesMap.clear();\n                host.getPendingUpdatesForIdLocked(mContext, appWidgetIds[i], updatesMap);\n                // We key the updates based on request id, so that the values are sorted in the\n                // order they were received.\n                int m = updatesMap.size();\n                for (int j = 0; j < m; j++) {\n                    outUpdates.add(updatesMap.valueAt(j));\n                }\n            }\n            // Reset the update counter once all the updates have been calculated\n            host.lastWidgetUpdateSequenceNo = updateSequenceNo;\n            return new ParceledListSlice<>(outUpdates);\n        }\n    }\n\n    @Override\n    public void stopListening(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"stopListening() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId, /* enforceUserUnlockingOrUnlocked */ false);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                host.callbacks = null;\n                pruneHostLocked(host);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(host.getWidgetUids(), false);\n            }\n        }\n    }\n\n    @Override\n    public int allocateAppWidgetId(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"allocateAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            // Instant apps cannot host app widgets.\n            if (mSecurityPolicy.isInstantAppLocked(callingPackage, userId)) {\n                Slog.w(TAG, \"Instant package \" + callingPackage + \" cannot host app widgets\");\n                return AppWidgetManager.INVALID_APPWIDGET_ID;\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n                mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);\n            }\n\n            final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts it owns.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupOrAddHostLocked(id);\n\n            Widget widget = new Widget();\n            widget.appWidgetId = appWidgetId;\n            widget.host = host;\n\n            host.widgets.add(widget);\n            addWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Allocated widget id \" + appWidgetId\n                        + \" for host \" + host.id);\n            }\n\n            return appWidgetId;\n        }\n    }\n\n    @Override\n    public void deleteAppWidgetId(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            deleteAppWidgetLocked(widget);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted widget id \" + appWidgetId\n                        + \" for host \" + widget.host.id);\n            }\n        }\n    }\n\n    @Override\n    public boolean hasBindAppWidgetPermission(String packageName, int grantId) {\n        if (DEBUG) {\n            Slog.i(TAG, \"hasBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return false;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            return mPackagesWithBindWidgetPermission.contains(packageId);\n        }\n    }\n\n    @Override\n    public void setBindAppWidgetPermission(String packageName, int grantId,\n            boolean grantPermission) {\n        if (DEBUG) {\n            Slog.i(TAG, \"setBindAppWidgetPermission() \" + UserHandle.getCallingUserId());\n        }\n\n        // A special permission is required for managing allowlisting.\n        mSecurityPolicy.enforceModifyAppWidgetBindPermissions(packageName);\n\n        synchronized (mLock) {\n            // The grants are stored in user state wich gets the grant.\n            ensureGroupStateLoadedLocked(grantId);\n\n            final int packageUid = getUidForPackage(packageName, grantId);\n            if (packageUid < 0) {\n                return;\n            }\n\n            Pair<Integer, String> packageId = Pair.create(grantId, packageName);\n            if (grantPermission) {\n                mPackagesWithBindWidgetPermission.add(packageId);\n            } else {\n                mPackagesWithBindWidgetPermission.remove(packageId);\n            }\n\n            saveGroupStateAsync(grantId);\n        }\n    }\n\n    @Override\n    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId,\n            final int intentFlags) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"createAppWidgetConfigIntentSender() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id \" + appWidgetId);\n            }\n\n            Provider provider = widget.provider;\n            if (provider == null) {\n                throw new IllegalArgumentException(\"Widget not bound \" + appWidgetId);\n            }\n\n            // Make sure only safe flags can be passed it.\n            final int secureFlags = intentFlags & ~Intent.IMMUTABLE_FLAGS;\n\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            intent.setComponent(provider.getInfoLocked(mContext).configure);\n            intent.setFlags(secureFlags);\n\n            // All right, create the sender.\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return PendingIntent.getActivityAsUser(\n                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                                | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT,\n                                null, new UserHandle(provider.getUserId()))\n                        .getIntentSender();\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    @Override\n    public boolean bindAppWidgetId(String callingPackage, int appWidgetId,\n            int providerProfileId, ComponentName providerComponent, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"bindAppWidgetId() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        // Check that if a cross-profile binding is attempted, it is allowed.\n        if (!mSecurityPolicy.isEnabledGroupProfile(providerProfileId)) {\n            return false;\n        }\n\n        // If the provider is not under the calling user, make sure this\n        // provider is allowlisted for access from the parent.\n        if (!mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                providerComponent.getPackageName(), providerProfileId)) {\n            return false;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // A special permission or allowlisting is required to bind widgets.\n            if (!mSecurityPolicy.hasCallerBindPermissionOrBindWhiteListedLocked(\n                    callingPackage)) {\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                Slog.e(TAG, \"Bad widget id \" + appWidgetId);\n                return false;\n            }\n\n            if (widget.provider != null) {\n                Slog.e(TAG, \"Widget id \" + appWidgetId\n                        + \" already bound to: \" + widget.provider.id);\n                return false;\n            }\n\n            final int providerUid = getUidForPackage(providerComponent.getPackageName(),\n                    providerProfileId);\n            if (providerUid < 0) {\n                Slog.e(TAG, \"Package \" + providerComponent.getPackageName() + \" not installed \"\n                        + \" for profile \" + providerProfileId);\n                return false;\n            }\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the provider is in the already vetted user profile.\n            ProviderId providerId = new ProviderId(providerUid, providerComponent);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.e(TAG, \"No widget provider \" + providerComponent + \" for profile \"\n                        + providerProfileId);\n                return false;\n            }\n\n            if (provider.zombie) {\n                Slog.e(TAG, \"Can't bind to a 3rd party provider in\"\n                        + \" safe mode \" + provider);\n                return false;\n            }\n\n            widget.provider = provider;\n            widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle();\n\n            // We need to provide a default value for the widget category if it is not specified\n            if (!widget.options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {\n                widget.options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,\n                        AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            }\n\n            provider.widgets.add(widget);\n\n            onWidgetProviderAddedOrChangedLocked(widget);\n\n            final int widgetCount = provider.widgets.size();\n            if (widgetCount == 1) {\n                // Tell the provider that it's ready.\n                sendEnableIntentLocked(provider);\n            }\n\n            // Send an update now -- We need this update now, and just for this appWidgetId.\n            // It's less critical when the next one happens, so when we schedule the next one,\n            // we add updatePeriodMillis to its start time. That time will have some slop,\n            // but that's okay.\n            sendUpdateIntentLocked(provider, new int[] {appWidgetId});\n\n            // Schedule the future updates.\n            registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets));\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Bound widget \" + appWidgetId + \" to provider \" + provider.id);\n            }\n        }\n\n        return true;\n    }\n\n    @Override\n    public int[] getAppWidgetIds(ComponentName componentName) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIds() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider != null) {\n                return getWidgetIds(provider.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public int[] getAppWidgetIdsForHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetIdsForHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access its hosts.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host != null) {\n                return getWidgetIds(host.widgets);\n            }\n\n            return new int[0];\n        }\n    }\n\n    @Override\n    public boolean bindRemoteViewsService(String callingPackage, int appWidgetId, Intent intent,\n            IApplicationThread caller, IBinder activtiyToken, IServiceConnection connection,\n            int flags) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"bindRemoteViewsService() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                throw new IllegalArgumentException(\"Bad widget id\");\n            }\n\n            // Make sure the widget has a provider.\n            if (widget.provider == null) {\n                throw new IllegalArgumentException(\"No provider for widget \"\n                        + appWidgetId);\n            }\n\n            ComponentName componentName = intent.getComponent();\n\n            // Ensure that the service belongs to the same package as the provider.\n            // But this is not enough as they may be under different users - see below...\n            String providerPackage = widget.provider.id.componentName.getPackageName();\n            String servicePackage = componentName.getPackageName();\n            if (!servicePackage.equals(providerPackage)) {\n                throw new SecurityException(\"The taget service not in the same package\"\n                        + \" as the widget provider\");\n            }\n\n            // Make sure this service exists under the same user as the provider and\n            // requires a permission which allows only the system to bind to it.\n            mSecurityPolicy.enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                    componentName, widget.provider.getUserId());\n\n            // Good to go - the service package is correct, it exists for the correct\n            // user, and requires the bind permission.\n\n            final long callingIdentity = Binder.clearCallingIdentity();\n            try {\n                // Ask ActivityManager to bind it. Notice that we are binding the service with the\n                // caller app instead of DevicePolicyManagerService.\n                if (ActivityManager.getService().bindService(\n                        caller, activtiyToken, intent,\n                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                        connection, flags & (Context.BIND_AUTO_CREATE\n                                | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE),\n                        mContext.getOpPackageName(), widget.provider.getUserId()) != 0) {\n\n                    // Add it to the mapping of RemoteViewsService to appWidgetIds so that we\n                    // can determine when we can call back to the RemoteViewsService later to\n                    // destroy associated factories.\n                    incrementAppWidgetServiceRefCount(appWidgetId,\n                            Pair.create(widget.provider.id.uid, new FilterComparison(intent)));\n                    return true;\n                }\n            } catch (RemoteException ex) {\n                // Same process, should not happen.\n            } finally {\n                Binder.restoreCallingIdentity(callingIdentity);\n            }\n        }\n\n        // Failed to bind.\n        return false;\n    }\n\n    @Override\n    public void deleteHost(String callingPackage, int hostId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteHost() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access hosts in its uid and package.\n            HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);\n            Host host = lookupHostLocked(id);\n\n            if (host == null) {\n                return;\n            }\n\n            deleteHostLocked(host);\n\n            saveGroupStateAsync(userId);\n\n            if (DEBUG) {\n                Slog.i(TAG, \"Deleted host \" + host.id);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAllHosts() {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"deleteAllHosts() \" + userId);\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            boolean changed = false;\n\n            final int N = mHosts.size();\n            for (int i = N - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n\n                // Delete only hosts in the calling uid.\n                if (host.id.uid == Binder.getCallingUid()) {\n                    deleteHostLocked(host);\n                    changed = true;\n\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Deleted host \" + host.id);\n                    }\n                }\n            }\n\n            if (changed) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    @Override\n    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetInfo() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.provider != null && !widget.provider.zombie) {\n                return cloneIfLocalBinder(widget.provider.getInfoLocked(mContext));\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public RemoteViews getAppWidgetViews(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetViews() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null) {\n                return cloneIfLocalBinder(widget.getEffectiveViewsLocked());\n            }\n\n            return null;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetOptions(String callingPackage, int appWidgetId, Bundle options) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget == null) {\n                return;\n            }\n\n            // Merge the options.\n            widget.options.putAll(options);\n\n            // Send the broacast to notify the provider that options changed.\n            sendOptionsChangedIntentLocked(widget);\n\n            saveGroupStateAsync(userId);\n        }\n    }\n\n    @Override\n    public Bundle getAppWidgetOptions(String callingPackage, int appWidgetId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getAppWidgetOptions() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can only access widgets it hosts or provides.\n            Widget widget = lookupWidgetLocked(appWidgetId,\n                    Binder.getCallingUid(), callingPackage);\n\n            if (widget != null && widget.options != null) {\n                return cloneIfLocalBinder(widget.options);\n            }\n\n            return Bundle.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, false);\n    }\n\n    @Override\n    public void partiallyUpdateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views) {\n        if (DEBUG) {\n            Slog.i(TAG, \"partiallyUpdateAppWidgetIds() \" + UserHandle.getCallingUserId());\n        }\n\n        updateAppWidgetIds(callingPackage, appWidgetIds, views, true);\n    }\n\n    @Override\n    public void notifyAppWidgetViewDataChanged(String callingPackage, int[] appWidgetIds,\n            int viewId) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"notifyAppWidgetViewDataChanged() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    scheduleNotifyAppWidgetViewDataChanged(widget, viewId);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProvider(ComponentName componentName, RemoteViews views) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n\n            if (provider == null) {\n                Slog.w(TAG, \"Provider doesn't exist \" + providerId);\n                return;\n            }\n\n            ArrayList<Widget> instances = provider.widgets;\n            final int N = instances.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = instances.get(i);\n                updateAppWidgetInstanceLocked(widget, views, false);\n            }\n        }\n    }\n\n    @Override\n    public void updateAppWidgetProviderInfo(ComponentName componentName, String metadataKey) {\n        final int userId = UserHandle.getCallingUserId();\n        if (DEBUG) {\n            Slog.i(TAG, \"updateAppWidgetProvider() \" + userId);\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(componentName.getPackageName());\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // NOTE: The lookup is enforcing security across users by making\n            // sure the caller can access only its providers.\n            ProviderId providerId = new ProviderId(Binder.getCallingUid(), componentName);\n            Provider provider = lookupProviderLocked(providerId);\n            if (provider == null) {\n                throw new IllegalArgumentException(\n                        componentName + \" is not a valid AppWidget provider\");\n            }\n            if (Objects.equals(provider.infoTag, metadataKey)) {\n                // No change\n                return;\n            }\n\n            String keyToUse = metadataKey == null\n                    ? AppWidgetManager.META_DATA_APPWIDGET_PROVIDER : metadataKey;\n            AppWidgetProviderInfo info = parseAppWidgetProviderInfo(mContext, providerId,\n                    provider.getPartialInfoLocked().providerInfo, keyToUse);\n            if (info == null) {\n                throw new IllegalArgumentException(\"Unable to parse \" + keyToUse\n                        + \" meta-data to a valid AppWidget provider\");\n            }\n\n            provider.setInfoLocked(info);\n            provider.infoTag = metadataKey;\n\n            // Update all widgets for this provider\n            final int N = provider.widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = provider.widgets.get(i);\n                scheduleNotifyProviderChangedLocked(widget);\n                updateAppWidgetInstanceLocked(widget, widget.views, false /* isPartialUpdate */);\n            }\n\n            saveGroupStateAsync(userId);\n            scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n        }\n    }\n\n    @Override\n    public boolean isRequestPinAppWidgetSupported() {\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + Binder.getCallingUid()\n                        + \" query information about app widgets\");\n                return false;\n            }\n        }\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .isRequestPinItemSupported(UserHandle.getCallingUserId(),\n                        LauncherApps.PinItemRequest.REQUEST_TYPE_APPWIDGET);\n    }\n\n    @Override\n    public boolean requestPinAppWidget(String callingPackage, ComponentName componentName,\n            Bundle extras, IntentSender resultSender) {\n        final int callingUid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(callingUid);\n\n        if (DEBUG) {\n            Slog.i(TAG, \"requestPinAppWidget() \" + userId);\n        }\n\n        final AppWidgetProviderInfo info;\n\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            // Look for the widget associated with the caller.\n            Provider provider = lookupProviderLocked(new ProviderId(callingUid, componentName));\n            if (provider == null || provider.zombie) {\n                return false;\n            }\n            info = provider.getInfoLocked(mContext);\n            if ((info.widgetCategory & AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN) == 0) {\n                return false;\n            }\n        }\n\n        return LocalServices.getService(ShortcutServiceInternal.class)\n                .requestPinAppWidget(callingPackage, info, extras, resultSender, userId);\n    }\n\n    @Override\n    public ParceledListSlice<AppWidgetProviderInfo> getInstalledProvidersForProfile(int categoryFilter,\n            int profileId, String packageName) {\n        final int userId = UserHandle.getCallingUserId();\n        final int callingUid = Binder.getCallingUid();\n\n        if (DEBUG) {\n            Slog.i(TAG, \"getInstalledProvidersForProfiles() \" + userId);\n        }\n\n        // Ensure the profile is in the group and enabled.\n        if (!mSecurityPolicy.isEnabledGroupProfile(profileId)) {\n            return null;\n        }\n\n        synchronized (mLock) {\n            if (mSecurityPolicy.isCallerInstantAppLocked()) {\n                Slog.w(TAG, \"Instant uid \" + callingUid\n                        + \" cannot access widget providers\");\n                return ParceledListSlice.emptyList();\n            }\n\n            ensureGroupStateLoadedLocked(userId);\n\n            ArrayList<AppWidgetProviderInfo> result = new ArrayList<AppWidgetProviderInfo>();\n\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n                final String providerPackageName = provider.id.componentName.getPackageName();\n\n                // Ignore an invalid provider, one not matching the filter,\n                // or one that isn't in the given package, if any.\n                boolean inPackage = packageName == null\n                        || providerPackageName.equals(packageName);\n                if (provider.zombie || (info.widgetCategory & categoryFilter) == 0 || !inPackage) {\n                    continue;\n                }\n\n                // Add providers only for the requested profile that are allowlisted.\n                final int providerProfileId = info.getProfile().getIdentifier();\n                if (providerProfileId == profileId\n                        && mSecurityPolicy.isProviderInCallerOrInProfileAndWhitelListed(\n                        providerPackageName, providerProfileId)\n                        && !mPackageManagerInternal.filterAppAccess(providerPackageName, callingUid,\n                        userId)) {\n                    result.add(cloneIfLocalBinder(info));\n                }\n            }\n\n            return new ParceledListSlice<AppWidgetProviderInfo>(result);\n        }\n    }\n\n    private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,\n            RemoteViews views, boolean partially) {\n        final int userId = UserHandle.getCallingUserId();\n\n        if (appWidgetIds == null || appWidgetIds.length == 0) {\n            return;\n        }\n\n        // Make sure the package runs under the caller uid.\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        synchronized (mLock) {\n            ensureGroupStateLoadedLocked(userId);\n\n            final int N = appWidgetIds.length;\n            for (int i = 0; i < N; i++) {\n                final int appWidgetId = appWidgetIds[i];\n\n                // NOTE: The lookup is enforcing security across users by making\n                // sure the caller can only access widgets it hosts or provides.\n                Widget widget = lookupWidgetLocked(appWidgetId,\n                        Binder.getCallingUid(), callingPackage);\n\n                if (widget != null) {\n                    updateAppWidgetInstanceLocked(widget, views, partially);\n                }\n            }\n        }\n    }\n\n    private int incrementAndGetAppWidgetIdLocked(int userId) {\n        final int appWidgetId = peekNextAppWidgetIdLocked(userId) + 1;\n        mNextAppWidgetIds.put(userId, appWidgetId);\n        return appWidgetId;\n    }\n\n    private void setMinAppWidgetIdLocked(int userId, int minWidgetId) {\n        final int nextAppWidgetId = peekNextAppWidgetIdLocked(userId);\n        if (nextAppWidgetId < minWidgetId) {\n            mNextAppWidgetIds.put(userId, minWidgetId);\n        }\n    }\n\n    private int peekNextAppWidgetIdLocked(int userId) {\n        if (mNextAppWidgetIds.indexOfKey(userId) < 0) {\n            return AppWidgetManager.INVALID_APPWIDGET_ID + 1;\n        } else {\n            return mNextAppWidgetIds.get(userId);\n        }\n    }\n\n    private Host lookupOrAddHostLocked(HostId id) {\n        Host host = lookupHostLocked(id);\n        if (host != null) {\n            return host;\n        }\n        ensureHostCountBeforeAddLocked(id);\n        host = new Host();\n        host.id = id;\n        mHosts.add(host);\n\n        return host;\n    }\n\n    /**\n     * Ensures that the number of hosts for a package is less than the maximum number of hosts per\n     * package. If the number of hosts is greater than the maximum number of hosts per package, then\n     * removes the oldest host.\n     */\n    private void ensureHostCountBeforeAddLocked(HostId hostId) {\n        final List<Host> hosts = new ArrayList<>();\n        for (Host host : mHosts) {\n            if (host.id.uid == hostId.uid\n                    && host.id.packageName.equals(hostId.packageName)) {\n                hosts.add(host);\n            }\n        }\n        while (hosts.size() >= MAX_NUMBER_OF_HOSTS_PER_PACKAGE) {\n            deleteHostLocked(hosts.remove(0));\n        }\n    }\n\n    private void deleteHostLocked(Host host) {\n        final int N = host.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = host.widgets.remove(i);\n            deleteAppWidgetLocked(widget);\n        }\n        mHosts.remove(host);\n\n        // it's gone or going away, abruptly drop the callback connection\n        host.callbacks = null;\n    }\n\n    private void deleteAppWidgetLocked(Widget widget) {\n        // We first unbind all services that are bound to this id\n        // Check if we need to destroy any services (if no other app widgets are\n        // referencing the same service)\n        decrementAppWidgetServiceRefCount(widget);\n\n        Host host = widget.host;\n        host.widgets.remove(widget);\n        pruneHostLocked(host);\n\n        removeWidgetLocked(widget);\n\n        Provider provider = widget.provider;\n        if (provider != null) {\n            provider.widgets.remove(widget);\n            if (!provider.zombie) {\n                // send the broacast saying that this appWidgetId has been deleted\n                sendDeletedIntentLocked(widget);\n\n                if (provider.widgets.isEmpty()) {\n                    // cancel the future updates\n                    cancelBroadcastsLocked(provider);\n\n                    // send the broacast saying that the provider is not in use any more\n                    sendDisabledIntentLocked(provider);\n                }\n            }\n        }\n    }\n\n    private void cancelBroadcastsLocked(Provider provider) {\n        if (DEBUG) {\n            Slog.i(TAG, \"cancelBroadcastsLocked() for \" + provider);\n        }\n        if (provider.broadcast != null) {\n            final PendingIntent broadcast = provider.broadcast;\n            mSaveStateHandler.post(() -> {\n                    mAlarmManager.cancel(broadcast);\n                    broadcast.cancel();\n            });\n            provider.broadcast = null;\n        }\n    }\n\n    // Destroys the cached factory on the RemoteViewsService's side related to the specified intent\n    private void destroyRemoteViewsService(final Intent intent, Widget widget) {\n        final ServiceConnection conn = new ServiceConnection() {\n            @Override\n            public void onServiceConnected(ComponentName name, IBinder service) {\n                final IRemoteViewsFactory cb = IRemoteViewsFactory.Stub.asInterface(service);\n                try {\n                    cb.onDestroy(intent);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Error calling remove view factory\", re);\n                }\n                mContext.unbindService(this);\n            }\n\n            @Override\n            public void onServiceDisconnected(ComponentName name) {\n                // Do nothing\n            }\n        };\n\n        // Bind to the service and remove the static intent->factory mapping in the\n        // RemoteViewsService.\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, conn,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    widget.provider.id.getProfile());\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    // Adds to the ref-count for a given RemoteViewsService intent\n    private void incrementAppWidgetServiceRefCount(int appWidgetId,\n            Pair<Integer, FilterComparison> serviceId) {\n        final HashSet<Integer> appWidgetIds;\n        if (mRemoteViewsServicesAppWidgets.containsKey(serviceId)) {\n            appWidgetIds = mRemoteViewsServicesAppWidgets.get(serviceId);\n        } else {\n            appWidgetIds = new HashSet<>();\n            mRemoteViewsServicesAppWidgets.put(serviceId, appWidgetIds);\n        }\n        appWidgetIds.add(appWidgetId);\n    }\n\n    // Subtracts from the ref-count for a given RemoteViewsService intent, prompting a delete if\n    // the ref-count reaches zero.\n    private void decrementAppWidgetServiceRefCount(Widget widget) {\n        Iterator<Pair<Integer, FilterComparison>> it = mRemoteViewsServicesAppWidgets\n                .keySet().iterator();\n        while (it.hasNext()) {\n            final Pair<Integer, FilterComparison> key = it.next();\n            final HashSet<Integer> ids = mRemoteViewsServicesAppWidgets.get(key);\n            if (ids.remove(widget.appWidgetId)) {\n                // If we have removed the last app widget referencing this service, then we\n                // should destroy it and remove it from this set\n                if (ids.isEmpty()) {\n                    destroyRemoteViewsService(key.second.getIntent(), widget);\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    private void saveGroupStateAsync(int groupId) {\n        mSaveStateHandler.post(new SaveStateRunnable(groupId));\n    }\n\n    private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,\n            boolean isPartialUpdate) {\n        if (widget != null && widget.provider != null\n                && !widget.provider.zombie && !widget.host.zombie) {\n\n            if (isPartialUpdate && widget.views != null) {\n                // For a partial update, we merge the new RemoteViews with the old.\n                widget.views.mergeRemoteViews(views);\n            } else {\n                // For a full update we replace the RemoteViews completely.\n                widget.views = views;\n            }\n            int memoryUsage;\n            if ((UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) &&\n                    (widget.views != null) &&\n                    ((memoryUsage = widget.views.estimateMemoryUsage()) > mMaxWidgetBitmapMemory)) {\n                widget.views = null;\n                throw new IllegalArgumentException(\"RemoteViews for widget update exceeds\"\n                        + \" maximum bitmap memory usage (used: \" + memoryUsage\n                        + \", max: \" + mMaxWidgetBitmapMemory + \")\");\n            }\n            scheduleNotifyUpdateAppWidgetLocked(widget, widget.getEffectiveViewsLocked());\n        }\n    }\n    private void scheduleNotifyAppWidgetViewDataChanged(Widget widget, int viewId) {\n        if (viewId == ID_VIEWS_UPDATE || viewId == ID_PROVIDER_CHANGED) {\n            // A view id should never collide with these constants but a developer can call this\n            // method with a wrong id. In that case, ignore the call.\n            return;\n        }\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(viewId, requestId);\n        }\n        if (widget == null || widget.host == null || widget.host.zombie\n                || widget.host.callbacks == null || widget.provider == null\n                || widget.provider.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n        args.argi2 = viewId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_VIEW_DATA_CHANGED,\n                args).sendToTarget();\n    }\n\n\n    private void handleNotifyAppWidgetViewDataChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, int viewId, long requestId) {\n        try {\n            callbacks.viewDataChanged(appWidgetId, viewId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            // It failed; remove the callback. No need to prune because\n            // we know that this host is still referenced by this instance.\n            callbacks = null;\n        }\n\n        // If the host is unavailable, then we call the associated\n        // RemoteViewsFactory.onDataSetChanged() directly\n        synchronized (mLock) {\n            if (callbacks == null) {\n                host.callbacks = null;\n\n                Set<Pair<Integer, FilterComparison>> keys = mRemoteViewsServicesAppWidgets.keySet();\n                for (Pair<Integer, FilterComparison> key : keys) {\n                    if (mRemoteViewsServicesAppWidgets.get(key).contains(appWidgetId)) {\n                        final ServiceConnection connection = new ServiceConnection() {\n                            @Override\n                            public void onServiceConnected(ComponentName name, IBinder service) {\n                                IRemoteViewsFactory cb = IRemoteViewsFactory.Stub\n                                        .asInterface(service);\n                                try {\n                                    cb.onDataSetChangedAsync();\n                                } catch (RemoteException e) {\n                                    Slog.e(TAG, \"Error calling onDataSetChangedAsync()\", e);\n                                }\n                                mContext.unbindService(this);\n                            }\n\n                            @Override\n                            public void onServiceDisconnected(android.content.ComponentName name) {\n                                // Do nothing\n                            }\n                        };\n\n                        final int userId = UserHandle.getUserId(key.first);\n                        Intent intent = key.second.getIntent();\n\n                        // Bind to the service and call onDataSetChanged()\n                        bindService(intent, connection, new UserHandle(userId));\n                    }\n                }\n            }\n        }\n    }\n\n    private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.put(ID_VIEWS_UPDATE, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n        if (updateViews != null) {\n            updateViews = new RemoteViews(updateViews);\n            updateViews.setProviderInstanceId(requestId);\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = updateViews;\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, RemoteViews views, long requestId) {\n        try {\n            callbacks.updateAppWidget(appWidgetId, views);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyProviderChangedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            // When the provider changes, reset everything else.\n            widget.updateSequenceNos.clear();\n            widget.updateSequenceNos.append(ID_PROVIDER_CHANGED, requestId);\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = widget.provider.getInfoLocked(mContext);\n        args.arg4 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n                CallbackHandler.MSG_NOTIFY_PROVIDER_CHANGED,\n                args).sendToTarget();\n    }\n\n    private void handleNotifyProviderChanged(Host host, IAppWidgetHost callbacks,\n            int appWidgetId, AppWidgetProviderInfo info, long requestId) {\n        try {\n            callbacks.providerChanged(appWidgetId, info);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock){\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyAppWidgetRemovedLocked(Widget widget) {\n        long requestId = UPDATE_COUNTER.incrementAndGet();\n        if (widget != null) {\n            widget.updateSequenceNos.clear();\n        }\n        if (widget == null || widget.provider == null || widget.provider.zombie\n                || widget.host.callbacks == null || widget.host.zombie) {\n            return;\n        }\n\n        SomeArgs args = SomeArgs.obtain();\n        args.arg1 = widget.host;\n        args.arg2 = widget.host.callbacks;\n        args.arg3 = requestId;\n        args.argi1 = widget.appWidgetId;\n\n        mCallbackHandler.obtainMessage(\n            CallbackHandler.MSG_NOTIFY_APP_WIDGET_REMOVED,\n            args).sendToTarget();\n    }\n\n    private void handleNotifyAppWidgetRemoved(Host host, IAppWidgetHost callbacks, int appWidgetId,\n            long requestId) {\n        try {\n            callbacks.appWidgetRemoved(appWidgetId);\n            host.lastWidgetUpdateSequenceNo = requestId;\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private void scheduleNotifyGroupHostsForProvidersChangedLocked(int userId) {\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n\n            boolean hostInGroup = false;\n            final int M = profileIds.length;\n            for (int j = 0; j < M; j++) {\n                final int profileId = profileIds[j];\n                if (host.getUserId() == profileId) {\n                    hostInGroup = true;\n                    break;\n                }\n            }\n\n            if (!hostInGroup) {\n                continue;\n            }\n\n            if (host == null || host.zombie || host.callbacks == null) {\n                continue;\n            }\n\n            SomeArgs args = SomeArgs.obtain();\n            args.arg1 = host;\n            args.arg2 = host.callbacks;\n\n            mCallbackHandler.obtainMessage(\n                    CallbackHandler.MSG_NOTIFY_PROVIDERS_CHANGED,\n                    args).sendToTarget();\n        }\n    }\n\n    private void handleNotifyProvidersChanged(Host host, IAppWidgetHost callbacks) {\n        try {\n            callbacks.providersChanged();\n        } catch (RemoteException re) {\n            synchronized (mLock) {\n                Slog.e(TAG, \"Widget host dead: \" + host.id, re);\n                host.callbacks = null;\n            }\n        }\n    }\n\n    private static boolean isLocalBinder() {\n        return Process.myPid() == Binder.getCallingPid();\n    }\n\n    private static RemoteViews cloneIfLocalBinder(RemoteViews rv) {\n        if (isLocalBinder() && rv != null) {\n            return rv.clone();\n        }\n        return rv;\n    }\n\n    private static AppWidgetProviderInfo cloneIfLocalBinder(AppWidgetProviderInfo info) {\n        if (isLocalBinder() && info != null) {\n            return info.clone();\n        }\n        return info;\n    }\n\n    private static Bundle cloneIfLocalBinder(Bundle bundle) {\n        // Note: this is only a shallow copy. For now this will be fine, but it could be problematic\n        // if we start adding objects to the options. Further, it would only be an issue if keyguard\n        // used such options.\n        if (isLocalBinder() && bundle != null) {\n            return (Bundle) bundle.clone();\n        }\n        return bundle;\n    }\n\n    private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) {\n        final int N = mWidgets.size();\n        for (int i = 0; i < N; i++) {\n            Widget widget = mWidgets.get(i);\n            if (widget.appWidgetId == appWidgetId\n                    && mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) {\n                return widget;\n            }\n        }\n        return null;\n    }\n\n    private Provider lookupProviderLocked(ProviderId id) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.id.equals(id)) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host lookupHostLocked(HostId hostId) {\n        final int N = mHosts.size();\n        for (int i = 0; i < N; i++) {\n            Host host = mHosts.get(i);\n            if (host.id.equals(hostId)) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    private void pruneHostLocked(Host host) {\n        if (host.widgets.size() == 0 && host.callbacks == null) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Pruning host \" + host.id);\n            }\n            mHosts.remove(host);\n        }\n    }\n\n    private void loadGroupWidgetProvidersLocked(int[] profileIds) {\n        List<ResolveInfo> allReceivers = null;\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            List<ResolveInfo> receivers = queryIntentReceivers(intent, profileId);\n            if (receivers != null && !receivers.isEmpty()) {\n                if (allReceivers == null) {\n                    allReceivers = new ArrayList<>();\n                }\n                allReceivers.addAll(receivers);\n            }\n        }\n\n        final int N = (allReceivers == null) ? 0 : allReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo receiver = allReceivers.get(i);\n            addProviderLocked(receiver);\n        }\n    }\n\n    private boolean addProviderLocked(ResolveInfo ri) {\n        if ((ri.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n            return false;\n        }\n\n        ComponentName componentName = new ComponentName(ri.activityInfo.packageName,\n                ri.activityInfo.name);\n        ProviderId providerId = new ProviderId(ri.activityInfo.applicationInfo.uid, componentName);\n\n        // we might have an inactive entry for this provider already due to\n        // a preceding restore operation.  if so, fix it up in place; otherwise\n        // just add this new one.\n        Provider existing = lookupProviderLocked(providerId);\n\n        // If the provider was not found it may be because it was restored and\n        // we did not know its UID so let us find if there is such one.\n        if (existing == null) {\n            ProviderId restoredProviderId = new ProviderId(UNKNOWN_UID, componentName);\n            existing = lookupProviderLocked(restoredProviderId);\n        }\n\n        AppWidgetProviderInfo info = createPartialProviderInfo(providerId, ri, existing);\n        if (info != null) {\n            if (existing != null) {\n                if (existing.zombie && !mSafeMode) {\n                    // it's a placeholder that was set up during an app restore\n                    existing.id = providerId;\n                    existing.zombie = false;\n                    existing.setPartialInfoLocked(info);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Provider placeholder now reified: \" + existing);\n                    }\n                }\n            } else {\n                Provider provider = new Provider();\n                provider.id = providerId;\n                provider.setPartialInfoLocked(info);\n                mProviders.add(provider);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    // Remove widgets for provider that are hosted in userId.\n    private void deleteWidgetsLocked(Provider provider, int userId) {\n        final int N = provider.widgets.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Widget widget = provider.widgets.get(i);\n            if (userId == UserHandle.USER_ALL\n                    || userId == widget.host.getUserId()) {\n                provider.widgets.remove(i);\n                // Call back with empty RemoteViews\n                updateAppWidgetInstanceLocked(widget, null, false);\n                // clear out references to this appWidgetId\n                widget.host.widgets.remove(widget);\n                removeWidgetLocked(widget);\n                widget.provider = null;\n                pruneHostLocked(widget.host);\n                widget.host = null;\n            }\n        }\n    }\n\n    private void deleteProviderLocked(Provider provider) {\n        deleteWidgetsLocked(provider, UserHandle.USER_ALL);\n        mProviders.remove(provider);\n\n        // no need to send the DISABLE broadcast, since the receiver is gone anyway\n        cancelBroadcastsLocked(provider);\n    }\n\n    private void sendEnableIntentLocked(Provider p) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_ENABLED);\n        intent.setComponent(p.id.componentName);\n        sendBroadcastAsUser(intent, p.id.getProfile());\n    }\n\n    private void sendUpdateIntentLocked(Provider provider, int[] appWidgetIds) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    private void sendDeletedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DELETED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void sendDisabledIntentLocked(Provider provider) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_DISABLED);\n        intent.setComponent(provider.id.componentName);\n        sendBroadcastAsUser(intent, provider.id.getProfile());\n    }\n\n    public void sendOptionsChangedIntentLocked(Widget widget) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED);\n        intent.setComponent(widget.provider.id.componentName);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widget.appWidgetId);\n        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, widget.options);\n        sendBroadcastAsUser(intent, widget.provider.id.getProfile());\n    }\n\n    private void registerForBroadcastsLocked(Provider provider, int[] appWidgetIds) {\n        AppWidgetProviderInfo info = provider.getInfoLocked(mContext);\n        if (info.updatePeriodMillis > 0) {\n            // if this is the first instance, set the alarm. otherwise,\n            // rely on the fact that we've already set it and that\n            // PendingIntent.getBroadcast will update the extras.\n            boolean alreadyRegistered = provider.broadcast != null;\n            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);\n            intent.setComponent(info.provider);\n            final long token = Binder.clearCallingIdentity();\n            try {\n                // Broadcast alarms sent by system are immutable\n                provider.broadcast = PendingIntent.getBroadcastAsUser(mContext, 1, intent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                        info.getProfile());\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (!alreadyRegistered) {\n                // Set the alarm outside of our locks; we've latched the first-time\n                // invariant and established the PendingIntent safely.\n                final long period = Math.max(info.updatePeriodMillis, MIN_UPDATE_PERIOD);\n                final PendingIntent broadcast = provider.broadcast;\n                mSaveStateHandler.post(() ->\n                    mAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                            SystemClock.elapsedRealtime() + period, period, broadcast)\n                );\n            }\n        }\n    }\n\n    private static int[] getWidgetIds(ArrayList<Widget> widgets) {\n        int instancesSize = widgets.size();\n        int appWidgetIds[] = new int[instancesSize];\n        for (int i = 0; i < instancesSize; i++) {\n            appWidgetIds[i] = widgets.get(i).appWidgetId;\n        }\n        return appWidgetIds;\n    }\n\n    private static void dumpProviderLocked(Provider provider, int index, PrintWriter pw) {\n        AppWidgetProviderInfo info = provider.getPartialInfoLocked();\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] provider \");\n        pw.println(provider.id);\n        pw.print(\"    min=(\"); pw.print(info.minWidth);\n        pw.print(\"x\"); pw.print(info.minHeight);\n        pw.print(\")   minResize=(\"); pw.print(info.minResizeWidth);\n        pw.print(\"x\"); pw.print(info.minResizeHeight);\n        pw.print(\") updatePeriodMillis=\");\n        pw.print(info.updatePeriodMillis);\n        pw.print(\" resizeMode=\");\n        pw.print(info.resizeMode);\n        pw.print(\" widgetCategory=\");\n        pw.print(info.widgetCategory);\n        pw.print(\" autoAdvanceViewId=\");\n        pw.print(info.autoAdvanceViewId);\n        pw.print(\" initialLayout=#\");\n        pw.print(Integer.toHexString(info.initialLayout));\n        pw.print(\" initialKeyguardLayout=#\");\n        pw.print(Integer.toHexString(info.initialKeyguardLayout));\n        pw.print(\"   zombie=\"); pw.println(provider.zombie);\n    }\n\n    private static void dumpHost(Host host, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] hostId=\");\n        pw.println(host.id);\n        pw.print(\"    callbacks=\"); pw.println(host.callbacks);\n        pw.print(\"    widgets.size=\"); pw.print(host.widgets.size());\n        pw.print(\" zombie=\"); pw.println(host.zombie);\n    }\n\n    private static void dumpGrant(Pair<Integer, String> grant, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(']');\n        pw.print(\" user=\"); pw.print(grant.first);\n        pw.print(\" package=\"); pw.println(grant.second);\n    }\n\n    private static void dumpWidget(Widget widget, int index, PrintWriter pw) {\n        pw.print(\"  [\"); pw.print(index); pw.print(\"] id=\");\n        pw.println(widget.appWidgetId);\n        pw.print(\"    host=\");\n        pw.println(widget.host.id);\n        if (widget.provider != null) {\n            pw.print(\"    provider=\"); pw.println(widget.provider.id);\n        }\n        if (widget.host != null) {\n            pw.print(\"    host.callbacks=\"); pw.println(widget.host.callbacks);\n        }\n        if (widget.views != null) {\n            pw.print(\"    views=\"); pw.println(widget.views);\n        }\n    }\n\n    private static void serializeProvider(TypedXmlSerializer out, Provider p) throws IOException {\n        out.startTag(null, \"p\");\n        out.attribute(null, \"pkg\", p.id.componentName.getPackageName());\n        out.attribute(null, \"cl\", p.id.componentName.getClassName());\n        out.attributeIntHex(null, \"tag\", p.tag);\n        if (!TextUtils.isEmpty(p.infoTag)) {\n            out.attribute(null, \"info_tag\", p.infoTag);\n        }\n        out.endTag(null, \"p\");\n    }\n\n    private static void serializeHost(TypedXmlSerializer out, Host host) throws IOException {\n        out.startTag(null, \"h\");\n        out.attribute(null, \"pkg\", host.id.packageName);\n        out.attributeIntHex(null, \"id\", host.id.hostId);\n        out.attributeIntHex(null, \"tag\", host.tag);\n        out.endTag(null, \"h\");\n    }\n\n    private static void serializeAppWidget(TypedXmlSerializer out, Widget widget,\n            boolean saveRestoreCompleted) throws IOException {\n        out.startTag(null, \"g\");\n        out.attributeIntHex(null, \"id\", widget.appWidgetId);\n        out.attributeIntHex(null, \"rid\", widget.restoredId);\n        out.attributeIntHex(null, \"h\", widget.host.tag);\n        if (widget.provider != null) {\n            out.attributeIntHex(null, \"p\", widget.provider.tag);\n        }\n        if (widget.options != null) {\n            int minWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH);\n            int minHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);\n            int maxWidth = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH);\n            int maxHeight = widget.options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT);\n            out.attributeIntHex(null, \"min_width\", (minWidth > 0) ? minWidth : 0);\n            out.attributeIntHex(null, \"min_height\", (minHeight > 0) ? minHeight : 0);\n            out.attributeIntHex(null, \"max_width\", (maxWidth > 0) ? maxWidth : 0);\n            out.attributeIntHex(null, \"max_height\", (maxHeight > 0) ? maxHeight : 0);\n            out.attributeIntHex(null, \"host_category\", widget.options.getInt(\n                    AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY));\n            if (saveRestoreCompleted) {\n                boolean restoreCompleted = widget.options.getBoolean(\n                        AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED);\n                out.attributeBoolean(null, \"restore_completed\", restoreCompleted);\n            }\n        }\n        out.endTag(null, \"g\");\n    }\n\n    private static Bundle parseWidgetIdOptions(TypedXmlPullParser parser) {\n        Bundle options = new Bundle();\n        boolean restoreCompleted = parser.getAttributeBoolean(null, \"restore_completed\", false);\n        if (restoreCompleted) {\n            options.putBoolean(AppWidgetManager.OPTION_APPWIDGET_RESTORE_COMPLETED, true);\n        }\n        int minWidth = parser.getAttributeIntHex(null, \"min_width\", -1);\n        if (minWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);\n        }\n        int minHeight = parser.getAttributeIntHex(null, \"min_height\", -1);\n        if (minHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);\n        }\n        int maxWidth = parser.getAttributeIntHex(null, \"max_width\", -1);\n        if (maxWidth != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);\n        }\n        int maxHeight = parser.getAttributeIntHex(null, \"max_height\", -1);\n        if (maxHeight != -1) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);\n        }\n        int category = parser.getAttributeIntHex(null, \"host_category\",\n                AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN);\n        if (category != AppWidgetProviderInfo.WIDGET_CATEGORY_UNKNOWN) {\n            options.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, category);\n        }\n        return options;\n    }\n\n    @Override\n    public List<String> getWidgetParticipants(int userId) {\n        return mBackupRestoreController.getWidgetParticipants(userId);\n    }\n\n    @Override\n    public byte[] getWidgetState(String packageName, int userId) {\n        return mBackupRestoreController.getWidgetState(packageName, userId);\n    }\n\n    @Override\n    public void systemRestoreStarting(int userId) {\n        mBackupRestoreController.systemRestoreStarting(userId);\n    }\n\n    @Override\n    public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n        mBackupRestoreController.restoreWidgetState(packageName, restoredState, userId);\n    }\n\n    @Override\n    public void systemRestoreFinished(int userId) {\n        mBackupRestoreController.systemRestoreFinished(userId);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private AppWidgetProviderInfo createPartialProviderInfo(ProviderId providerId, ResolveInfo ri,\n            Provider provider) {\n        boolean hasXmlDefinition = false;\n        Bundle metaData = ri.activityInfo.metaData;\n        if (metaData == null) {\n            return null;\n        }\n\n        if (provider != null && !TextUtils.isEmpty(provider.infoTag)) {\n            hasXmlDefinition = metaData.getInt(provider.infoTag) != 0;\n        }\n        hasXmlDefinition |= metaData.getInt(AppWidgetManager.META_DATA_APPWIDGET_PROVIDER) != 0;\n\n        if (hasXmlDefinition) {\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = ri.activityInfo;\n            return info;\n        }\n        return null;\n    }\n\n    private static AppWidgetProviderInfo parseAppWidgetProviderInfo(Context context,\n            ProviderId providerId, ActivityInfo activityInfo, String metadataKey) {\n        final PackageManager pm = context.getPackageManager();\n        try (XmlResourceParser parser = activityInfo.loadXmlMetaData(pm, metadataKey)) {\n            if (parser == null) {\n                Slog.w(TAG, \"No \" + metadataKey + \" meta-data for AppWidget provider '\"\n                        + providerId + '\\'');\n                return null;\n            }\n\n            AttributeSet attrs = Xml.asAttributeSet(parser);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // drain whitespace, comments, etc.\n            }\n\n            String nodeName = parser.getName();\n            if (!\"appwidget-provider\".equals(nodeName)) {\n                Slog.w(TAG, \"Meta-data does not start with appwidget-provider tag for\"\n                        + \" AppWidget provider \" + providerId.componentName\n                        + \" for user \" + providerId.uid);\n                return null;\n            }\n\n            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n            info.provider = providerId.componentName;\n            info.providerInfo = activityInfo;\n\n            final Resources resources;\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final int userId = UserHandle.getUserId(providerId.uid);\n                final ApplicationInfo app = pm.getApplicationInfoAsUser(activityInfo.packageName,\n                        0, userId);\n                resources = pm.getResourcesForApplication(app);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n\n            TypedArray sa = resources.obtainAttributes(attrs,\n                    com.android.internal.R.styleable.AppWidgetProviderInfo);\n\n            // These dimensions has to be resolved in the application's context.\n            // We simply send back the raw complex data, which will be\n            // converted to dp in {@link AppWidgetManager#getAppWidgetInfo}.\n            TypedValue value = sa\n                    .peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minWidth);\n            info.minWidth = value != null ? value.data : 0;\n            value = sa.peekValue(com.android.internal.R.styleable.AppWidgetProviderInfo_minHeight);\n            info.minHeight = value != null ? value.data : 0;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeWidth);\n            info.minResizeWidth = value != null ? value.data : info.minWidth;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_minResizeHeight);\n            info.minResizeHeight = value != null ? value.data : info.minHeight;\n\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeWidth);\n            info.maxResizeWidth = value != null ? value.data : 0;\n            value = sa.peekValue(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_maxResizeHeight);\n            info.maxResizeHeight = value != null ? value.data : 0;\n\n            info.targetCellWidth = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellWidth, 0);\n            info.targetCellHeight = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_targetCellHeight, 0);\n\n            info.updatePeriodMillis = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_updatePeriodMillis, 0);\n            info.initialLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_initialLayout, ID_NULL);\n            info.initialKeyguardLayout = sa.getResourceId(com.android.internal.R.styleable.\n                    AppWidgetProviderInfo_initialKeyguardLayout, ID_NULL);\n\n            String className = sa\n                    .getString(com.android.internal.R.styleable.AppWidgetProviderInfo_configure);\n            if (className != null) {\n                info.configure = new ComponentName(providerId.componentName.getPackageName(),\n                        className);\n            }\n            info.label = activityInfo.loadLabel(pm).toString();\n            info.icon = activityInfo.getIconResource();\n            info.previewImage = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewImage, ID_NULL);\n            info.previewLayout = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_previewLayout, ID_NULL);\n            info.autoAdvanceViewId = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_autoAdvanceViewId,\n                    View.NO_ID);\n            info.resizeMode = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_resizeMode,\n                    AppWidgetProviderInfo.RESIZE_NONE);\n            info.widgetCategory = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetCategory,\n                    AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);\n            info.widgetFeatures = sa.getInt(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_widgetFeatures, 0);\n            info.descriptionRes = sa.getResourceId(\n                    com.android.internal.R.styleable.AppWidgetProviderInfo_description, ID_NULL);\n            sa.recycle();\n            return info;\n        } catch (IOException | PackageManager.NameNotFoundException | XmlPullParserException e) {\n            // Ok to catch Exception here, because anything going wrong because\n            // of what a client process passes to us should not be fatal for the\n            // system process.\n            Slog.w(TAG, \"XML parsing failed for AppWidget provider \"\n                    + providerId.componentName + \" for user \" + providerId.uid, e);\n            return null;\n        }\n    }\n\n    private int getUidForPackage(String packageName, int userId) {\n        PackageInfo pkgInfo = null;\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            pkgInfo = mPackageManager.getPackageInfo(packageName, 0, userId);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local call\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n\n        if (pkgInfo == null || pkgInfo.applicationInfo == null) {\n            return -1;\n        }\n\n        return pkgInfo.applicationInfo.uid;\n    }\n\n    private ActivityInfo getProviderInfo(ComponentName componentName, int userId) {\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setComponent(componentName);\n\n        List<ResolveInfo> receivers = queryIntentReceivers(intent, userId);\n        // We are setting component, so there is only one or none.\n        if (!receivers.isEmpty()) {\n            return receivers.get(0).activityInfo;\n        }\n\n        return null;\n    }\n\n    private List<ResolveInfo> queryIntentReceivers(Intent intent, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            int flags = PackageManager.GET_META_DATA;\n\n            // We really need packages to be around and parsed to know if they\n            // provide widgets.\n            flags |= PackageManager.MATCH_DEBUG_TRIAGED_MISSING;\n\n            // Widget hosts that are non-crypto aware may be hosting widgets\n            // from a profile that is still locked, so let them see those\n            // widgets.\n            if (isProfileWithUnlockedParent(userId)) {\n                flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE\n                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;\n            }\n\n            // Widgets referencing shared libraries need to have their\n            // dependencies loaded.\n            flags |= PackageManager.GET_SHARED_LIBRARY_FILES;\n\n            return mPackageManager.queryIntentReceivers(intent,\n                    intent.resolveTypeIfNeeded(mContext.getContentResolver()),\n                    flags, userId).getList();\n        } catch (RemoteException re) {\n            return Collections.emptyList();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    /**\n     * This does not use the usual onUserUnlocked() listener mechanism because it is\n     * invoked at a choreographed point in the middle of the user unlock sequence,\n     * before the boot-completed broadcast is issued and the listeners notified.\n     */\n    void handleUserUnlocked(int userId) {\n        if (isProfileWithLockedParent(userId)) {\n            return;\n        }\n        if (!mUserManager.isUserUnlockingOrUnlocked(userId)) {\n            Slog.w(TAG, \"User \" + userId + \" is no longer unlocked - exiting\");\n            return;\n        }\n        long time = SystemClock.elapsedRealtime();\n        synchronized (mLock) {\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget ensure\");\n            ensureGroupStateLoadedLocked(userId);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"appwidget reload\");\n            reloadWidgetsMaskedStateForGroup(mSecurityPolicy.getGroupParent(userId));\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n\n                // Send broadcast only to the providers of the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n\n                if (provider.widgets.size() > 0) {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,\n                            \"appwidget init \" + provider.id.componentName.getPackageName());\n                    sendEnableIntentLocked(provider);\n                    int[] appWidgetIds = getWidgetIds(provider.widgets);\n                    sendUpdateIntentLocked(provider, appWidgetIds);\n                    registerForBroadcastsLocked(provider, appWidgetIds);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                }\n            }\n        }\n        Slog.i(TAG, \"Processing of handleUserUnlocked u\" + userId + \" took \"\n                + (SystemClock.elapsedRealtime() - time) + \" ms\");\n    }\n\n    // only call from initialization -- it assumes that the data structures are all empty\n    private void loadGroupStateLocked(int[] profileIds) {\n        // We can bind the widgets to host and providers only after\n        // reading the host and providers for all users since a widget\n        // can have a host and a provider in different users.\n        List<LoadedWidgetState> loadedWidgets = new ArrayList<>();\n\n        int version = 0;\n\n        final int profileIdCount = profileIds.length;\n        for (int i = 0; i < profileIdCount; i++) {\n            final int profileId = profileIds[i];\n\n            // No file written for this user - nothing to do.\n            AtomicFile file = getSavedStateFile(profileId);\n            try (FileInputStream stream = file.openRead()) {\n                version = readProfileStateFromFileLocked(stream, profileId, loadedWidgets);\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed to read state: \" + e);\n            }\n        }\n\n        if (version >= 0) {\n            // Hooke'm up...\n            bindLoadedWidgetsLocked(loadedWidgets);\n\n            // upgrade the database if needed\n            performUpgradeLocked(version);\n        } else {\n            // failed reading, clean up\n            Slog.w(TAG, \"Failed to read state, clearing widgets and hosts.\");\n            clearWidgetsLocked();\n            mHosts.clear();\n            final int N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                mProviders.get(i).widgets.clear();\n            }\n        }\n    }\n\n    private void bindLoadedWidgetsLocked(List<LoadedWidgetState> loadedWidgets) {\n        final int loadedWidgetCount = loadedWidgets.size();\n        for (int i = loadedWidgetCount - 1; i >= 0; i--) {\n            LoadedWidgetState loadedWidget = loadedWidgets.remove(i);\n            Widget widget = loadedWidget.widget;\n\n            widget.provider = findProviderByTag(loadedWidget.providerTag);\n            if (widget.provider == null) {\n                // This provider is gone. We just let the host figure out\n                // that this happened when it fails to load it.\n                continue;\n            }\n\n            widget.host = findHostByTag(loadedWidget.hostTag);\n            if (widget.host == null) {\n                // This host is gone.\n                continue;\n            }\n\n            widget.provider.widgets.add(widget);\n            widget.host.widgets.add(widget);\n            addWidgetLocked(widget);\n        }\n    }\n\n    private Provider findProviderByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.tag == tag) {\n                return provider;\n            }\n        }\n        return null;\n    }\n\n    private Host findHostByTag(int tag) {\n        if (tag < 0) {\n            return null;\n        }\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            if (host.tag == tag) {\n                return host;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds the widget to mWidgets and tracks the package name in mWidgetPackages.\n     */\n    void addWidgetLocked(Widget widget) {\n        ensureWidgetCountBeforeAddLocked(widget);\n        mWidgets.add(widget);\n\n        onWidgetProviderAddedOrChangedLocked(widget);\n    }\n\n    /**\n     * Ensures that the widget count for the widget's host is not greater than the maximum\n     * number of widgets per host. If the count is greater than the maximum, removes oldest widgets\n     * from the host until the count is less than or equal to the maximum.\n     */\n    private void ensureWidgetCountBeforeAddLocked(Widget widget) {\n        if (widget.host == null || widget.host.id == null) {\n            return;\n        }\n        final List<Widget> widgetsInSameHost = new ArrayList<>();\n        for (Widget w : mWidgets) {\n            if (w.host != null && widget.host.id.equals(w.host.id)) {\n                widgetsInSameHost.add(w);\n            }\n        }\n        while (widgetsInSameHost.size() >= MAX_NUMBER_OF_WIDGETS_PER_HOST) {\n            removeWidgetLocked(widgetsInSameHost.remove(0));\n        }\n    }\n\n    /**\n     * Checks if the provider is assigned and updates the mWidgetPackages to track packages\n     * that have bound widgets.\n     */\n    void onWidgetProviderAddedOrChangedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        int userId = widget.provider.getUserId();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                mWidgetPackages.put(userId, packages = new ArraySet<String>());\n            }\n            packages.add(widget.provider.id.componentName.getPackageName());\n        }\n\n        // If we are adding a widget it might be for a provider that\n        // is currently masked, if so mask the widget.\n        if (widget.provider.isMaskedLocked()) {\n            maskWidgetsViewsLocked(widget.provider, widget);\n        } else {\n            widget.clearMaskedViewsLocked();\n        }\n    }\n\n    /**\n     * Removes a widget from mWidgets and updates the cache of bound widget provider packages.\n     * If there are other widgets with the same package, leaves it in the cache, otherwise it\n     * removes the associated package from the cache.\n     */\n    void removeWidgetLocked(Widget widget) {\n        mWidgets.remove(widget);\n        onWidgetRemovedLocked(widget);\n        scheduleNotifyAppWidgetRemovedLocked(widget);\n    }\n\n    private void onWidgetRemovedLocked(Widget widget) {\n        if (widget.provider == null) return;\n\n        final int userId = widget.provider.getUserId();\n        final String packageName = widget.provider.id.componentName.getPackageName();\n        synchronized (mWidgetPackagesLock) {\n            ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages == null) {\n                return;\n            }\n            // Check if there is any other widget with the same package name.\n            // Remove packageName if none.\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget w = mWidgets.get(i);\n                if (w.provider == null) continue;\n                if (w.provider.getUserId() == userId\n                        && packageName.equals(w.provider.id.componentName.getPackageName())) {\n                    return;\n                }\n            }\n            packages.remove(packageName);\n        }\n    }\n\n    /**\n     * Clears all widgets and associated cache of packages with bound widgets.\n     */\n    void clearWidgetsLocked() {\n        mWidgets.clear();\n\n        onWidgetsClearedLocked();\n    }\n\n    private void onWidgetsClearedLocked() {\n        synchronized (mWidgetPackagesLock) {\n            mWidgetPackages.clear();\n        }\n    }\n\n    @Override\n    public boolean isBoundWidgetPackage(String packageName, int userId) {\n        if (Binder.getCallingUid() != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Only the system process can call this\");\n        }\n        synchronized (mWidgetPackagesLock) {\n            final ArraySet<String> packages = mWidgetPackages.get(userId);\n            if (packages != null) {\n                return packages.contains(packageName);\n            }\n        }\n        return false;\n    }\n\n    private void saveStateLocked(int userId) {\n        tagProvidersAndHosts();\n\n        final int[] profileIds = mSecurityPolicy.getEnabledGroupProfileIds(userId);\n\n        final int profileCount = profileIds.length;\n        for (int i = 0; i < profileCount; i++) {\n            final int profileId = profileIds[i];\n\n            AtomicFile file = getSavedStateFile(profileId);\n            FileOutputStream stream;\n            try {\n                stream = file.startWrite();\n                if (writeProfileStateToFileLocked(stream, profileId)) {\n                    file.finishWrite(stream);\n                } else {\n                    file.failWrite(stream);\n                    Slog.w(TAG, \"Failed to save state, restoring backup.\");\n                }\n            } catch (IOException e) {\n                Slog.w(TAG, \"Failed open state file for write: \" + e);\n            }\n        }\n    }\n\n    private void tagProvidersAndHosts() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = i;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = i;\n        }\n    }\n\n    private void clearProvidersAndHostsTagsLocked() {\n        final int providerCount = mProviders.size();\n        for (int i = 0; i < providerCount; i++) {\n            Provider provider = mProviders.get(i);\n            provider.tag = TAG_UNDEFINED;\n        }\n\n        final int hostCount = mHosts.size();\n        for (int i = 0; i < hostCount; i++) {\n            Host host = mHosts.get(i);\n            host.tag = TAG_UNDEFINED;\n        }\n    }\n\n    private boolean writeProfileStateToFileLocked(FileOutputStream stream, int userId) {\n        int N;\n\n        try {\n            TypedXmlSerializer out = Xml.resolveSerializer(stream);\n            out.startDocument(null, true);\n            out.startTag(null, \"gs\");\n            out.attributeInt(null, \"version\", CURRENT_VERSION);\n\n            N = mProviders.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = mProviders.get(i);\n                // Save only providers for the user.\n                if (provider.getUserId() != userId) {\n                    continue;\n                }\n                if (provider.shouldBePersisted()) {\n                    serializeProvider(out, provider);\n                }\n            }\n\n            N = mHosts.size();\n            for (int i = 0; i < N; i++) {\n                Host host = mHosts.get(i);\n                // Save only hosts for the user.\n                if (host.getUserId() != userId) {\n                    continue;\n                }\n                serializeHost(out, host);\n            }\n\n            N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                // Save only widgets hosted by the user.\n                if (widget.host.getUserId() != userId) {\n                    continue;\n                }\n                serializeAppWidget(out, widget, true);\n            }\n\n            Iterator<Pair<Integer, String>> it = mPackagesWithBindWidgetPermission.iterator();\n            while (it.hasNext()) {\n                Pair<Integer, String> binding = it.next();\n                // Save only white listings for the user.\n                if (binding.first != userId) {\n                    continue;\n                }\n                out.startTag(null, \"b\");\n                out.attribute(null, \"packageName\", binding.second);\n                out.endTag(null, \"b\");\n            }\n\n            out.endTag(null, \"gs\");\n            out.endDocument();\n            return true;\n        } catch (IOException e) {\n            Slog.w(TAG, \"Failed to write state: \" + e);\n            return false;\n        }\n    }\n\n    private int readProfileStateFromFileLocked(FileInputStream stream, int userId,\n            List<LoadedWidgetState> outLoadedWidgets) {\n        int version = -1;\n        try {\n            TypedXmlPullParser parser = Xml.resolvePullParser(stream);\n\n            int legacyProviderIndex = -1;\n            int legacyHostIndex = -1;\n            int type;\n            do {\n                type = parser.next();\n                if (type == XmlPullParser.START_TAG) {\n                    String tag = parser.getName();\n                    if (\"gs\".equals(tag)) {\n                        version = parser.getAttributeInt(null, \"version\", 0);\n                    } else if (\"p\".equals(tag)) {\n                        legacyProviderIndex++;\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n                        String cl = parser.getAttributeValue(null, \"cl\");\n\n                        pkg = getCanonicalPackageName(pkg, cl, userId);\n                        if (pkg == null) {\n                            continue;\n                        }\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            continue;\n                        }\n\n                        ComponentName componentName = new ComponentName(pkg, cl);\n\n                        ActivityInfo providerInfo = getProviderInfo(componentName, userId);\n                        if (providerInfo == null) {\n                            continue;\n                        }\n\n                        ProviderId providerId = new ProviderId(uid, componentName);\n                        Provider provider = lookupProviderLocked(providerId);\n\n                        if (provider == null && mSafeMode) {\n                            // if we're in safe mode, make a temporary one\n                            AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                            info.provider = providerId.componentName;\n                            info.providerInfo = providerInfo;\n\n                            provider = new Provider();\n                            provider.setPartialInfoLocked(info);\n                            provider.zombie = true;\n                            provider.id = providerId;\n                            mProviders.add(provider);\n                        }\n\n                        final int providerTag = parser.getAttributeIntHex(null, \"tag\",\n                                legacyProviderIndex);\n                        provider.tag = providerTag;\n                        provider.infoTag = parser.getAttributeValue(null, \"info_tag\");\n                    } else if (\"h\".equals(tag)) {\n                        legacyHostIndex++;\n                        Host host = new Host();\n                        // TODO: do we need to check that this package has the same signature\n                        // as before?\n                        String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                        final int uid = getUidForPackage(pkg, userId);\n                        if (uid < 0) {\n                            host.zombie = true;\n                        }\n\n                        if (!host.zombie || mSafeMode) {\n                            // In safe mode, we don't discard the hosts we don't recognize\n                            // so that they're not pruned from our list. Otherwise, we do.\n                            final int hostId = parser.getAttributeIntHex(null, \"id\");\n                            final int hostTag = parser.getAttributeIntHex(null, \"tag\",\n                                    legacyHostIndex);\n\n                            host.tag = hostTag;\n                            host.id = new HostId(uid, hostId, pkg);\n                            mHosts.add(host);\n                        }\n                    } else if (\"b\".equals(tag)) {\n                        String packageName = parser.getAttributeValue(null, \"packageName\");\n                        final int uid = getUidForPackage(packageName, userId);\n                        if (uid >= 0) {\n                            Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                            mPackagesWithBindWidgetPermission.add(packageId);\n                        }\n                    } else if (\"g\".equals(tag)) {\n                        Widget widget = new Widget();\n                        widget.appWidgetId = parser.getAttributeIntHex(null, \"id\");\n                        setMinAppWidgetIdLocked(userId, widget.appWidgetId + 1);\n\n                        // restored ID is allowed to be absent\n                        widget.restoredId = parser.getAttributeIntHex(null, \"rid\", 0);\n                        widget.options = parseWidgetIdOptions(parser);\n\n                        final int hostTag = parser.getAttributeIntHex(null, \"h\");\n                        String providerString = parser.getAttributeValue(null, \"p\");\n                        final int providerTag = (providerString != null)\n                                ? parser.getAttributeIntHex(null, \"p\") : TAG_UNDEFINED;\n\n                        // We can match widgets with hosts and providers only after hosts\n                        // and providers for all users have been loaded since the widget\n                        // host and provider can be in different user profiles.\n                        LoadedWidgetState loadedWidgets = new LoadedWidgetState(widget,\n                                hostTag, providerTag);\n                        outLoadedWidgets.add(loadedWidgets);\n                    }\n                }\n            } while (type != XmlPullParser.END_DOCUMENT);\n        } catch (NullPointerException\n                | NumberFormatException\n                | XmlPullParserException\n                | IOException\n                | IndexOutOfBoundsException e) {\n            Slog.w(TAG, \"failed parsing \" + e);\n            return -1;\n        }\n\n        return version;\n    }\n\n    private void performUpgradeLocked(int fromVersion) {\n        if (fromVersion < CURRENT_VERSION) {\n            Slog.v(TAG, \"Upgrading widget database from \" + fromVersion + \" to \"\n                    + CURRENT_VERSION);\n        }\n\n        int version = fromVersion;\n\n        // Update 1: keyguard moved from package \"android\" to \"com.android.keyguard\"\n        if (version == 0) {\n            HostId oldHostId = new HostId(Process.myUid(),\n                    KEYGUARD_HOST_ID, OLD_KEYGUARD_HOST_PACKAGE);\n\n            Host host = lookupHostLocked(oldHostId);\n            if (host != null) {\n                final int uid = getUidForPackage(NEW_KEYGUARD_HOST_PACKAGE,\n                        UserHandle.USER_SYSTEM);\n                if (uid >= 0) {\n                    host.id = new HostId(uid, KEYGUARD_HOST_ID, NEW_KEYGUARD_HOST_PACKAGE);\n                }\n            }\n\n            version = 1;\n        }\n\n        if (version != CURRENT_VERSION) {\n            throw new IllegalStateException(\"Failed to upgrade widget database\");\n        }\n    }\n\n    private static File getStateFile(int userId) {\n        return new File(Environment.getUserSystemDirectory(userId), STATE_FILENAME);\n    }\n\n    private static AtomicFile getSavedStateFile(int userId) {\n        File dir = Environment.getUserSystemDirectory(userId);\n        File settingsFile = getStateFile(userId);\n        if (!settingsFile.exists() && userId == UserHandle.USER_SYSTEM) {\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            // Migrate old data\n            File oldFile = new File(\"/data/system/\" + STATE_FILENAME);\n            // Method doesn't throw an exception on failure. Ignore any errors\n            // in moving the file (like non-existence)\n            oldFile.renameTo(settingsFile);\n        }\n        return new AtomicFile(settingsFile);\n    }\n\n    void onUserStopped(int userId) {\n        synchronized (mLock) {\n            boolean crossProfileWidgetsChanged = false;\n\n            // Remove widgets that have both host and provider in the user.\n            final int widgetCount = mWidgets.size();\n            for (int i = widgetCount - 1; i >= 0; i--) {\n                Widget widget = mWidgets.get(i);\n\n                final boolean hostInUser = widget.host.getUserId() == userId;\n                final boolean hasProvider = widget.provider != null;\n                final boolean providerInUser = hasProvider && widget.provider.getUserId() == userId;\n\n                // If both host and provider are in the user, just drop the widgets\n                // as we do not want to make host callbacks and provider broadcasts\n                // as the host and the provider will be killed.\n                if (hostInUser && (!hasProvider || providerInUser)) {\n                    removeWidgetLocked(widget);\n                    widget.host.widgets.remove(widget);\n                    widget.host = null;\n                    if (hasProvider) {\n                        widget.provider.widgets.remove(widget);\n                        widget.provider = null;\n                    }\n                }\n            }\n\n            // Remove hosts and notify providers in other profiles.\n            final int hostCount = mHosts.size();\n            for (int i = hostCount - 1; i >= 0; i--) {\n                Host host = mHosts.get(i);\n                if (host.getUserId() == userId) {\n                    crossProfileWidgetsChanged |= !host.widgets.isEmpty();\n                    deleteHostLocked(host);\n                }\n            }\n\n            // Leave the providers present as hosts will show the widgets\n            // masked while the user is stopped.\n\n            // Remove grants for this user.\n            final int grantCount = mPackagesWithBindWidgetPermission.size();\n            for (int i = grantCount - 1; i >= 0; i--) {\n                Pair<Integer, String> packageId = mPackagesWithBindWidgetPermission.valueAt(i);\n                if (packageId.first == userId) {\n                    mPackagesWithBindWidgetPermission.removeAt(i);\n                }\n            }\n\n            // Take a note we no longer have state for this user.\n            final int userIndex = mLoadedUserIds.indexOfKey(userId);\n            if (userIndex >= 0) {\n                mLoadedUserIds.removeAt(userIndex);\n            }\n\n            // Remove the widget id counter.\n            final int nextIdIndex = mNextAppWidgetIds.indexOfKey(userId);\n            if (nextIdIndex >= 0) {\n                mNextAppWidgetIds.removeAt(nextIdIndex);\n            }\n\n            // Save state if removing a profile changed the group state.\n            // Nothing will be saved if the group parent was removed.\n            if (crossProfileWidgetsChanged) {\n                saveGroupStateAsync(userId);\n            }\n        }\n    }\n\n    private void applyResourceOverlaysToWidgetsLocked(Set<String> packageNames, int userId,\n            boolean updateFrameworkRes) {\n        for (int i = 0, N = mProviders.size(); i < N; i++) {\n            Provider provider = mProviders.get(i);\n            if (provider.getUserId() != userId) {\n                continue;\n            }\n\n            final String packageName = provider.id.componentName.getPackageName();\n            if (!updateFrameworkRes && !packageNames.contains(packageName)) {\n                continue;\n            }\n\n            ApplicationInfo newAppInfo = null;\n            try {\n                newAppInfo = mPackageManager.getApplicationInfo(packageName,\n                        PackageManager.GET_SHARED_LIBRARY_FILES, userId);\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Failed to retrieve app info for \" + packageName\n                        + \" userId=\" + userId, e);\n            }\n            if (newAppInfo == null || provider.info == null\n                    || provider.info.providerInfo == null) {\n                continue;\n            }\n            ApplicationInfo oldAppInfo = provider.info.providerInfo.applicationInfo;\n            if (oldAppInfo == null || !newAppInfo.sourceDir.equals(oldAppInfo.sourceDir)) {\n                // Overlay paths are generated against a particular version of an application.\n                // The overlays paths of a newly upgraded application are incompatible with the\n                // old version of the application.\n                continue;\n            }\n\n            // Isolate the changes relating to RROs. The app info must be copied to prevent\n            // affecting other parts of system server that may have cached this app info.\n            oldAppInfo = new ApplicationInfo(oldAppInfo);\n            oldAppInfo.overlayPaths = newAppInfo.overlayPaths.clone();\n            oldAppInfo.resourceDirs = newAppInfo.resourceDirs.clone();\n            provider.info.providerInfo.applicationInfo = oldAppInfo;\n\n            for (int j = 0, M = provider.widgets.size(); j < M; j++) {\n                Widget widget = provider.widgets.get(j);\n                if (widget.views != null) {\n                    widget.views.updateAppInfo(oldAppInfo);\n                }\n                if (widget.maskedViews != null) {\n                    widget.maskedViews.updateAppInfo(oldAppInfo);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates all providers with the specified package names, and records any providers that were\n     * pruned.\n     *\n     * @return whether any providers were updated\n     */\n    private boolean updateProvidersForPackageLocked(String packageName, int userId,\n            Set<ProviderId> removedProviders) {\n        boolean providersUpdated = false;\n\n        HashSet<ProviderId> keep = new HashSet<>();\n        Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);\n        intent.setPackage(packageName);\n        List<ResolveInfo> broadcastReceivers = queryIntentReceivers(intent, userId);\n\n        // add the missing ones and collect which ones to keep\n        int N = broadcastReceivers == null ? 0 : broadcastReceivers.size();\n        for (int i = 0; i < N; i++) {\n            ResolveInfo ri = broadcastReceivers.get(i);\n            ActivityInfo ai = ri.activityInfo;\n\n            if ((ai.applicationInfo.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {\n                continue;\n            }\n\n            if (packageName.equals(ai.packageName)) {\n                ProviderId providerId = new ProviderId(ai.applicationInfo.uid,\n                        new ComponentName(ai.packageName, ai.name));\n\n                Provider provider = lookupProviderLocked(providerId);\n                if (provider == null) {\n                    if (addProviderLocked(ri)) {\n                        keep.add(providerId);\n                        providersUpdated = true;\n                    }\n                } else {\n                    AppWidgetProviderInfo info =\n                            createPartialProviderInfo(providerId, ri, provider);\n                    if (info != null) {\n                        keep.add(providerId);\n                        // Use the new AppWidgetProviderInfo.\n                        provider.setPartialInfoLocked(info);\n                        // If it's enabled\n                        final int M = provider.widgets.size();\n                        if (M > 0) {\n                            int[] appWidgetIds = getWidgetIds(provider.widgets);\n                            // Reschedule for the new updatePeriodMillis (don't worry about handling\n                            // it specially if updatePeriodMillis didn't change because we just sent\n                            // an update, and the next one will be updatePeriodMillis from now).\n                            cancelBroadcastsLocked(provider);\n                            registerForBroadcastsLocked(provider, appWidgetIds);\n                            // If it's currently showing, call back with the new\n                            // AppWidgetProviderInfo.\n                            for (int j = 0; j < M; j++) {\n                                Widget widget = provider.widgets.get(j);\n                                widget.views = null;\n                                scheduleNotifyProviderChangedLocked(widget);\n                            }\n                            // Now that we've told the host, push out an update.\n                            sendUpdateIntentLocked(provider, appWidgetIds);\n                        }\n                    }\n                    providersUpdated = true;\n                }\n            }\n        }\n\n        // prune the ones we don't want to keep\n        N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (packageName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && !keep.contains(provider.id)) {\n                if (removedProviders != null) {\n                    removedProviders.add(provider.id);\n                }\n                deleteProviderLocked(provider);\n                providersUpdated = true;\n            }\n        }\n\n        return providersUpdated;\n    }\n\n    // Remove widgets for provider in userId that are hosted in parentUserId\n    private void removeWidgetsForPackageLocked(String pkgName, int userId, int parentUserId) {\n        final int N = mProviders.size();\n        for (int i = 0; i < N; ++i) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId\n                    && provider.widgets.size() > 0) {\n                deleteWidgetsLocked(provider, parentUserId);\n            }\n        }\n    }\n\n    private boolean removeProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = false;\n\n        final int N = mProviders.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Provider provider = mProviders.get(i);\n            if (pkgName.equals(provider.id.componentName.getPackageName())\n                    && provider.getUserId() == userId) {\n                deleteProviderLocked(provider);\n                removed = true;\n            }\n        }\n        return removed;\n    }\n\n    private boolean removeHostsAndProvidersForPackageLocked(String pkgName, int userId) {\n        boolean removed = removeProvidersForPackageLocked(pkgName, userId);\n\n        // Delete the hosts for this package too\n        // By now, we have removed any AppWidgets that were in any hosts here,\n        // so we don't need to worry about sending DISABLE broadcasts to them.\n        final int N = mHosts.size();\n        for (int i = N - 1; i >= 0; i--) {\n            Host host = mHosts.get(i);\n            if (pkgName.equals(host.id.packageName)\n                    && host.getUserId() == userId) {\n                deleteHostLocked(host);\n                removed = true;\n            }\n        }\n\n        return removed;\n    }\n\n    private String getCanonicalPackageName(String packageName, String className, int userId) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            try {\n                AppGlobals.getPackageManager().getReceiverInfo(new ComponentName(packageName,\n                        className), 0, userId);\n                return packageName;\n            } catch (RemoteException re) {\n                String[] packageNames = mContext.getPackageManager()\n                        .currentToCanonicalPackageNames(new String[]{packageName});\n                if (packageNames != null && packageNames.length > 0) {\n                    return packageNames[0];\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return null;\n    }\n\n    private void sendBroadcastAsUser(Intent intent, UserHandle userHandle) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            mContext.sendBroadcastAsUser(intent, userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private void bindService(Intent intent, ServiceConnection connection,\n            UserHandle userHandle) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.bindServiceAsUser(intent, connection,\n                    Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,\n                    userHandle);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void unbindService(ServiceConnection connection) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            mContext.unbindService(connection);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void onCrossProfileWidgetProvidersChanged(int userId, List<String> packages) {\n        final int parentId = mSecurityPolicy.getProfileParent(userId);\n        // We care only if the allowlisted package is in a profile of\n        // the group parent as only the parent can add widgets from the\n        // profile and not the other way around.\n        if (parentId != userId) {\n            synchronized (mLock) {\n                boolean providersChanged = false;\n\n                ArraySet<String> previousPackages = new ArraySet<String>();\n                final int providerCount = mProviders.size();\n                for (int i = 0; i < providerCount; ++i) {\n                    Provider provider = mProviders.get(i);\n                    if (provider.getUserId() == userId) {\n                        previousPackages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n\n                final int packageCount = packages.size();\n                for (int i = 0; i < packageCount; i++) {\n                    String packageName = packages.get(i);\n                    previousPackages.remove(packageName);\n                    providersChanged |= updateProvidersForPackageLocked(packageName,\n                            userId, null);\n                }\n\n                // Remove widgets from hosts in parent user for packages not in the allowlist\n                final int removedCount = previousPackages.size();\n                for (int i = 0; i < removedCount; ++i) {\n                    removeWidgetsForPackageLocked(previousPackages.valueAt(i),\n                            userId, parentId);\n                }\n\n                if (providersChanged || removedCount > 0) {\n                    saveGroupStateAsync(userId);\n                    scheduleNotifyGroupHostsForProvidersChangedLocked(userId);\n                }\n            }\n        }\n    }\n\n    private boolean isProfileWithLockedParent(int userId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            UserInfo userInfo = mUserManager.getUserInfo(userId);\n            if (userInfo != null && userInfo.isProfile()) {\n                UserInfo parentInfo = mUserManager.getProfileParent(userId);\n                if (parentInfo != null\n                        && !isUserRunningAndUnlocked(parentInfo.getUserHandle().getIdentifier())) {\n                    return true;\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return false;\n    }\n\n    private boolean isProfileWithUnlockedParent(int userId) {\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        if (userInfo != null && userInfo.isProfile()) {\n            UserInfo parentInfo = mUserManager.getProfileParent(userId);\n            if (parentInfo != null\n                    && mUserManager.isUserUnlockingOrUnlocked(parentInfo.getUserHandle())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Note an app widget is tapped on. If a app widget is tapped, the underlying app is treated as\n     * foreground so the app can get while-in-use permission.\n     *\n     * @param callingPackage calling app's packageName.\n     * @param appWidgetId App widget id.\n     */\n    @Override\n    public void noteAppWidgetTapped(String callingPackage, int appWidgetId) {\n        mSecurityPolicy.enforceCallFromPackage(callingPackage);\n        final int callingUid = Binder.getCallingUid();\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            // The launcher must be at TOP.\n            final int procState = mActivityManagerInternal.getUidProcessState(callingUid);\n            if (procState > ActivityManager.PROCESS_STATE_TOP) {\n                return;\n            }\n            synchronized (mLock) {\n                final Widget widget = lookupWidgetLocked(appWidgetId, callingUid, callingPackage);\n                if (widget == null) {\n                    return;\n                }\n                final ProviderId providerId = widget.provider.id;\n                final String packageName = providerId.componentName.getPackageName();\n                if (packageName == null) {\n                    return;\n                }\n                final SparseArray<String> uid2PackageName = new SparseArray<String>();\n                uid2PackageName.put(providerId.uid, packageName);\n                mAppOpsManagerInternal.updateAppWidgetVisibility(uid2PackageName, true);\n                mUsageStatsManagerInternal.reportEvent(packageName,\n                        UserHandle.getUserId(providerId.uid), UsageEvents.Event.USER_INTERACTION);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }\n\n    private final class CallbackHandler extends Handler {\n        public static final int MSG_NOTIFY_UPDATE_APP_WIDGET = 1;\n        public static final int MSG_NOTIFY_PROVIDER_CHANGED = 2;\n        public static final int MSG_NOTIFY_PROVIDERS_CHANGED = 3;\n        public static final int MSG_NOTIFY_VIEW_DATA_CHANGED = 4;\n        public static final int MSG_NOTIFY_APP_WIDGET_REMOVED = 5;\n\n        public CallbackHandler(Looper looper) {\n            super(looper, null, false);\n        }\n\n        @Override\n        public void handleMessage(Message message) {\n            switch (message.what) {\n                case MSG_NOTIFY_UPDATE_APP_WIDGET: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    RemoteViews views = (RemoteViews) args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDER_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    AppWidgetProviderInfo info = (AppWidgetProviderInfo)args.arg3;\n                    long requestId = (Long) args.arg4;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n\n                    handleNotifyProviderChanged(host, callbacks, appWidgetId, info, requestId);\n                } break;\n\n                case MSG_NOTIFY_APP_WIDGET_REMOVED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    args.recycle();\n                    handleNotifyAppWidgetRemoved(host, callbacks, appWidgetId, requestId);\n                } break;\n\n                case MSG_NOTIFY_PROVIDERS_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    args.recycle();\n\n                    handleNotifyProvidersChanged(host, callbacks);\n                } break;\n\n                case MSG_NOTIFY_VIEW_DATA_CHANGED: {\n                    SomeArgs args = (SomeArgs) message.obj;\n                    Host host = (Host) args.arg1;\n                    IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;\n                    long requestId = (Long) args.arg3;\n                    final int appWidgetId = args.argi1;\n                    final int viewId = args.argi2;\n                    args.recycle();\n\n                    handleNotifyAppWidgetViewDataChanged(host, callbacks, appWidgetId, viewId,\n                            requestId);\n                } break;\n            }\n        }\n    }\n\n    private final class SecurityPolicy {\n\n        public boolean isEnabledGroupProfile(int profileId) {\n            final int parentId = UserHandle.getCallingUserId();\n            return isParentOrProfile(parentId, profileId) && isProfileEnabled(profileId);\n        }\n\n        public int[] getEnabledGroupProfileIds(int userId) {\n            final int parentId = getGroupParent(userId);\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mUserManager.getEnabledProfileIds(parentId);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceServiceExistsAndRequiresBindRemoteViewsPermission(\n                ComponentName componentName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                ServiceInfo serviceInfo = mPackageManager.getServiceInfo(componentName,\n                        PackageManager.GET_PERMISSIONS, userId);\n                if (serviceInfo == null) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" not installed for user \" + userId);\n                }\n                if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(serviceInfo.permission)) {\n                    throw new SecurityException(\"Service \" + componentName\n                            + \" in user \" + userId + \"does not require \"\n                            + android.Manifest.permission.BIND_REMOTEVIEWS);\n                }\n            } catch (RemoteException re) {\n                // Local call - shouldn't happen.\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n\n        public void enforceModifyAppWidgetBindPermissions(String packageName) {\n            mContext.enforceCallingPermission(\n                    android.Manifest.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS,\n                    \"hasBindAppWidgetPermission packageName=\" + packageName);\n        }\n\n        public boolean isCallerInstantAppLocked() {\n            final int callingUid =  Binder.getCallingUid();\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                final String[] uidPackages = mPackageManager.getPackagesForUid(callingUid);\n                if (!ArrayUtils.isEmpty(uidPackages)) {\n                    return mPackageManager.isInstantApp(uidPackages[0],\n                            UserHandle.getUserId(callingUid));\n                }\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public boolean isInstantAppLocked(String packageName, int userId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                return mPackageManager.isInstantApp(packageName, userId);\n            } catch (RemoteException e) {\n                /* ignore - same process */\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return false;\n        }\n\n        public void enforceCallFromPackage(String packageName) {\n            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);\n        }\n\n        public boolean hasCallerBindPermissionOrBindWhiteListedLocked(String packageName) {\n            try {\n                mContext.enforceCallingOrSelfPermission(\n                        android.Manifest.permission.BIND_APPWIDGET, null);\n            } catch (SecurityException se) {\n                if (!isCallerBindAppWidgetWhiteListedLocked(packageName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean isCallerBindAppWidgetWhiteListedLocked(String packageName) {\n            final int userId = UserHandle.getCallingUserId();\n            final int packageUid = getUidForPackage(packageName, userId);\n            if (packageUid < 0) {\n                throw new IllegalArgumentException(\"No package \" + packageName\n                        + \" for user \" + userId);\n            }\n            synchronized (mLock) {\n                ensureGroupStateLoadedLocked(userId);\n\n                Pair<Integer, String> packageId = Pair.create(userId, packageName);\n                if (mPackagesWithBindWidgetPermission.contains(packageId)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        public boolean canAccessAppWidget(Widget widget, int uid, String packageName) {\n            if (isHostInPackageForUid(widget.host, uid, packageName)) {\n                // Apps hosting the AppWidget have access to it.\n                return true;\n            }\n            if (isProviderInPackageForUid(widget.provider, uid, packageName)) {\n                // Apps providing the AppWidget have access to it.\n                return true;\n            }\n            if (isHostAccessingProvider(widget.host, widget.provider, uid, packageName)) {\n                // Apps hosting the AppWidget get to bind to a remote view service in the provider.\n                return true;\n            }\n            final int userId = UserHandle.getUserId(uid);\n            if ((widget.host.getUserId() == userId || (widget.provider != null\n                    && widget.provider.getUserId() == userId))\n                && mContext.checkCallingPermission(android.Manifest.permission.BIND_APPWIDGET)\n                    == PackageManager.PERMISSION_GRANTED) {\n                // Apps that run in the same user as either the host or the provider and\n                // have the bind widget permission have access to the widget.\n                return true;\n            }\n            return false;\n        }\n\n        private boolean isParentOrProfile(int parentId, int profileId) {\n            if (parentId == profileId) {\n                return true;\n            }\n            return getProfileParent(profileId) == parentId;\n        }\n\n        public boolean isProviderInCallerOrInProfileAndWhitelListed(String packageName,\n                int profileId) {\n            final int callerId = UserHandle.getCallingUserId();\n            if (profileId == callerId) {\n                return true;\n            }\n            final int parentId = getProfileParent(profileId);\n            if (parentId != callerId) {\n                return false;\n            }\n            return isProviderWhiteListed(packageName, profileId);\n        }\n\n        public boolean isProviderWhiteListed(String packageName, int profileId) {\n            // If the policy manager is not available on the device we deny it all.\n            if (mDevicePolicyManagerInternal == null) {\n                return false;\n            }\n\n            List<String> crossProfilePackages = mDevicePolicyManagerInternal\n                    .getCrossProfileWidgetProviders(profileId);\n\n            return crossProfilePackages.contains(packageName);\n        }\n\n        public int getProfileParent(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo parent = mUserManager.getProfileParent(profileId);\n                if (parent != null) {\n                    return parent.getUserHandle().getIdentifier();\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return UNKNOWN_USER_ID;\n        }\n\n        public int getGroupParent(int profileId) {\n            final int parentId = mSecurityPolicy.getProfileParent(profileId);\n            return (parentId != UNKNOWN_USER_ID) ? parentId : profileId;\n        }\n\n        public boolean isHostInPackageForUid(Host host, int uid, String packageName) {\n            return host.id.uid == uid && host.id.packageName.equals(packageName);\n        }\n\n        public boolean isProviderInPackageForUid(Provider provider, int uid,\n                String packageName) {\n            // Packages providing the AppWidget have access to it.\n            return provider != null && provider.id.uid == uid\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        public boolean isHostAccessingProvider(Host host, Provider provider, int uid,\n                String packageName) {\n            // The host creates a package context to bind to remote views service in the provider.\n            return host.id.uid == uid && provider != null\n                    && provider.id.componentName.getPackageName().equals(packageName);\n        }\n\n        private boolean isProfileEnabled(int profileId) {\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                UserInfo userInfo = mUserManager.getUserInfo(profileId);\n                if (userInfo == null || !userInfo.isEnabled()) {\n                    return false;\n                }\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n            return true;\n        }\n    }\n\n    private static final class Provider {\n\n        ProviderId id;\n        AppWidgetProviderInfo info;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        PendingIntent broadcast;\n        String infoTag;\n\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        boolean maskedByLockedProfile;\n        boolean maskedByQuietProfile;\n        boolean maskedBySuspendedPackage;\n\n        boolean mInfoParsed = false;\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId\n                    && id.componentName.getPackageName().equals(packageName);\n        }\n\n        // is there an instance of this provider hosted by the given app?\n        public boolean hostedByPackageForUser(String packageName, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (packageName.equals(widget.host.id.packageName)\n                        && widget.host.getUserId() == userId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getInfoLocked(Context context) {\n            if (!mInfoParsed) {\n                // parse\n                if (!zombie) {\n                    AppWidgetProviderInfo newInfo = null;\n                    if (!TextUtils.isEmpty(infoTag)) {\n                        newInfo = parseAppWidgetProviderInfo(\n                                context, id, info.providerInfo, infoTag);\n                    }\n                    if (newInfo == null) {\n                        newInfo = parseAppWidgetProviderInfo(context, id, info.providerInfo,\n                                AppWidgetManager.META_DATA_APPWIDGET_PROVIDER);\n                    }\n                    if (newInfo != null) {\n                        info = newInfo;\n                    }\n                }\n                mInfoParsed = true;\n            }\n            return info;\n        }\n\n        /**\n         * Returns the last updated AppWidgetProviderInfo for this provider. This info may not\n         * be completely parsed and only contain placeHolder information like\n         * {@link AppWidgetProviderInfo#providerInfo}\n         */\n        @GuardedBy(\"mLock\")\n        public AppWidgetProviderInfo getPartialInfoLocked() {\n            return info;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setPartialInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = false;\n        }\n\n        @GuardedBy(\"mLock\")\n        public void setInfoLocked(AppWidgetProviderInfo info) {\n            this.info = info;\n            mInfoParsed = true;\n        }\n\n        @Override\n        public String toString() {\n            return \"Provider{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByQuietProfileLocked(boolean masked) {\n            boolean oldState = maskedByQuietProfile;\n            maskedByQuietProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedByLockedProfileLocked(boolean masked) {\n            boolean oldState = maskedByLockedProfile;\n            maskedByLockedProfile = masked;\n            return masked != oldState;\n        }\n\n        // returns true if it's different from previous state.\n        public boolean setMaskedBySuspendedPackageLocked(boolean masked) {\n            boolean oldState = maskedBySuspendedPackage;\n            maskedBySuspendedPackage = masked;\n            return masked != oldState;\n        }\n\n        public boolean isMaskedLocked() {\n            return maskedByQuietProfile || maskedByLockedProfile || maskedBySuspendedPackage;\n        }\n\n        public boolean shouldBePersisted() {\n            return !widgets.isEmpty() || !TextUtils.isEmpty(infoTag);\n        }\n    }\n\n    private static final class ProviderId {\n        final int uid;\n        final ComponentName componentName;\n\n        private ProviderId(int uid, ComponentName componentName) {\n            this.uid = uid;\n            this.componentName = componentName;\n        }\n\n        public UserHandle getProfile() {\n            return UserHandle.getUserHandleForUid(uid);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            ProviderId other = (ProviderId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (componentName == null) {\n                if (other.componentName != null) {\n                    return false;\n                }\n            } else if (!componentName.equals(other.componentName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + ((componentName != null)\n                    ? componentName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"ProviderId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", cmp:\" + componentName + '}';\n        }\n    }\n\n    private static final class Host {\n        HostId id;\n        ArrayList<Widget> widgets = new ArrayList<>();\n        IAppWidgetHost callbacks;\n        boolean zombie; // if we're in safe mode, don't prune this just because nobody references it\n\n        int tag = TAG_UNDEFINED; // for use while saving state (the index)\n        // Sequence no for the last update successfully sent. This is updated whenever a\n        // widget update is successfully sent to the host callbacks. As all new/undelivered updates\n        // will have sequenceNo greater than this, all those updates will be sent when the host\n        // callbacks are attached again.\n        long lastWidgetUpdateSequenceNo;\n\n        public int getUserId() {\n            return UserHandle.getUserId(id.uid);\n        }\n\n        public boolean isInPackageForUser(String packageName, int userId) {\n            return getUserId() == userId && id.packageName.equals(packageName);\n        }\n\n        private boolean hostsPackageForUser(String pkg, int userId) {\n            final int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Provider provider = widgets.get(i).provider;\n                if (provider != null && provider.getUserId() == userId\n                        && pkg.equals(provider.id.componentName.getPackageName())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Adds all pending updates in {@param outUpdates} keys by the update time.\n         */\n        public void getPendingUpdatesForIdLocked(Context context, int appWidgetId,\n                LongSparseArray<PendingHostUpdate> outUpdates) {\n            long updateSequenceNo = lastWidgetUpdateSequenceNo;\n            int N = widgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = widgets.get(i);\n                if (widget.appWidgetId == appWidgetId) {\n                    for (int j = widget.updateSequenceNos.size() - 1; j >= 0; j--) {\n                        long requestId = widget.updateSequenceNos.valueAt(j);\n                        if (requestId <= updateSequenceNo) {\n                            continue;\n                        }\n                        int id = widget.updateSequenceNos.keyAt(j);\n                        final PendingHostUpdate update;\n                        switch (id) {\n                            case ID_PROVIDER_CHANGED:\n                                update = PendingHostUpdate.providerChanged(\n                                        appWidgetId, widget.provider.getInfoLocked(context));\n                                break;\n                            case ID_VIEWS_UPDATE:\n                                update = PendingHostUpdate.updateAppWidget(appWidgetId,\n                                        cloneIfLocalBinder(widget.getEffectiveViewsLocked()));\n                                break;\n                            default:\n                                update = PendingHostUpdate.viewDataChanged(appWidgetId, id);\n                        }\n                        outUpdates.put(requestId, update);\n                    }\n                    return;\n                }\n            }\n            outUpdates.put(lastWidgetUpdateSequenceNo,\n                    PendingHostUpdate.appWidgetRemoved(appWidgetId));\n        }\n\n        public SparseArray<String> getWidgetUids() {\n            final SparseArray<String> uids = new SparseArray<>();\n            for (int i = widgets.size() - 1; i >= 0; i--) {\n                final Widget widget = widgets.get(i);\n                final ProviderId providerId = widget.provider.id;\n                uids.put(providerId.uid, providerId.componentName.getPackageName());\n            }\n            return uids;\n        }\n\n        @Override\n        public String toString() {\n            return \"Host{\" + id + (zombie ? \" Z\" : \"\") + '}';\n        }\n    }\n\n    private static final class HostId {\n        final int uid;\n        final int hostId;\n        final String packageName;\n\n        public HostId(int uid, int hostId, String packageName) {\n            this.uid = uid;\n            this.hostId = hostId;\n            this.packageName = packageName;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            HostId other = (HostId) obj;\n            if (uid != other.uid)  {\n                return false;\n            }\n            if (hostId != other.hostId) {\n                return false;\n            }\n            if (packageName == null) {\n                if (other.packageName != null) {\n                    return false;\n                }\n            } else if (!packageName.equals(other.packageName)) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = uid;\n            result = 31 * result + hostId;\n            result = 31 * result + ((packageName != null)\n                    ? packageName.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"HostId{user:\" + UserHandle.getUserId(uid) + \", app:\"\n                    + UserHandle.getAppId(uid) + \", hostId:\" + hostId\n                    + \", pkg:\" + packageName + '}';\n        }\n    }\n\n    // These can be any constants that would not collide with a resource id.\n    private static final int ID_VIEWS_UPDATE = 0;\n    private static final int ID_PROVIDER_CHANGED = 1;\n\n    private static final class Widget {\n        int appWidgetId;\n        int restoredId;  // tracking & remapping any restored state\n        Provider provider;\n        RemoteViews views;\n        RemoteViews maskedViews;\n        Bundle options;\n        Host host;\n        // Map of request type to updateSequenceNo.\n        SparseLongArray updateSequenceNos = new SparseLongArray(2);\n\n        @Override\n        public String toString() {\n            return \"AppWidgetId{\" + appWidgetId + ':' + host + ':' + provider + '}';\n        }\n\n        private boolean replaceWithMaskedViewsLocked(RemoteViews views) {\n            maskedViews = views;\n            return true;\n        }\n\n        private boolean clearMaskedViewsLocked() {\n            if (maskedViews != null) {\n                maskedViews = null;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        public RemoteViews getEffectiveViewsLocked() {\n            return maskedViews != null ? maskedViews : views;\n        }\n    }\n\n    private class LoadedWidgetState {\n        final Widget widget;\n        final int hostTag;\n        final int providerTag;\n\n        public LoadedWidgetState(Widget widget, int hostTag, int providerTag) {\n            this.widget = widget;\n            this.hostTag = hostTag;\n            this.providerTag = providerTag;\n        }\n    }\n\n    private final class SaveStateRunnable implements Runnable {\n        final int mUserId;\n\n        public SaveStateRunnable(int userId) {\n            mUserId = userId;\n        }\n\n        @Override\n        public void run() {\n            synchronized (mLock) {\n                // No need to enforce unlocked state when there is no caller. User can be in the\n                // stopping state or removed by the time the message is processed\n                ensureGroupStateLoadedLocked(mUserId, false /* enforceUserUnlockingOrUnlocked */ );\n                saveStateLocked(mUserId);\n            }\n        }\n    }\n\n    /**\n     * This class encapsulates the backup and restore logic for a user group state.\n     */\n    private final class BackupRestoreController {\n        private static final String TAG = \"BackupRestoreController\";\n\n        private static final boolean DEBUG = true;\n\n        // Version of backed-up widget state.\n        private static final int WIDGET_STATE_VERSION = 2;\n\n        // We need to make sure to wipe the pre-restore widget state only once for\n        // a given package.  Keep track of what we've done so far here; the list is\n        // cleared at the start of every system restore pass, but preserved through\n        // any install-time restore operations.\n        private final HashSet<String> mPrunedApps = new HashSet<>();\n\n        private final HashMap<Provider, ArrayList<RestoreUpdateRecord>> mUpdatesByProvider =\n                new HashMap<>();\n        private final HashMap<Host, ArrayList<RestoreUpdateRecord>> mUpdatesByHost =\n                new HashMap<>();\n\n        @GuardedBy(\"mLock\")\n        private boolean mHasSystemRestoreFinished;\n\n        public List<String> getWidgetParticipants(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget participants for user: \" + userId);\n            }\n\n            HashSet<String> packages = new HashSet<>();\n            synchronized (mLock) {\n                final int N = mWidgets.size();\n                for (int i = 0; i < N; i++) {\n                    Widget widget = mWidgets.get(i);\n\n                    // Skip cross-user widgets.\n                    if (!isProviderAndHostInUser(widget, userId)) {\n                        continue;\n                    }\n\n                    packages.add(widget.host.id.packageName);\n                    Provider provider = widget.provider;\n                    if (provider != null) {\n                        packages.add(provider.id.componentName.getPackageName());\n                    }\n                }\n            }\n            return new ArrayList<>(packages);\n        }\n\n        public byte[] getWidgetState(String backedupPackage, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Getting widget state for user: \" + userId);\n            }\n\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            synchronized (mLock) {\n                // Preflight: if this app neither hosts nor provides any live widgets\n                // we have no work to do.\n                if (!packageNeedsWidgetBackupLocked(backedupPackage, userId)) {\n                    return null;\n                }\n\n                try {\n                    TypedXmlSerializer out = Xml.newFastSerializer();\n                    out.setOutput(stream, StandardCharsets.UTF_8.name());\n                    out.startDocument(null, true);\n                    out.startTag(null, \"ws\");      // widget state\n                    out.attributeInt(null, \"version\", WIDGET_STATE_VERSION);\n                    out.attribute(null, \"pkg\", backedupPackage);\n\n                    // Remember all the providers that are currently hosted or published\n                    // by this package: that is, all of the entities related to this app\n                    // which will need to be told about id remapping.\n                    int index = 0;\n                    int N = mProviders.size();\n                    for (int i = 0; i < N; i++) {\n                        Provider provider = mProviders.get(i);\n\n                        if (provider.shouldBePersisted()\n                                && (provider.isInPackageForUser(backedupPackage, userId)\n                                || provider.hostedByPackageForUser(backedupPackage, userId))) {\n                            provider.tag = index;\n                            serializeProvider(out, provider);\n                            index++;\n                        }\n                    }\n\n                    N = mHosts.size();\n                    index = 0;\n                    for (int i = 0; i < N; i++) {\n                        Host host = mHosts.get(i);\n\n                        if (!host.widgets.isEmpty()\n                                && (host.isInPackageForUser(backedupPackage, userId)\n                                || host.hostsPackageForUser(backedupPackage, userId))) {\n                            host.tag = index;\n                            serializeHost(out, host);\n                            index++;\n                        }\n                    }\n\n                    // All widget instances involving this package,\n                    // either as host or as provider\n                    N = mWidgets.size();\n                    for (int i = 0; i < N; i++) {\n                        Widget widget = mWidgets.get(i);\n\n                        Provider provider = widget.provider;\n                        if (widget.host.isInPackageForUser(backedupPackage, userId)\n                                || (provider != null\n                                &&  provider.isInPackageForUser(backedupPackage, userId))) {\n                            serializeAppWidget(out, widget, false);\n                        }\n                    }\n\n                    out.endTag(null, \"ws\");\n                    out.endDocument();\n                } catch (IOException e) {\n                    Slog.w(TAG, \"Unable to save widget state for \" + backedupPackage);\n                    return null;\n                }\n            }\n\n            return stream.toByteArray();\n        }\n\n        public void systemRestoreStarting(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"System restore starting for user: \" + userId);\n            }\n\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = false;\n                // We're starting a new \"system\" restore operation, so any widget restore\n                // state that we see from here on is intended to replace the current\n                // widget configuration of any/all of the affected apps.\n                mPrunedApps.clear();\n                mUpdatesByProvider.clear();\n                mUpdatesByHost.clear();\n            }\n        }\n\n        public void restoreWidgetState(String packageName, byte[] restoredState, int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Restoring widget state for user:\" + userId\n                        + \" package: \" + packageName);\n            }\n\n            ByteArrayInputStream stream = new ByteArrayInputStream(restoredState);\n            try {\n                // Providers mentioned in the widget dataset by ordinal\n                ArrayList<Provider> restoredProviders = new ArrayList<>();\n\n                // Hosts mentioned in the widget dataset by ordinal\n                ArrayList<Host> restoredHosts = new ArrayList<>();\n\n                TypedXmlPullParser parser = Xml.newFastPullParser();\n                parser.setInput(stream, StandardCharsets.UTF_8.name());\n\n                synchronized (mLock) {\n                    int type;\n                    do {\n                        type = parser.next();\n                        if (type == XmlPullParser.START_TAG) {\n                            final String tag = parser.getName();\n                            if (\"ws\".equals(tag)) {\n                                final int versionNumber = parser.getAttributeInt(null, \"version\");\n                                if (versionNumber > WIDGET_STATE_VERSION) {\n                                    Slog.w(TAG, \"Unable to process state version \" + versionNumber);\n                                    return;\n                                }\n\n                                // TODO: fix up w.r.t. canonical vs current package names\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                if (!packageName.equals(pkg)) {\n                                    Slog.w(TAG, \"Package mismatch in ws\");\n                                    return;\n                                }\n                            } else if (\"p\".equals(tag)) {\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n                                String cl = parser.getAttributeValue(null, \"cl\");\n\n                                // hostedProviders index will match 'p' attribute in widget's\n                                // entry in the xml file being restored\n                                // If there's no live entry for this provider, add an inactive one\n                                // so that widget IDs referring to them can be properly allocated\n\n                                // Backup and resotre only for the parent profile.\n                                ComponentName componentName = new ComponentName(pkg, cl);\n\n                                Provider p = findProviderLocked(componentName, userId);\n                                if (p == null) {\n                                    AppWidgetProviderInfo info = new AppWidgetProviderInfo();\n                                    info.provider = componentName;\n\n                                    p = new Provider();\n                                    p.id = new ProviderId(UNKNOWN_UID, componentName);\n                                    p.setPartialInfoLocked(info);\n                                    p.zombie = true;\n                                    mProviders.add(p);\n                                }\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   provider \" + p.id);\n                                }\n                                restoredProviders.add(p);\n                            } else if (\"h\".equals(tag)) {\n                                // The host app may not yet exist on the device.  If it's here we\n                                // just use the existing Host entry, otherwise we create a\n                                // placeholder whose uid will be fixed up at PACKAGE_ADDED time.\n                                String pkg = parser.getAttributeValue(null, \"pkg\");\n\n                                final int uid = getUidForPackage(pkg, userId);\n                                final int hostId = parser.getAttributeIntHex(null, \"id\");\n\n                                HostId id = new HostId(uid, hostId, pkg);\n                                Host h = lookupOrAddHostLocked(id);\n                                restoredHosts.add(h);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   host[\" + restoredHosts.size()\n                                            + \"]: {\" + h.id + \"}\");\n                                }\n                            } else if (\"g\".equals(tag)) {\n                                int restoredId = parser.getAttributeIntHex(null, \"id\");\n                                int hostIndex = parser.getAttributeIntHex(null, \"h\");\n                                Host host = restoredHosts.get(hostIndex);\n                                Provider p = null;\n                                int which = parser.getAttributeIntHex(null, \"p\", -1);\n                                if (which != -1) {\n                                    // could have been null if the app had allocated an id\n                                    // but not yet established a binding under that id\n                                    p = restoredProviders.get(which);\n                                }\n\n                                // We'll be restoring widget state for both the host and\n                                // provider sides of this widget ID, so make sure we are\n                                // beginning from a clean slate on both fronts.\n                                pruneWidgetStateLocked(host.id.packageName, userId);\n                                if (p != null) {\n                                    pruneWidgetStateLocked(p.id.componentName.getPackageName(),\n                                            userId);\n                                }\n\n                                // Have we heard about this ancestral widget instance before?\n                                Widget id = findRestoredWidgetLocked(restoredId, host, p);\n                                if (id == null) {\n                                    id = new Widget();\n                                    id.appWidgetId = incrementAndGetAppWidgetIdLocked(userId);\n                                    id.restoredId = restoredId;\n                                    id.options = parseWidgetIdOptions(parser);\n                                    id.host = host;\n                                    id.host.widgets.add(id);\n                                    id.provider = p;\n                                    if (id.provider != null) {\n                                        id.provider.widgets.add(id);\n                                    }\n                                    if (DEBUG) {\n                                        Slog.i(TAG, \"New restored id \" + restoredId\n                                                + \" now \" + id);\n                                    }\n                                    addWidgetLocked(id);\n                                }\n                                if (id.provider != null\n                                        && id.provider.getPartialInfoLocked() != null) {\n                                    stashProviderRestoreUpdateLocked(id.provider,\n                                            restoredId, id.appWidgetId);\n                                } else {\n                                    Slog.w(TAG, \"Missing provider for restored widget \" + id);\n                                }\n                                stashHostRestoreUpdateLocked(id.host, restoredId, id.appWidgetId);\n\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   instance: \" + restoredId\n                                            + \" -> \" + id.appWidgetId\n                                            + \" :: p=\" + id.provider);\n                                }\n                            }\n                        }\n                    } while (type != XmlPullParser.END_DOCUMENT);\n\n                    // We've updated our own bookkeeping.  We'll need to notify the hosts and\n                    // providers about the changes, but we can't do that yet because the restore\n                    // target is not necessarily fully live at this moment.  Set aside the\n                    // information for now; the backup manager will call us once more at the\n                    // end of the process when all of the targets are in a known state, and we\n                    // will update at that point.\n                }\n            } catch (XmlPullParserException | IOException e) {\n                Slog.w(TAG, \"Unable to restore widget state for \" + packageName);\n            } finally {\n                saveGroupStateAsync(userId);\n            }\n        }\n\n        // Called once following the conclusion of a system restore operation.  This is when we\n        // send out updates to apps involved in widget-state restore telling them about\n        // the new widget ID space.  Apps that are not yet installed will be notifed when they are.\n        public void systemRestoreFinished(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"systemRestoreFinished for \" + userId);\n            }\n            synchronized (mLock) {\n                mHasSystemRestoreFinished = true;\n                maybeSendWidgetRestoreBroadcastsLocked(userId);\n            }\n        }\n\n        // Called when widget components (hosts or providers) are added or changed.  If system\n        // restore has completed, we use this opportunity to tell the apps to update to the new\n        // widget ID space.  If system restore is still in progress, we delay the updates until\n        // the end, to allow all participants to restore their state before updating widget IDs.\n        public void widgetComponentsChanged(int userId) {\n            synchronized (mLock) {\n                if (mHasSystemRestoreFinished) {\n                    maybeSendWidgetRestoreBroadcastsLocked(userId);\n                }\n            }\n        }\n\n        // Called following the conclusion of a restore operation and when widget components\n        // are added or changed.  This is when we send out updates to apps involved in widget-state\n        // restore telling them about the new widget ID space.\n        @GuardedBy(\"mLock\")\n        private void maybeSendWidgetRestoreBroadcastsLocked(int userId) {\n            if (DEBUG) {\n                Slog.i(TAG, \"maybeSendWidgetRestoreBroadcasts for \" + userId);\n            }\n\n            final UserHandle userHandle = new UserHandle(userId);\n            // Build the providers' broadcasts and send them off\n            Set<Map.Entry<Provider, ArrayList<RestoreUpdateRecord>>> providerEntries\n                    = mUpdatesByProvider.entrySet();\n            for (Map.Entry<Provider, ArrayList<RestoreUpdateRecord>> e : providerEntries) {\n                // For each provider there's a list of affected IDs\n                Provider provider = e.getKey();\n                if (provider.zombie) {\n                    // Provider not installed, we can't send them broadcasts yet.\n                    // We'll be called again when the provider is installed.\n                    continue;\n                }\n                ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                final int pending = countPendingUpdates(updates);\n                if (DEBUG) {\n                    Slog.i(TAG, \"Provider \" + provider + \" pending: \" + pending);\n                }\n                if (pending > 0) {\n                    int[] oldIds = new int[pending];\n                    int[] newIds = new int[pending];\n                    final int N = updates.size();\n                    int nextPending = 0;\n                    for (int i = 0; i < N; i++) {\n                        RestoreUpdateRecord r = updates.get(i);\n                        if (!r.notified) {\n                            r.notified = true;\n                            oldIds[nextPending] = r.oldId;\n                            newIds[nextPending] = r.newId;\n                            nextPending++;\n                            if (DEBUG) {\n                                Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                            }\n                        }\n                    }\n                    sendWidgetRestoreBroadcastLocked(\n                            AppWidgetManager.ACTION_APPWIDGET_RESTORED,\n                            provider, null, oldIds, newIds, userHandle);\n                }\n            }\n\n            // same thing per host\n            Set<Map.Entry<Host, ArrayList<RestoreUpdateRecord>>> hostEntries\n                    = mUpdatesByHost.entrySet();\n            for (Map.Entry<Host, ArrayList<RestoreUpdateRecord>> e : hostEntries) {\n                Host host = e.getKey();\n                if (host.id.uid != UNKNOWN_UID) {\n                    ArrayList<RestoreUpdateRecord> updates = e.getValue();\n                    final int pending = countPendingUpdates(updates);\n                    if (DEBUG) {\n                        Slog.i(TAG, \"Host \" + host + \" pending: \" + pending);\n                    }\n                    if (pending > 0) {\n                        int[] oldIds = new int[pending];\n                        int[] newIds = new int[pending];\n                        final int N = updates.size();\n                        int nextPending = 0;\n                        for (int i = 0; i < N; i++) {\n                            RestoreUpdateRecord r = updates.get(i);\n                            if (!r.notified) {\n                                r.notified = true;\n                                oldIds[nextPending] = r.oldId;\n                                newIds[nextPending] = r.newId;\n                                nextPending++;\n                                if (DEBUG) {\n                                    Slog.i(TAG, \"   \" + r.oldId + \" => \" + r.newId);\n                                }\n                            }\n                        }\n                        sendWidgetRestoreBroadcastLocked(\n                                AppWidgetManager.ACTION_APPWIDGET_HOST_RESTORED,\n                                null, host, oldIds, newIds, userHandle);\n                    }\n                }\n            }\n        }\n\n        private Provider findProviderLocked(ComponentName componentName, int userId) {\n            final int providerCount = mProviders.size();\n            for (int i = 0; i < providerCount; i++) {\n                Provider provider = mProviders.get(i);\n                if (provider.getUserId() == userId\n                        && provider.id.componentName.equals(componentName)) {\n                    return provider;\n                }\n            }\n            return null;\n        }\n\n        private Widget findRestoredWidgetLocked(int restoredId, Host host, Provider p) {\n            if (DEBUG) {\n                Slog.i(TAG, \"Find restored widget: id=\" + restoredId\n                        + \" host=\" + host + \" provider=\" + p);\n            }\n\n            if (p == null || host == null) {\n                return null;\n            }\n\n            final int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n                if (widget.restoredId == restoredId\n                        && widget.host.id.equals(host.id)\n                        && widget.provider.id.equals(p.id)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"   Found at \" + i + \" : \" + widget);\n                    }\n                    return widget;\n                }\n            }\n            return null;\n        }\n\n        private boolean packageNeedsWidgetBackupLocked(String packageName, int userId) {\n            int N = mWidgets.size();\n            for (int i = 0; i < N; i++) {\n                Widget widget = mWidgets.get(i);\n\n                // Skip cross-user widgets.\n                if (!isProviderAndHostInUser(widget, userId)) {\n                    continue;\n                }\n\n                if (widget.host.isInPackageForUser(packageName, userId)) {\n                    // this package is hosting widgets, so it knows widget IDs.\n                    return true;\n                }\n\n                Provider provider = widget.provider;\n                if (provider != null && provider.isInPackageForUser(packageName, userId)) {\n                    // someone is hosting this app's widgets, so it knows widget IDs.\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashProviderRestoreUpdateLocked(Provider provider, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByProvider.get(provider);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByProvider.put(provider, r);\n            } else {\n                // don't duplicate\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + provider);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private boolean alreadyStashed(ArrayList<RestoreUpdateRecord> stash,\n                final int oldId, final int newId) {\n            final int N = stash.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = stash.get(i);\n                if (r.oldId == oldId && r.newId == newId) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private void stashHostRestoreUpdateLocked(Host host, int oldId, int newId) {\n            ArrayList<RestoreUpdateRecord> r = mUpdatesByHost.get(host);\n            if (r == null) {\n                r = new ArrayList<>();\n                mUpdatesByHost.put(host, r);\n            } else {\n                if (alreadyStashed(r, oldId, newId)) {\n                    if (DEBUG) {\n                        Slog.i(TAG, \"ID remap \" + oldId + \" -> \" + newId\n                                + \" already stashed for \" + host);\n                    }\n                    return;\n                }\n            }\n            r.add(new RestoreUpdateRecord(oldId, newId));\n        }\n\n        private void sendWidgetRestoreBroadcastLocked(String action, Provider provider,\n                Host host, int[] oldIds, int[] newIds, UserHandle userHandle) {\n            Intent intent = new Intent(action);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS, oldIds);\n            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, newIds);\n            if (provider != null) {\n                intent.setComponent(provider.id.componentName);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n            if (host != null) {\n                intent.setComponent(null);\n                intent.setPackage(host.id.packageName);\n                intent.putExtra(AppWidgetManager.EXTRA_HOST_ID, host.id.hostId);\n                sendBroadcastAsUser(intent, userHandle);\n            }\n        }\n\n        // We're restoring widget state for 'pkg', so we start by wiping (a) all widget\n        // instances that are hosted by that app, and (b) all instances in other hosts\n        // for which 'pkg' is the provider.  We assume that we'll be restoring all of\n        // these hosts & providers, so will be reconstructing a correct live state.\n        private void pruneWidgetStateLocked(String pkg, int userId) {\n            if (!mPrunedApps.contains(pkg)) {\n                if (DEBUG) {\n                    Slog.i(TAG, \"pruning widget state for restoring package \" + pkg);\n                }\n                for (int i = mWidgets.size() - 1; i >= 0; i--) {\n                    Widget widget = mWidgets.get(i);\n\n                    Host host = widget.host;\n                    Provider provider = widget.provider;\n\n                    if (host.hostsPackageForUser(pkg, userId)\n                            || (provider != null && provider.isInPackageForUser(pkg, userId))) {\n                        // 'pkg' is either the host or the provider for this instances,\n                        // so we tear it down in anticipation of it (possibly) being\n                        // reconstructed due to the restore\n                        host.widgets.remove(widget);\n                        provider.widgets.remove(widget);\n                        // Check if we need to destroy any services (if no other app widgets are\n                        // referencing the same service)\n                        decrementAppWidgetServiceRefCount(widget);\n                        removeWidgetLocked(widget);\n                    }\n                }\n                mPrunedApps.add(pkg);\n            } else {\n                if (DEBUG) {\n                    Slog.i(TAG, \"already pruned \" + pkg + \", continuing normally\");\n                }\n            }\n        }\n\n        private boolean isProviderAndHostInUser(Widget widget, int userId) {\n            // Backup only widgets hosted or provided by the owner profile.\n            return widget.host.getUserId() == userId && (widget.provider == null\n                    || widget.provider.getUserId() == userId);\n        }\n\n        private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {\n            int pending = 0;\n            final int N = updates.size();\n            for (int i = 0; i < N; i++) {\n                RestoreUpdateRecord r = updates.get(i);\n                if (!r.notified) {\n                    pending++;\n                }\n            }\n            return pending;\n        }\n\n        // Accumulate a list of updates that affect the given provider for a final\n        // coalesced notification broadcast once restore is over.\n        private class RestoreUpdateRecord {\n            public int oldId;\n            public int newId;\n            public boolean notified;\n\n            public RestoreUpdateRecord(int theOldId, int theNewId) {\n                oldId = theOldId;\n                newId = theNewId;\n                notified = false;\n            }\n        }\n    }\n\n    private class AppWidgetManagerLocal extends AppWidgetManagerInternal {\n        @Override\n        public ArraySet<String> getHostedWidgetPackages(int uid) {\n            synchronized (mLock) {\n                ArraySet<String> widgetPackages = null;\n                final int widgetCount = mWidgets.size();\n                for (int i = 0; i < widgetCount; i++) {\n                    final Widget widget = mWidgets.get(i);\n                    if  (widget.host.id.uid == uid && widget.provider != null) {\n                        if (widgetPackages == null) {\n                            widgetPackages = new ArraySet<>();\n                        }\n                        widgetPackages.add(widget.provider.id.componentName.getPackageName());\n                    }\n                }\n                return widgetPackages;\n            }\n        }\n\n        @Override\n        public void unlockUser(int userId) {\n            handleUserUnlocked(userId);\n        }\n\n        @Override\n        public void applyResourceOverlaysToWidgets(Set<String> packageNames, int userId,\n                boolean updateFrameworkRes) {\n            synchronized (mLock) {\n                applyResourceOverlaysToWidgetsLocked(new HashSet<>(packageNames), userId,\n                        updateFrameworkRes);\n            }\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9935,
      "normalized_edit_similarity": 0.6058,
      "token_level_edit_distance": 9748,
      "codebert_score": {
        "precision": 0.9605,
        "recall": 0.9612,
        "f1": 0.9609,
        "f3": 0.9611
      },
      "token_count_upstream": 16705,
      "token_count_downstream": 16871,
      "token_count_total": 33576,
      "cosine_similarity_openai": "skipped"
    }
  }
]