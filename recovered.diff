diff --git a/.DS_Store b/.DS_Store
index 0804d7d..f65e774 100644
Binary files a/.DS_Store and b/.DS_Store differ
diff --git a/download_diff/__pycache__/fetch_diff.cpython-313.pyc b/download_diff/__pycache__/fetch_diff.cpython-313.pyc
index 7e7a8d8..f754c9c 100644
Binary files a/download_diff/__pycache__/fetch_diff.cpython-313.pyc and b/download_diff/__pycache__/fetch_diff.cpython-313.pyc differ
diff --git a/download_diff/fetch_diff.py b/download_diff/fetch_diff.py
index 029e2d6..eaea895 100644
--- a/download_diff/fetch_diff.py
+++ b/download_diff/fetch_diff.py
@@ -31,6 +31,22 @@ def extract_diff(url, files_to_include):
 
     return "\n".join(filtered_diff) if filtered_diff else None
 
+def extract_commit_hash(commit_url):
+    """Extracts the commit hash from a Googlesource or CodeLinaro URL."""
+    
+    # Matches full 40-character SHA-1 hash (if present)
+    full_hash_match = re.search(r'/([a-f0-9]{40})$', commit_url)
+    if full_hash_match:
+        return full_hash_match.group(1)
+    
+    # Matches shorter commit hashes (Googlesource sometimes uses short hashes)
+    short_hash_match = re.search(r'/\+/(.*?)$', commit_url)
+    if short_hash_match:
+        return short_hash_match.group(1)
+
+    print(f"⚠️ Could not extract commit hash from URL: {commit_url}")
+    return None
+
 def fetch_patch(commit_url, files_to_include):
     """
     Fetches the diff for a given commit URL, filters it to only include relevant files, and saves it.
@@ -43,20 +59,17 @@ def fetch_patch(commit_url, files_to_include):
         str: The path to the saved formatted diff file.
     """
 
-    # Extract commit hash from URL
-    commit_hash_match = re.search(r'/([a-f0-9]{40})$', commit_url)
-    if not commit_hash_match:
-        print(f"⚠️ Could not extract commit hash from URL: {commit_url}")
+    # Extract commit hash from the URL
+    commit_hash = extract_commit_hash(commit_url)
+    if not commit_hash:
         return None
 
-    commit_hash = commit_hash_match.group(1)
-
-    # Determine source type
+    # Determine source type and construct the diff URL
     if "android.googlesource.com" in commit_url:
-        diff_url = commit_url + "^!"
+        diff_url = commit_url + "^!"  # Googlesource requires ^! for diff
         is_codelinaro = False
     elif "git.codelinaro.org" in commit_url:
-        diff_url = commit_url + ".diff"
+        diff_url = commit_url + ".diff"  # CodeLinaro requires .diff suffix
         is_codelinaro = True
     else:
         print(f"⚠️ Unsupported commit URL: {commit_url}")
@@ -75,9 +88,11 @@ def fetch_patch(commit_url, files_to_include):
         print(f"❌ Failed to fetch diff for {commit_hash}. HTTP Status: {response.status_code}")
         return None
 
+    # Set output filename using commit hash
+    output_filename = os.path.join(output_dir_diff, f"{commit_hash}.diff")
+
     # Save raw .diff for CodeLinaro
     if is_codelinaro:
-        output_filename = os.path.join(output_dir_diff, f"{commit_hash}.diff")
         with open(output_filename, "w", encoding="utf-8") as f:
             f.write(response.text.strip() + "\n")  # Ensure exactly one empty line at the end
         print(f"✅ CodeLinaro: Diff file saved as: {output_filename}")
@@ -90,7 +105,6 @@ def fetch_patch(commit_url, files_to_include):
         return None
 
     # Save filtered diff
-    output_filename = os.path.join(output_dir_diff, f"{commit_hash}.diff")
     with open(output_filename, "w", encoding="utf-8") as output_file:
         output_file.write(extracted_diff.strip() + "\n")  # Ensure exactly one empty line at the end
 
diff --git a/download_diff/run_diff_fetcher.py b/download_diff/run_diff_fetcher.py
index 7f97e76..943e424 100644
--- a/download_diff/run_diff_fetcher.py
+++ b/download_diff/run_diff_fetcher.py
@@ -2,7 +2,7 @@ import json
 from fetch_diff import fetch_patch  # ✅ Correct import
 
 # Load the parsed report JSON
-parsed_report_path = "parsed-20250306201629.json"
+parsed_report_path = "/Users/theophilasetiawan/Desktop/files/capstone/vidar/reports/parsed_report.json"
 
 with open(parsed_report_path, "r") as f:
     parsed_report = json.load(f)
diff --git a/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff_fixed.diff b/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff_fixed.diff
deleted file mode 100644
index b657a78..0000000
--- a/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff_fixed.diff
+++ /dev/null
@@ -1,29 +0,0 @@
-```diff
---- a/mm/mremap.c
-+++ b/mm/mremap.c
-@@ -156,8 +156,6 @@
- 	return pte;
- }
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
- {
- 	/*
- 	 * If we have the only reference, swap the refcount to -1. This
-@@ -222,6 +220,7 @@
- 		spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
- 
- 	/*
-+
- 	 * If SPF is enabled, take the ptl lock on the source page table
- 	 * page, to prevent the entire pmd from being moved under a
- 	 * concurrent SPF.
-@@ -263,6 +262,7 @@
- 		spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
- 
- 	/* Clear the pmd */
-+
- 	pmd = *old_pmd;
- 	pmd_clear(old_pmd);
- 
-```
\ No newline at end of file
diff --git a/fetch_patch_output/diff_output/0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff b/fetch_patch_output/diff_output/0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff
deleted file mode 100644
index 590e1b5..0000000
--- a/fetch_patch_output/diff_output/0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff
+++ /dev/null
@@ -1,74 +0,0 @@
-diff --git a/drivers/media/platform/msm/cvp/hfi_response_handler.c b/drivers/media/platform/msm/cvp/hfi_response_handler.c
-index db857c210f3fb8e18d02e193afcb9384342e48f7..e9d61e382612896aa9e7aaaf9ff0564ee5810b9f 100644
---- a/drivers/media/platform/msm/cvp/hfi_response_handler.c
-+++ b/drivers/media/platform/msm/cvp/hfi_response_handler.c
-@@ -467,7 +467,7 @@ static struct msm_cvp_inst *cvp_get_inst_from_id(struct msm_cvp_core *core,
- 			}
- 		}
- 
--		inst = match ? inst : NULL;
-+		inst = match && kref_get_unless_zero(&inst->kref) ? inst : NULL;
- 		mutex_unlock(&core->lock);
- 	} else {
- 		if (core->state == CVP_CORE_UNINIT)
-@@ -519,7 +519,7 @@ static int hfi_process_session_cvp_msg(u32 device_id,
- 	sess_msg = kmem_cache_alloc(cvp_driver->msg_cache, GFP_KERNEL);
- 	if (sess_msg == NULL) {
- 		dprintk(CVP_ERR, "%s runs out msg cache memory\n", __func__);
--		return -ENOMEM;
-+		goto error_no_mem;
- 	}
- 
- 	memcpy(&sess_msg->pkt, pkt, get_msg_size(pkt));
-@@ -542,11 +542,14 @@ static int hfi_process_session_cvp_msg(u32 device_id,
- 
- 	info->response_type = HAL_NO_RESP;
- 
-+	cvp_put_inst(inst);
- 	return 0;
- 
- error_handle_msg:
- 	spin_unlock(&sq->lock);
- 	kmem_cache_free(cvp_driver->msg_cache, sess_msg);
-+error_no_mem:
-+	cvp_put_inst(inst);
- 	return -ENOMEM;
- }
- 
-diff --git a/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c b/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c
-index 013232aaa66dc6a0dce12ca7b4c01305d8afa159..539779ba2fab42703223d78000b39e7c39ccdb33 100644
---- a/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c
-+++ b/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c
-@@ -427,7 +427,7 @@ static struct msm_cvp_inst *cvp_get_inst_from_id(struct msm_cvp_core *core,
- 			}
- 		}
- 
--		inst = match ? inst : NULL;
-+		inst = match && kref_get_unless_zero(&inst->kref) ? inst : NULL;
- 		mutex_unlock(&core->lock);
- 	} else {
- 		if (core->state == CVP_CORE_UNINIT)
-@@ -526,7 +526,7 @@ static int hfi_process_session_cvp_msg(u32 device_id,
- 	sess_msg = kmem_cache_alloc(cvp_driver->msg_cache, GFP_KERNEL);
- 	if (sess_msg == NULL) {
- 		dprintk(CVP_ERR, "%s runs out msg cache memory\n", __func__);
--		return -ENOMEM;
-+		goto error_no_mem;
- 	}
- 
- 	memcpy(&sess_msg->pkt, pkt, get_msg_size());
-@@ -548,12 +548,14 @@ static int hfi_process_session_cvp_msg(u32 device_id,
- 	wake_up_all(&inst->session_queue.wq);
- 
- 	info->response_type = HAL_NO_RESP;
--
-+	cvp_put_inst(inst);
- 	return 0;
- 
- error_handle_msg:
- 	spin_unlock(&inst->session_queue.lock);
- 	kmem_cache_free(cvp_driver->msg_cache, sess_msg);
-+error_no_mem:
-+	cvp_put_inst(inst);
- 	return -ENOMEM;
- }
diff --git a/fetch_patch_output/diff_output/0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff.rej b/fetch_patch_output/diff_output/0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff.rej
deleted file mode 100644
index ee5d2b4..0000000
--- a/fetch_patch_output/diff_output/0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff b/fetch_patch_output/diff_output/051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff
deleted file mode 100644
index d847363..0000000
--- a/fetch_patch_output/diff_output/051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff
+++ /dev/null
@@ -1,96 +0,0 @@
-diff --git a/drivers/slimbus/qcom-ngd-ctrl.c b/drivers/slimbus/qcom-ngd-ctrl.c
-index b249e0a17e48c2a67799f11ccb0fbbb4ce7f04bb..99eba7c01c0f929ba7a98e230452d9042091ebc9 100644
---- a/drivers/slimbus/qcom-ngd-ctrl.c
-+++ b/drivers/slimbus/qcom-ngd-ctrl.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: GPL-2.0
- // Copyright (c) 2011-2017, 2020-2021, The Linux Foundation. All rights reserved.
- // Copyright (c) 2018, Linaro Limited
--// Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-+// Copyright (c) 2022-2024 Qualcomm Innovation Center, Inc. All rights reserved.
- 
- #include <linux/irq.h>
- #include <linux/kernel.h>
-@@ -201,6 +201,8 @@ struct qcom_slim_ngd_ctrl {
- 	struct work_struct ngd_up_work;
- 	struct workqueue_struct *mwq;
- 	struct completion qmi_up;
-+	struct completion xfer_done;
-+	struct completion sync_done;
- 	spinlock_t tx_buf_lock;
- 	struct mutex tx_lock;
- 	struct mutex suspend_resume_lock;
-@@ -970,7 +972,6 @@ static int qcom_slim_ngd_xfer_msg(struct slim_controller *sctrl,
- {
- 	struct qcom_slim_ngd_ctrl *ctrl = dev_get_drvdata(sctrl->dev);
- 	DECLARE_COMPLETION_ONSTACK(tx_sent);
--	DECLARE_COMPLETION_ONSTACK(done);
- 	int ret, timeout, i;
- 	u8 wbuf[SLIM_MSGQ_BUF_LEN];
- 	u8 rbuf[SLIM_MSGQ_BUF_LEN];
-@@ -979,6 +980,8 @@ static int qcom_slim_ngd_xfer_msg(struct slim_controller *sctrl,
- 	u8 la = txn->la;
- 	bool usr_msg = false;
- 
-+	reinit_completion(&ctrl->xfer_done);
-+
- 	if (txn->mt == SLIM_MSG_MT_CORE &&
- 		(txn->mc >= SLIM_MSG_MC_BEGIN_RECONFIGURATION &&
- 		 txn->mc <= SLIM_MSG_MC_RECONFIGURE_NOW))
-@@ -1049,7 +1052,7 @@ static int qcom_slim_ngd_xfer_msg(struct slim_controller *sctrl,
- 		if (txn->mc != SLIM_USR_MC_DISCONNECT_PORT)
- 			wbuf[i++] = txn->msg->wbuf[1];
- 
--		txn->comp = &done;
-+		txn->comp = &ctrl->xfer_done;
- 		ret = slim_alloc_txn_tid(sctrl, txn);
- 		if (ret) {
- 			SLIM_ERR(ctrl, "Unable to allocate TID\n");
-@@ -1113,7 +1116,7 @@ static int qcom_slim_ngd_xfer_msg(struct slim_controller *sctrl,
- 	}
- 
- 	if (usr_msg) {
--		timeout = wait_for_completion_timeout(&done, HZ);
-+		timeout = wait_for_completion_timeout(&ctrl->xfer_done, HZ);
- 		if (!timeout) {
- 			SLIM_WARN(ctrl, "TX usr_msg timed out:MC:0x%x,mt:0x%x",
- 				txn->mc, txn->mt);
-@@ -1133,9 +1136,10 @@ static int qcom_slim_ngd_xfer_msg_sync(struct slim_controller *ctrl,
- {
- 	struct qcom_slim_ngd_ctrl *dev =
- 		container_of(ctrl, struct qcom_slim_ngd_ctrl, ctrl);
--	DECLARE_COMPLETION_ONSTACK(done);
- 	int ret, timeout;
- 
-+	reinit_completion(&dev->sync_done);
-+
- 	ret = pm_runtime_get_sync(ctrl->dev);
- 	if (ret < 0) {
- 		SLIM_ERR(dev, "SLIM %s: PM get_sync failed ret :%d count:%d TID:%d\n",
-@@ -1146,7 +1150,7 @@ static int qcom_slim_ngd_xfer_msg_sync(struct slim_controller *ctrl,
- 	SLIM_INFO(dev, "SLIM %s: PM get_sync count:%d TID:%d\n",
- 		__func__, atomic_read(&ctrl->dev->power.usage_count), txn->tid);
- 
--	txn->comp = &done;
-+	txn->comp = &dev->sync_done;
- 
- 	ret = qcom_slim_ngd_xfer_msg(ctrl, txn);
- 	if (ret) {
-@@ -1155,7 +1159,7 @@ static int qcom_slim_ngd_xfer_msg_sync(struct slim_controller *ctrl,
- 		goto err;
- 	}
- 
--	timeout = wait_for_completion_timeout(&done, HZ);
-+	timeout = wait_for_completion_timeout(&dev->sync_done, HZ);
- 	if (!timeout) {
- 		SLIM_WARN(dev, "TX sync timed out:MC:0x%x,mt:0x%x", txn->mc,
- 				txn->mt);
-@@ -2155,6 +2159,8 @@ static int qcom_slim_ngd_ctrl_probe(struct platform_device *pdev)
- 	init_completion(&ctrl->ctrl_up);
- 	init_completion(&ctrl->qmi.qmi_comp);
- 	init_completion(&ctrl->qmi_up);
-+	init_completion(&ctrl->xfer_done);
-+	init_completion(&ctrl->sync_done);
- 
- 	ctrl->pdr = pdr_handle_alloc(slim_pd_status, ctrl);
- 	if (IS_ERR(ctrl->pdr)) {
diff --git a/fetch_patch_output/diff_output/051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff.rej b/fetch_patch_output/diff_output/051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff.rej
deleted file mode 100644
index ee5d2b4..0000000
--- a/fetch_patch_output/diff_output/051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff b/fetch_patch_output/diff_output/079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff
deleted file mode 100644
index 448d452..0000000
--- a/fetch_patch_output/diff_output/079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff
+++ /dev/null
@@ -1,162 +0,0 @@
-diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
-index 88ff7bb..dd7c0b3 100644
---- a/include/net/dst_ops.h
-+++ b/include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
-diff --git a/include/net/sock.h b/include/net/sock.h
-index 2935c4a..d4f1c2f 100644
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -1919,19 +1919,12 @@ sk_dst_get(struct sock *sk)
- 
- static inline void dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
- 	sk_rethink_txhash(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void
-
-diff --git a/net/ipv4/route.c b/net/ipv4/route.c
-index 3014605..3c5401d 100644
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -140,7 +140,8 @@ static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
- static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -848,22 +849,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
-diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index a650024..a6c82b0 100644
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -88,7 +88,8 @@ enum rt6_nud_state {
- static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2281,24 +2282,24 @@ static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
- 	return dst_ret;
- }
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
-diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
-index 6fe5787..c3fbd83 100644
---- a/net/xfrm/xfrm_policy.c
-+++ b/net/xfrm/xfrm_policy.c
-@@ -2558,15 +2558,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
diff --git a/fetch_patch_output/diff_output/079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff.rej b/fetch_patch_output/diff_output/079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff.rej
deleted file mode 100644
index 770ee13..0000000
--- a/fetch_patch_output/diff_output/079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff.rej
+++ /dev/null
@@ -1,436 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/dst_ops.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/xfrm/xfrm_policy.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- include/net/dst_ops.h
-+++ include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
---- include/net/sock.h
-+++ include/net/sock.h
-@@ -1919,19 +1919,12 @@ sk_dst_get(struct sock *sk)
- 
- static inline void dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
- 	sk_rethink_txhash(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/ipv4/route.c
-+++ net/ipv4/route.c
-@@ -140,7 +140,8 @@ static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
- static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -848,22 +849,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
---- net/ipv6/route.c
-+++ net/ipv6/route.c
-@@ -88,7 +88,8 @@ enum rt6_nud_state {
- static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2281,24 +2282,24 @@ static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
- 	return dst_ret;
- }
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
---- net/xfrm/xfrm_policy.c
-+++ net/xfrm/xfrm_policy.c
-@@ -2558,15 +2558,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
-
diff --git a/fetch_patch_output/diff_output/135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff b/fetch_patch_output/diff_output/135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff
deleted file mode 100644
index 9b50993..0000000
--- a/fetch_patch_output/diff_output/135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index 3185d01b..783a345 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3423,6 +3423,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff.rej b/fetch_patch_output/diff_output/135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff.rej
deleted file mode 100644
index 3f452fb..0000000
--- a/fetch_patch_output/diff_output/135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3423,6 +3423,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/25c49620c22e375fbd69631ea1eb408ed43db6e0.diff b/fetch_patch_output/diff_output/25c49620c22e375fbd69631ea1eb408ed43db6e0.diff
deleted file mode 100644
index 0db0f6f..0000000
--- a/fetch_patch_output/diff_output/25c49620c22e375fbd69631ea1eb408ed43db6e0.diff
+++ /dev/null
@@ -1,74 +0,0 @@
-diff --git a/drivers/gpu/msm/kgsl_vbo.c b/drivers/gpu/msm/kgsl_vbo.c
-index aead43fc6514ac15b2bebe22e3c2b4a14613d2f7..2ab97c3f5ba0ab104b6d336c43345c4fdcfe803b 100644
---- a/drivers/gpu/msm/kgsl_vbo.c
-+++ b/drivers/gpu/msm/kgsl_vbo.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: GPL-2.0-only
- /*
-  * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
-- * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2023-2024, Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/file.h>
-@@ -46,6 +46,12 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 	return range;
- }
- 
-+static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
-+{
-+	kgsl_mem_entry_put(range->entry);
-+	kfree(range);
-+}
-+
- static u64 bind_range_len(struct kgsl_memdesc_bind_range *range)
- {
- 	return (range->range.last - range->range.start) + 1;
-@@ -113,8 +119,7 @@ static void kgsl_memdesc_remove_range(struct kgsl_mem_entry *target,
- 			kgsl_mmu_map_zero_page_to_range(memdesc->pagetable,
- 				memdesc, range->range.start, bind_range_len(range));
- 
--			kgsl_mem_entry_put(range->entry);
--			kfree(range);
-+			bind_range_destroy(range);
- 		}
- 	}
- 
-@@ -161,8 +166,7 @@ static int kgsl_memdesc_add_range(struct kgsl_mem_entry *target,
- 
- 		if (start <= cur->range.start) {
- 			if (last >= cur->range.last) {
--				kgsl_mem_entry_put(cur->entry);
--				kfree(cur);
-+				bind_range_destroy(cur);
- 				continue;
- 			}
- 			/* Adjust the start of the mapping */
-@@ -216,8 +220,7 @@ static int kgsl_memdesc_add_range(struct kgsl_mem_entry *target,
- 	return ret;
- 
- error:
--	kgsl_mem_entry_put(range->entry);
--	kfree(range);
-+	bind_range_destroy(range);
- 	mutex_unlock(&memdesc->ranges_lock);
- 	return ret;
- }
-@@ -247,12 +250,11 @@ static void kgsl_sharedmem_vbo_put_gpuaddr(struct kgsl_memdesc *memdesc)
- 
- 		interval_tree_remove(node, &memdesc->ranges);
- 
--		/* If unmap failed, mark the child memdesc as still mapped */
--		if (ret)
--			range->entry->memdesc.priv |= KGSL_MEMDESC_MAPPED;
--
--		kgsl_mem_entry_put(range->entry);
--		kfree(range);
-+		/* Put the child's refcount if unmap succeeds */
-+		if (!ret)
-+			bind_range_destroy(range);
-+		else
-+			kfree(range);
- 	}
- 
- 	if (ret)
diff --git a/fetch_patch_output/diff_output/25c49620c22e375fbd69631ea1eb408ed43db6e0.diff.rej b/fetch_patch_output/diff_output/25c49620c22e375fbd69631ea1eb408ed43db6e0.diff.rej
deleted file mode 100644
index 6d531a0..0000000
--- a/fetch_patch_output/diff_output/25c49620c22e375fbd69631ea1eb408ed43db6e0.diff.rej
+++ /dev/null
@@ -1,260 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/28204d125055f0dec3e9625382cb92810f5528d0.diff b/fetch_patch_output/diff_output/28204d125055f0dec3e9625382cb92810f5528d0.diff
deleted file mode 100644
index 99db527..0000000
--- a/fetch_patch_output/diff_output/28204d125055f0dec3e9625382cb92810f5528d0.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/char/adsprpc.c b/drivers/char/adsprpc.c
-index 64a28032f7fd04e3565ad68d8ba803dd1da82851..a9fd81b17a401a000c6ddefeb0b72dd669dfc42a 100644
---- a/drivers/char/adsprpc.c
-+++ b/drivers/char/adsprpc.c
-@@ -6301,7 +6301,7 @@ static int fastrpc_device_open(struct inode *inode, struct file *filp)
- 
- static int fastrpc_get_process_gids(struct gid_list *gidlist)
- {
--	struct group_info *group_info = get_current_groups();
-+	struct group_info *group_info = current_cred()->group_info;
- 	int i = 0, err = 0, num_gids = group_info->ngroups + 1;
- 	unsigned int *gids = NULL;
diff --git a/fetch_patch_output/diff_output/28204d125055f0dec3e9625382cb92810f5528d0.diff.rej b/fetch_patch_output/diff_output/28204d125055f0dec3e9625382cb92810f5528d0.diff.rej
deleted file mode 100644
index ee5d2b4..0000000
--- a/fetch_patch_output/diff_output/28204d125055f0dec3e9625382cb92810f5528d0.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/30efc10dfe20bbf7410adb3d756106f365ac75cc.diff b/fetch_patch_output/diff_output/30efc10dfe20bbf7410adb3d756106f365ac75cc.diff
deleted file mode 100644
index a92d39a..0000000
--- a/fetch_patch_output/diff_output/30efc10dfe20bbf7410adb3d756106f365ac75cc.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index dec6cf1..00c300d 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3546,6 +3546,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/30efc10dfe20bbf7410adb3d756106f365ac75cc.diff.rej b/fetch_patch_output/diff_output/30efc10dfe20bbf7410adb3d756106f365ac75cc.diff.rej
deleted file mode 100644
index 3bc32a2..0000000
--- a/fetch_patch_output/diff_output/30efc10dfe20bbf7410adb3d756106f365ac75cc.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3546,6 +3546,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff b/fetch_patch_output/diff_output/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff
deleted file mode 100644
index 62bf7b2..0000000
--- a/fetch_patch_output/diff_output/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index 4228d81..2ad57d5 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3647,6 +3647,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff.rej b/fetch_patch_output/diff_output/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff.rej
deleted file mode 100644
index a9a85a3..0000000
--- a/fetch_patch_output/diff_output/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3647,6 +3647,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/3856ad0c3e3028d54c8dac960dec411e45c13146.diff b/fetch_patch_output/diff_output/3856ad0c3e3028d54c8dac960dec411e45c13146.diff
deleted file mode 100644
index 61d35a8..0000000
--- a/fetch_patch_output/diff_output/3856ad0c3e3028d54c8dac960dec411e45c13146.diff
+++ /dev/null
@@ -1,160 +0,0 @@
-diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
-index 88ff7bb..dd7c0b3 100644
---- a/include/net/dst_ops.h
-+++ b/include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
-diff --git a/include/net/sock.h b/include/net/sock.h
-index a98ed62..709d226 100644
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -2012,17 +2012,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
-diff --git a/net/ipv4/route.c b/net/ipv4/route.c
-index b6aca58..950ff00 100644
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -137,7 +137,8 @@ static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
- static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -866,22 +867,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
-diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index 9b9f72d..3619075 100644
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -85,7 +85,8 @@ enum rt6_nud_state {
- static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2635,24 +2636,24 @@ static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
- 	return dst_ret;
- }
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
-diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
-index e373b04..9e6b186 100644
---- a/net/xfrm/xfrm_policy.c
-+++ b/net/xfrm/xfrm_policy.c
-@@ -3799,15 +3799,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
diff --git a/fetch_patch_output/diff_output/3856ad0c3e3028d54c8dac960dec411e45c13146.diff.rej b/fetch_patch_output/diff_output/3856ad0c3e3028d54c8dac960dec411e45c13146.diff.rej
deleted file mode 100644
index 1f0fa7c..0000000
--- a/fetch_patch_output/diff_output/3856ad0c3e3028d54c8dac960dec411e45c13146.diff.rej
+++ /dev/null
@@ -1,299 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- include/net/sock.h
-+++ include/net/sock.h
-@@ -2012,17 +2012,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/41a05cfc0e471cea173345622375b672edd8ed3c.diff b/fetch_patch_output/diff_output/41a05cfc0e471cea173345622375b672edd8ed3c.diff
deleted file mode 100644
index f1d5e37..0000000
--- a/fetch_patch_output/diff_output/41a05cfc0e471cea173345622375b672edd8ed3c.diff
+++ /dev/null
@@ -1,162 +0,0 @@
-diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
-index 88ff7bb..dd7c0b3 100644
---- a/include/net/dst_ops.h
-+++ b/include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
-diff --git a/include/net/sock.h b/include/net/sock.h
-index 538ca55..8b173a1 100644
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -1955,19 +1955,12 @@ sk_dst_get(struct sock *sk)
- 
- static inline void dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
- 	sk_rethink_txhash(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void
-
-diff --git a/net/ipv4/route.c b/net/ipv4/route.c
-index 902296e..63453c2 100644
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -137,7 +137,8 @@ static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
- static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -856,22 +857,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
-diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index 4c51cabc..23cfce6 100644
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -84,7 +84,8 @@ enum rt6_nud_state {
- static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2658,24 +2659,24 @@ static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
- 	return dst_ret;
- }
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
-diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
-index 8632776..cbf9387 100644
---- a/net/xfrm/xfrm_policy.c
-+++ b/net/xfrm/xfrm_policy.c
-@@ -3778,15 +3778,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
diff --git a/fetch_patch_output/diff_output/41a05cfc0e471cea173345622375b672edd8ed3c.diff.rej b/fetch_patch_output/diff_output/41a05cfc0e471cea173345622375b672edd8ed3c.diff.rej
deleted file mode 100644
index 49ce22c..0000000
--- a/fetch_patch_output/diff_output/41a05cfc0e471cea173345622375b672edd8ed3c.diff.rej
+++ /dev/null
@@ -1,436 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/dst_ops.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/xfrm/xfrm_policy.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- include/net/dst_ops.h
-+++ include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
---- include/net/sock.h
-+++ include/net/sock.h
-@@ -1955,19 +1955,12 @@ sk_dst_get(struct sock *sk)
- 
- static inline void dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
- 	sk_rethink_txhash(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/ipv4/route.c
-+++ net/ipv4/route.c
-@@ -137,7 +137,8 @@ static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
- static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -856,22 +857,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
---- net/ipv6/route.c
-+++ net/ipv6/route.c
-@@ -84,7 +84,8 @@ enum rt6_nud_state {
- static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- static unsigned int	 ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2658,24 +2659,24 @@ static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
- 	return dst_ret;
- }
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
---- net/xfrm/xfrm_policy.c
-+++ net/xfrm/xfrm_policy.c
-@@ -3778,15 +3778,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
-
diff --git a/fetch_patch_output/diff_output/61abd2ada929a54983f95345ffa2504bbd9b993d.diff b/fetch_patch_output/diff_output/61abd2ada929a54983f95345ffa2504bbd9b993d.diff
deleted file mode 100644
index fb12827..0000000
--- a/fetch_patch_output/diff_output/61abd2ada929a54983f95345ffa2504bbd9b993d.diff
+++ /dev/null
@@ -1,40 +0,0 @@
-diff --git a/drivers/gpu/msm/kgsl_vbo.c b/drivers/gpu/msm/kgsl_vbo.c
-index 551822ba98daf1b11a835b35c47642924dadd280..c850a47f0fdbe3136bca7672559a4114d84109d0 100644
---- a/drivers/gpu/msm/kgsl_vbo.c
-+++ b/drivers/gpu/msm/kgsl_vbo.c
-@@ -12,6 +12,7 @@
- 
- #include "kgsl_device.h"
- #include "kgsl_mmu.h"
-+#include "kgsl_reclaim.h"
- #include "kgsl_sharedmem.h"
- #include "kgsl_trace.h"
- 
-@@ -371,6 +372,12 @@ kgsl_sharedmem_create_bind_op(struct kgsl_process_private *private,
- 	op->nr_ops = ranges_nents;
- 	op->target = target;
- 
-+	/* Make sure process is pinned in memory before proceeding */
-+	atomic_inc(&private->cmd_count);
-+	ret = kgsl_reclaim_to_pinned_state(private);
-+	if (ret)
-+		goto err;
-+
- 	for (i = 0; i < ranges_nents; i++) {
- 		struct kgsl_gpumem_bind_range range;
- 		struct kgsl_mem_entry *entry;
-@@ -471,12 +478,14 @@ kgsl_sharedmem_create_bind_op(struct kgsl_process_private *private,
- 		ranges += ranges_size;
- 	}
- 
-+	atomic_dec(&private->cmd_count);
- 	init_completion(&op->comp);
- 	kref_init(&op->ref);
- 
- 	return op;
- 
- err:
-+	atomic_dec(&private->cmd_count);
- 	kgsl_sharedmem_free_bind_op(op);
- 	return ERR_PTR(ret);
- }
diff --git a/fetch_patch_output/diff_output/61abd2ada929a54983f95345ffa2504bbd9b993d.diff.rej b/fetch_patch_output/diff_output/61abd2ada929a54983f95345ffa2504bbd9b993d.diff.rej
deleted file mode 100644
index 6d531a0..0000000
--- a/fetch_patch_output/diff_output/61abd2ada929a54983f95345ffa2504bbd9b993d.diff.rej
+++ /dev/null
@@ -1,260 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff b/fetch_patch_output/diff_output/65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff
deleted file mode 100644
index 91efd9c..0000000
--- a/fetch_patch_output/diff_output/65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff
+++ /dev/null
@@ -1,120 +0,0 @@
-diff --git a/include/net/af_unix.h b/include/net/af_unix.h
-index 7d142e8..01f3aec 100644
---- a/include/net/af_unix.h
-+++ b/include/net/af_unix.h
-@@ -62,7 +62,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
-diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
-index f079a5b..23bfe5d 100644
---- a/net/unix/af_unix.c
-+++ b/net/unix/af_unix.c
-@@ -877,11 +877,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
-diff --git a/net/unix/garbage.c b/net/unix/garbage.c
-index dc27635..312474c 100644
---- a/net/unix/garbage.c
-+++ b/net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
-diff --git a/net/unix/scm.c b/net/unix/scm.c
-index e8e2a00..bdcda4e 100644
---- a/net/unix/scm.c
-+++ b/net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
diff --git a/fetch_patch_output/diff_output/65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff.rej b/fetch_patch_output/diff_output/65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff.rej
deleted file mode 100644
index 0634d9f..0000000
--- a/fetch_patch_output/diff_output/65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff.rej
+++ /dev/null
@@ -1,117 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
diff --git a/fetch_patch_output/diff_output/6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff b/fetch_patch_output/diff_output/6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff
deleted file mode 100644
index fb0a274..0000000
--- a/fetch_patch_output/diff_output/6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index 7f877ae..f42e980 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff.rej b/fetch_patch_output/diff_output/6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff.rej
deleted file mode 100644
index ee5d2b4..0000000
--- a/fetch_patch_output/diff_output/6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/7a2aa337ab8235460c1efa92a846eaeade5f2514.diff b/fetch_patch_output/diff_output/7a2aa337ab8235460c1efa92a846eaeade5f2514.diff
deleted file mode 100644
index e565201..0000000
--- a/fetch_patch_output/diff_output/7a2aa337ab8235460c1efa92a846eaeade5f2514.diff
+++ /dev/null
@@ -1,16 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index eec637d..abec538 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -1837,8 +1837,10 @@ static size_t binder_get_object(struct binder_proc *proc,
- 	size_t object_size = 0;
- 
- 	read_size = min_t(size_t, sizeof(*object), buffer->data_size - offset);
--	if (offset > buffer->data_size || read_size < sizeof(*hdr))
-+	if (offset > buffer->data_size || read_size < sizeof(*hdr) ||
-+	    !IS_ALIGNED(offset, sizeof(u32)))
- 		return 0;
-+
- 	if (u) {
- 		if (copy_from_user(object, u + offset, read_size))
- 			return 0;
diff --git a/fetch_patch_output/diff_output/7a2aa337ab8235460c1efa92a846eaeade5f2514.diff.rej b/fetch_patch_output/diff_output/7a2aa337ab8235460c1efa92a846eaeade5f2514.diff.rej
deleted file mode 100644
index 6d531a0..0000000
--- a/fetch_patch_output/diff_output/7a2aa337ab8235460c1efa92a846eaeade5f2514.diff.rej
+++ /dev/null
@@ -1,260 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/841cae881066f0dd38d15a90cfcf245b0db9fc73.diff b/fetch_patch_output/diff_output/841cae881066f0dd38d15a90cfcf245b0db9fc73.diff
deleted file mode 100644
index 012d132..0000000
--- a/fetch_patch_output/diff_output/841cae881066f0dd38d15a90cfcf245b0db9fc73.diff
+++ /dev/null
@@ -1,13 +0,0 @@
-diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c
-index 75c9c86..0d6649d 100644
---- a/net/sched/sch_multiq.c
-+++ b/net/sched/sch_multiq.c
-@@ -185,7 +185,7 @@ static int multiq_tune(struct Qdisc *sch, struct nlattr *opt,
- 
- 	qopt->bands = qdisc_dev(sch)->real_num_tx_queues;
- 
--	removed = kmalloc(sizeof(*removed) * (q->max_bands - q->bands),
-+	removed = kmalloc(sizeof(*removed) * (q->max_bands - qopt->bands),
- 			  GFP_KERNEL);
- 	if (!removed)
- 		return -ENOMEM;
diff --git a/fetch_patch_output/diff_output/841cae881066f0dd38d15a90cfcf245b0db9fc73.diff.rej b/fetch_patch_output/diff_output/841cae881066f0dd38d15a90cfcf245b0db9fc73.diff.rej
deleted file mode 100644
index ee5d2b4..0000000
--- a/fetch_patch_output/diff_output/841cae881066f0dd38d15a90cfcf245b0db9fc73.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff b/fetch_patch_output/diff_output/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff
deleted file mode 100644
index 89d9e7a..0000000
--- a/fetch_patch_output/diff_output/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff
+++ /dev/null
@@ -1,41 +0,0 @@
-diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
-index c606bca1eb4efd384c0ddd9353787e43f3f275fb..398abd77304dbc28fd135d40b079ba4440bdbcf8 100644
---- a/drivers/gpu/msm/kgsl.c
-+++ b/drivers/gpu/msm/kgsl.c
-@@ -3877,6 +3877,8 @@ static int kgsl_update_fault_details(struct kgsl_context *context,
- 		memcpy(&faults[fault.type], &fault, sizeof(fault));
- 	}
- 
-+	mutex_lock(&context->fault_lock);
-+
- 	list_for_each_entry(fault_node, &context->faults, node) {
- 		u32 fault_type = fault_node->type;
- 
-@@ -3894,12 +3896,15 @@ static int kgsl_update_fault_details(struct kgsl_context *context,
- 			cur_idx[fault_type] * faults[fault_type].size),
- 			fault_node->priv, size)) {
- 			ret = -EFAULT;
--			goto err;
-+			goto release_lock;
- 		}
- 
- 		cur_idx[fault_type] += 1;
- 	}
- 
-+release_lock:
-+	mutex_unlock(&context->fault_lock);
-+
- err:
- 	kfree(faults);
- 	return ret;
-@@ -3913,8 +3918,10 @@ static int kgsl_update_fault_count(struct kgsl_context *context,
- 	struct kgsl_fault_node *fault_node;
- 	int i, j;
- 
-+	mutex_lock(&context->fault_lock);
- 	list_for_each_entry(fault_node, &context->faults, node)
- 		faultcount[fault_node->type]++;
-+	mutex_unlock(&context->fault_lock);
- 
- 	/* KGSL_FAULT_TYPE_NO_FAULT (i.e. 0) is not an actual fault type */
- 	for (i = 0, j = 1; i < faultnents && j < KGSL_FAULT_TYPE_MAX; j++) {
diff --git a/fetch_patch_output/diff_output/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff.rej b/fetch_patch_output/diff_output/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff.rej
deleted file mode 100644
index 6d531a0..0000000
--- a/fetch_patch_output/diff_output/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff.rej
+++ /dev/null
@@ -1,260 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff b/fetch_patch_output/diff_output/94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff
deleted file mode 100644
index 1263fd2..0000000
--- a/fetch_patch_output/diff_output/94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff
+++ /dev/null
@@ -1,120 +0,0 @@
-diff --git a/include/net/af_unix.h b/include/net/af_unix.h
-index 480fa579..af4646f 100644
---- a/include/net/af_unix.h
-+++ b/include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
-diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
-index 6dbeb80..6757d11 100644
---- a/net/unix/af_unix.c
-+++ b/net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
-diff --git a/net/unix/garbage.c b/net/unix/garbage.c
-index dc27635..312474c 100644
---- a/net/unix/garbage.c
-+++ b/net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
-diff --git a/net/unix/scm.c b/net/unix/scm.c
-index e8e2a00..bdcda4e 100644
---- a/net/unix/scm.c
-+++ b/net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
diff --git a/fetch_patch_output/diff_output/94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff.rej b/fetch_patch_output/diff_output/94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff.rej
deleted file mode 100644
index d1ad7b0..0000000
--- a/fetch_patch_output/diff_output/94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff.rej
+++ /dev/null
@@ -1,238 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/9b0dadc811eb0140a61734cde73498c1dd574fa1.diff b/fetch_patch_output/diff_output/9b0dadc811eb0140a61734cde73498c1dd574fa1.diff
deleted file mode 100644
index 08fb018..0000000
--- a/fetch_patch_output/diff_output/9b0dadc811eb0140a61734cde73498c1dd574fa1.diff
+++ /dev/null
@@ -1,160 +0,0 @@
-diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
-index 88ff7bb..dd7c0b3 100644
---- a/include/net/dst_ops.h
-+++ b/include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
-diff --git a/include/net/sock.h b/include/net/sock.h
-index 90bee06c..a66cd03 100644
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -2088,17 +2088,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
-diff --git a/net/ipv4/route.c b/net/ipv4/route.c
-index 12c59d7..09287d5 100644
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -139,7 +139,8 @@ struct dst_entry	*ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -844,22 +845,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
-diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index 7669355..7218656 100644
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -87,7 +87,8 @@ struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2763,24 +2764,24 @@ INDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,
- }
- EXPORT_INDIRECT_CALLABLE(ip6_dst_check);
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
-diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
-index b0a19cc..5de1b6e 100644
---- a/net/xfrm/xfrm_policy.c
-+++ b/net/xfrm/xfrm_policy.c
-@@ -3768,15 +3768,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
diff --git a/fetch_patch_output/diff_output/9b0dadc811eb0140a61734cde73498c1dd574fa1.diff.rej b/fetch_patch_output/diff_output/9b0dadc811eb0140a61734cde73498c1dd574fa1.diff.rej
deleted file mode 100644
index fe259d7..0000000
--- a/fetch_patch_output/diff_output/9b0dadc811eb0140a61734cde73498c1dd574fa1.diff.rej
+++ /dev/null
@@ -1,434 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/dst_ops.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/xfrm/xfrm_policy.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- include/net/dst_ops.h
-+++ include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
---- include/net/sock.h
-+++ include/net/sock.h
-@@ -2088,17 +2088,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/ipv4/route.c
-+++ net/ipv4/route.c
-@@ -139,7 +139,8 @@ struct dst_entry	*ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -844,22 +845,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
---- net/ipv6/route.c
-+++ net/ipv6/route.c
-@@ -87,7 +87,8 @@ struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2763,24 +2764,24 @@ INDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,
- }
- EXPORT_INDIRECT_CALLABLE(ip6_dst_check);
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
---- net/xfrm/xfrm_policy.c
-+++ net/xfrm/xfrm_policy.c
-@@ -3768,15 +3768,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
-
diff --git a/fetch_patch_output/diff_output/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff b/fetch_patch_output/diff_output/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff
deleted file mode 100644
index b6e3391..0000000
--- a/fetch_patch_output/diff_output/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index 2d0fae7..17c508da 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3486,6 +3486,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff.rej b/fetch_patch_output/diff_output/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff.rej
deleted file mode 100644
index fed46ad..0000000
--- a/fetch_patch_output/diff_output/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3486,6 +3486,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/b42ed94769088450987f2b52f41a3fb274244827.diff b/fetch_patch_output/diff_output/b42ed94769088450987f2b52f41a3fb274244827.diff
deleted file mode 100644
index 27ac78e..0000000
--- a/fetch_patch_output/diff_output/b42ed94769088450987f2b52f41a3fb274244827.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index da7bf56..6570587 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3636,6 +3636,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/b42ed94769088450987f2b52f41a3fb274244827.diff.rej b/fetch_patch_output/diff_output/b42ed94769088450987f2b52f41a3fb274244827.diff.rej
deleted file mode 100644
index 2641ef8..0000000
--- a/fetch_patch_output/diff_output/b42ed94769088450987f2b52f41a3fb274244827.diff.rej
+++ /dev/null
@@ -1,277 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -1915,8 +1915,10 @@ static size_t binder_get_object(struct binder_proc *proc,
- 	size_t object_size = 0;
- 
- 	read_size = min_t(size_t, sizeof(*object), buffer->data_size - offset);
--	if (offset > buffer->data_size || read_size < sizeof(*hdr))
-+	if (offset > buffer->data_size || read_size < sizeof(*hdr) ||
-+	    !IS_ALIGNED(offset, sizeof(u32)))
- 		return 0;
-+
- 	if (u) {
- 		if (copy_from_user(object, u + offset, read_size))
- 			return 0;
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/b8932254b9b2f02620e96572fee9c615c1db2bc3.diff b/fetch_patch_output/diff_output/b8932254b9b2f02620e96572fee9c615c1db2bc3.diff
deleted file mode 100644
index c809513..0000000
--- a/fetch_patch_output/diff_output/b8932254b9b2f02620e96572fee9c615c1db2bc3.diff
+++ /dev/null
@@ -1,160 +0,0 @@
-diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
-index 88ff7bb..dd7c0b3 100644
---- a/include/net/dst_ops.h
-+++ b/include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
-diff --git a/include/net/sock.h b/include/net/sock.h
-index 741f779..558f026 100644
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -2083,17 +2083,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
-diff --git a/net/ipv4/route.c b/net/ipv4/route.c
-index 12c59d7..09287d5 100644
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -139,7 +139,8 @@ struct dst_entry	*ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -844,22 +845,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
-diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index 7669355..7218656 100644
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -87,7 +87,8 @@ struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2763,24 +2764,24 @@ INDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,
- }
- EXPORT_INDIRECT_CALLABLE(ip6_dst_check);
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
-diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
-index b0a19cc..5de1b6e 100644
---- a/net/xfrm/xfrm_policy.c
-+++ b/net/xfrm/xfrm_policy.c
-@@ -3768,15 +3768,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
diff --git a/fetch_patch_output/diff_output/b8932254b9b2f02620e96572fee9c615c1db2bc3.diff.rej b/fetch_patch_output/diff_output/b8932254b9b2f02620e96572fee9c615c1db2bc3.diff.rej
deleted file mode 100644
index 7636a70..0000000
--- a/fetch_patch_output/diff_output/b8932254b9b2f02620e96572fee9c615c1db2bc3.diff.rej
+++ /dev/null
@@ -1,434 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/dst_ops.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/xfrm/xfrm_policy.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- include/net/dst_ops.h
-+++ include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
---- include/net/sock.h
-+++ include/net/sock.h
-@@ -2083,17 +2083,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/ipv4/route.c
-+++ net/ipv4/route.c
-@@ -139,7 +139,8 @@ struct dst_entry	*ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -844,22 +845,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
---- net/ipv6/route.c
-+++ net/ipv6/route.c
-@@ -87,7 +87,8 @@ struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2763,24 +2764,24 @@ INDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,
- }
- EXPORT_INDIRECT_CALLABLE(ip6_dst_check);
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
---- net/xfrm/xfrm_policy.c
-+++ net/xfrm/xfrm_policy.c
-@@ -3768,15 +3768,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
-
diff --git a/fetch_patch_output/diff_output/bce004fba8be9e1bb575301f398b3ecc27ba42de.diff b/fetch_patch_output/diff_output/bce004fba8be9e1bb575301f398b3ecc27ba42de.diff
deleted file mode 100644
index 4bd3173..0000000
--- a/fetch_patch_output/diff_output/bce004fba8be9e1bb575301f398b3ecc27ba42de.diff
+++ /dev/null
@@ -1,139 +0,0 @@
-diff --git a/mm/mremap.c b/mm/mremap.c
-index 5eb3bc2..73d838b 100644
---- a/mm/mremap.c
-+++ b/mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -305,6 +265,24 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 	if (new_ptl != old_ptl)
- 		spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
- 
-+	/*
-+	 * If SPF is enabled, take the ptl lock on the source page table
-+	 * page, to prevent the entire pmd from being moved under a
-+	 * concurrent SPF.
-+	 *
-+	 * There is no need to take the destination ptl lock since, mremap
-+	 * has already created a hole at the destination and freed the
-+	 * corresponding page tables in the process.
-+	 *
-+	 * NOTE: If USE_SPLIT_PTE_PTLOCKS is false, then the old_ptl, new_ptl,
-+	 * and the old_pte_ptl; are all the same lock (mm->page_table_lock).
-+	 * Check that the locks are different to avoid a deadlock.
-+	 */
-+	old_pte_ptl = pte_lockptr(mm, old_pmd);
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_lock(old_pte_ptl);
-+
-+
- 	/* Clear the pmd */
- 	pmd = *old_pmd;
- 	pmd_clear(old_pmd);
-@@ -313,11 +291,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -329,7 +309,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -347,14 +328,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -375,7 +348,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
diff --git a/fetch_patch_output/diff_output/bce004fba8be9e1bb575301f398b3ecc27ba42de.diff.rej b/fetch_patch_output/diff_output/bce004fba8be9e1bb575301f398b3ecc27ba42de.diff.rej
deleted file mode 100644
index 0634d9f..0000000
--- a/fetch_patch_output/diff_output/bce004fba8be9e1bb575301f398b3ecc27ba42de.diff.rej
+++ /dev/null
@@ -1,117 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
diff --git a/fetch_patch_output/diff_output/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff b/fetch_patch_output/diff_output/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff
deleted file mode 100644
index 00fc267..0000000
--- a/fetch_patch_output/diff_output/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff
+++ /dev/null
@@ -1,160 +0,0 @@
-diff --git a/include/net/dst_ops.h b/include/net/dst_ops.h
-index 88ff7bb..dd7c0b3 100644
---- a/include/net/dst_ops.h
-+++ b/include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
-diff --git a/include/net/sock.h b/include/net/sock.h
-index 239c15f..7f9d5c9 100644
---- a/include/net/sock.h
-+++ b/include/net/sock.h
-@@ -2215,17 +2215,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
-diff --git a/net/ipv4/route.c b/net/ipv4/route.c
-index 474f391..abd8661 100644
---- a/net/ipv4/route.c
-+++ b/net/ipv4/route.c
-@@ -132,7 +132,8 @@ struct dst_entry	*ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -837,22 +838,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
-diff --git a/net/ipv6/route.c b/net/ipv6/route.c
-index af4fe30..8d88b46 100644
---- a/net/ipv6/route.c
-+++ b/net/ipv6/route.c
-@@ -87,7 +87,8 @@ struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2762,24 +2763,24 @@ INDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,
- }
- EXPORT_INDIRECT_CALLABLE(ip6_dst_check);
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
-diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
-index 1adfb27..e0ac396 100644
---- a/net/xfrm/xfrm_policy.c
-+++ b/net/xfrm/xfrm_policy.c
-@@ -3774,15 +3774,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
diff --git a/fetch_patch_output/diff_output/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff.rej b/fetch_patch_output/diff_output/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff.rej
deleted file mode 100644
index 9652e19..0000000
--- a/fetch_patch_output/diff_output/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff.rej
+++ /dev/null
@@ -1,434 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/dst_ops.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/xfrm/xfrm_policy.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3460,6 +3460,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- include/net/dst_ops.h
-+++ include/net/dst_ops.h
-@@ -24,7 +24,7 @@ struct dst_ops {
- 	void			(*destroy)(struct dst_entry *);
- 	void			(*ifdown)(struct dst_entry *,
- 					  struct net_device *dev, int how);
--	struct dst_entry *	(*negative_advice)(struct dst_entry *);
-+	void			(*negative_advice)(struct sock *sk, struct dst_entry *);
- 	void			(*link_failure)(struct sk_buff *);
- 	void			(*update_pmtu)(struct dst_entry *dst, struct sock *sk,
- 					       struct sk_buff *skb, u32 mtu,
-
---- include/net/sock.h
-+++ include/net/sock.h
-@@ -2215,17 +2215,10 @@ sk_dst_get(struct sock *sk)
- 
- static inline void __dst_negative_advice(struct sock *sk)
- {
--	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
-+	struct dst_entry *dst = __sk_dst_get(sk);
- 
--	if (dst && dst->ops->negative_advice) {
--		ndst = dst->ops->negative_advice(dst);
--
--		if (ndst != dst) {
--			rcu_assign_pointer(sk->sk_dst_cache, ndst);
--			sk_tx_queue_clear(sk);
--			WRITE_ONCE(sk->sk_dst_pending_confirm, 0);
--		}
--	}
-+	if (dst && dst->ops->negative_advice)
-+		dst->ops->negative_advice(sk, dst);
- }
- 
- static inline void dst_negative_advice(struct sock *sk)
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/ipv4/route.c
-+++ net/ipv4/route.c
-@@ -132,7 +132,8 @@ struct dst_entry	*ipv4_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ipv4_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ipv4_mtu(const struct dst_entry *dst);
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
-+static void		ipv4_negative_advice(struct sock *sk,
-+					     struct dst_entry *dst);
- static void		 ipv4_link_failure(struct sk_buff *skb);
- static void		 ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
- 					   struct sk_buff *skb, u32 mtu,
-@@ -837,22 +838,15 @@ static void ip_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buf
- 	__ip_do_redirect(rt, skb, &fl4, true);
- }
- 
--static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst)
-+static void ipv4_negative_advice(struct sock *sk,
-+				 struct dst_entry *dst)
- {
- 	struct rtable *rt = (struct rtable *)dst;
--	struct dst_entry *ret = dst;
- 
--	if (rt) {
--		if (dst->obsolete > 0) {
--			ip_rt_put(rt);
--			ret = NULL;
--		} else if ((rt->rt_flags & RTCF_REDIRECTED) ||
--			   rt->dst.expires) {
--			ip_rt_put(rt);
--			ret = NULL;
--		}
--	}
--	return ret;
-+	if ((dst->obsolete > 0) ||
-+	    (rt->rt_flags & RTCF_REDIRECTED) ||
-+	    rt->dst.expires)
-+		sk_dst_reset(sk);
- }
- 
- /*
-
---- net/ipv6/route.c
-+++ net/ipv6/route.c
-@@ -87,7 +87,8 @@ struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
- static unsigned int	 ip6_default_advmss(const struct dst_entry *dst);
- INDIRECT_CALLABLE_SCOPE
- unsigned int		ip6_mtu(const struct dst_entry *dst);
--static struct dst_entry *ip6_negative_advice(struct dst_entry *);
-+static void		ip6_negative_advice(struct sock *sk,
-+					    struct dst_entry *dst);
- static void		ip6_dst_destroy(struct dst_entry *);
- static void		ip6_dst_ifdown(struct dst_entry *,
- 				       struct net_device *dev, int how);
-@@ -2762,24 +2763,24 @@ INDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,
- }
- EXPORT_INDIRECT_CALLABLE(ip6_dst_check);
- 
--static struct dst_entry *ip6_negative_advice(struct dst_entry *dst)
-+static void ip6_negative_advice(struct sock *sk,
-+				struct dst_entry *dst)
- {
- 	struct rt6_info *rt = (struct rt6_info *) dst;
- 
--	if (rt) {
--		if (rt->rt6i_flags & RTF_CACHE) {
--			rcu_read_lock();
--			if (rt6_check_expired(rt)) {
--				rt6_remove_exception_rt(rt);
--				dst = NULL;
--			}
--			rcu_read_unlock();
--		} else {
--			dst_release(dst);
--			dst = NULL;
-+	if (rt->rt6i_flags & RTF_CACHE) {
-+		rcu_read_lock();
-+		if (rt6_check_expired(rt)) {
-+			/* counteract the dst_release() in sk_dst_reset() */
-+			dst_hold(dst);
-+			sk_dst_reset(sk);
-+
-+			rt6_remove_exception_rt(rt);
- 		}
-+		rcu_read_unlock();
-+		return;
- 	}
--	return dst;
-+	sk_dst_reset(sk);
- }
- 
- static void ip6_link_failure(struct sk_buff *skb)
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
---- net/xfrm/xfrm_policy.c
-+++ net/xfrm/xfrm_policy.c
-@@ -3774,15 +3774,10 @@ static void xfrm_link_failure(struct sk_buff *skb)
- 	/* Impossible. Such dst must be popped before reaches point of failure. */
- }
- 
--static struct dst_entry *xfrm_negative_advice(struct dst_entry *dst)
-+static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)
- {
--	if (dst) {
--		if (dst->obsolete) {
--			dst_release(dst);
--			dst = NULL;
--		}
--	}
--	return dst;
-+	if (dst->obsolete)
-+		sk_dst_reset(sk);
- }
- 
- static void xfrm_init_pmtu(struct xfrm_dst **bundle, int nr)
-
diff --git a/fetch_patch_output/diff_output/bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff b/fetch_patch_output/diff_output/bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff
deleted file mode 100644
index 4f6aa51..0000000
--- a/fetch_patch_output/diff_output/bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff
+++ /dev/null
@@ -1,16 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index 57295e6..29f6a1b 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -1915,8 +1915,10 @@ static size_t binder_get_object(struct binder_proc *proc,
- 	size_t object_size = 0;
- 
- 	read_size = min_t(size_t, sizeof(*object), buffer->data_size - offset);
--	if (offset > buffer->data_size || read_size < sizeof(*hdr))
-+	if (offset > buffer->data_size || read_size < sizeof(*hdr) ||
-+	    !IS_ALIGNED(offset, sizeof(u32)))
- 		return 0;
-+
- 	if (u) {
- 		if (copy_from_user(object, u + offset, read_size))
- 			return 0;
diff --git a/fetch_patch_output/diff_output/bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff.rej b/fetch_patch_output/diff_output/bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff.rej
deleted file mode 100644
index 2641ef8..0000000
--- a/fetch_patch_output/diff_output/bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff.rej
+++ /dev/null
@@ -1,277 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -1915,8 +1915,10 @@ static size_t binder_get_object(struct binder_proc *proc,
- 	size_t object_size = 0;
- 
- 	read_size = min_t(size_t, sizeof(*object), buffer->data_size - offset);
--	if (offset > buffer->data_size || read_size < sizeof(*hdr))
-+	if (offset > buffer->data_size || read_size < sizeof(*hdr) ||
-+	    !IS_ALIGNED(offset, sizeof(u32)))
- 		return 0;
-+
- 	if (u) {
- 		if (copy_from_user(object, u + offset, read_size))
- 			return 0;
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff b/fetch_patch_output/diff_output/c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff
deleted file mode 100644
index ce8f98a..0000000
--- a/fetch_patch_output/diff_output/c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff
+++ /dev/null
@@ -1,107 +0,0 @@
-diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
-index 6a7632a83eb42248e39a9b8beb6ce62949f47807..2c88eab6656d0472f3f0d3346e0609173a713072 100644
---- a/drivers/gpu/msm/kgsl.c
-+++ b/drivers/gpu/msm/kgsl.c
-@@ -268,6 +268,7 @@ static struct kgsl_mem_entry *kgsl_mem_entry_create(void)
- 		/* put this ref in userspace memory alloc and map ioctls */
- 		kref_get(&entry->refcount);
- 		atomic_set(&entry->map_count, 0);
-+		atomic_set(&entry->vbo_count, 0);
- 	}
- 
- 	return entry;
-diff --git a/drivers/gpu/msm/kgsl.h b/drivers/gpu/msm/kgsl.h
-index a47e91bc6845ba349de5f456126b1b73f8baf37c..288fa83ff262fb7f43a92dc829dc18e65ab891df 100644
---- a/drivers/gpu/msm/kgsl.h
-+++ b/drivers/gpu/msm/kgsl.h
-@@ -1,7 +1,7 @@
- /* SPDX-License-Identifier: GPL-2.0-only */
- /*
-  * Copyright (c) 2008-2021, The Linux Foundation. All rights reserved.
-- * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2022-2024, Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- #ifndef __KGSL_H
- #define __KGSL_H
-@@ -350,6 +350,8 @@ struct kgsl_mem_entry {
- 	 * debugfs accounting
- 	 */
- 	atomic_t map_count;
-+	/** @vbo_count: Count how many VBO ranges this entry is mapped in */
-+	atomic_t vbo_count;
- };
- 
- struct kgsl_device_private;
-diff --git a/drivers/gpu/msm/kgsl_reclaim.c b/drivers/gpu/msm/kgsl_reclaim.c
-index 4b38b5501eeda74bcc268813eae737aa78466300..3c24c3eed534aa1a41177400d151461386bde294 100644
---- a/drivers/gpu/msm/kgsl_reclaim.c
-+++ b/drivers/gpu/msm/kgsl_reclaim.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: GPL-2.0-only
- /*
-  * Copyright (c) 2021, The Linux Foundation. All rights reserved.
-- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2022, 2024 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/kthread.h>
-@@ -266,6 +266,13 @@ static u32 kgsl_reclaim_process(struct kgsl_process_private *process,
- 			continue;
- 		}
- 
-+		/* Do not reclaim pages mapped into a VBO */
-+		if (atomic_read(&valid_entry->vbo_count)) {
-+			kgsl_mem_entry_put(entry);
-+			next++;
-+			continue;
-+		}
-+
- 		if ((atomic_read(&process->unpinned_page_count) +
- 			memdesc->page_count) > kgsl_reclaim_max_page_limit) {
- 			kgsl_mem_entry_put(entry);
-diff --git a/drivers/gpu/msm/kgsl_vbo.c b/drivers/gpu/msm/kgsl_vbo.c
-index 2ab97c3f5ba0ab104b6d336c43345c4fdcfe803b..551822ba98daf1b11a835b35c47642924dadd280 100644
---- a/drivers/gpu/msm/kgsl_vbo.c
-+++ b/drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
- 
-@@ -309,8 +313,12 @@ static void kgsl_sharedmem_free_bind_op(struct kgsl_sharedmem_bind_op *op)
- 	if (IS_ERR_OR_NULL(op))
- 		return;
- 
--	for (i = 0; i < op->nr_ops; i++)
-+	for (i = 0; i < op->nr_ops; i++) {
-+		/* Decrement the vbo_count we added when creating the bind_op */
-+		if (op->ops[i].entry)
-+			atomic_dec(&op->ops[i].entry->vbo_count);
- 		kgsl_mem_entry_put(op->ops[i].entry);
-+	}
- 
- 	kgsl_mem_entry_put(op->target);
- 
-@@ -416,6 +424,9 @@ kgsl_sharedmem_create_bind_op(struct kgsl_process_private *private,
- 			goto err;
- 		}
- 
-+		/* Keep the child pinned in memory */
-+		atomic_inc(&entry->vbo_count);
-+
- 		/* Make sure the child is not a VBO */
- 		if ((entry->memdesc.flags & KGSL_MEMFLAGS_VBO)) {
- 			ret = -EINVAL;
diff --git a/fetch_patch_output/diff_output/c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff.rej b/fetch_patch_output/diff_output/c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff.rej
deleted file mode 100644
index 6d531a0..0000000
--- a/fetch_patch_output/diff_output/c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff.rej
+++ /dev/null
@@ -1,260 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/c2201dde2a76788b5b7a75426e53a58e1490a028.diff b/fetch_patch_output/diff_output/c2201dde2a76788b5b7a75426e53a58e1490a028.diff
deleted file mode 100644
index 5033a61..0000000
--- a/fetch_patch_output/diff_output/c2201dde2a76788b5b7a75426e53a58e1490a028.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index a09270e..aae0acb 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3436,6 +3436,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/c2201dde2a76788b5b7a75426e53a58e1490a028.diff.rej b/fetch_patch_output/diff_output/c2201dde2a76788b5b7a75426e53a58e1490a028.diff.rej
deleted file mode 100644
index 2b944d2..0000000
--- a/fetch_patch_output/diff_output/c2201dde2a76788b5b7a75426e53a58e1490a028.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3436,6 +3436,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/f4e5b5151e55932279287c55d4e4a801fbf1df96.diff b/fetch_patch_output/diff_output/f4e5b5151e55932279287c55d4e4a801fbf1df96.diff
deleted file mode 100644
index 10a073d..0000000
--- a/fetch_patch_output/diff_output/f4e5b5151e55932279287c55d4e4a801fbf1df96.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/drivers/android/binder.c b/drivers/android/binder.c
-index 9a1151c..28117dd 100644
---- a/drivers/android/binder.c
-+++ b/drivers/android/binder.c
-@@ -3326,6 +3326,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
diff --git a/fetch_patch_output/diff_output/f4e5b5151e55932279287c55d4e4a801fbf1df96.diff.rej b/fetch_patch_output/diff_output/f4e5b5151e55932279287c55d4e4a801fbf1df96.diff.rej
deleted file mode 100644
index 37ac59f..0000000
--- a/fetch_patch_output/diff_output/f4e5b5151e55932279287c55d4e4a801fbf1df96.diff.rej
+++ /dev/null
@@ -1,273 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/android/binder.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/af_unix.h.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/af_unix.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/garbage.c.rej
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/unix/scm.c.rej
-
---- drivers/android/binder.c
-+++ drivers/android/binder.c
-@@ -3326,6 +3326,7 @@ static void binder_transaction(struct binder_proc *proc,
- 		 */
- 		copy_size = object_offset - user_offset;
- 		if (copy_size && (user_offset > object_offset ||
-+				object_offset > tr->data_size ||
- 				binder_alloc_copy_user_to_buffer(
- 					&target_proc->alloc,
- 					t->buffer, user_offset,
-
---- drivers/gpu/msm/kgsl_vbo.c
-+++ drivers/gpu/msm/kgsl_vbo.c
-@@ -43,12 +43,16 @@ static struct kgsl_memdesc_bind_range *bind_range_create(u64 start, u64 last,
- 		return ERR_PTR(-EINVAL);
- 	}
- 
-+	atomic_inc(&entry->vbo_count);
- 	return range;
- }
- 
- static void bind_range_destroy(struct kgsl_memdesc_bind_range *range)
- {
--	kgsl_mem_entry_put(range->entry);
-+	struct kgsl_mem_entry *entry = range->entry;
-+
-+	atomic_dec(&entry->vbo_count);
-+	kgsl_mem_entry_put(entry);
- 	kfree(range);
- }
-
---- include/net/af_unix.h
-+++ include/net/af_unix.h
-@@ -60,7 +60,7 @@ struct unix_sock {
- 	struct mutex		iolock, bindlock;
- 	struct sock		*peer;
- 	struct list_head	link;
--	atomic_long_t		inflight;
-+	unsigned long		inflight;
- 	spinlock_t		lock;
- 	unsigned long		gc_flags;
- #define UNIX_GC_CANDIDATE	0
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -331,11 +309,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -347,7 +327,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -365,14 +346,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -393,7 +366,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-
---- net/unix/af_unix.c
-+++ net/unix/af_unix.c
-@@ -970,11 +970,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock, int kern,
- 	sk->sk_write_space	= unix_write_space;
- 	sk->sk_max_ack_backlog	= net->unx.sysctl_max_dgram_qlen;
- 	sk->sk_destruct		= unix_sock_destructor;
--	u	  = unix_sk(sk);
-+	u = unix_sk(sk);
-+	u->inflight = 0;
- 	u->path.dentry = NULL;
- 	u->path.mnt = NULL;
- 	spin_lock_init(&u->lock);
--	atomic_long_set(&u->inflight, 0);
- 	INIT_LIST_HEAD(&u->link);
- 	mutex_init(&u->iolock); /* single task reading lock */
- 	mutex_init(&u->bindlock); /* single task binding lock */
-
---- net/unix/garbage.c
-+++ net/unix/garbage.c
-@@ -166,17 +166,18 @@ static void scan_children(struct sock *x, void (*func)(struct unix_sock *),
- 
- static void dec_inflight(struct unix_sock *usk)
- {
--	atomic_long_dec(&usk->inflight);
-+	usk->inflight--;
- }
- 
- static void inc_inflight(struct unix_sock *usk)
- {
--	atomic_long_inc(&usk->inflight);
-+	usk->inflight++;
- }
- 
- static void inc_inflight_move_tail(struct unix_sock *u)
- {
--	atomic_long_inc(&u->inflight);
-+	u->inflight++;
-+
- 	/* If this still might be part of a cycle, move it to the end
- 	 * of the list, so that it's checked even if it was already
- 	 * passed over
-@@ -237,14 +238,12 @@ void unix_gc(void)
- 	 */
- 	list_for_each_entry_safe(u, next, &gc_inflight_list, link) {
- 		long total_refs;
--		long inflight_refs;
- 
- 		total_refs = file_count(u->sk.sk_socket->file);
--		inflight_refs = atomic_long_read(&u->inflight);
- 
--		BUG_ON(inflight_refs < 1);
--		BUG_ON(total_refs < inflight_refs);
--		if (total_refs == inflight_refs) {
-+		BUG_ON(!u->inflight);
-+		BUG_ON(total_refs < u->inflight);
-+		if (total_refs == u->inflight) {
- 			list_move_tail(&u->link, &gc_candidates);
- 			__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);
- 			__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
-@@ -271,7 +270,7 @@ void unix_gc(void)
- 		/* Move cursor to after the current position. */
- 		list_move(&cursor, &u->link);
- 
--		if (atomic_long_read(&u->inflight) > 0) {
-+		if (u->inflight) {
- 			list_move_tail(&u->link, &not_cycle_list);
- 			__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);
- 			scan_children(&u->sk, inc_inflight_move_tail, NULL);
-
---- net/unix/scm.c
-+++ net/unix/scm.c
-@@ -54,12 +54,13 @@ void unix_inflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		if (atomic_long_inc_return(&u->inflight) == 1) {
-+		if (!u->inflight) {
- 			BUG_ON(!list_empty(&u->link));
- 			list_add_tail(&u->link, &gc_inflight_list);
- 		} else {
- 			BUG_ON(list_empty(&u->link));
- 		}
-+		u->inflight++;
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);
- 	}
-@@ -76,10 +77,11 @@ void unix_notinflight(struct user_struct *user, struct file *fp)
- 	if (s) {
- 		struct unix_sock *u = unix_sk(s);
- 
--		BUG_ON(!atomic_long_read(&u->inflight));
-+		BUG_ON(!u->inflight);
- 		BUG_ON(list_empty(&u->link));
- 
--		if (atomic_long_dec_and_test(&u->inflight))
-+		u->inflight--;
-+		if (!u->inflight)
- 			list_del_init(&u->link);
- 		/* Paired with READ_ONCE() in wait_for_unix_gc() */
- 		WRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);
-
diff --git a/fetch_patch_output/diff_output/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff b/fetch_patch_output/diff_output/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff
deleted file mode 100644
index 4bd3173..0000000
--- a/fetch_patch_output/diff_output/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff
+++ /dev/null
@@ -1,139 +0,0 @@
-diff --git a/mm/mremap.c b/mm/mremap.c
-index 5eb3bc2..73d838b 100644
---- a/mm/mremap.c
-+++ b/mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -289,14 +257,6 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -305,6 +265,24 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 	if (new_ptl != old_ptl)
- 		spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
- 
-+	/*
-+	 * If SPF is enabled, take the ptl lock on the source page table
-+	 * page, to prevent the entire pmd from being moved under a
-+	 * concurrent SPF.
-+	 *
-+	 * There is no need to take the destination ptl lock since, mremap
-+	 * has already created a hole at the destination and freed the
-+	 * corresponding page tables in the process.
-+	 *
-+	 * NOTE: If USE_SPLIT_PTE_PTLOCKS is false, then the old_ptl, new_ptl,
-+	 * and the old_pte_ptl; are all the same lock (mm->page_table_lock).
-+	 * Check that the locks are different to avoid a deadlock.
-+	 */
-+	old_pte_ptl = pte_lockptr(mm, old_pmd);
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_lock(old_pte_ptl);
-+
-+
- 	/* Clear the pmd */
- 	pmd = *old_pmd;
- 	pmd_clear(old_pmd);
-@@ -313,11 +291,13 @@ static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 
- 	pmd_populate(mm, new_pmd, pmd_pgtable(pmd));
- 	flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);
-+
-+	if (IS_ENABLED(CONFIG_SPECULATIVE_PAGE_FAULT) && old_pte_ptl != old_ptl)
-+		spin_unlock(old_pte_ptl);
- 	if (new_ptl != old_ptl)
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
-@@ -329,7 +309,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-@@ -347,14 +328,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		return false;
- 
- 	/*
--	 * We hold both exclusive mmap_lock and rmap_lock at this point and
--	 * cannot block. If we cannot immediately take exclusive ownership
--	 * of the VMA fallback to the move_ptes().
--	 */
--	if (!trylock_vma_ref_count(vma))
--		return false;
--
--	/*
- 	 * We don't have to worry about the ordering of src and dst
- 	 * ptlocks because exclusive mmap_lock prevents deadlock.
- 	 */
-@@ -375,7 +348,6 @@ static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		spin_unlock(new_ptl);
- 	spin_unlock(old_ptl);
- 
--	unlock_vma_ref_count(vma);
- 	return true;
- }
- #else
diff --git a/fetch_patch_output/diff_output/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff.rej b/fetch_patch_output/diff_output/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff.rej
deleted file mode 100644
index 12132fa..0000000
--- a/fetch_patch_output/diff_output/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff.rej
+++ /dev/null
@@ -1,64 +0,0 @@
-# Combined .rej files:
-
-# /Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej
-
---- mm/mremap.c
-+++ mm/mremap.c
-@@ -219,44 +219,12 @@ static inline bool arch_supports_page_table_move(void)
- }
- #endif
- 
--#ifdef CONFIG_SPECULATIVE_PAGE_FAULT
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	/*
--	 * If we have the only reference, swap the refcount to -1. This
--	 * will prevent other concurrent references by get_vma() for SPFs.
--	 */
--	return atomic_cmpxchg_acquire(&vma->file_ref_count, 0, -1) == 0;
--}
--
--/*
-- * Restore the VMA reference count to 1 after a fast mremap.
-- */
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--	int old = atomic_xchg_release(&vma->file_ref_count, 0);
--
--	/*
--	 * This should only be called after a corresponding,
--	 * successful trylock_vma_ref_count().
--	 */
--	VM_BUG_ON_VMA(old != -1, vma);
--}
--#else	/* !CONFIG_SPECULATIVE_PAGE_FAULT */
--static inline bool trylock_vma_ref_count(struct vm_area_struct *vma)
--{
--	return true;
--}
--static inline void unlock_vma_ref_count(struct vm_area_struct *vma)
--{
--}
--#endif	/* CONFIG_SPECULATIVE_PAGE_FAULT */
--
- #ifdef CONFIG_HAVE_MOVE_PMD
- static bool move_normal_pmd(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pmd_t *old_pmd, pmd_t *new_pmd)
- {
--	spinlock_t *old_ptl, *new_ptl;
-+	spinlock_t *old_ptl, *new_ptl, *old_pte_ptl;
-+
- 	struct mm_struct *mm = vma->vm_mm;
- 	pmd_t pmd;
- 
-@@ -341,7 +321,8 @@ static inline bool move_normal_pmd(struct vm_area_struct *vma,
- }
- #endif
- 
--#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD)
-+#if CONFIG_PGTABLE_LEVELS > 2 && defined(CONFIG_HAVE_MOVE_PUD) && \
-+		!defined(CONFIG_SPECULATIVE_PAGE_FAULT)
- static bool move_normal_pud(struct vm_area_struct *vma, unsigned long old_addr,
- 		  unsigned long new_addr, pud_t *old_pud, pud_t *new_pud)
- {
-
diff --git a/llm_integration/failed_patch.json b/llm_integration/failed_patch.json
index 42dd128..6b9da51 100644
--- a/llm_integration/failed_patch.json
+++ b/llm_integration/failed_patch.json
@@ -1,16 +1,138 @@
 {
-  "patch": [
+  "patches": [
     {
-      "patch_file": "f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff",
-      "patch_url": "https://android.googlesource.com/kernel/common/+/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2",
+      "patch_file": "212b4d3a42674d2cf366bd7b06fe9faae03477fc.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/212b4d3a42674d2cf366bd7b06fe9faae03477fc",
       "status": "Rejected",
       "rejected_files": [
         {
-          "failed_file": "mm/mremap.c",
-          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej"
+          "failed_file": "drivers/staging/android/ion/ion.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/staging/android/ion/ion.c.rej"
         }
       ],
-      "message_output": "patching file mm/mremap.c\nHunk #1 FAILED at 219.\nHunk #2 succeeded at 277 (offset -12 lines).\nHunk #3 succeeded at 285 (offset -12 lines).\nHunk #4 succeeded at 312 with fuzz 2 (offset -11 lines).\nHunk #5 FAILED at 341.\nHunk #6 succeeded at 346 (offset -13 lines).\nHunk #7 succeeded at 367 (offset -12 lines).\n2 out of 7 hunks FAILED -- saving rejects to file mm/mremap.c.rej\n"
+      "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 FAILED at 323.\nHunk #2 succeeded at 344 (offset -26 lines).\n1 out of 2 hunks FAILED -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
+    },
+    {
+      "patch_file": "41a097c0ed6658bf451c5cf993ab0469eb1ce4a5.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/41a097c0ed6658bf451c5cf993ab0469eb1ce4a5",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/staging/android/ion/ion.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/staging/android/ion/ion.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 FAILED at 969.\n1 out of 1 hunk FAILED -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
+    },
+    {
+      "patch_file": "41a097c0ed6658bf451c5cf993ab0469eb1ce4a5.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/41a097c0ed6658bf451c5cf993ab0469eb1ce4a5",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/staging/android/ion/ion.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/staging/android/ion/ion.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 FAILED at 969.\n1 out of 1 hunk FAILED -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
+    },
+    {
+      "patch_file": "8f66dc1a78a743ea3c3f039500d2aa0cddd776d5.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/8f66dc1a78a743ea3c3f039500d2aa0cddd776d5",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/mmc/core/block.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/mmc/core/block.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/mmc/core/block.c\nHunk #1 FAILED at 1652.\n1 out of 1 hunk FAILED -- saving rejects to file drivers/mmc/core/block.c.rej\n"
+    },
+    {
+      "patch_file": "032a6762957f8.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/032a6762957f8",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/tee/tee_shm.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tee/tee_shm.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/tee/tee_shm.c\nHunk #1 FAILED at 1.\nHunk #2 FAILED at 28.\nHunk #3 FAILED at 64.\nHunk #4 succeeded at 152 with fuzz 2 (offset 15 lines).\nHunk #5 FAILED at 151.\nHunk #6 FAILED at 162.\nHunk #7 succeeded at 266 with fuzz 2 (offset 22 lines).\nHunk #8 FAILED at 305.\nHunk #9 succeeded at 350 (offset 12 lines).\nHunk #10 FAILED at 379.\nHunk #11 succeeded at 403 (offset 11 lines).\nHunk #12 succeeded at 510 (offset 11 lines).\nHunk #13 succeeded at 530 (offset 11 lines).\n7 out of 13 hunks FAILED -- saving rejects to file drivers/tee/tee_shm.c.rej\n"
+    },
+    {
+      "patch_file": "c05d8f66ec347.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c05d8f66ec347",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/tee/tee_shm.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tee/tee_shm.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/tee/tee_shm.c\nHunk #1 FAILED at 1.\nHunk #2 FAILED at 28.\nHunk #3 FAILED at 64.\nHunk #4 FAILED at 137.\nHunk #5 FAILED at 150.\nHunk #6 FAILED at 161.\nHunk #7 FAILED at 243.\nHunk #8 FAILED at 303.\nHunk #9 succeeded at 379 with fuzz 2 (offset 43 lines).\nHunk #10 FAILED at 377.\nHunk #11 FAILED at 390.\nHunk #12 FAILED at 507.\nHunk #13 FAILED at 522.\n12 out of 13 hunks FAILED -- saving rejects to file drivers/tee/tee_shm.c.rej\n"
+    },
+    {
+      "patch_file": "df2c1f38939aa.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/df2c1f38939aa",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/gpu/drm/vgem/vgem_drv.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/drm/vgem/vgem_drv.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/gpu/drm/vgem/vgem_drv.c\nHunk #1 FAILED at 189.\nHunk #2 succeeded at 219 (offset 5 lines).\n1 out of 2 hunks FAILED -- saving rejects to file drivers/gpu/drm/vgem/vgem_drv.c.rej\n"
+    },
+    {
+      "patch_file": "c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/tty/tty_jobctrl.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tty/tty_jobctrl.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/tty/tty_io.c\nHunk #1 succeeded at 2724 (offset -173 lines).\nHunk #2 succeeded at 2763 (offset -173 lines).\npatching file drivers/tty/tty_jobctrl.c\nHunk #4 FAILED at 502.\n1 out of 5 hunks FAILED -- saving rejects to file drivers/tty/tty_jobctrl.c.rej\n"
+    },
+
+    {
+      "patch_file": "90bfdeef83f1d6c696039b6a917190dcbbad3220.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/90bfdeef83f1d6c696039b6a917190dcbbad3220",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/tty/vt/vt_ioctl.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tty/vt/vt_ioctl.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/tty/vt/vt_ioctl.c\nHunk #1 FAILED at 484.\nHunk #2 succeeded at 239 (offset -263 lines).\nHunk #3 FAILED at 519.\nHunk #4 FAILED at 538.\nHunk #5 FAILED at 585.\nHunk #6 FAILED at 594.\nHunk #7 FAILED at 610.\nHunk #8 succeeded at 1072 (offset 5 lines).\nHunk #9 succeeded at 1092 (offset 5 lines).\nHunk #10 succeeded at 1101 (offset 5 lines).\nHunk #11 FAILED at 1186.\n7 out of 11 hunks FAILED -- saving rejects to file drivers/tty/vt/vt_ioctl.c.rej\n"
+    },
+
+    {
+      "patch_file": "a50ef731e0981.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/a50ef731e0981",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "drivers/media/v4l2-core/v4l2-mem2mem.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/media/v4l2-core/v4l2-mem2mem.c.rej"
+        }
+      ],
+      "message_output": "patching file drivers/media/v4l2-core/v4l2-mem2mem.c\nHunk #1 FAILED at 585.\nHunk #2 succeeded at 380 (offset -225 lines).\nHunk #3 succeeded at 539 with fuzz 2 (offset -239 lines).\nHunk #4 FAILED at 802.\nHunk #5 FAILED at 813.\n3 out of 5 hunks FAILED -- saving rejects to file drivers/media/v4l2-core/v4l2-mem2mem.c.rej\n"
+    },
+    {
+      "patch_file": "20fdf274472998123a8d173ba4cb6282ff6b63bd.diff",
+      "patch_url": "https://android.googlesource.com/kernel/common/+/20fdf274472998123a8d173ba4cb6282ff6b63bd",
+      "status": "Rejected",
+      "rejected_files": [
+        {
+          "failed_file": "net/bpf/test_run.c",
+          "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/bpf/test_run.c.rej"
+        }
+      ],
+      "message_output": "patching file net/bpf/test_run.c\nHunk #2 FAILED at 132.\n1 out of 2 hunks FAILED -- saving rejects to file net/bpf/test_run.c.rej\n"
     }
   ]
 }
diff --git a/llm_integration/gemini_function.py b/llm_integration/gemini_function.py
index 93a60bd..13f8eda 100644
--- a/llm_integration/gemini_function.py
+++ b/llm_integration/gemini_function.py
@@ -2,6 +2,7 @@ from google import genai
 from google.genai import types
 import os
 import json
+from datetime import datetime
 
 class LLMPatchGenerator:
     """Handles AI-based patch porting from upstream to downstream versions."""
@@ -34,7 +35,7 @@ class LLMPatchGenerator:
             downstream_version = self.load_file(downstream_version_path, base_path=self.kernel_path)
         except FileNotFoundError as e:
             print(e)
-            return None
+            return None, str(e)
 
         user_prompt = f"""Task:
 Your task is to port the security patch from the upstream_diff_file to the downstream_version.
@@ -91,12 +92,20 @@ ensuring compatibility and resolving any merge conflicts."""
         ):
             response_text += chunk.text
 
-        if output_path:
-            with open(output_path, "w", encoding="utf-8") as f:
-                f.write(response_text)
-            print(f"✅ Ported patch saved to {output_path}")
+        success = True
+        error_message = None
+        try:
+            if output_path:
+                os.makedirs(os.path.dirname(output_path), exist_ok=True)
+                with open(output_path, "w", encoding="utf-8") as f:
+                    f.write(response_text)
+                print(f"✅ Ported patch saved to {output_path}")
+        except Exception as e:
+            success = False
+            error_message = str(e)
+            print(f"⚠️ Error saving patch: {error_message}")
 
-        return response_text
+        return response_text, error_message
 
 
 # === Main Script ===
@@ -104,30 +113,66 @@ if __name__ == "__main__":
     kernel_path = "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource"
     failed_patch_path = os.path.join(os.path.dirname(__file__), "failed_patch.json")
 
+    # Create output directories
+    base_dir = os.path.dirname(os.path.dirname(__file__))
+    generated_patches_dir = os.path.join(base_dir, "patch_adoption", "generated_patches")
+    reports_dir = os.path.join(base_dir, "reports")
+    
+    os.makedirs(generated_patches_dir, exist_ok=True)
+    os.makedirs(reports_dir, exist_ok=True)
+
     # Load failed patches JSON
     with open(failed_patch_path, "r") as f:
         failed_patches = json.load(f)
 
     generator = LLMPatchGenerator(kernel_path)
+    
+    # Initialize list to store individual patch results
+    patch_results = []
 
-    for patch in failed_patches["patch"]:
-        patch_file = patch["patch_file"]
+    for patch in failed_patches["patches"]:
+        patch_hash = os.path.splitext(patch["patch_file"])[0]  # Remove .diff extension
         patch_url = patch["patch_url"]
-        rejected_files = patch["rejected_files"]
+        message_output = patch["message_output"]
 
-        for file in rejected_files:
+        for file in patch["rejected_files"]:
             failed_file = file["failed_file"]
             reject_file = file["reject_file"]
 
-            print(f"\n🔍 Processing failed patch: {patch_file}")
+            print(f"\n🔍 Processing failed patch: {patch_hash}")
             print(f" - Failed File: {failed_file}")
             print(f" - Reject File: {reject_file}")
 
-            # Generate new patched diff
-            output_patch_file = f"{patch_file}_fixed.diff"
-            generated_patch = generator.generate_patch(reject_file, failed_file, output_patch_file)
+            # Generate output filename
+            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
+            output_filename = f"{patch_hash}_{timestamp}.diff"
+            output_path = os.path.join(generated_patches_dir, output_filename)
 
-            if generated_patch:
-                print(f"🎉 Successfully generated patch for {patch_file}")
+            # Generate new patched diff
+            generated_patch, error = generator.generate_patch(reject_file, failed_file, output_path)
+
+            # Create result entry for this specific patch attempt
+            result = {
+                "patch_hash": patch_hash,
+                "patch_url": patch_url,
+                "related_file": failed_file,
+                "message": message_output,
+                "generated_patch_path": output_path if not error else None,
+                "success": bool(generated_patch and not error),
+                "error": error,
+                "timestamp": datetime.now().isoformat()
+            }
+            
+            patch_results.append(result)
+
+            if generated_patch and not error:
+                print(f"🎉 Successfully generated patch for {patch_hash}")
             else:
-                print(f"⚠️ Failed to generate patch for {patch_file}")
+                print(f"⚠️ Failed to generate patch for {patch_hash}")
+
+    # Save results to report file
+    report_path = os.path.join(reports_dir, "1_llm_output.json")
+    with open(report_path, "w", encoding="utf-8") as f:
+        json.dump(patch_results, f, indent=2)
+
+    print(f"\n✅ Results saved to {report_path}")
diff --git a/patch_adoption/patch_adopter.py b/patch_adoption/patch_adopter.py
index bfaf434..ba63ae0 100644
--- a/patch_adoption/patch_adopter.py
+++ b/patch_adoption/patch_adopter.py
@@ -155,7 +155,7 @@ if __name__ == "__main__":
     # Paths
     kernel_path = "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource"
     patch_dir = "/Users/theophilasetiawan/Desktop/files/capstone/vidar/fetch_patch_output/diff_output"
-    parsed_report_path = "/Users/theophilasetiawan/Desktop/files/capstone/vidar/llm_integration/parsed_report.json"
+    parsed_report_path = "/Users/theophilasetiawan/Desktop/files/capstone/vidar/reports/parsed_report.json"
     report_output_path = "/Users/theophilasetiawan/Desktop/files/capstone/vidar/reports/patch_application_report.json"
 
     # Ensure the Xiaomi Kernel directory exists
@@ -183,4 +183,4 @@ if __name__ == "__main__":
         patcher.patch_results["patches"].append(patch_result)
 
     # Save the final report
-    patcher.save_report()
+    patcher.save_report()
\ No newline at end of file
diff --git a/patch_adoption/patch_runner.py b/patch_adoption/patch_runner.py
index e5f1174..08d4608 100644
--- a/patch_adoption/patch_runner.py
+++ b/patch_adoption/patch_runner.py
@@ -104,7 +104,7 @@ class PatchLLMAdopter:
 if __name__ == "__main__":
     # Paths
     kernel_path = "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource"
-    llm_patch_dir = "/Users/theophilasetiawan/Desktop/files/capstone/vidar/patch_adoption/generated_patches"
+    llm_patch_dir = "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/generated_patches"
 
     # Ensure the kernel directory exists
     if not os.path.isdir(kernel_path):
diff --git a/reports/parsed_report.json b/reports/parsed_report.json
index 2c62b9d..df17fd7 100644
--- a/reports/parsed_report.json
+++ b/reports/parsed_report.json
@@ -1,403 +1,1284 @@
 {
-    "patches": [
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2",
-            "patch_file": "f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff",
-            "files": {
-                "mm/mremap.c": {
-                    "functions": [
-                        "unlock_vma_ref_count",
-                        "trylock_vma_ref_count"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/bce004fba8be9e1bb575301f398b3ecc27ba42de",
-            "patch_file": "bce004fba8be9e1bb575301f398b3ecc27ba42de.diff",
-            "files": {
-                "mm/mremap.c": {
-                    "functions": [
-                        "unlock_vma_ref_count",
-                        "trylock_vma_ref_count"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/65e0a92c6d27d4cbaa0deef668df12b69853d65e",
-            "patch_file": "65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff",
-            "files": {
-                "include/net/af_unix.h": {
-                    "functions": []
-                },
-                "net/unix/garbage.c": {
-                    "functions": [
-                        "dec_inflight",
-                        "inc_inflight",
-                        "inc_inflight_move_tail",
-                        "unix_gc"
-                    ]
-                },
-                "net/unix/scm.c": {
-                    "functions": [
-                        "unix_inflight",
-                        "unix_notinflight"
-                    ]
-                },
-                "net/unix/af_unix.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/94c88f80ffddff00f0af448c02dfd8a3f3cdd692",
-            "patch_file": "94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff",
-            "files": {
-                "include/net/af_unix.h": {
-                    "functions": []
-                },
-                "net/unix/garbage.c": {
-                    "functions": [
-                        "inc_inflight",
-                        "dec_inflight",
-                        "inc_inflight_move_tail",
-                        "unix_gc"
-                    ]
-                },
-                "net/unix/scm.c": {
-                    "functions": [
-                        "unix_inflight",
-                        "unix_notinflight"
-                    ]
-                },
-                "net/unix/af_unix.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/c1a7b4b4a736fa175488122cca9743cff2ae72e8",
-            "patch_file": "c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff",
-            "files": {
-                "drivers/gpu/msm/kgsl_vbo.c": {
-                    "functions": [
-                        "bind_range_create",
-                        "kgsl_sharedmem_free_bind_op",
-                        "kgsl_sharedmem_create_bind_op"
-                    ]
-                },
-                "drivers/gpu/msm/kgsl_reclaim.c": {
-                    "functions": [
-                        "kgsl_reclaim_process"
-                    ]
-                },
-                "drivers/gpu/msm/kgsl.c": {
-                    "functions": [
-                        "kgsl_mem_entry_create"
-                    ]
-                },
-                "drivers/gpu/msm/kgsl.h": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/61abd2ada929a54983f95345ffa2504bbd9b993d",
-            "patch_file": "61abd2ada929a54983f95345ffa2504bbd9b993d.diff",
-            "files": {
-                "drivers/gpu/msm/kgsl_vbo.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/25c49620c22e375fbd69631ea1eb408ed43db6e0",
-            "patch_file": "25c49620c22e375fbd69631ea1eb408ed43db6e0.diff",
-            "files": {
-                "drivers/gpu/msm/kgsl_vbo.c": {
-                    "functions": [
-                        "kgsl_memdesc_remove_range",
-                        "kgsl_memdesc_add_range",
-                        "kgsl_sharedmem_vbo_put_gpuaddr"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e",
-            "patch_file": "8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff",
-            "files": {
-                "drivers/gpu/msm/kgsl.c": {
-                    "functions": [
-                        "kgsl_update_fault_details",
-                        "kgsl_update_fault_count"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/7a2aa337ab8235460c1efa92a846eaeade5f2514",
-            "patch_file": "7a2aa337ab8235460c1efa92a846eaeade5f2514.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": [
-                        "binder_get_object"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/bf4f9bc41c3b5203e1e7284e1de78e82f0630473",
-            "patch_file": "bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": [
-                        "binder_get_object"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/b42ed94769088450987f2b52f41a3fb274244827",
-            "patch_file": "b42ed94769088450987f2b52f41a3fb274244827.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/f4e5b5151e55932279287c55d4e4a801fbf1df96",
-            "patch_file": "f4e5b5151e55932279287c55d4e4a801fbf1df96.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/c2201dde2a76788b5b7a75426e53a58e1490a028",
-            "patch_file": "c2201dde2a76788b5b7a75426e53a58e1490a028.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9",
-            "patch_file": "370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a",
-            "patch_file": "ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/30efc10dfe20bbf7410adb3d756106f365ac75cc",
-            "patch_file": "30efc10dfe20bbf7410adb3d756106f365ac75cc.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/135a19cfad1e5e9c1db63970df743c28f5dd74c8",
-            "patch_file": "135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/6a1de5f5d37141467efb9e5d9b3844a19f9990a9",
-            "patch_file": "6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff",
-            "files": {
-                "drivers/android/binder.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.15/commit/051d2f9bed5c7b1f58fd3e2808420b5106512a46",
-            "patch_file": "051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff",
-            "files": {
-                "drivers/slimbus/qcom-ngd-ctrl.c": {
-                    "functions": [
-                        "qcom_slim_ngd_xfer_msg_sync"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.4/commit/0215bbc2e0d7590e324c9d11cc4247304ff65f22",
-            "patch_file": "0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff",
-            "files": {
-                "drivers/media/platform/msm/cvp/hfi_response_handler.c": {
-                    "functions": [
-                        "cvp_get_inst_from_id",
-                        "hfi_process_session_cvp_msg"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.15/commit/28204d125055f0dec3e9625382cb92810f5528d0",
-            "patch_file": "28204d125055f0dec3e9625382cb92810f5528d0.diff",
-            "files": {
-                "drivers/char/adsprpc.c": {
-                    "functions": [
-                        "fastrpc_get_process_gids"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/841cae881066f0dd38d15a90cfcf245b0db9fc73",
-            "patch_file": "841cae881066f0dd38d15a90cfcf245b0db9fc73.diff",
-            "files": {
-                "net/sched/sch_multiq.c": {
-                    "functions": []
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/3856ad0c3e3028d54c8dac960dec411e45c13146",
-            "patch_file": "3856ad0c3e3028d54c8dac960dec411e45c13146.diff",
-            "files": {
-                "net/ipv6/route.c": {
-                    "functions": [
-                        "ip6_negative_advice"
-                    ]
-                },
-                "net/xfrm/xfrm_policy.c": {
-                    "functions": [
-                        "xfrm_negative_advice"
-                    ]
-                },
-                "net/ipv4/route.c": {
-                    "functions": [
-                        "ipv4_negative_advice"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/b8932254b9b2f02620e96572fee9c615c1db2bc3",
-            "patch_file": "b8932254b9b2f02620e96572fee9c615c1db2bc3.diff",
-            "files": {
-                "net/ipv6/route.c": {
-                    "functions": [
-                        "ip6_negative_advice"
-                    ]
-                },
-                "net/xfrm/xfrm_policy.c": {
-                    "functions": [
-                        "xfrm_negative_advice"
-                    ]
-                },
-                "net/ipv4/route.c": {
-                    "functions": [
-                        "ipv4_negative_advice"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/079d4f3ff06b21f99aed51d8b22534bdfda5a134",
-            "patch_file": "079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff",
-            "files": {
-                "net/ipv6/route.c": {
-                    "functions": [
-                        "ip6_negative_advice"
-                    ]
-                },
-                "net/xfrm/xfrm_policy.c": {
-                    "functions": [
-                        "xfrm_negative_advice"
-                    ]
-                },
-                "net/ipv4/route.c": {
-                    "functions": [
-                        "ipv4_negative_advice"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/41a05cfc0e471cea173345622375b672edd8ed3c",
-            "patch_file": "41a05cfc0e471cea173345622375b672edd8ed3c.diff",
-            "files": {
-                "net/ipv6/route.c": {
-                    "functions": [
-                        "ip6_negative_advice"
-                    ]
-                },
-                "net/xfrm/xfrm_policy.c": {
-                    "functions": [
-                        "xfrm_negative_advice"
-                    ]
-                },
-                "net/ipv4/route.c": {
-                    "functions": [
-                        "ipv4_negative_advice"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/9b0dadc811eb0140a61734cde73498c1dd574fa1",
-            "patch_file": "9b0dadc811eb0140a61734cde73498c1dd574fa1.diff",
-            "files": {
-                "net/ipv6/route.c": {
-                    "functions": [
-                        "ip6_negative_advice"
-                    ]
-                },
-                "net/xfrm/xfrm_policy.c": {
-                    "functions": [
-                        "xfrm_negative_advice"
-                    ]
-                },
-                "net/ipv4/route.c": {
-                    "functions": [
-                        "ipv4_negative_advice"
-                    ]
-                }
-            }
-        },
-        {
-            "patch_url": "https://android.googlesource.com/kernel/common/+/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5",
-            "patch_file": "bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff",
-            "files": {
-                "net/ipv6/route.c": {
-                    "functions": [
-                        "ip6_negative_advice"
-                    ]
-                },
-                "net/xfrm/xfrm_policy.c": {
-                    "functions": [
-                        "xfrm_negative_advice"
-                    ]
-                },
-                "net/ipv4/route.c": {
-                    "functions": [
-                        "ipv4_negative_advice"
-                    ]
-                }
-            }
-        }
-    ]
-}
\ No newline at end of file
+  "patches": [
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/8019ad13ef7f64be44d4f892af9c840179009254",
+      "patch_file": "8019ad13ef7f64be44d4f892af9c840179009254.diff",
+      "files": {
+        "fs/inode.c": {
+          "functions": []
+        },
+        "include/linux/fs.h": {
+          "functions": []
+        },
+        "kernel/futex.c": {
+          "functions": ["get_futex_key_refs", "drop_futex_key_refs"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/49289b1fa5a67011",
+      "patch_file": "49289b1fa5a67011.diff",
+      "files": {
+        "fs/block_dev.c": {
+          "functions": ["blkdev_get"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/a9ed4a6560b8",
+      "patch_file": "a9ed4a6560b8.diff",
+      "files": {
+        "fs/eventpoll.c": {
+          "functions": ["clear_tfile_check_list"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b",
+      "patch_file": "8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b.diff",
+      "files": {
+        "fs/seq_file.c": {
+          "functions": ["seq_buf_alloc"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/9537bae0da1f",
+      "patch_file": "9537bae0da1f.diff",
+      "files": {
+        "fs/signalfd.c": {
+          "functions": ["signalfd_cleanup"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/9763ffd4da217",
+      "patch_file": "9763ffd4da217.diff",
+      "files": {
+        "fs/overlayfs/dir.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/24d464d38beb08cda1e972f79827d2fed6193de7",
+      "patch_file": "24d464d38beb08cda1e972f79827d2fed6193de7.diff",
+      "files": {
+        "fs/fuse/dev.c": {
+          "functions": ["fuse_copy_page"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/528611246fcbd",
+      "patch_file": "528611246fcbd.diff",
+      "files": {
+        "fs/f2fs/node.h": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/212b4d3a42674d2cf366bd7b06fe9faae03477fc",
+      "patch_file": "212b4d3a42674d2cf366bd7b06fe9faae03477fc.diff",
+      "files": {
+        "drivers/staging/android/ion/ion.c": {
+          "functions": [
+            "ion_dma_buf_kunmap",
+            "ion_dma_buf_kmap",
+            "ion_dma_buf_end_cpu_access"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/6c5bc69f722cb5e2fe47196ee8f1aabe6498f8a7",
+      "patch_file": "6c5bc69f722cb5e2fe47196ee8f1aabe6498f8a7.diff",
+      "files": {
+        "drivers/staging/android/ion/ion.c": {
+          "functions": [
+            "ion_dma_buf_kunmap",
+            "ion_dma_buf_kmap",
+            "ion_dma_buf_begin_cpu_access",
+            "ion_dma_buf_end_cpu_access"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/41a097c0ed6658bf451c5cf993ab0469eb1ce4a5",
+      "patch_file": "41a097c0ed6658bf451c5cf993ab0469eb1ce4a5.diff",
+      "files": {
+        "drivers/staging/android/ion/ion.c": {
+          "functions": ["ion_dma_buf_kunmap", "ion_dma_buf_kmap"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/594cc251fdd0d231d342d88b2fdff4bc42fb0690",
+      "patch_file": "594cc251fdd0d231d342d88b2fdff4bc42fb0690.diff",
+      "files": {
+        "lib/strncpy_from_user.c": {
+          "functions": ["strncpy_from_user"]
+        },
+        "lib/strnlen_user.c": {
+          "functions": ["strnlen_user"]
+        },
+        "arch/x86/include/asm/uaccess.h": {
+          "functions": []
+        },
+        "drivers/gpu/drm/i915/i915_gem_execbuffer.c": {
+          "functions": ["i915_gem_execbuffer2_ioctl"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/17743798d81238ab13050e8e2833699b54e15467",
+      "patch_file": "17743798d81238ab13050e8e2833699b54e15467.diff",
+      "files": {
+        "mm/hugetlb.c": {
+          "functions": [
+            "hugetlb_sysctl_handler_common",
+            "hugetlb_overcommit_handler"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/4158b1508f2b1",
+      "patch_file": "4158b1508f2b1.diff",
+      "files": {
+        "mm/rmap.c": {
+          "functions": ["anon_vma_alloc", "__anon_vma_prepare", "anon_vma_fork"]
+        },
+        "include/linux/rmap.h": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/6f99528e97977",
+      "patch_file": "6f99528e97977.diff",
+      "files": {
+        "include/linux/rtnetlink.h": {
+          "functions": []
+        },
+        "net/core/rtnetlink.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/3a7d0d07a3867",
+      "patch_file": "3a7d0d07a3867.diff",
+      "files": {
+        "include/net/pkt_sched.h": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/86bd446b5cebd",
+      "patch_file": "86bd446b5cebd.diff",
+      "files": {
+        "include/net/sch_generic.h": {
+          "functions": []
+        },
+        "net/sched/sch_red.c": {
+          "functions": []
+        },
+        "net/sched/sch_atm.c": {
+          "functions": []
+        },
+        "net/sched/sch_dsmark.c": {
+          "functions": []
+        },
+        "net/sched/sch_mq.c": {
+          "functions": []
+        },
+        "net/sched/sch_sfb.c": {
+          "functions": []
+        },
+        "net/sched/sch_cbq.c": {
+          "functions": []
+        },
+        "net/sched/sch_api.c": {
+          "functions": []
+        },
+        "net/sched/sch_generic.c": {
+          "functions": ["qdisc_destroy"]
+        },
+        "net/sched/sch_qfq.c": {
+          "functions": []
+        },
+        "net/sched/sch_fifo.c": {
+          "functions": []
+        },
+        "net/sched/sch_mqprio.c": {
+          "functions": []
+        },
+        "net/sched/sch_hfsc.c": {
+          "functions": []
+        },
+        "net/sched/sch_prio.c": {
+          "functions": []
+        },
+        "net/sched/sch_drr.c": {
+          "functions": []
+        },
+        "net/sched/sch_multiq.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/11db2de0af2a",
+      "patch_file": "11db2de0af2a.diff",
+      "files": {
+        "include/linux/security.h": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/3af7a2f61023",
+      "patch_file": "3af7a2f61023.diff",
+      "files": {
+        "security/security.c": {
+          "functions": [
+            "security_binder_set_context_mgr",
+            "security_binder_transaction",
+            "security_binder_transfer_binder",
+            "security_binder_transfer_file"
+          ]
+        },
+        "security/selinux/hooks.c": {
+          "functions": [
+            "selinux_binder_set_context_mgr",
+            "selinux_binder_transaction",
+            "selinux_binder_transfer_binder"
+          ]
+        },
+        "drivers/android/binder.c": {
+          "functions": ["binder_translate_binder"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/35556bed836f",
+      "patch_file": "35556bed836f.diff",
+      "files": {
+        "include/linux/hid.h": {
+          "functions": ["hid_map_usage", "hid_map_usage_clear"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/bce1305c0ece",
+      "patch_file": "bce1305c0ece.diff",
+      "files": {
+        "drivers/hid/hid-core.c": {
+          "functions": ["hid_output_report"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/55667441c84fa5e0911a0aac44fb059c15ba6da2",
+      "patch_file": "55667441c84fa5e0911a0aac44fb059c15ba6da2.diff",
+      "files": {
+        "include/linux/skbuff.h": {
+          "functions": []
+        },
+        "include/net/fq_impl.h": {
+          "functions": ["fq_init"]
+        },
+        "include/net/fq.h": {
+          "functions": []
+        },
+        "net/sched/sch_hhf.c": {
+          "functions": ["hhf_classify"]
+        },
+        "net/sched/sch_sfb.c": {
+          "functions": ["sfb_init_perturbation", "sfb_enqueue"]
+        },
+        "net/sched/sch_sfq.c": {
+          "functions": [
+            "sfq_hash",
+            "sfq_perturbation",
+            "sfq_change",
+            "sfq_init"
+          ]
+        },
+        "net/core/flow_dissector.c": {
+          "functions": [
+            "__flow_hash_words",
+            "flow_keys_hash_start",
+            "flow_keys_hash_length",
+            "__flow_hash_from_keys",
+            "flow_hash_from_keys",
+            "___skb_get_hash",
+            "__skb_get_hash",
+            "skb_get_hash_perturb"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "http://android.googlesource.com/kernel/common/+/b207caff4176",
+      "patch_file": "b207caff4176.diff",
+      "files": {
+        "include/linux/compiler.h": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d",
+      "patch_file": "c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d.diff",
+      "files": {
+        "include/sound/rawmidi.h": {
+          "functions": []
+        },
+        "sound/core/rawmidi.c": {
+          "functions": ["snd_rawmidi_kernel_read1", "snd_rawmidi_kernel_write1"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/dbb2483b2a46fbaf833cfb5deb5ed9cace9c7399",
+      "patch_file": "dbb2483b2a46fbaf833cfb5deb5ed9cace9c7399.diff",
+      "files": {
+        "include/net/xfrm.h": {
+          "functions": []
+        },
+        "net/key/af_key.c": {
+          "functions": ["parse_ipsecrequest"]
+        },
+        "net/xfrm/xfrm_user.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/5c4c8c9544099bb9043a10a5318130a943e32fc3",
+      "patch_file": "5c4c8c9544099bb9043a10a5318130a943e32fc3.diff",
+      "files": {
+        "include/net/bluetooth/hci_core.h": {
+          "functions": []
+        },
+        "net/bluetooth/hci_event.c": {
+          "functions": [
+            "hci_loglink_complete_evt",
+            "hci_disconn_loglink_complete_evt"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/cacbff013baa586c63dd779e67d13238bf46c28e",
+      "patch_file": "cacbff013baa586c63dd779e67d13238bf46c28e.diff",
+      "files": {
+        "include/net/bluetooth/l2cap.h": {
+          "functions": []
+        },
+        "net/bluetooth/l2cap_core.c": {
+          "functions": [
+            "l2cap_get_chan_by_scid",
+            "l2cap_get_chan_by_dcid",
+            "l2cap_get_chan_by_ident",
+            "l2cap_global_chan_by_psm",
+            "l2cap_move_continue",
+            "l2cap_move_fail",
+            "l2cap_move_channel_confirm",
+            "l2cap_move_channel_confirm_rsp",
+            "l2cap_le_credits",
+            "l2cap_global_fixed_chan"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/2f9fed9ce805cf4d97cffb2f59d57b41b8e7fca8",
+      "patch_file": "2f9fed9ce805cf4d97cffb2f59d57b41b8e7fca8.diff",
+      "files": {
+        "include/net/bluetooth/l2cap.h": {
+          "functions": []
+        },
+        "net/bluetooth/l2cap_core.c": {
+          "functions": [
+            "l2cap_get_chan_by_scid",
+            "l2cap_get_chan_by_dcid",
+            "l2cap_get_chan_by_ident",
+            "l2cap_global_chan_by_psm",
+            "l2cap_move_continue",
+            "l2cap_move_fail",
+            "l2cap_move_channel_confirm",
+            "l2cap_move_channel_confirm_rsp",
+            "l2cap_le_credits",
+            "l2cap_global_fixed_chan"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/769d14abd35e0",
+      "patch_file": "769d14abd35e0.diff",
+      "files": {
+        "include/net/sctp/sctp.h": {
+          "functions": []
+        },
+        "include/net/sctp/structs.h": {
+          "functions": []
+        },
+        "net/sctp/diag.c": {
+          "functions": ["sctp_sock_dump", "sctp_sock_filter"]
+        },
+        "net/sctp/endpointola.c": {
+          "functions": ["sctp_endpoint_hold"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/d4dbef7046e2",
+      "patch_file": "d4dbef7046e2.diff",
+      "files": {
+        "include/net/sctp/structs.h": {
+          "functions": []
+        },
+        "net/sctp/ipv6.c": {
+          "functions": ["sctp_v6_from_addr_param"]
+        },
+        "net/sctp/bind_addr.c": {
+          "functions": ["sctp_raw_to_bind_addrs"]
+        },
+        "net/sctp/sm_make_chunk.c": {
+          "functions": ["sctp_asconf_param_success"]
+        },
+        "net/sctp/input.c": {
+          "functions": ["__sctp_rcv_init_lookup", "__sctp_rcv_asconf_lookup"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/6ef81a5c0e22",
+      "patch_file": "6ef81a5c0e22.diff",
+      "files": {
+        "net/sctp/input.c": {
+          "functions": ["__sctp_rcv_walk_lookup"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ffca46766850",
+      "patch_file": "ffca46766850.diff",
+      "files": {
+        "net/sctp/input.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/b6d75218ff65f",
+      "patch_file": "b6d75218ff65f.diff",
+      "files": {
+        "kernel/ptrace.c": {
+          "functions": ["ptrace_setoptions"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/5a41a3033a934",
+      "patch_file": "5a41a3033a934.diff",
+      "files": {
+        "kernel/ptrace.c": {
+          "functions": ["ptrace_setoptions"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/6210ced85099d",
+      "patch_file": "6210ced85099d.diff",
+      "files": {
+        "kernel/ptrace.c": {
+          "functions": ["ptrace_setoptions"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/2ad3e17ebf94b7b7f3f64c050ff168f9915345eb",
+      "patch_file": "2ad3e17ebf94b7b7f3f64c050ff168f9915345eb.diff",
+      "files": {
+        "kernel/auditfilter.c": {
+          "functions": ["audit_data_to_entry"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/e80c3533c354e",
+      "patch_file": "e80c3533c354e.diff",
+      "files": {
+        "kernel/bpf/disasm.c": {
+          "functions": []
+        },
+        "arch/x86/net/bpf_jit_comp.c": {
+          "functions": []
+        },
+        "arch/x86/net/bpf_jit_comp32.c": {
+          "functions": []
+        },
+        "arch/s390/net/bpf_jit_comp.c": {
+          "functions": []
+        },
+        "arch/arm64/net/bpf_jit_comp.c": {
+          "functions": []
+        },
+        "arch/mips/net/ebpf_jit.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/30e29a9a2bc6a4888335a6ede968b75cd329657a",
+      "patch_file": "30e29a9a2bc6a4888335a6ede968b75cd329657a.diff",
+      "files": {
+        "kernel/bpf/stackmap.c": {
+          "functions": ["prealloc_elems_and_freelist"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
+      "patch_file": "050fad7c4534c13c8eb1d9c2ba66012e014773cb.diff",
+      "files": {
+        "kernel/bpf/core.c": {
+          "functions": ["bpf_adj_branches", "bpf_patch_insn_single"]
+        },
+        "net/core/filter.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ee1e2de73cc54",
+      "patch_file": "ee1e2de73cc54.diff",
+      "files": {
+        "kernel/cgroup/cgroup-v1.c": {
+          "functions": ["cgroup_release_agent_write"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/1fc3444cda9a7",
+      "patch_file": "1fc3444cda9a7.diff",
+      "files": {
+        "kernel/cgroup/cgroup-v1.c": {
+          "functions": ["cgroup_release_agent_write"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/26f55a59dc65ff77cd1c4b37991e26497fc68049",
+      "patch_file": "26f55a59dc65ff77cd1c4b37991e26497fc68049.diff",
+      "files": {
+        "arch/x86/net/bpf_jit_comp.c": {
+          "functions": []
+        },
+        "arch/x86/net/bpf_jit_comp32.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/e4d4d456436bfb2fe412ee2cd489f7658449b098",
+      "patch_file": "e4d4d456436bfb2fe412ee2cd489f7658449b098.diff",
+      "files": {
+        "arch/x86/net/bpf_jit_comp.c": {
+          "functions": []
+        },
+        "arch/x86/net/bpf_jit_comp32.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/96468c6085fc87f1defb2b187bd778505723e1bc",
+      "patch_file": "96468c6085fc87f1defb2b187bd778505723e1bc.diff",
+      "files": {
+        "arch/arm64/include/asm/cpu.h": {
+          "functions": []
+        },
+        "arch/arm64/kvm/sys_regs.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/15e43a2ac5e15c503c104831e9e2b6d5fc7d6131",
+      "patch_file": "15e43a2ac5e15c503c104831e9e2b6d5fc7d6131.diff",
+      "files": {
+        "arch/arm64/include/asm/sections.h": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/885349f53dd73",
+      "patch_file": "885349f53dd73.diff",
+      "files": {
+        "arch/arm64/kernel/armv8_deprecated.c": {
+          "functions": ["emulation_proc_handler"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/9c698bff66ab4914bb3d71da7dc6112519bde23e",
+      "patch_file": "9c698bff66ab4914bb3d71da7dc6112519bde23e.diff",
+      "files": {
+        "arch/arm/kernel/signal.c": {
+          "functions": ["get_signal_page"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/8f66dc1a78a743ea3c3f039500d2aa0cddd776d5",
+      "patch_file": "8f66dc1a78a743ea3c3f039500d2aa0cddd776d5.diff",
+      "files": {
+        "drivers/mmc/core/block.c": {
+          "functions": ["mmc_blk_read_single"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/8a3679a75730c1babde6bf63e35d227f3305bd90",
+      "patch_file": "8a3679a75730c1babde6bf63e35d227f3305bd90.diff",
+      "files": {
+        "drivers/mmc/core/block.c": {
+          "functions": ["mmc_blk_read_single"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/2aea7dc18f4249dc53e53598db50b59c26a60aeb",
+      "patch_file": "2aea7dc18f4249dc53e53598db50b59c26a60aeb.diff",
+      "files": {
+        "drivers/mmc/core/block.c": {
+          "functions": ["mmc_blk_read_single"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/618a931c",
+      "patch_file": "618a931c.diff",
+      "files": {
+        "drivers/staging/android/ion/ion.c": {
+          "functions": ["ion_buffer_kmap_get"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/b6b3781a",
+      "patch_file": "b6b3781a.diff",
+      "files": {
+        "drivers/staging/android/ion/ion.c": {
+          "functions": ["ion_buffer_kmap_get"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/032a6762957f8",
+      "patch_file": "032a6762957f8.diff",
+      "files": {
+        "drivers/tee/tee_shm.c": {
+          "functions": [
+            "tee_shm_op_release",
+            "tee_shm_op_map_dma_buf",
+            "tee_shm_op_unmap_dma_buf",
+            "tee_shm_free",
+            "tee_shm_get_from_id",
+            "tee_shm_put"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c05d8f66ec347",
+      "patch_file": "c05d8f66ec347.diff",
+      "files": {
+        "drivers/tee/tee_shm.c": {
+          "functions": [
+            "tee_shm_op_release",
+            "tee_shm_op_map_dma_buf",
+            "tee_shm_op_unmap_dma_buf",
+            "tee_shm_free",
+            "tee_shm_get_from_id",
+            "tee_shm_put"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/5de5b6ecf97a021f29403aa272cb4e03318ef586",
+      "patch_file": "5de5b6ecf97a021f29403aa272cb4e03318ef586.diff",
+      "files": {
+        "drivers/gpu/drm/nouveau/nouveau_sgdma.c": {
+          "functions": ["nouveau_sgdma_create_ttm"]
+        },
+        "drivers/gpu/drm/ttm/ttm_tt.c": {
+          "functions": ["ttm_tt_init", "ttm_dma_tt_init", "ttm_sg_tt_init"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/df2c1f38939aa",
+      "patch_file": "df2c1f38939aa.diff",
+      "files": {
+        "drivers/gpu/drm/vgem/vgem_drv.c": {
+          "functions": ["vgem_gem_dumb_create"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9",
+      "patch_file": "c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9.diff",
+      "files": {
+        "drivers/tty/tty_jobctrl.c": {
+          "functions": [
+            "__proc_set_tty",
+            "disassociate_ctty",
+            "tiocspgrp",
+            "tiocgsid"
+          ]
+        },
+        "drivers/tty/tty_io.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/54ffccbf053b5b6ca4f6e45094b942fab92a25fc",
+      "patch_file": "54ffccbf053b5b6ca4f6e45094b942fab92a25fc.diff",
+      "files": {
+        "drivers/tty/tty_jobctrl.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/82e61c3909db51d91b9d3e2071557b6435018b80",
+      "patch_file": "82e61c3909db51d91b9d3e2071557b6435018b80.diff",
+      "files": {
+        "drivers/tty/vt/keyboard.c": {
+          "functions": ["k_fn"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/90bfdeef83f1d6c696039b6a917190dcbbad3220",
+      "patch_file": "90bfdeef83f1d6c696039b6a917190dcbbad3220.diff",
+      "files": {
+        "drivers/tty/vt/vt_ioctl.c": {
+          "functions": ["compat_fontx_ioctl"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/d75ef462c3dbd5bb52313e32d545c8be7f79049d",
+      "patch_file": "d75ef462c3dbd5bb52313e32d545c8be7f79049d.diff",
+      "files": {
+        "drivers/video/fbdev/pxa3xx-gcu.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/19bb609b45fb",
+      "patch_file": "19bb609b45fb.diff",
+      "files": {
+        "drivers/android/binder.c": {
+          "functions": ["binder_inc_ref_for_node"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/cb222aed03d798fc074be55e59d9a112338ee784",
+      "patch_file": "cb222aed03d798fc074be55e59d9a112338ee784.diff",
+      "files": {
+        "drivers/input/input.c": {
+          "functions": ["input_default_setkeycode", "input_set_keycode"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/64e6bbfff52db4bf6785fab9cffab850b2de6870",
+      "patch_file": "64e6bbfff52db4bf6785fab9cffab850b2de6870.diff",
+      "files": {
+        "drivers/usb/gadget/configfs.c": {
+          "functions": ["gadget_dev_desc_UDC_show"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/53afb231f54a69d827b882fa282b30bb10cb08a5",
+      "patch_file": "53afb231f54a69d827b882fa282b30bb10cb08a5.diff",
+      "files": {
+        "drivers/usb/gadget/composite.c": {
+          "functions": []
+        },
+        "drivers/usb/gadget/legacy/dbgp.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/b4604acd52a691c2fd33ad0a0fafb7cc19dee5de",
+      "patch_file": "b4604acd52a691c2fd33ad0a0fafb7cc19dee5de.diff",
+      "files": {
+        "drivers/usb/gadget/composite.c": {
+          "functions": []
+        },
+        "drivers/usb/gadget/legacy/dbgp.c": {
+          "functions": ["dbgp_setup"]
+        },
+        "drivers/usb/gadget/legacy/inode.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/823fc2b264f1ec12678564271c5fa34e3250cf83",
+      "patch_file": "823fc2b264f1ec12678564271c5fa34e3250cf83.diff",
+      "files": {
+        "drivers/usb/gadget/composite.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/528615555b59cbd659186d44b3c6db69c30414eb",
+      "patch_file": "528615555b59cbd659186d44b3c6db69c30414eb.diff",
+      "files": {
+        "drivers/usb/gadget/function/rndis.c": {
+          "functions": ["rndis_set_response"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/7193ad3e50e59",
+      "patch_file": "7193ad3e50e59.diff",
+      "files": {
+        "drivers/usb/gadget/composite.c": {
+          "functions": []
+        },
+        "drivers/usb/gadget/legacy/dbgp.c": {
+          "functions": ["dbgp_setup"]
+        },
+        "drivers/usb/gadget/legacy/inode.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/fb4ff0f96de37",
+      "patch_file": "fb4ff0f96de37.diff",
+      "files": {
+        "drivers/usb/gadget/function/rndis.c": {
+          "functions": ["rndis_set_response"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c7732dbce590e",
+      "patch_file": "c7732dbce590e.diff",
+      "files": {
+        "drivers/usb/gadget/composite.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/22ec100472854",
+      "patch_file": "22ec100472854.diff",
+      "files": {
+        "drivers/usb/gadget/composite.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/fdd64084e4055",
+      "patch_file": "fdd64084e4055.diff",
+      "files": {
+        "drivers/usb/gadget/legacy/inode.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/590a98d5d1086",
+      "patch_file": "590a98d5d1086.diff",
+      "files": {
+        "drivers/usb/gadget/legacy/inode.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ff0000fe82f45",
+      "patch_file": "ff0000fe82f45.diff",
+      "files": {
+        "drivers/usb/gadget/legacy/inode.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/c13159a588818",
+      "patch_file": "c13159a588818.diff",
+      "files": {
+        "drivers/usb/gadget/legacy/inode.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/38ea1eac7d88072bbffb630e2b3db83ca649b826",
+      "patch_file": "38ea1eac7d88072bbffb630e2b3db83ca649b826.diff",
+      "files": {
+        "drivers/usb/gadget/function/rndis.c": {
+          "functions": ["rndis_set_response"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/056ad39ee925",
+      "patch_file": "056ad39ee925.diff",
+      "files": {
+        "drivers/usb/core/message.c": {
+          "functions": ["usb_sg_cancel"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/b5fdf5c6e6bee35837e160c00ac89327bdad031b",
+      "patch_file": "b5fdf5c6e6bee35837e160c00ac89327bdad031b.diff",
+      "files": {
+        "drivers/usb/host/max3421-hcd.c": {
+          "functions": [
+            "max3421_set_address",
+            "max3421_select_and_start_urb",
+            "max3421_urb_done"
+          ]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/68035c80e129",
+      "patch_file": "68035c80e129.diff",
+      "files": {
+        "drivers/media/usb/uvc/uvc_driver.c": {
+          "functions": ["uvc_scan_chain_forward", "uvc_scan_chain_backward"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/a50ef731e0981",
+      "patch_file": "a50ef731e0981.diff",
+      "files": {
+        "drivers/media/v4l2-core/v4l2-mem2mem.c": {
+          "functions": ["v4l2_m2m_dqbuf"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-4.14/commit/bdb176c8afd933f26a135aba4d4a0384fb13d156",
+      "patch_file": "bdb176c8afd933f26a135aba4d4a0384fb13d156.diff",
+      "files": {
+        "drivers/media/platform/qcom/venus/hfi_msgs.c": {
+          "functions": ["session_get_prop_buf_req"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a",
+      "patch_file": "4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a.diff",
+      "files": {
+        "drivers/md/dm-ioctl.c": {
+          "functions": ["list_devices"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/7320fb1abd44b68bbeeb6ad6eb828899ab6b617e",
+      "patch_file": "7320fb1abd44b68bbeeb6ad6eb828899ab6b617e.diff",
+      "files": {
+        "drivers/hid/hid-roccat-pyra.c": {
+          "functions": ["pyra_probe"]
+        },
+        "drivers/hid/hid-roccat-kone.c": {
+          "functions": ["kone_probe"]
+        },
+        "drivers/hid/hid-roccat-ryos.c": {
+          "functions": ["ryos_probe"]
+        },
+        "drivers/hid/hid-roccat-savu.c": {
+          "functions": ["savu_probe"]
+        },
+        "drivers/hid/hid-roccat-konepure.c": {
+          "functions": ["konepure_probe"]
+        },
+        "drivers/hid/hid-roccat-lua.c": {
+          "functions": ["lua_probe"]
+        },
+        "drivers/hid/hid-roccat-kovaplus.c": {
+          "functions": ["kovaplus_probe"]
+        },
+        "drivers/hid/hid-roccat-koneplus.c": {
+          "functions": ["koneplus_probe"]
+        },
+        "drivers/hid/hid-corsair.c": {
+          "functions": ["corsair_probe"]
+        },
+        "drivers/hid/hid-roccat-arvo.c": {
+          "functions": ["arvo_probe"]
+        },
+        "drivers/hid/hid-roccat-isku.c": {
+          "functions": ["isku_probe"]
+        },
+        "drivers/hid/hid-elo.c": {
+          "functions": ["elo_probe"]
+        },
+        "drivers/hid/hid-holtek-mouse.c": {
+          "functions": []
+        },
+        "drivers/hid/hid-prodikeys.c": {
+          "functions": ["pk_probe"]
+        },
+        "drivers/hid/hid-lg.c": {
+          "functions": []
+        },
+        "drivers/hid/hid-holtek-kbd.c": {
+          "functions": ["holtek_kbd_probe"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/e98c96b8b8a5a7a97a0c1ae75638b362b16f0187",
+      "patch_file": "e98c96b8b8a5a7a97a0c1ae75638b362b16f0187.diff",
+      "files": {
+        "drivers/hid/wacom_sys.c": {
+          "functions": ["wacom_retrieve_hid_descriptor", "wacom_wireless_work"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ed9be64eefe2",
+      "patch_file": "ed9be64eefe2.diff",
+      "files": {
+        "drivers/hid/hid-core.c": {
+          "functions": ["hid_register_field"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/bce1305c0ece3",
+      "patch_file": "bce1305c0ece3.diff",
+      "files": {
+        "drivers/hid/hid-core.c": {
+          "functions": ["hid_output_report"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/f6ec306b93dc6",
+      "patch_file": "f6ec306b93dc6.diff",
+      "files": {
+        "drivers/char/virtio_console.c": {
+          "functions": ["get_inbuf", "control_work_handler"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/9292423a3e5fcf8b341ffbd135487f32f7e33d41",
+      "patch_file": "9292423a3e5fcf8b341ffbd135487f32f7e33d41.diff",
+      "files": {
+        "drivers/net/can/usb/ems_usb.c": {
+          "functions": ["ems_usb_start_xmit"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/bb4c6c0105eccc03b6bd005b6b396e1faf995a48",
+      "patch_file": "bb4c6c0105eccc03b6bd005b6b396e1faf995a48.diff",
+      "files": {
+        "drivers/net/can/usb/usb_8dev.c": {
+          "functions": ["usb_8dev_start_xmit"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/5c455c5ab332773464d02ba17015acdca198f03d",
+      "patch_file": "5c455c5ab332773464d02ba17015acdca198f03d.diff",
+      "files": {
+        "drivers/net/wireless/marvell/mwifiex/join.c": {
+          "functions": ["mwifiex_cmd_802_11_ad_hoc_start"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/e7f39d0aa294f",
+      "patch_file": "e7f39d0aa294f.diff",
+      "files": {
+        "drivers/net/usb/sr9700.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/4f5f5411f0c14",
+      "patch_file": "4f5f5411f0c14.diff",
+      "files": {
+        "drivers/net/usb/sr9700.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/35fc4cd34426c242ab015ef280853b7bff101f48",
+      "patch_file": "35fc4cd34426c242ab015ef280853b7bff101f48.diff",
+      "files": {
+        "drivers/scsi/ufs/ufshcd.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ef299cc3fa1a9",
+      "patch_file": "ef299cc3fa1a9.diff",
+      "files": {
+        "net/sched/cls_route.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/8f4dc50b5c12e159",
+      "patch_file": "8f4dc50b5c12e159.diff",
+      "files": {
+        "net/netfilter/nf_tables_api.c": {
+          "functions": ["nft_flush_table"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/b29c457a6511435960115c0f548c4360d5f4801d",
+      "patch_file": "b29c457a6511435960115c0f548c4360d5f4801d.diff",
+      "files": {
+        "net/netfilter/x_tables.c": {
+          "functions": [
+            "xt_compat_match_from_user",
+            "xt_compat_target_from_user"
+          ]
+        },
+        "net/ipv6/netfilter/ip6_tables.c": {
+          "functions": ["translate_compat_table"]
+        },
+        "net/ipv4/netfilter/ip_tables.c": {
+          "functions": ["translate_compat_table"]
+        },
+        "net/ipv4/netfilter/arp_tables.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/b52e0cf0bfc1e",
+      "patch_file": "b52e0cf0bfc1e.diff",
+      "files": {
+        "net/can/bcm.c": {
+          "functions": ["bcm_delete_rx_op"]
+        }
+      }
+    },
+    {
+      "patch_url": "http://android.googlesource.com/kernel/common/+/b59a23d596807a5aa88d8dd5655a66c6843729b3",
+      "patch_file": "b59a23d596807a5aa88d8dd5655a66c6843729b3.diff",
+      "files": {
+        "net/key/af_key.c": {
+          "functions": ["pfkey_dump"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/3c7e594355359",
+      "patch_file": "3c7e594355359.diff",
+      "files": {
+        "net/tipc/monitor.c": {
+          "functions": ["tipc_mon_rcv"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/20fdf274472998123a8d173ba4cb6282ff6b63bd",
+      "patch_file": "20fdf274472998123a8d173ba4cb6282ff6b63bd.diff",
+      "files": {
+        "net/bpf/test_run.c": {
+          "functions": ["bpf_prog_test_run_skb"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/d39fc9b94dc07",
+      "patch_file": "d39fc9b94dc07.diff",
+      "files": {
+        "net/unix/af_unix.c": {
+          "functions": ["unix_stream_sendpage"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/790c2f9d15b59",
+      "patch_file": "790c2f9d15b59.diff",
+      "files": {
+        "net/unix/af_unix.c": {
+          "functions": ["unix_stream_sendpage"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/84d3e59750bbd",
+      "patch_file": "84d3e59750bbd.diff",
+      "files": {
+        "net/unix/af_unix.c": {
+          "functions": ["unix_stream_sendpage"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/e6ed59127c865",
+      "patch_file": "e6ed59127c865.diff",
+      "files": {
+        "net/unix/af_unix.c": {
+          "functions": ["unix_stream_sendpage"]
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ea75080110a4c",
+      "patch_file": "ea75080110a4c.diff",
+      "files": {
+        "net/wireless/nl80211.c": {
+          "functions": []
+        }
+      }
+    },
+    {
+      "patch_url": "https://android.googlesource.com/kernel/common/+/ddd7e8b7b8483",
+      "patch_file": "ddd7e8b7b8483.diff",
+      "files": {
+        "net/ipv4/igmp.c": {
+          "functions": ["ip_check_mc_rcu"]
+        }
+      }
+    }
+  ]
+}
diff --git a/reports/patch_application_report.json b/reports/patch_application_report.json
index d56ec10..725c3c1 100644
--- a/reports/patch_application_report.json
+++ b/reports/patch_application_report.json
@@ -1,269 +1,808 @@
 {
     "patches": [
         {
-            "patch_file": "f913f0123e6cff4dbc7c1e17d13b7a59a54475d2.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/f913f0123e6cff4dbc7c1e17d13b7a59a54475d2",
+            "patch_file": "8019ad13ef7f64be44d4f892af9c840179009254.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/8019ad13ef7f64be44d4f892af9c840179009254",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/inode.c\nHunk #1 succeeded at 136 (offset -2 lines).\npatching file include/linux/fs.h\nHunk #1 succeeded at 640 (offset -58 lines).\npatching file kernel/futex.c\nHunk #1 succeeded at 436 (offset 7 lines).\nHunk #2 succeeded at 470 (offset 7 lines).\nHunk #3 succeeded at 477 with fuzz 1 (offset -27 lines).\nHunk #4 succeeded at 529 (offset -27 lines).\nHunk #5 succeeded at 677 (offset -27 lines).\nHunk #6 succeeded at 708 (offset -27 lines).\n"
+        },
+        {
+            "patch_file": "49289b1fa5a67011.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/49289b1fa5a67011",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/block_dev.c\nHunk #1 succeeded at 1443 (offset -20 lines).\nHunk #2 succeeded at 1514 (offset -19 lines).\nHunk #3 succeeded at 1569 (offset -17 lines).\nHunk #4 succeeded at 1654 (offset -17 lines).\n"
+        },
+        {
+            "patch_file": "a9ed4a6560b8.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/a9ed4a6560b8",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/eventpoll.c\nHunk #1 succeeded at 1883 (offset -111 lines).\nHunk #2 succeeded at 1931 (offset -111 lines).\nHunk #3 FAILED at 2207.\n1 out of 3 hunks FAILED -- saving rejects to file fs/eventpoll.c.rej\n"
+        },
+        {
+            "patch_file": "8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/seq_file.c\nHunk #1 succeeded at 29 (offset -3 lines).\n"
+        },
+        {
+            "patch_file": "9537bae0da1f.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/9537bae0da1f",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/signalfd.c\n"
+        },
+        {
+            "patch_file": "9763ffd4da217.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/9763ffd4da217",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/overlayfs/dir.c\nHunk #1 succeeded at 1028 (offset -186 lines).\n"
+        },
+        {
+            "patch_file": "24d464d38beb08cda1e972f79827d2fed6193de7.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/24d464d38beb08cda1e972f79827d2fed6193de7",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/fuse/dev.c\nHunk #1 succeeded at 957 (offset 7 lines).\n"
+        },
+        {
+            "patch_file": "528611246fcbd.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/528611246fcbd",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file fs/f2fs/node.h\nHunk #1 succeeded at 142 (offset -5 lines).\n"
+        },
+        {
+            "patch_file": "212b4d3a42674d2cf366bd7b06fe9faae03477fc.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/212b4d3a42674d2cf366bd7b06fe9faae03477fc",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "mm/mremap.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej"
+                    "failed_file": "drivers/staging/android/ion/ion.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/staging/android/ion/ion.c.rej"
                 }
             ],
-            "message_output": "patching file mm/mremap.c\nHunk #1 FAILED at 219.\nHunk #2 succeeded at 277 (offset -12 lines).\nHunk #3 succeeded at 285 (offset -12 lines).\nHunk #4 succeeded at 312 with fuzz 2 (offset -11 lines).\nHunk #5 FAILED at 341.\nHunk #6 succeeded at 346 (offset -13 lines).\nHunk #7 succeeded at 367 (offset -12 lines).\n2 out of 7 hunks FAILED -- saving rejects to file mm/mremap.c.rej\n"
+            "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 FAILED at 323.\nHunk #2 succeeded at 344 (offset -26 lines).\n1 out of 2 hunks FAILED -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
+        },
+        {
+            "patch_file": "6c5bc69f722cb5e2fe47196ee8f1aabe6498f8a7.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/6c5bc69f722cb5e2fe47196ee8f1aabe6498f8a7",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 succeeded at 303 (offset -23 lines).\nHunk #2 FAILED at 378.\n1 out of 2 hunks FAILED -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
         },
         {
-            "patch_file": "bce004fba8be9e1bb575301f398b3ecc27ba42de.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/bce004fba8be9e1bb575301f398b3ecc27ba42de",
+            "patch_file": "41a097c0ed6658bf451c5cf993ab0469eb1ce4a5.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/41a097c0ed6658bf451c5cf993ab0469eb1ce4a5",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "mm/mremap.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/mm/mremap.c.rej"
+                    "failed_file": "drivers/staging/android/ion/ion.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/staging/android/ion/ion.c.rej"
                 }
             ],
-            "message_output": "patching file mm/mremap.c\nHunk #1 FAILED at 219.\nHunk #2 FAILED at 289.\nHunk #3 succeeded at 303 with fuzz 2 (offset -2 lines).\nHunk #4 FAILED at 331.\nHunk #5 FAILED at 347.\nHunk #6 FAILED at 365.\nHunk #7 FAILED at 393.\n6 out of 7 hunks FAILED -- saving rejects to file mm/mremap.c.rej\n"
+            "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 FAILED at 969.\n1 out of 1 hunk FAILED -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
         },
         {
-            "patch_file": "65e0a92c6d27d4cbaa0deef668df12b69853d65e.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/65e0a92c6d27d4cbaa0deef668df12b69853d65e",
+            "patch_file": "594cc251fdd0d231d342d88b2fdff4bc42fb0690.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/594cc251fdd0d231d342d88b2fdff4bc42fb0690",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file include/net/af_unix.h\npatching file net/unix/af_unix.c\nHunk #1 succeeded at 817 (offset -60 lines).\npatching file net/unix/garbage.c\npatching file net/unix/scm.c\n"
+            "message_output": "patching file arch/x86/include/asm/uaccess.h\nHunk #1 succeeded at 708 (offset 3 lines).\npatching file drivers/gpu/drm/i915/i915_gem_execbuffer.c\nHunk #1 succeeded at 1557 (offset -67 lines).\nHunk #2 succeeded at 2613 (offset 5 lines).\npatching file lib/strncpy_from_user.c\npatching file lib/strnlen_user.c\n"
         },
         {
-            "patch_file": "94c88f80ffddff00f0af448c02dfd8a3f3cdd692.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/94c88f80ffddff00f0af448c02dfd8a3f3cdd692",
+            "patch_file": "17743798d81238ab13050e8e2833699b54e15467.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/17743798d81238ab13050e8e2833699b54e15467",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file include/net/af_unix.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/af_unix.h.rej\npatching file net/unix/af_unix.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file net/unix/af_unix.c.rej\npatching file net/unix/garbage.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file net/unix/garbage.c.rej\npatching file net/unix/scm.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file net/unix/scm.c.rej\n"
+            "message_output": "patching file mm/hugetlb.c\nHunk #1 succeeded at 2901 with fuzz 1 (offset -564 lines).\nHunk #2 succeeded at 2928 (offset -564 lines).\nHunk #3 succeeded at 2973 (offset -563 lines).\n"
         },
         {
-            "patch_file": "c1a7b4b4a736fa175488122cca9743cff2ae72e8.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/c1a7b4b4a736fa175488122cca9743cff2ae72e8",
+            "patch_file": "4158b1508f2b1.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/4158b1508f2b1",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/linux/rmap.h\nHunk #1 succeeded at 38 (offset -4 lines).\nHunk #2 succeeded at 53 (offset -4 lines).\npatching file mm/rmap.c\nHunk #1 succeeded at 81 (offset -12 lines).\nHunk #2 succeeded at 190 (offset -12 lines).\nHunk #3 succeeded at 200 (offset -12 lines).\nHunk #4 FAILED at 297.\nHunk #5 succeeded at 341 (offset -18 lines).\nHunk #6 succeeded at 362 (offset -18 lines).\nHunk #7 succeeded at 394 (offset -18 lines).\nHunk #8 FAILED at 420.\nHunk #9 succeeded at 413 (offset -27 lines).\n2 out of 9 hunks FAILED -- saving rejects to file mm/rmap.c.rej\n"
+        },
+        {
+            "patch_file": "6f99528e97977.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/6f99528e97977",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/linux/rtnetlink.h\npatching file net/core/rtnetlink.c\nHunk #1 succeeded at 127 (offset -3 lines).\n"
+        },
+        {
+            "patch_file": "3a7d0d07a3867.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/3a7d0d07a3867",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/net/pkt_sched.h\nHunk #1 succeeded at 100 (offset -2 lines).\n"
+        },
+        {
+            "patch_file": "86bd446b5cebd.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/86bd446b5cebd",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/net/sch_generic.h\nHunk #1 succeeded at 500 (offset -54 lines).\npatching file net/sched/sch_api.c\nHunk #1 succeeded at 914 (offset -6 lines).\nHunk #2 succeeded at 967 (offset -6 lines).\npatching file net/sched/sch_atm.c\npatching file net/sched/sch_cbq.c\npatching file net/sched/sch_drr.c\npatching file net/sched/sch_dsmark.c\npatching file net/sched/sch_fifo.c\npatching file net/sched/sch_generic.c\nHunk #1 succeeded at 908 (offset 7 lines).\nHunk #2 succeeded at 948 (offset 7 lines).\nHunk #3 succeeded at 979 (offset 7 lines).\nHunk #4 succeeded at 1280 (offset 5 lines).\nHunk #5 succeeded at 1289 (offset 5 lines).\npatching file net/sched/sch_hfsc.c\npatching file net/sched/sch_mq.c\nHunk #1 succeeded at 32 (offset -33 lines).\nHunk #2 succeeded at 84 (offset -35 lines).\npatching file net/sched/sch_mqprio.c\npatching file net/sched/sch_multiq.c\npatching file net/sched/sch_prio.c\npatching file net/sched/sch_qfq.c\npatching file net/sched/sch_red.c\nHunk #2 succeeded at 232 (offset -1 lines).\npatching file net/sched/sch_sfb.c\n"
+        },
+        {
+            "patch_file": "11db2de0af2a.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/11db2de0af2a",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/linux/security.h\nHunk #1 succeeded at 907 (offset -104 lines).\n"
+        },
+        {
+            "patch_file": "3af7a2f61023.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/3af7a2f61023",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/android/binder.c\nHunk #1 succeeded at 2350 (offset 169 lines).\nHunk #2 succeeded at 2397 (offset 169 lines).\nHunk #3 succeeded at 2482 (offset 165 lines).\nHunk #4 FAILED at 2728.\nHunk #5 succeeded at 4514 (offset -203 lines).\n1 out of 5 hunks FAILED -- saving rejects to file drivers/android/binder.c.rej\npatching file security/security.c\nHunk #1 succeeded at 227 (offset -462 lines).\npatching file security/selinux/hooks.c\nHunk #1 succeeded at 2171 (offset 164 lines).\nHunk #2 FAILED at 2030.\n1 out of 2 hunks FAILED -- saving rejects to file security/selinux/hooks.c.rej\n"
+        },
+        {
+            "patch_file": "35556bed836f.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/35556bed836f",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/linux/hid.h\nHunk #1 succeeded at 931 (offset -28 lines).\nHunk #2 succeeded at 987 (offset -28 lines).\n"
+        },
+        {
+            "patch_file": "bce1305c0ece.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/bce1305c0ece",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/hid/hid-core.c\nHunk #1 succeeded at 1338 (offset -260 lines).\nHunk #2 succeeded at 1360 (offset -260 lines).\nHunk #3 succeeded at 1487 with fuzz 2 (offset -263 lines).\n"
+        },
+        {
+            "patch_file": "55667441c84fa5e0911a0aac44fb059c15ba6da2.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/55667441c84fa5e0911a0aac44fb059c15ba6da2",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "drivers/gpu/msm/kgsl_vbo.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/msm/kgsl_vbo.c.rej"
+                    "failed_file": "include/net/fq_impl.h",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/fq_impl.h.rej"
                 }
             ],
-            "message_output": "patching file drivers/gpu/msm/kgsl.c\npatching file drivers/gpu/msm/kgsl.h\npatching file drivers/gpu/msm/kgsl_reclaim.c\npatching file drivers/gpu/msm/kgsl_vbo.c\nHunk #1 FAILED at 43.\nHunk #2 succeeded at 307 (offset -2 lines).\nHunk #3 succeeded at 418 (offset -2 lines).\n1 out of 3 hunks FAILED -- saving rejects to file drivers/gpu/msm/kgsl_vbo.c.rej\n"
+            "message_output": "patching file include/linux/skbuff.h\nHunk #1 succeeded at 1244 (offset -110 lines).\npatching file include/net/fq.h\nHunk #1 succeeded at 70 (offset 1 line).\npatching file include/net/fq_impl.h\nHunk #1 FAILED at 108.\nHunk #2 succeeded at 307 (offset -1 lines).\n1 out of 2 hunks FAILED -- saving rejects to file include/net/fq_impl.h.rej\npatching file net/core/flow_dissector.c\nHunk #1 succeeded at 1044 (offset -306 lines).\nHunk #2 succeeded at 1073 (offset -306 lines).\nHunk #3 succeeded at 1139 (offset -306 lines).\nHunk #4 succeeded at 1157 (offset -306 lines).\nHunk #5 succeeded at 1211 with fuzz 1 (offset -306 lines).\nHunk #6 succeeded at 1231 (offset -306 lines).\npatching file net/sched/sch_hhf.c\nHunk #1 succeeded at 4 (offset -1 lines).\nHunk #2 succeeded at 125 (offset -1 lines).\nHunk #3 succeeded at 263 (offset -1 lines).\nHunk #4 succeeded at 580 (offset -2 lines).\npatching file net/sched/sch_sfb.c\nHunk #1 succeeded at 22 (offset 4 lines).\nHunk #2 succeeded at 49 (offset 4 lines).\nHunk #3 succeeded at 221 (offset 4 lines).\nHunk #4 succeeded at 319 (offset 4 lines).\nHunk #5 succeeded at 357 (offset 4 lines).\npatching file net/sched/sch_sfq.c\nHunk #1 succeeded at 18 (offset 4 lines).\nHunk #2 succeeded at 121 (offset 4 lines).\nHunk #3 succeeded at 161 (offset 4 lines).\nHunk #4 succeeded at 611 (offset 4 lines).\nHunk #5 succeeded at 694 (offset 4 lines).\nHunk #6 succeeded at 751 (offset 4 lines).\n"
+        },
+        {
+            "patch_file": "b207caff4176.diff",
+            "patch_url": "http://android.googlesource.com/kernel/common/+/b207caff4176",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/linux/compiler.h\n"
+        },
+        {
+            "patch_file": "c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/c1f6e3c818dd734c30f6a7eeebf232ba2cf3181d",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/sound/rawmidi.h\nHunk #1 succeeded at 76 (offset 15 lines).\npatching file sound/core/rawmidi.c\nHunk #1 succeeded at 107 (offset -13 lines).\nHunk #2 FAILED at 680.\nHunk #3 succeeded at 963 (offset -67 lines).\nHunk #4 succeeded at 985 (offset -67 lines).\nHunk #5 succeeded at 1268 (offset -90 lines).\nHunk #6 succeeded at 1300 (offset -90 lines).\n1 out of 6 hunks FAILED -- saving rejects to file sound/core/rawmidi.c.rej\n"
+        },
+        {
+            "patch_file": "dbb2483b2a46fbaf833cfb5deb5ed9cace9c7399.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/dbb2483b2a46fbaf833cfb5deb5ed9cace9c7399",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/net/xfrm.h\nHunk #1 succeeded at 1398 (offset -6 lines).\npatching file net/key/af_key.c\nHunk #1 succeeded at 1936 (offset -15 lines).\npatching file net/xfrm/xfrm_user.c\nHunk #1 succeeded at 1454 (offset -59 lines).\n"
+        },
+        {
+            "patch_file": "5c4c8c9544099bb9043a10a5318130a943e32fc3.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/5c4c8c9544099bb9043a10a5318130a943e32fc3",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/net/bluetooth/hci_core.h\nHunk #1 succeeded at 511 (offset -193 lines).\npatching file net/bluetooth/hci_event.c\nHunk #1 succeeded at 4396 (offset -636 lines).\nHunk #2 succeeded at 4429 (offset -636 lines).\n"
+        },
+        {
+            "patch_file": "cacbff013baa586c63dd779e67d13238bf46c28e.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/cacbff013baa586c63dd779e67d13238bf46c28e",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/net/bluetooth/l2cap.h\nHunk #1 succeeded at 796 (offset -61 lines).\npatching file net/bluetooth/l2cap_core.c\nHunk #1 succeeded at 113 (offset 2 lines).\nHunk #2 succeeded at 122 (offset 2 lines).\nHunk #3 succeeded at 143 (offset 2 lines).\nHunk #4 succeeded at 173 (offset 2 lines).\nHunk #5 succeeded at 499 with fuzz 1 (offset -11 lines).\nHunk #6 succeeded at 1796 (offset -196 lines).\nHunk #7 succeeded at 1814 (offset -196 lines).\nHunk #8 succeeded at 4178 (offset -312 lines).\nHunk #9 succeeded at 4291 (offset -314 lines).\nHunk #10 succeeded at 5015 (offset -318 lines).\nHunk #11 succeeded at 5108 (offset -318 lines).\nHunk #12 succeeded at 5138 (offset -318 lines).\nHunk #13 succeeded at 5202 (offset -318 lines).\nHunk #14 succeeded at 5238 (offset -318 lines).\nHunk #15 succeeded at 5611 (offset -318 lines).\nHunk #16 succeeded at 5626 (offset -318 lines).\nHunk #17 succeeded at 6915 (offset -717 lines).\nHunk #18 succeeded at 7320 (offset -801 lines).\n"
+        },
+        {
+            "patch_file": "2f9fed9ce805cf4d97cffb2f59d57b41b8e7fca8.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/2f9fed9ce805cf4d97cffb2f59d57b41b8e7fca8",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file include/net/bluetooth/l2cap.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/bluetooth/l2cap.h.rej\npatching file net/bluetooth/l2cap_core.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n18 out of 18 hunks ignored -- saving rejects to file net/bluetooth/l2cap_core.c.rej\n"
         },
         {
-            "patch_file": "61abd2ada929a54983f95345ffa2504bbd9b993d.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/61abd2ada929a54983f95345ffa2504bbd9b993d",
+            "patch_file": "769d14abd35e0.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/769d14abd35e0",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/gpu/msm/kgsl_vbo.c\nHunk #2 succeeded at 366 (offset -6 lines).\nHunk #3 succeeded at 472 (offset -6 lines).\n"
+            "message_output": "patching file include/net/sctp/sctp.h\nHunk #1 succeeded at 116 (offset 13 lines).\nHunk #2 succeeded at 127 (offset 13 lines).\npatching file include/net/sctp/structs.h\nHunk #1 succeeded at 1332 (offset -7 lines).\nHunk #2 succeeded at 1348 (offset -7 lines).\npatching file net/sctp/diag.c\nHunk #1 succeeded at 310 (offset 18 lines).\nHunk #2 succeeded at 321 (offset 18 lines).\nHunk #3 succeeded at 365 (offset 18 lines).\nHunk #4 succeeded at 524 (offset 17 lines).\npatching file net/sctp/endpointola.c\nHunk #1 succeeded at 241 (offset 57 lines).\nHunk #2 succeeded at 286 (offset 61 lines).\n"
         },
         {
-            "patch_file": "25c49620c22e375fbd69631ea1eb408ed43db6e0.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/25c49620c22e375fbd69631ea1eb408ed43db6e0",
+            "patch_file": "d4dbef7046e2.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/d4dbef7046e2",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/gpu/msm/kgsl_vbo.c\nHunk #2 succeeded at 47 (offset 1 line).\nHunk #3 succeeded at 120 (offset 1 line).\nHunk #4 succeeded at 167 (offset 1 line).\nHunk #5 succeeded at 221 (offset 1 line).\nHunk #6 succeeded at 251 (offset 1 line).\n"
+            "message_output": "patching file include/net/sctp/structs.h\nHunk #1 succeeded at 471 (offset 13 lines).\npatching file net/sctp/bind_addr.c\nHunk #1 succeeded at 285 (offset 15 lines).\nHunk #2 succeeded at 306 (offset 15 lines).\npatching file net/sctp/input.c\nHunk #1 succeeded at 1080 (offset -51 lines).\nHunk #2 succeeded at 1124 (offset -51 lines).\npatching file net/sctp/ipv6.c\nHunk #1 succeeded at 519 (offset -11 lines).\npatching file net/sctp/sm_make_chunk.c\nHunk #1 succeeded at 2344 (offset 15 lines).\nHunk #2 succeeded at 2536 (offset 20 lines).\nHunk #3 succeeded at 2630 (offset 12 lines).\nHunk #4 succeeded at 3047 (offset 9 lines).\nHunk #5 succeeded at 3325 (offset 9 lines).\n"
         },
         {
-            "patch_file": "8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.10/commit/8954d806a5c57b8bdb3fe7cd32147fc1f7d5974e",
+            "patch_file": "6ef81a5c0e22.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/6ef81a5c0e22",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/gpu/msm/kgsl.c\nHunk #1 succeeded at 3870 (offset -7 lines).\nHunk #2 succeeded at 3889 (offset -7 lines).\nHunk #3 succeeded at 3911 (offset -7 lines).\n"
+            "message_output": "patching file net/sctp/input.c\nHunk #1 succeeded at 1196 (offset -51 lines).\n"
         },
         {
-            "patch_file": "7a2aa337ab8235460c1efa92a846eaeade5f2514.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/7a2aa337ab8235460c1efa92a846eaeade5f2514",
+            "patch_file": "ffca46766850.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ffca46766850",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nHunk #1 succeeded at 1799 (offset -38 lines).\n"
+            "message_output": "patching file net/sctp/input.c\nHunk #1 succeeded at 1117 (offset -51 lines).\n"
         },
         {
-            "patch_file": "bf4f9bc41c3b5203e1e7284e1de78e82f0630473.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/bf4f9bc41c3b5203e1e7284e1de78e82f0630473",
+            "patch_file": "b6d75218ff65f.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/b6d75218ff65f",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/ptrace.c\nHunk #1 succeeded at 340 (offset -31 lines).\nHunk #2 succeeded at 371 (offset -31 lines).\nHunk #3 succeeded at 653 (offset -31 lines).\n"
         },
         {
-            "patch_file": "b42ed94769088450987f2b52f41a3fb274244827.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/b42ed94769088450987f2b52f41a3fb274244827",
+            "patch_file": "5a41a3033a934.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/5a41a3033a934",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nHunk #1 succeeded at 3415 (offset -221 lines).\n"
+            "message_output": "patching file kernel/ptrace.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file kernel/ptrace.c.rej\n"
         },
         {
-            "patch_file": "f4e5b5151e55932279287c55d4e4a801fbf1df96.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/f4e5b5151e55932279287c55d4e4a801fbf1df96",
+            "patch_file": "6210ced85099d.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/6210ced85099d",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/ptrace.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file kernel/ptrace.c.rej\n"
         },
         {
-            "patch_file": "c2201dde2a76788b5b7a75426e53a58e1490a028.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/c2201dde2a76788b5b7a75426e53a58e1490a028",
+            "patch_file": "2ad3e17ebf94b7b7f3f64c050ff168f9915345eb.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/2ad3e17ebf94b7b7f3f64c050ff168f9915345eb",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/auditfilter.c\nHunk #1 succeeded at 454 (offset -2 lines).\nHunk #2 succeeded at 463 (offset -2 lines).\nHunk #3 succeeded at 484 (offset -2 lines).\nHunk #4 succeeded at 493 (offset -2 lines).\nHunk #5 succeeded at 511 (offset -2 lines).\nHunk #6 succeeded at 526 (offset -2 lines).\n"
         },
         {
-            "patch_file": "370ea8bc2e0b1c4880c41bbfc2b01bac973209b9.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/370ea8bc2e0b1c4880c41bbfc2b01bac973209b9",
+            "patch_file": "e80c3533c354e.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/e80c3533c354e",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file arch/arm64/net/bpf_jit_comp.c\nHunk #1 succeeded at 663 (offset -38 lines).\npatching file arch/mips/net/ebpf_jit.c\nHunk #1 succeeded at 1304 (offset -51 lines).\npatching file arch/s390/net/bpf_jit_comp.c\nHunk #1 succeeded at 832 (offset -82 lines).\npatching file arch/x86/net/bpf_jit_comp.c\nHunk #1 succeeded at 745 (offset 17 lines).\npatching file arch/x86/net/bpf_jit_comp32.c\nHunk #1 succeeded at 1845 (offset 140 lines).\npatching file kernel/bpf/disasm.c\nHunk #1 succeeded at 171 (offset 9 lines).\n"
         },
         {
-            "patch_file": "ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/ae7e5da1cae2b6be45f7c6ab6a70d35f6e532d5a",
+            "patch_file": "30e29a9a2bc6a4888335a6ede968b75cd329657a.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/30e29a9a2bc6a4888335a6ede968b75cd329657a",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/bpf/stackmap.c\nHunk #1 succeeded at 45 (offset -18 lines).\n"
         },
         {
-            "patch_file": "30efc10dfe20bbf7410adb3d756106f365ac75cc.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/30efc10dfe20bbf7410adb3d756106f365ac75cc",
+            "patch_file": "050fad7c4534c13c8eb1d9c2ba66012e014773cb.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/bpf/core.c\nHunk #1 succeeded at 219 (offset 1 line).\nHunk #2 succeeded at 307 (offset 1 line).\nHunk #3 succeeded at 341 (offset 1 line).\npatching file net/core/filter.c\nHunk #1 succeeded at 645 (offset 164 lines).\n"
         },
         {
-            "patch_file": "135a19cfad1e5e9c1db63970df743c28f5dd74c8.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/135a19cfad1e5e9c1db63970df743c28f5dd74c8",
+            "patch_file": "ee1e2de73cc54.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ee1e2de73cc54",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/cgroup/cgroup-v1.c\nHunk #1 succeeded at 576 (offset 28 lines).\nHunk #2 FAILED at 969.\n1 out of 2 hunks FAILED -- saving rejects to file kernel/cgroup/cgroup-v1.c.rej\n"
         },
         {
-            "patch_file": "6a1de5f5d37141467efb9e5d9b3844a19f9990a9.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/6a1de5f5d37141467efb9e5d9b3844a19f9990a9",
+            "patch_file": "1fc3444cda9a7.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/1fc3444cda9a7",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/android/binder.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/android/binder.c.rej\n"
+            "message_output": "patching file kernel/cgroup/cgroup-v1.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file kernel/cgroup/cgroup-v1.c.rej\n"
         },
         {
-            "patch_file": "051d2f9bed5c7b1f58fd3e2808420b5106512a46.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.15/commit/051d2f9bed5c7b1f58fd3e2808420b5106512a46",
+            "patch_file": "26f55a59dc65ff77cd1c4b37991e26497fc68049.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/26f55a59dc65ff77cd1c4b37991e26497fc68049",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/slimbus/qcom-ngd-ctrl.c\nHunk #3 succeeded at 970 (offset -2 lines).\nHunk #4 succeeded at 978 (offset -2 lines).\nHunk #5 succeeded at 1053 (offset 1 line).\nHunk #6 succeeded at 1114 (offset -2 lines).\nHunk #7 succeeded at 1132 (offset -4 lines).\nHunk #8 succeeded at 1146 (offset -4 lines).\nHunk #9 succeeded at 1155 (offset -4 lines).\nHunk #10 succeeded at 2136 (offset -23 lines).\n"
+            "message_output": "patching file arch/x86/net/bpf_jit_comp32.c\nHunk #1 succeeded at 2311 (offset 35 lines).\n"
         },
         {
-            "patch_file": "0215bbc2e0d7590e324c9d11cc4247304ff65f22.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.4/commit/0215bbc2e0d7590e324c9d11cc4247304ff65f22",
+            "patch_file": "e4d4d456436bfb2fe412ee2cd489f7658449b098.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/e4d4d456436bfb2fe412ee2cd489f7658449b098",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/media/platform/msm/cvp/hfi_response_handler.c\nHunk #1 succeeded at 461 (offset -6 lines).\nHunk #2 succeeded at 513 (offset -6 lines).\nHunk #3 succeeded at 536 (offset -6 lines).\ncan't find file to patch at input line 42\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n|diff --git a/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c b/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c\n|index 013232aaa66dc6a0dce12ca7b4c01305d8afa159..539779ba2fab42703223d78000b39e7c39ccdb33 100644\n|--- a/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c\n|+++ b/drivers/media/platform/msm/cvp2.0/hfi_response_handler.c\n--------------------------\nFile to patch: \nSkip this patch? [y] \nSkipping patch.\n3 out of 3 hunks ignored\n"
+            "message_output": "patching file arch/x86/net/bpf_jit_comp.c\nHunk #1 succeeded at 1046 (offset -643 lines).\n"
         },
         {
-            "patch_file": "28204d125055f0dec3e9625382cb92810f5528d0.diff",
-            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-5.15/commit/28204d125055f0dec3e9625382cb92810f5528d0",
+            "patch_file": "96468c6085fc87f1defb2b187bd778505723e1bc.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/96468c6085fc87f1defb2b187bd778505723e1bc",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file drivers/char/adsprpc.c\nHunk #1 succeeded at 6267 (offset -34 lines).\n"
+            "message_output": "patching file arch/arm64/include/asm/cpu.h\nHunk #1 succeeded at 36 (offset -14 lines).\npatching file arch/arm64/kvm/sys_regs.c\nHunk #1 succeeded at 1244 (offset -249 lines).\n"
         },
         {
-            "patch_file": "841cae881066f0dd38d15a90cfcf245b0db9fc73.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/841cae881066f0dd38d15a90cfcf245b0db9fc73",
+            "patch_file": "15e43a2ac5e15c503c104831e9e2b6d5fc7d6131.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/15e43a2ac5e15c503c104831e9e2b6d5fc7d6131",
             "status": "Applied Successfully",
             "rejected_files": [],
-            "message_output": "patching file net/sched/sch_multiq.c\n"
+            "message_output": "patching file arch/arm64/include/asm/sections.h\nHunk #1 succeeded at 30 (offset 7 lines).\n"
         },
         {
-            "patch_file": "3856ad0c3e3028d54c8dac960dec411e45c13146.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/3856ad0c3e3028d54c8dac960dec411e45c13146",
+            "patch_file": "885349f53dd73.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/885349f53dd73",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file arch/arm64/kernel/armv8_deprecated.c\nHunk #1 succeeded at 63 (offset 4 lines).\nHunk #2 succeeded at 209 (offset 1 line).\nHunk #3 succeeded at 225 (offset 1 line).\nHunk #4 succeeded at 247 (offset -1 lines).\n"
+        },
+        {
+            "patch_file": "9c698bff66ab4914bb3d71da7dc6112519bde23e.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/9c698bff66ab4914bb3d71da7dc6112519bde23e",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file arch/arm/kernel/signal.c\nHunk #1 succeeded at 682 (offset -11 lines).\n"
+        },
+        {
+            "patch_file": "8f66dc1a78a743ea3c3f039500d2aa0cddd776d5.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/8f66dc1a78a743ea3c3f039500d2aa0cddd776d5",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "include/net/sock.h",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej"
+                    "failed_file": "drivers/mmc/core/block.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/mmc/core/block.c.rej"
                 }
             ],
-            "message_output": "patching file include/net/dst_ops.h\npatching file include/net/sock.h\nHunk #1 FAILED at 2012.\n1 out of 1 hunk FAILED -- saving rejects to file include/net/sock.h.rej\npatching file net/ipv4/route.c\npatching file net/ipv6/route.c\npatching file net/xfrm/xfrm_policy.c\nHunk #1 succeeded at 3804 (offset 5 lines).\n"
+            "message_output": "patching file drivers/mmc/core/block.c\nHunk #1 FAILED at 1652.\n1 out of 1 hunk FAILED -- saving rejects to file drivers/mmc/core/block.c.rej\n"
         },
         {
-            "patch_file": "b8932254b9b2f02620e96572fee9c615c1db2bc3.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/b8932254b9b2f02620e96572fee9c615c1db2bc3",
+            "patch_file": "8a3679a75730c1babde6bf63e35d227f3305bd90.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/8a3679a75730c1babde6bf63e35d227f3305bd90",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/mmc/core/block.c\nHunk #1 succeeded at 1682 (offset -18 lines).\n"
+        },
+        {
+            "patch_file": "2aea7dc18f4249dc53e53598db50b59c26a60aeb.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/2aea7dc18f4249dc53e53598db50b59c26a60aeb",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/mmc/core/block.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/mmc/core/block.c.rej\n"
+        },
+        {
+            "patch_file": "618a931c.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/618a931c",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/staging/android/ion/ion.c\nHunk #1 succeeded at 140 (offset -20 lines).\n"
+        },
+        {
+            "patch_file": "b6b3781a.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/b6b3781a",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/staging/android/ion/ion.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/staging/android/ion/ion.c.rej\n"
+        },
+        {
+            "patch_file": "032a6762957f8.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/032a6762957f8",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "include/net/sock.h",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej"
-                },
-                {
-                    "failed_file": "net/ipv4/route.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej"
-                },
-                {
-                    "failed_file": "net/ipv6/route.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej"
+                    "failed_file": "drivers/tee/tee_shm.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tee/tee_shm.c.rej"
                 }
             ],
-            "message_output": "patching file include/net/dst_ops.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/dst_ops.h.rej\npatching file include/net/sock.h\nHunk #1 FAILED at 2083.\n1 out of 1 hunk FAILED -- saving rejects to file include/net/sock.h.rej\npatching file net/ipv4/route.c\nHunk #1 FAILED at 139.\nHunk #2 FAILED at 844.\n2 out of 2 hunks FAILED -- saving rejects to file net/ipv4/route.c.rej\npatching file net/ipv6/route.c\nHunk #1 FAILED at 87.\nHunk #2 FAILED at 2763.\n2 out of 2 hunks FAILED -- saving rejects to file net/ipv6/route.c.rej\npatching file net/xfrm/xfrm_policy.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file net/xfrm/xfrm_policy.c.rej\n"
+            "message_output": "patching file drivers/tee/tee_shm.c\nHunk #1 FAILED at 1.\nHunk #2 FAILED at 28.\nHunk #3 FAILED at 64.\nHunk #4 succeeded at 152 with fuzz 2 (offset 15 lines).\nHunk #5 FAILED at 151.\nHunk #6 FAILED at 162.\nHunk #7 succeeded at 266 with fuzz 2 (offset 22 lines).\nHunk #8 FAILED at 305.\nHunk #9 succeeded at 350 (offset 12 lines).\nHunk #10 FAILED at 379.\nHunk #11 succeeded at 403 (offset 11 lines).\nHunk #12 succeeded at 510 (offset 11 lines).\nHunk #13 succeeded at 530 (offset 11 lines).\n7 out of 13 hunks FAILED -- saving rejects to file drivers/tee/tee_shm.c.rej\n"
         },
         {
-            "patch_file": "079d4f3ff06b21f99aed51d8b22534bdfda5a134.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/079d4f3ff06b21f99aed51d8b22534bdfda5a134",
+            "patch_file": "c05d8f66ec347.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/c05d8f66ec347",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "include/net/sock.h",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej"
+                    "failed_file": "drivers/tee/tee_shm.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tee/tee_shm.c.rej"
                 }
             ],
-            "message_output": "patching file include/net/dst_ops.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/dst_ops.h.rej\npatching file include/net/sock.h\nHunk #1 FAILED at 1919.\n1 out of 1 hunk FAILED -- saving rejects to file include/net/sock.h.rej\npatching file net/ipv4/route.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file net/ipv4/route.c.rej\npatching file net/ipv6/route.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file net/ipv6/route.c.rej\npatching file net/xfrm/xfrm_policy.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file net/xfrm/xfrm_policy.c.rej\n"
+            "message_output": "patching file drivers/tee/tee_shm.c\nHunk #1 FAILED at 1.\nHunk #2 FAILED at 28.\nHunk #3 FAILED at 64.\nHunk #4 FAILED at 137.\nHunk #5 FAILED at 150.\nHunk #6 FAILED at 161.\nHunk #7 FAILED at 243.\nHunk #8 FAILED at 303.\nHunk #9 succeeded at 379 with fuzz 2 (offset 43 lines).\nHunk #10 FAILED at 377.\nHunk #11 FAILED at 390.\nHunk #12 FAILED at 507.\nHunk #13 FAILED at 522.\n12 out of 13 hunks FAILED -- saving rejects to file drivers/tee/tee_shm.c.rej\n"
+        },
+        {
+            "patch_file": "5de5b6ecf97a021f29403aa272cb4e03318ef586.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/5de5b6ecf97a021f29403aa272cb4e03318ef586",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/gpu/drm/nouveau/nouveau_sgdma.c\nHunk #1 succeeded at 96 (offset 1 line).\npatching file drivers/gpu/drm/ttm/ttm_tt.c\nHunk #1 succeeded at 251 (offset 7 lines).\nHunk #2 succeeded at 274 (offset 7 lines).\nHunk #3 succeeded at 295 (offset 7 lines).\n"
         },
         {
-            "patch_file": "41a05cfc0e471cea173345622375b672edd8ed3c.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/41a05cfc0e471cea173345622375b672edd8ed3c",
+            "patch_file": "df2c1f38939aa.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/df2c1f38939aa",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "include/net/sock.h",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej"
+                    "failed_file": "drivers/gpu/drm/vgem/vgem_drv.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/gpu/drm/vgem/vgem_drv.c.rej"
                 }
             ],
-            "message_output": "patching file include/net/dst_ops.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/dst_ops.h.rej\npatching file include/net/sock.h\nHunk #1 FAILED at 1955.\n1 out of 1 hunk FAILED -- saving rejects to file include/net/sock.h.rej\npatching file net/ipv4/route.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file net/ipv4/route.c.rej\npatching file net/ipv6/route.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file net/ipv6/route.c.rej\npatching file net/xfrm/xfrm_policy.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file net/xfrm/xfrm_policy.c.rej\n"
+            "message_output": "patching file drivers/gpu/drm/vgem/vgem_drv.c\nHunk #1 FAILED at 189.\nHunk #2 succeeded at 219 (offset 5 lines).\n1 out of 2 hunks FAILED -- saving rejects to file drivers/gpu/drm/vgem/vgem_drv.c.rej\n"
         },
         {
-            "patch_file": "9b0dadc811eb0140a61734cde73498c1dd574fa1.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/9b0dadc811eb0140a61734cde73498c1dd574fa1",
+            "patch_file": "c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "include/net/sock.h",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej"
-                },
-                {
-                    "failed_file": "net/ipv4/route.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej"
-                },
-                {
-                    "failed_file": "net/ipv6/route.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej"
+                    "failed_file": "drivers/tty/tty_jobctrl.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tty/tty_jobctrl.c.rej"
                 }
             ],
-            "message_output": "patching file include/net/dst_ops.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/dst_ops.h.rej\npatching file include/net/sock.h\nHunk #1 FAILED at 2088.\n1 out of 1 hunk FAILED -- saving rejects to file include/net/sock.h.rej\npatching file net/ipv4/route.c\nHunk #1 FAILED at 139.\nHunk #2 FAILED at 844.\n2 out of 2 hunks FAILED -- saving rejects to file net/ipv4/route.c.rej\npatching file net/ipv6/route.c\nHunk #1 FAILED at 87.\nHunk #2 FAILED at 2763.\n2 out of 2 hunks FAILED -- saving rejects to file net/ipv6/route.c.rej\npatching file net/xfrm/xfrm_policy.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file net/xfrm/xfrm_policy.c.rej\n"
+            "message_output": "patching file drivers/tty/tty_io.c\nHunk #1 succeeded at 2724 (offset -173 lines).\nHunk #2 succeeded at 2763 (offset -173 lines).\npatching file drivers/tty/tty_jobctrl.c\nHunk #4 FAILED at 502.\n1 out of 5 hunks FAILED -- saving rejects to file drivers/tty/tty_jobctrl.c.rej\n"
+        },
+        {
+            "patch_file": "54ffccbf053b5b6ca4f6e45094b942fab92a25fc.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/54ffccbf053b5b6ca4f6e45094b942fab92a25fc",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/tty/tty_jobctrl.c\nHunk #1 succeeded at 502 (offset 8 lines).\n"
+        },
+        {
+            "patch_file": "82e61c3909db51d91b9d3e2071557b6435018b80.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/82e61c3909db51d91b9d3e2071557b6435018b80",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/tty/vt/keyboard.c\nHunk #1 succeeded at 709 (offset -34 lines).\nHunk #2 succeeded at 1958 (offset -38 lines).\nHunk #3 FAILED at 2028.\n1 out of 3 hunks FAILED -- saving rejects to file drivers/tty/vt/keyboard.c.rej\n"
         },
         {
-            "patch_file": "bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5.diff",
-            "patch_url": "https://android.googlesource.com/kernel/common/+/bd2bcb81d4ebcffd4e56bb8dfe3e3d4c871928f5",
+            "patch_file": "90bfdeef83f1d6c696039b6a917190dcbbad3220.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/90bfdeef83f1d6c696039b6a917190dcbbad3220",
             "status": "Rejected",
             "rejected_files": [
                 {
-                    "failed_file": "include/net/sock.h",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/include/net/sock.h.rej"
-                },
+                    "failed_file": "drivers/tty/vt/vt_ioctl.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/tty/vt/vt_ioctl.c.rej"
+                }
+            ],
+            "message_output": "patching file drivers/tty/vt/vt_ioctl.c\nHunk #1 FAILED at 484.\nHunk #2 succeeded at 239 (offset -263 lines).\nHunk #3 FAILED at 519.\nHunk #4 FAILED at 538.\nHunk #5 FAILED at 585.\nHunk #6 FAILED at 594.\nHunk #7 FAILED at 610.\nHunk #8 succeeded at 1072 (offset 5 lines).\nHunk #9 succeeded at 1092 (offset 5 lines).\nHunk #10 succeeded at 1101 (offset 5 lines).\nHunk #11 FAILED at 1186.\n7 out of 11 hunks FAILED -- saving rejects to file drivers/tty/vt/vt_ioctl.c.rej\n"
+        },
+        {
+            "patch_file": "d75ef462c3dbd5bb52313e32d545c8be7f79049d.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/d75ef462c3dbd5bb52313e32d545c8be7f79049d",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/video/fbdev/pxa3xx-gcu.c\nHunk #1 succeeded at 393 (offset 12 lines).\n"
+        },
+        {
+            "patch_file": "19bb609b45fb.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/19bb609b45fb",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/android/binder.c\nHunk #1 succeeded at 1832 (offset 313 lines).\n"
+        },
+        {
+            "patch_file": "cb222aed03d798fc074be55e59d9a112338ee784.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/cb222aed03d798fc074be55e59d9a112338ee784",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/input/input.c\nHunk #1 succeeded at 850 (offset -28 lines).\nHunk #2 succeeded at 917 (offset -28 lines).\n"
+        },
+        {
+            "patch_file": "64e6bbfff52db4bf6785fab9cffab850b2de6870.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/64e6bbfff52db4bf6785fab9cffab850b2de6870",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/configfs.c\nHunk #1 succeeded at 231 (offset 10 lines).\n"
+        },
+        {
+            "patch_file": "53afb231f54a69d827b882fa282b30bb10cb08a5.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/53afb231f54a69d827b882fa282b30bb10cb08a5",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/composite.c\nHunk #1 succeeded at 2079 (offset -142 lines).\npatching file drivers/usb/gadget/legacy/dbgp.c\n"
+        },
+        {
+            "patch_file": "b4604acd52a691c2fd33ad0a0fafb7cc19dee5de.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/b4604acd52a691c2fd33ad0a0fafb7cc19dee5de",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/composite.c\nHunk #1 succeeded at 1569 (offset -110 lines).\npatching file drivers/usb/gadget/legacy/dbgp.c\npatching file drivers/usb/gadget/legacy/inode.c\nHunk #1 succeeded at 109 (offset -1 lines).\nHunk #2 succeeded at 145 (offset -1 lines).\nHunk #3 succeeded at 1334 (offset -1 lines).\n"
+        },
+        {
+            "patch_file": "823fc2b264f1ec12678564271c5fa34e3250cf83.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/823fc2b264f1ec12678564271c5fa34e3250cf83",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/composite.c\nHunk #1 succeeded at 1863 (offset -112 lines).\n"
+        },
+        {
+            "patch_file": "528615555b59cbd659186d44b3c6db69c30414eb.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/528615555b59cbd659186d44b3c6db69c30414eb",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/function/rndis.c\n"
+        },
+        {
+            "patch_file": "7193ad3e50e59.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/7193ad3e50e59",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/composite.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/composite.c.rej\npatching file drivers/usb/gadget/legacy/dbgp.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/legacy/dbgp.c.rej\npatching file drivers/usb/gadget/legacy/inode.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file drivers/usb/gadget/legacy/inode.c.rej\n"
+        },
+        {
+            "patch_file": "fb4ff0f96de37.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/fb4ff0f96de37",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/function/rndis.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/function/rndis.c.rej\n"
+        },
+        {
+            "patch_file": "c7732dbce590e.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/c7732dbce590e",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/composite.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/composite.c.rej\n"
+        },
+        {
+            "patch_file": "22ec100472854.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/22ec100472854",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/composite.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/composite.c.rej\n"
+        },
+        {
+            "patch_file": "fdd64084e4055.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/fdd64084e4055",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/legacy/inode.c\n"
+        },
+        {
+            "patch_file": "590a98d5d1086.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/590a98d5d1086",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/legacy/inode.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n2 out of 2 hunks ignored -- saving rejects to file drivers/usb/gadget/legacy/inode.c.rej\n"
+        },
+        {
+            "patch_file": "ff0000fe82f45.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ff0000fe82f45",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/legacy/inode.c\nHunk #1 succeeded at 1829 (offset 1 line).\n"
+        },
+        {
+            "patch_file": "c13159a588818.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/c13159a588818",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/legacy/inode.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/legacy/inode.c.rej\n"
+        },
+        {
+            "patch_file": "38ea1eac7d88072bbffb630e2b3db83ca649b826.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/38ea1eac7d88072bbffb630e2b3db83ca649b826",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/gadget/function/rndis.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/usb/gadget/function/rndis.c.rej\n"
+        },
+        {
+            "patch_file": "056ad39ee925.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/056ad39ee925",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/core/message.c\nHunk #1 succeeded at 587 (offset -2 lines).\nHunk #2 succeeded at 607 (offset -2 lines).\n"
+        },
+        {
+            "patch_file": "b5fdf5c6e6bee35837e160c00ac89327bdad031b.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/b5fdf5c6e6bee35837e160c00ac89327bdad031b",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/usb/host/max3421-hcd.c\nHunk #7 succeeded at 1354 (offset 1 line).\n"
+        },
+        {
+            "patch_file": "68035c80e129.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/68035c80e129",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/media/usb/uvc/uvc_driver.c\nHunk #1 succeeded at 1444 (offset -49 lines).\nHunk #2 succeeded at 1530 (offset -49 lines).\n"
+        },
+        {
+            "patch_file": "a50ef731e0981.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/a50ef731e0981",
+            "status": "Rejected",
+            "rejected_files": [
                 {
-                    "failed_file": "net/ipv4/route.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv4/route.c.rej"
-                },
+                    "failed_file": "drivers/media/v4l2-core/v4l2-mem2mem.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/drivers/media/v4l2-core/v4l2-mem2mem.c.rej"
+                }
+            ],
+            "message_output": "patching file drivers/media/v4l2-core/v4l2-mem2mem.c\nHunk #1 FAILED at 585.\nHunk #2 succeeded at 380 (offset -225 lines).\nHunk #3 succeeded at 539 with fuzz 2 (offset -239 lines).\nHunk #4 FAILED at 802.\nHunk #5 FAILED at 813.\n3 out of 5 hunks FAILED -- saving rejects to file drivers/media/v4l2-core/v4l2-mem2mem.c.rej\n"
+        },
+        {
+            "patch_file": "bdb176c8afd933f26a135aba4d4a0384fb13d156.diff",
+            "patch_url": "https://git.codelinaro.org/clo/la/kernel/msm-4.14/commit/bdb176c8afd933f26a135aba4d4a0384fb13d156",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/media/platform/qcom/venus/hfi_msgs.c\n"
+        },
+        {
+            "patch_file": "4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/md/dm-ioctl.c\n"
+        },
+        {
+            "patch_file": "7320fb1abd44b68bbeeb6ad6eb828899ab6b617e.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/7320fb1abd44b68bbeeb6ad6eb828899ab6b617e",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/hid/hid-corsair.c\nHunk #1 succeeded at 556 (offset 3 lines).\npatching file drivers/hid/hid-elo.c\nHunk #1 succeeded at 230 (offset 1 line).\npatching file drivers/hid/hid-holtek-kbd.c\nHunk #1 succeeded at 138 (offset -2 lines).\npatching file drivers/hid/hid-holtek-mouse.c\nHunk #1 succeeded at 65 (offset 3 lines).\nHunk #2 succeeded at 94 (offset 3 lines).\npatching file drivers/hid/hid-lg.c\nHunk #1 succeeded at 714 (offset -55 lines).\npatching file drivers/hid/hid-prodikeys.c\nHunk #1 succeeded at 794 (offset -4 lines).\npatching file drivers/hid/hid-roccat-arvo.c\nHunk #1 succeeded at 347 (offset 3 lines).\npatching file drivers/hid/hid-roccat-isku.c\nHunk #1 succeeded at 327 (offset 3 lines).\npatching file drivers/hid/hid-roccat-kone.c\nHunk #1 succeeded at 743 (offset -6 lines).\npatching file drivers/hid/hid-roccat-koneplus.c\nHunk #1 succeeded at 434 (offset 3 lines).\npatching file drivers/hid/hid-roccat-konepure.c\nHunk #1 succeeded at 136 (offset 3 lines).\npatching file drivers/hid/hid-roccat-kovaplus.c\nHunk #1 succeeded at 504 (offset 3 lines).\npatching file drivers/hid/hid-roccat-lua.c\nHunk #1 succeeded at 163 (offset 3 lines).\npatching file drivers/hid/hid-roccat-pyra.c\nHunk #1 succeeded at 452 (offset 3 lines).\npatching file drivers/hid/hid-roccat-ryos.c\nHunk #1 succeeded at 144 (offset 3 lines).\npatching file drivers/hid/hid-roccat-savu.c\nHunk #1 succeeded at 116 (offset 3 lines).\n"
+        },
+        {
+            "patch_file": "e98c96b8b8a5a7a97a0c1ae75638b362b16f0187.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/e98c96b8b8a5a7a97a0c1ae75638b362b16f0187",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/hid/wacom_sys.c\nHunk #1 succeeded at 674 (offset -52 lines).\nHunk #2 succeeded at 2374 (offset -74 lines).\nHunk #3 succeeded at 2656 (offset -74 lines).\nHunk #4 succeeded at 2692 (offset -72 lines).\n"
+        },
+        {
+            "patch_file": "ed9be64eefe2.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ed9be64eefe2",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/hid/hid-core.c\nHunk #3 succeeded at 253 (offset -47 lines).\n"
+        },
+        {
+            "patch_file": "bce1305c0ece3.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/bce1305c0ece3",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/hid/hid-core.c\nHunk #1 succeeded at 1349 (offset -249 lines).\nHunk #2 FAILED at 1620.\nHunk #3 FAILED at 1750.\n2 out of 3 hunks FAILED -- saving rejects to file drivers/hid/hid-core.c.rej\n"
+        },
+        {
+            "patch_file": "f6ec306b93dc6.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/f6ec306b93dc6",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/char/virtio_console.c\nHunk #1 succeeded at 489 (offset 14 lines).\nHunk #2 succeeded at 1753 (offset 41 lines).\n"
+        },
+        {
+            "patch_file": "9292423a3e5fcf8b341ffbd135487f32f7e33d41.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/9292423a3e5fcf8b341ffbd135487f32f7e33d41",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/net/can/usb/ems_usb.c\n"
+        },
+        {
+            "patch_file": "bb4c6c0105eccc03b6bd005b6b396e1faf995a48.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/bb4c6c0105eccc03b6bd005b6b396e1faf995a48",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/net/can/usb/usb_8dev.c\nHunk #1 succeeded at 680 (offset 10 lines).\nHunk #2 succeeded at 712 (offset 10 lines).\n"
+        },
+        {
+            "patch_file": "5c455c5ab332773464d02ba17015acdca198f03d.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/5c455c5ab332773464d02ba17015acdca198f03d",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/net/wireless/marvell/mwifiex/join.c\n"
+        },
+        {
+            "patch_file": "e7f39d0aa294f.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/e7f39d0aa294f",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/net/usb/sr9700.c\n"
+        },
+        {
+            "patch_file": "4f5f5411f0c14.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/4f5f5411f0c14",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/net/usb/sr9700.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file drivers/net/usb/sr9700.c.rej\n"
+        },
+        {
+            "patch_file": "35fc4cd34426c242ab015ef280853b7bff101f48.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/35fc4cd34426c242ab015ef280853b7bff101f48",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file drivers/scsi/ufs/ufshcd.c\nHunk #1 succeeded at 5517 (offset -1142 lines).\nHunk #2 succeeded at 5535 (offset -1142 lines).\n"
+        },
+        {
+            "patch_file": "ef299cc3fa1a9.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ef299cc3fa1a9",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/sched/cls_route.c\nHunk #1 succeeded at 541 (offset 7 lines).\n"
+        },
+        {
+            "patch_file": "8f4dc50b5c12e159.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/8f4dc50b5c12e159",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/netfilter/nf_tables_api.c\nHunk #1 succeeded at 796 (offset -185 lines).\n"
+        },
+        {
+            "patch_file": "b29c457a6511435960115c0f548c4360d5f4801d.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/b29c457a6511435960115c0f548c4360d5f4801d",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/ipv4/netfilter/arp_tables.c\nHunk #1 succeeded at 1189 (offset -4 lines).\npatching file net/ipv4/netfilter/ip_tables.c\nHunk #1 succeeded at 1431 (offset 3 lines).\npatching file net/ipv6/netfilter/ip6_tables.c\nHunk #1 succeeded at 1446 (offset 3 lines).\npatching file net/netfilter/x_tables.c\nHunk #1 succeeded at 730 (offset -3 lines).\nHunk #2 succeeded at 740 (offset -3 lines).\nHunk #3 succeeded at 1110 (offset -3 lines).\nHunk #4 succeeded at 1120 (offset -3 lines).\n"
+        },
+        {
+            "patch_file": "b52e0cf0bfc1e.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/b52e0cf0bfc1e",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/can/bcm.c\nHunk #1 succeeded at 814 (offset 29 lines).\nHunk #2 succeeded at 1537 (offset 3 lines).\n"
+        },
+        {
+            "patch_file": "b59a23d596807a5aa88d8dd5655a66c6843729b3.diff",
+            "patch_url": "http://android.googlesource.com/kernel/common/+/b59a23d596807a5aa88d8dd5655a66c6843729b3",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/key/af_key.c\nHunk #1 succeeded at 1840 (offset -15 lines).\n"
+        },
+        {
+            "patch_file": "3c7e594355359.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/3c7e594355359",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/tipc/monitor.c\nHunk #1 succeeded at 457 (offset -8 lines).\n"
+        },
+        {
+            "patch_file": "20fdf274472998123a8d173ba4cb6282ff6b63bd.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/20fdf274472998123a8d173ba4cb6282ff6b63bd",
+            "status": "Rejected",
+            "rejected_files": [
                 {
-                    "failed_file": "net/ipv6/route.c",
-                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/ipv6/route.c.rej"
+                    "failed_file": "net/bpf/test_run.c",
+                    "reject_file": "/Volumes/GitRepo/school/capstone/android/Xiaomi_Kernel_OpenSource/net/bpf/test_run.c.rej"
                 }
             ],
-            "message_output": "patching file include/net/dst_ops.h\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file include/net/dst_ops.h.rej\npatching file include/net/sock.h\nHunk #1 FAILED at 2215.\n1 out of 1 hunk FAILED -- saving rejects to file include/net/sock.h.rej\npatching file net/ipv4/route.c\nHunk #1 FAILED at 132.\nHunk #2 FAILED at 837.\n2 out of 2 hunks FAILED -- saving rejects to file net/ipv4/route.c.rej\npatching file net/ipv6/route.c\nHunk #1 FAILED at 87.\nHunk #2 FAILED at 2762.\n2 out of 2 hunks FAILED -- saving rejects to file net/ipv6/route.c.rej\npatching file net/xfrm/xfrm_policy.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n1 out of 1 hunk ignored -- saving rejects to file net/xfrm/xfrm_policy.c.rej\n"
+            "message_output": "patching file net/bpf/test_run.c\nHunk #2 FAILED at 132.\n1 out of 2 hunks FAILED -- saving rejects to file net/bpf/test_run.c.rej\n"
+        },
+        {
+            "patch_file": "d39fc9b94dc07.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/d39fc9b94dc07",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/unix/af_unix.c\nHunk #1 succeeded at 1937 (offset -219 lines).\nHunk #2 succeeded at 1977 (offset -219 lines).\nHunk #3 succeeded at 2008 (offset -219 lines).\n"
+        },
+        {
+            "patch_file": "790c2f9d15b59.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/790c2f9d15b59",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/unix/af_unix.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file net/unix/af_unix.c.rej\n"
+        },
+        {
+            "patch_file": "84d3e59750bbd.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/84d3e59750bbd",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/unix/af_unix.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file net/unix/af_unix.c.rej\n"
+        },
+        {
+            "patch_file": "e6ed59127c865.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/e6ed59127c865",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/unix/af_unix.c\nReversed (or previously applied) patch detected!  Assume -R? [n] \nApply anyway? [n] \nSkipping patch.\n3 out of 3 hunks ignored -- saving rejects to file net/unix/af_unix.c.rej\n"
+        },
+        {
+            "patch_file": "ea75080110a4c.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ea75080110a4c",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/wireless/nl80211.c\nHunk #1 succeeded at 289 (offset -148 lines).\n"
+        },
+        {
+            "patch_file": "ddd7e8b7b8483.diff",
+            "patch_url": "https://android.googlesource.com/kernel/common/+/ddd7e8b7b8483",
+            "status": "Applied Successfully",
+            "rejected_files": [],
+            "message_output": "patching file net/ipv4/igmp.c\nHunk #1 succeeded at 2684 (offset -36 lines).\nHunk #2 succeeded at 2695 (offset -36 lines).\n"
         }
     ]
 }
\ No newline at end of file
