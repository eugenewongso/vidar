[
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "upstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Settings.WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS;\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.app.admin.DevicePolicyManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    private DevicePolicyManager mDpm;\n    private UserManager mUm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mUm = getSystemService(UserManager.class);\n        mDpm = getSystemService(DevicePolicyManager.class);\n\n        if (mUm.isManagedProfile()) {\n            Slog.w(LOG_TAG, \"Apps in the work profile do not support notification listeners\");\n            Toast.makeText(this,\n                    mDpm.getResources().getString(WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS,\n                            () -> getString(R.string.notification_settings_work_profile)),\n                    Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "downstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.8895,
      "token_level_edit_similarity": 0.8717,
      "normalized_edit_similarity": 0.1283,
      "token_level_edit_distance": 0.1283,
      "codebert_score": {
        "precision": 0.9308,
        "recall": 0.9112,
        "f1": 0.9209,
        "f3": 0.9131
      },
      "cosine_similarity_openai": 0.9686
    }
  },
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "upstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Settings.WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS;\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.app.admin.DevicePolicyManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    private DevicePolicyManager mDpm;\n    private UserManager mUm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mUm = getSystemService(UserManager.class);\n        mDpm = getSystemService(DevicePolicyManager.class);\n\n        if (mUm.isManagedProfile()) {\n            Slog.w(LOG_TAG, \"Apps in the work profile do not support notification listeners\");\n            Toast.makeText(this,\n                    mDpm.getResources().getString(WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS,\n                            () -> getString(R.string.notification_settings_work_profile)),\n                    Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "downstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.8895,
      "token_level_edit_similarity": 0.8717,
      "normalized_edit_similarity": 0.1283,
      "token_level_edit_distance": 0.1283,
      "codebert_score": {
        "precision": 0.9308,
        "recall": 0.9112,
        "f1": 0.9209,
        "f3": 0.9131
      },
      "cosine_similarity_openai": 0.9686
    }
  }
]